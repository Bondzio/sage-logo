<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD Journal Publishing DTD v2.3 20070202//EN" "journalpublishing.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">PIG</journal-id>
<journal-id journal-id-type="hwp">sppig</journal-id>
<journal-title>Proceedings of the Institution of Mechanical Engineers, Part G: Journal of Aerospace Engineering</journal-title>
<issn pub-type="ppub">0954-4100</issn>
<issn pub-type="epub">2041-3025</issn>
<publisher>
<publisher-name>SAGE Publications</publisher-name>
<publisher-loc>Sage UK: London, England</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1177/0954410011409980</article-id>
<article-id pub-id-type="publisher-id">10.1177_0954410011409980</article-id>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Articles</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>Symbolic identification for fault detection in aircraft gas turbine engines</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<name><surname>Chakraborty</surname><given-names>S</given-names></name>
</contrib>
<contrib contrib-type="author">
<name><surname>Sarkar</surname><given-names>S</given-names></name>
</contrib>
<contrib contrib-type="author" corresp="yes">
<name><surname>Ray</surname><given-names>A</given-names></name>
<xref ref-type="corresp" rid="corresp1-0954410011409980">*</xref>
</contrib>
</contrib-group>
<aff id="aff1-0954410011409980">Department of Mechanical Engineering, The Pennsylvania State University, University Park, Pennsylvania, USA</aff>
<author-notes>
<corresp id="corresp1-0954410011409980"><label>*</label>Department of Mechanical Engineering, The Pennsylvania State University, 329 Reber Building, University Park, PA 16802, USA. email: <email>axr2@psu.edu</email></corresp>
</author-notes>
<pub-date pub-type="epub-ppub">
<month>4</month>
<year>2012</year>
</pub-date>
<volume>226</volume>
<issue>4</issue>
<fpage>422</fpage>
<lpage>436</lpage>
<history>
<date date-type="received"><day>6</day><month>7</month><year>2010</year></date>
<date date-type="accepted"><day>19</day><month>4</month><year>2011</year></date>
</history>
<permissions>
<copyright-statement>© Pennsylvania State University, University Park, PA 16802, USA 2011</copyright-statement>
<copyright-year>2011</copyright-year>
<copyright-holder content-type="society">Institution of Mechanical Engineers</copyright-holder>
</permissions>
<abstract>
<p>This article presents a robust and computationally inexpensive technique of component-level fault detection in aircraft gas-turbine engines. The underlying algorithm is based on a recently developed statistical pattern recognition tool, symbolic dynamic filtering (SDF), that is built upon symbolization of sensor time series data. Fault detection involves abstraction of a language-theoretic description from a general dynamical system structure, using state space embedding of output data streams and discretization of the resultant pseudo-state and input spaces. System identification is achieved through grammatical inference based on the generated symbol sequences. The deviation of the plant output from the nominal estimated language yields a metric for fault detection. The algorithm is validated for both single- and multiple-component faults on a simulation test-bed that is built upon the NASA C-MAPSS model of a generic commercial aircraft engine.</p>
</abstract>
<kwd-group>
<kwd>fault detection</kwd>
<kwd>model identification</kwd>
<kwd>gas turbine engines</kwd>
<kwd>language-theoretic analysis</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="sec1-0954410011409980"><title>1 INTRODUCTION</title>
<p>The propulsion system of modern aircraft performs as a collection of a large number of interconnected components, where fault detection and health monitoring at both component and system levels are of paramount importance. Especially, the inherent complexity and uncertainties in these systems pose a challenging problem because pertinent first-principle models are usually unavailable or are oversimplified as lump-parameter models. Therefore, in the absence of high-fidelity models, the major challenge is fault detection by developing a description of the component dynamics primarily from the input/output characteristics. These decisions of fault detection should not only be responsive to changes in the critical parameters of the dynamical system but also be invariant to changes in the operating/input conditions as much as practicable.</p>
<p>Several data-driven techniques have been reported in literature for fault detection and health monitoring in dynamical systems, which include statistical linearization [<bold><xref ref-type="bibr" rid="bibr1-0954410011409980">1</xref></bold>], Kalman filtering [<bold><xref ref-type="bibr" rid="bibr2-0954410011409980">2</xref></bold>], unscented Kalman filtering (UKF) [<bold><xref ref-type="bibr" rid="bibr3-0954410011409980">3</xref></bold>, <bold><xref ref-type="bibr" rid="bibr4-0954410011409980">4</xref></bold>], particle filtering (PF) [<bold><xref ref-type="bibr" rid="bibr5-0954410011409980">5</xref></bold>], Markov chain Monte Carlo (MCMC) [<bold><xref ref-type="bibr" rid="bibr6-0954410011409980">6</xref></bold>], Bayesian networks [<bold><xref ref-type="bibr" rid="bibr7-0954410011409980">7</xref></bold>], artificial neural networks (ANN) [<bold><xref ref-type="bibr" rid="bibr8-0954410011409980">8</xref></bold>], maximum likelihood estimation (MLE) [<bold><xref ref-type="bibr" rid="bibr9-0954410011409980">9</xref></bold>], wavelet-based tools [<bold><xref ref-type="bibr" rid="bibr10-0954410011409980">10</xref></bold>], and genetic algorithms (GA) [<bold><xref ref-type="bibr" rid="bibr11-0954410011409980">11</xref></bold>]. However, fault detection in single components is only a small part of the health monitoring problem in its entirety. In the setting of a more complex problem of fault detection in multiple components under changing input/operating conditions, the underlying algorithms and associated optimization techniques may have certain drawbacks. For example, computationally expensive algorithms may not be suitable for engineering systems like commercial-scale transport aircraft, where on-board health monitoring is needed to ensure flight safety.</p>
<p>In previous publications, the authors have addressed the problem of anomaly detection using symbolic dynamic filtering (SDF) [<bold><xref ref-type="bibr" rid="bibr12-0954410011409980">12</xref></bold>, <bold><xref ref-type="bibr" rid="bibr13-0954410011409980">13</xref></bold>] with applications to fault diagnosis in aircraft engines [<bold><xref ref-type="bibr" rid="bibr14-0954410011409980">14</xref></bold>–<bold><xref ref-type="bibr" rid="bibr16-0954410011409980">16</xref></bold>]. The anomaly detection algorithms, constructed in the SDF setting, have shown superior performance in terms of early detection of anomalies and robustness to measurement noise by comparison with other existing techniques such as principal component analysis (PCA), ANN, and Bayesian techniques [<bold><xref ref-type="bibr" rid="bibr17-0954410011409980">17</xref></bold>]. However, the issue of varying operating condition has not been addressed in SDF-based fault detection. Since multiple components of gas turbine engine systems are usually interconnected physically as well as through feedback control loops, the effects of degradation even in a single component may affect the input streams to the remaining components. Furthermore, in many situations (e.g. tactical aircraft), the system might need to be operated in different regimes and under diverse input conditions.</p>
<p>To address the above-mentioned issues and achieve the associated objectives, this article develops a robust and computationally inexpensive technique of system identification and fault detection that is built upon formal language theory and symbolic information. A central step is the proposed system identification method is discretization of the sensor time-series data for conversion into a corresponding sequence of symbols to achieve enhanced robustness and computational efficiency [<bold><xref ref-type="bibr" rid="bibr12-0954410011409980">12</xref></bold>, <bold><xref ref-type="bibr" rid="bibr13-0954410011409980">13</xref></bold>, <bold><xref ref-type="bibr" rid="bibr18-0954410011409980">18</xref></bold>]. Specifically, the fault detection algorithms are designed to be robust with respect to sensor noise and, at the same time, simple enough to be embedded in the sensors themselves. This method would also facilitate construction of a reliable sensor network to serve as a backbone to higher levels in the decision-making hierarchy of large-scale engineering systems (e.g. communication and control of aircraft's vehicle health and energy management system).</p>
<p>The real-time fault detection method, proposed in this article, has been validated on a test-bed that is built upon the NASA Commercial Modular Aero Propulsion System Simulation (C-MAPSS) model [<bold><xref ref-type="bibr" rid="bibr19-0954410011409980">19</xref></bold>]. This facility is particularly relevant for testing and validation of condition-monitoring algorithms as it allows the users to choose and design operational profiles (e.g. thrust levels), controllers, and environmental conditions to simulate scenarios of interest. Most importantly, the test facility allows the users to tune efficiency and flow parameters to simulate specific fault modes. Main contributions of this article beyond the work reported in the authors' previous publications [<bold><xref ref-type="bibr" rid="bibr14-0954410011409980">14</xref></bold>–<bold><xref ref-type="bibr" rid="bibr16-0954410011409980">16</xref></bold>] are succinctly stated below:
<list id="list1-0954410011409980" list-type="alpha-lower">
<list-item><p>formulation of a language-theoretic system identification method for fault detection under dynamically changing operating conditions;</p></list-item>
<list-item><p>validation of the proposed technique for data-driven detection of single and multiple component faults in aircraft gas turbine engines under noisy condition.</p></list-item>
</list></p>
<p>This article is organized in six sections. <xref ref-type="sec" rid="sec2-0954410011409980">Section 2</xref> briefly describes the C-MAPSS test-bed on which the fault detection algorithms have been validated. The concept and theoretical aspects of symbolic identification are presented in <xref ref-type="sec" rid="sec3-0954410011409980">section 3</xref> along with a necessary mathematical background. The resulting fault detection scheme is developed in <xref ref-type="sec" rid="sec4-0954410011409980">section 4</xref>. The pertinent results of algorithm validation on the C-MAPSS test-bed are presented in <xref ref-type="sec" rid="sec5-0954410011409980">section 5</xref>. This article is summarized and concluded in <xref ref-type="sec" rid="sec6-0954410011409980">section 6</xref> along with recommendations for future research.</p></sec>
<sec id="sec2-0954410011409980"><title>2 DESCRIPTION OF IN THE C-MAPSS TEST-BED</title>
<p>The C-MAPSS test-bed [<bold><xref ref-type="bibr" rid="bibr20-0954410011409980">20</xref></bold>], developed at NASA, is built upon the model of a commercial-scale two-spool turbofan engine and its control system. While the details of the model are available in open literature [<bold><xref ref-type="bibr" rid="bibr19-0954410011409980">19</xref></bold>], a brief outline of C-MAPSS is provided here for completeness of this article. The engine under consideration produces a thrust of approximately 400 000 N and is designed for operation at:
<list list-type="alpha-lower">
<list-item><p>altitudes from sea level up to 12 200 m;</p></list-item>
<list-item><p>Mach numbers from 0 to 0.90;</p></list-item>
<list-item><p>temperatures from approximately −50 °C to 50 °C.</p></list-item>
</list>The throttle resolving angle (TRA) can be set to any value in the range between 0 ° (minimum power) and 100 ° (maximum power).</p>
<p>As seen in <xref ref-type="fig" rid="fig1-0954410011409980">Figs 1(a) and 1(b)</xref>, the simulation test-bed of the gas turbine engine system consists of high-pressure compressor (HPC), combustor, and high-pressure turbine (HPT), which form the core of the engine model; this subsystem is also referred to as the gas generator. In the turbofan engine, the engine core is surrounded by the fan and low-pressure compressure (LPC) in the front and an additional low-pressure turbine (LPT) at the rear. The fan, LPC, and LPT are mechanically connected by an additional shaft. The fan shaft passes through the core shaft and, due to this type of arrangement, the engine is called a two-spool engine.
<fig id="fig1-0954410011409980" position="float"><label>Fig. 1</label><caption><p>The C-MAPSS simulation test-bed</p></caption><graphic xlink:href="10.1177_0954410011409980-fig1.tif"/></fig></p>
<p>A gain-scheduled control system is incorporated in the engine system, which consists of:
<list list-type="alpha-lower">
<list-item><p>a fan-speed controller for a specified TRA;</p></list-item>
<list-item><p>three high-limit regulators that prevent the engine from exceeding its design limits for core-spool speed, engine-pressure ratio, and HPT exit temperature;</p></list-item>
<list-item><p>the fourth limit regulator that attempts to prevent the static pressure at the HPC exit from dropping too low;</p></list-item>
<list-item><p>acceleration and deceleration limiters for the core-spool speed;</p></list-item>
<list-item><p>a comprehensive logic structure that integrates these control-system components in a manner similar to that used in real engine controllers such that integrator-windup problems are avoided.</p></list-item>
</list>To achieve fast execution of simulation runs, the sensors and actuators are approximated to have instantaneous response, no computational time delays, and no drift and/or bias. Given the inputs of TRA, altitude (<italic>a</italic>) and Mach number (<italic>M</italic>), the interactively controlled component models at the simulation test-bed compute non-linear dynamics of real-time turbofan engine operation. Both steady-state and transient operations are simulated in the continuous-time setting. This study addresses the detection of those faults that cause efficiency degradation in engine components. In the current configuration of the C-MAPSS test-bed, there are 13 health parameter inputs, namely, efficiency health parameters (ψ), flow health parameters (ζ), and pressure ratio modifiers, that simulate the effects of faults and/or degradation in the engine components. Out of these 13 health parameters, are selected to modify efficiency (η) and flow (ϕ), which are defined [<bold><xref ref-type="bibr" rid="bibr21-0954410011409980">21</xref></bold>] as:
<list id="list2-0954410011409980" list-type="alpha-lower">
<list-item><p>η ≜ ratio of changes in actual and ideal enthalpies;</p></list-item>
<list-item><p>ϕ ≜, ratio of tip rotor and axial fluid flow velocities.</p></list-item>
</list></p>
<p>For the engine's five rotating components (i.e. fan, LPC, HPC, HPT, and LPT), ten respective health parameters are: (a) fan (ψ<sub>F</sub> , ζ<sub>F</sub>), (b) low-pressure compressure (ψ<sub>LPC</sub> , ζ<sub>LPC</sub> ), (c) high-pressure compressor (ψ<sub>HPC</sub>, ζ<sub>HPC</sub>), (d) high-pressure turbine (ψ<sub>HPT</sub>, ζ<sub>HPT</sub>), and (e) low-pressure turbine (ψ<sub>LPT</sub>, ζ<sub>LPT</sub>). Out of the different types of sensors (e.g. pressure, temperature, and shaft speed) used in the C-MAPSS simulation model. <xref ref-type="table" rid="table1-0954410011409980">Table 1</xref> lists the sensors that are commonly adopted in the Instrumentation and Control system of commercial aircraft engines, as seen in <xref ref-type="fig" rid="fig1-0954410011409980">Fig. 1(b)</xref>.
<table-wrap id="table1-0954410011409980" position="float"><label>Table 1</label><caption><p>Sensor suite for the engine system</p></caption>
<graphic alternate-form-of="table1-0954410011409980" xlink:href="10.1177_0954410011409980-table1.tif"/>
<table frame="hsides"><thead>
<tr>
<th align="left">Sensors</th>
<th align="left">Description</th></tr></thead>
<tbody>
<tr>
<td align="left"><italic>P</italic><sub>2</sub></td>
<td align="left">Fan inlet pressure</td></tr>
<tr>
<td align="left"><italic>T</italic><sub>2</sub></td>
<td align="left">Fan inlet temperature</td></tr>
<tr>
<td align="left"><italic>P</italic><sub>24</sub></td>
<td align="left">LPC exit / HPC inlet pressure</td></tr>
<tr>
<td align="left"><italic>T</italic><sub>24</sub></td>
<td align="left">LPC exit / HPC inlet temperature</td></tr>
<tr>
<td align="left"><italic>Ps</italic><sub>30</sub></td>
<td align="left">HPC exit static pressure</td></tr>
<tr>
<td align="left"><italic>T</italic><sub>30</sub></td>
<td align="left">HPC exit / combustor inlet temperature</td></tr>
<tr>
<td align="left"><italic>T</italic><sub>48</sub></td>
<td align="left">HPT exit temperature</td></tr>
<tr>
<td align="left"><italic>N</italic><sub><italic>f</italic></sub></td>
<td align="left">Fan spool speed</td></tr>
<tr>
<td align="left"><italic>N</italic><sub><italic>c</italic></sub></td>
<td align="left">Core spool speed</td></tr>
</tbody>
</table>
</table-wrap></p>
<p>The overall objective is to detect changes in the health condition of gas-turbine components, parameterized by its efficiencies. The detection procedure has to be robust with respect to sensor noise, different operating conditions of the aircraft such as take-off, cruise, and landing, as well as possible presence of fault in one or more other components in the loop. The processing of the sensor information in order to arrive at such a fault detection algorithm form the subject matter of the rest of this article.</p></sec>
<sec id="sec3-0954410011409980"><title>3 CONCEPT OF SYMBOLIC IDENTIFICATION</title>
<p>Symbolic feature extraction from time series data is posed as a two-time-scale problem [<bold><xref ref-type="bibr" rid="bibr12-0954410011409980">12</xref></bold>]. The <italic>fast scale</italic> is related to the response time of the process dynamics. Over the span of data acquisition, dynamic behaviour of the system is assumed to remain invariant, i.e. the process is quasi-stationary at the fast scale. On the other hand, the <italic>slow scale</italic> is related to the time span over which non-stationary evolution of the system dynamics may occur. It is expected that the features extracted from the fast-scale data will depict statistical changes between two different slow-scale epochs if the underlying system has undergone a change.</p>
<p>For the symbolic analysis of time-series information (e.g. temperature and pressure sensor signals from a gas turbine engine), data acquired from the instrumentation and data-acquisition system, are discretized temporally and spatially to generate blocks of symbols, also called <italic>words</italic>. A grammar is the mathematical structure that constrains the inter-relationship among these words. In essence, the grammar <inline-formula id="ilm14-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="mml-math14-0954410011409980"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula> of a language is the set of rules that specify all words in the language and their relationships. Grammatical inference-making is an inductive problem, where the underlying grammar dictating these interrelationships has to be identified with just positive examples of valid <italic>sentences</italic>. To apply grammatical inference procedures to identification of non-autonomous dynamical systems, the system must be considered as an entity (i.e. a linguistic source) capable of generating a specific language.</p>
<p>Since many physical processes of interest can be faithfully represented by a dynamical system operating in the continuous time and in continuous state space, it is logical to construct a language-theoretic model to capture the pertinent dynamics in a robust and computationally efficient way. In this context, estimation of deviation of such a system from its nominal operating condition with grammatical inference techniques can be decomposed into three tasks.
<list id="list3-0954410011409980" list-type="order">
<list-item><p><italic>Abstraction</italic>: This task is abstracting a discrete qualitative counterpart of the general dynamical system representing the physical process, such that the system output of this abstracted description constitutes a unique language in the setting of the formal language in the Chomsky hierarchy [<bold><xref ref-type="bibr" rid="bibr22-0954410011409980">22</xref></bold>].</p></list-item>
<list-item><p><italic>Identification</italic>: This is the learning task in dynamical systems, the grammatical inference technique develops a grammatical description of a dynamical system from the input/output characteristics such that it is not only invariant with respect to the input conditions, but also sensitive to changes in the parameters of the actual dynamical system.</p></list-item>
<list-item><p><italic>Comparison</italic>: Upon completion of abstraction and identification, this task compares the output of the abstracted system with the actual output in the sense of an appropriately defined metric for estimation of degradation of the system under investigation.</p></list-item>
</list></p>
<sec id="sec4-0954410011409980"><title>3.1 Generalization of qualitative dynamical systems</title>
<p>In the context of the concepts, introduced above, the underlying structure of a dynamical system is represented by a generalized dynamical system (GDS).<statement>
<title>Definition</title>
<p>A GDS is defined as an 8-tuple automaton [<bold><xref ref-type="bibr" rid="bibr23-0954410011409980">23</xref></bold>].
<disp-formula id="disp-formula1-0954410011409980"><label>(1)</label><graphic xlink:href="10.1177_0954410011409980-eq1.tif"/></disp-formula>
where <italic>T</italic> is a time set (e.g. <italic>T</italic> = [0, ∞)), <italic>U</italic> and <italic>W</italic> are the input and output sets, respectively, <italic>Q</italic> are internal states, <italic>P</italic> is the input process <italic>P</italic> : <italic>T</italic> → <italic>U</italic>, and <italic>f</italic> is the global state transition
<list id="list4-0954410011409980" list-type="simple">
<list-item><p>
<disp-formula id="disp-formula2-0954410011409980"><label>(2)</label><graphic xlink:href="10.1177_0954410011409980-eq2.tif"/></disp-formula>
<disp-formula id="disp-formula3-0954410011409980"><label>(3)</label><graphic xlink:href="10.1177_0954410011409980-eq3.tif"/></disp-formula>
</p></list-item>
<list-item><p><italic>g</italic> denotes the output function
<disp-formula id="disp-formula4-0954410011409980"><label>(4)</label><graphic xlink:href="10.1177_0954410011409980-eq4.tif"/></disp-formula>
<disp-formula id="disp-formula5-0954410011409980"><label>(5)</label><graphic xlink:href="10.1177_0954410011409980-eq5.tif"/></disp-formula>
</p></list-item>
</list></p></statement></p>
<p>Let <bold><italic>D</italic></bold><sub><italic>i</italic></sub> be a GDS indexed by <italic>i</italic> representing different parametric conditions. Let <bold><italic>D</italic></bold><sub>0</sub> be the nominal or healthy condition of the plant (i.e. the system under consideration), and <italic>i</italic> = 1, 2, … signify deterioration of the plant health conditions due to an evolving anomaly. Let a component of the GDS <bold><italic>D</italic></bold><sub><italic>i</italic></sub> be denoted by the corresponding symbol with a subscript denoting its health condition. For example, <italic>f</italic><sub><italic>i</italic></sub> denotes the global state transition function for a system in the <italic>i</italic>th health state. Let <bold><italic>U</italic></bold><sub><italic>k</italic></sub>, <italic>k</italic> = 1, 2, … , <inline-formula id="ilm15-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="mml-math15-0954410011409980"><mml:mi mathvariant="script">K</mml:mi></mml:math></inline-formula> be <inline-formula id="ilm16-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="mml-math16-0954410011409980"><mml:mi mathvariant="script">K</mml:mi></mml:math></inline-formula> different input conditions, <inline-formula id="ilm1-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math1-0954410011409980"><mml:mrow><mml:msubsup><mml:mstyle mathsize="normal" mathvariant="bold"><mml:mi>y</mml:mi></mml:mstyle><mml:mrow><mml:mi>k</mml:mi> </mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> be the output from the <italic>i</italic>th system <bold><italic>D</italic></bold><sub><italic>i</italic></sub> receiving the <italic>k</italic>th input <bold><italic>U</italic></bold><sub><italic>k</italic></sub>.<statement>
<title>Definition</title>
<p>Let the nominal plant <bold><italic>D</italic></bold><sub>0</sub> be represented as a GDS and let its grammar be denoted as <inline-formula id="ilm17-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="mml-math17-0954410011409980"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula>. Then, the quantized abstraction of the GDS is called a qualitative dynamical system (QDS) that is represented as a 5-tuple
<disp-formula id="disp-formula6-0954410011409980"><label>(6)</label><graphic xlink:href="10.1177_0954410011409980-eq6.tif"/></disp-formula>
where
<list id="list5-0954410011409980" list-type="simple">
<list-item><p><inline-formula id="ilm18-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="mml-math18-0954410011409980"><mml:mi mathvariant="script">Q</mml:mi></mml:math></inline-formula> ≜ {<italic>q</italic><sub>1</sub>, <italic>q</italic><sub>2</sub>, … , <italic>q</italic><sub><italic>f</italic></sub> } is the finite set of qualitative states of the automaton,</p></list-item>
<list-item><p>Λ ≜ {λ<sub>1</sub>, λ<sub>2</sub>, … , λ<sub><italic>m</italic></sub>} is the set of qualitative input events,</p></list-item>
<list-item><p>Σ ≜ {σ<sub>1</sub>, σ<sub>2</sub>, … , σ<sub><italic>n</italic></sub>} is the set of output alphabets, where the output symbols are one-to-one with the quantized values of output from the dynamical system, and</p></list-item>
<list-item><p>δ : <inline-formula id="ilm19-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="mml-math19-0954410011409980"><mml:mi mathvariant="script">Q</mml:mi></mml:math></inline-formula> × Λ → <inline-formula id="ilm20-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="mml-math20-0954410011409980"><mml:mi mathvariant="script">Q</mml:mi></mml:math></inline-formula> is the state transition function that maps the current state into the next state upon receiving the input λ. The state transition function can be stochastic; in that case
<disp-formula id="disp-formula7-0954410011409980"><label>(7)</label><graphic xlink:href="10.1177_0954410011409980-eq7.tif"/></disp-formula>
where <italic>Pr</italic>{<inline-formula id="ilm21-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="mml-math21-0954410011409980"><mml:mi mathvariant="script">Q</mml:mi></mml:math></inline-formula>} is a probability distribution over <inline-formula id="ilm22-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="mml-math22-0954410011409980"><mml:mi mathvariant="script">Q</mml:mi></mml:math></inline-formula>.</p></list-item>
<list-item><p>γ : <inline-formula id="ilm23-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="mml-math23-0954410011409980"><mml:mi mathvariant="script">Q</mml:mi></mml:math></inline-formula> → Σ is the output generation function that determines the output symbol from the current state. In its full generality, γ can be stochastic as well, i.e. (with similar notation as before)
<disp-formula id="disp-formula8-0954410011409980"><label>(8)</label><graphic xlink:href="10.1177_0954410011409980-eq8.tif"/></disp-formula>
</p></list-item>
</list></p></statement></p></sec>
<sec id="sec5-0954410011409980"><title>3.2 Abstraction</title>
<p>Abstraction is the process of transforming a general dynamical system into its qualitative counterpart. The method is formalized as follows: Let χ denote a set of qualitative abstraction functions
<disp-formula id="disp-formula9-0954410011409980"><label>(9)</label><graphic xlink:href="10.1177_0954410011409980-eq9.tif"/></disp-formula>
It is noted that χ is a 3-tuple consisting of three individual abstraction functions
<disp-formula id="disp-formula21-0954410011409980"><graphic xlink:href="10.1177_0954410011409980-eq21.tif"/></disp-formula>
<disp-formula id="disp-formula10-0954410011409980"><label>(10)</label><graphic xlink:href="10.1177_0954410011409980-eq10.tif"/></disp-formula>
<disp-formula id="disp-formula11-0954410011409980"><label>(11)</label><graphic xlink:href="10.1177_0954410011409980-eq11.tif"/></disp-formula>
<disp-formula id="disp-formula12-0954410011409980"><label>(12)</label><graphic xlink:href="10.1177_0954410011409980-eq12.tif"/></disp-formula>
</p>
<p>Kokar [<bold><xref ref-type="bibr" rid="bibr23-0954410011409980">23</xref></bold>] introduced a set of necessary and sufficient conditions, or ‘consistency postulates’ that the pair <inline-formula id="ilm24-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="mml-math24-0954410011409980"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula>, χ must satisfy in order to be a valid representation of the general dynamical system. In this article, since the transfer of the QDS, δ is probabilistic, the consistency postulates have been redefined in a probabilistic sense. The modified consistency postulates can be stated as follows.<statement>
<title>Definition</title>
<p>Let <inline-formula id="ilm25-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="mml-math25-0954410011409980"><mml:mi mathvariant="script">D</mml:mi></mml:math></inline-formula>, <inline-formula id="ilm26-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="mml-math26-0954410011409980"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula>, and χ represent a GDS, QDS, and an abstraction function, respectively. Then, the pair (<inline-formula id="ilm27-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="mml-math27-0954410011409980"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula>, χ) forms a consistent representation in a probabilistic sense if, ∀<italic>q</italic>, <italic>u</italic>, <italic>t</italic>
<disp-formula id="disp-formula13-0954410011409980"><label>(13)</label><graphic xlink:href="10.1177_0954410011409980-eq13.tif"/></disp-formula>
<disp-formula id="disp-formula14-0954410011409980"><label>(14)</label><graphic xlink:href="10.1177_0954410011409980-eq14.tif"/></disp-formula>
where <italic>X</italic> ∼ <italic>P</italic> means the random variable <italic>X</italic> is distributed according to the probability distribution <italic>P</italic>.</p></statement><statement>
<title>Theorem 3.1 (Kokar [<bold><xref ref-type="bibr" rid="bibr23-0954410011409980">23</xref></bold>])</title>
<p>Let <italic>W</italic><sub>π</sub> = <italic>W</italic><sub>1</sub>, … , <italic>W</italic><sub><italic>n</italic></sub>, <italic>n</italic> ∈ ℕ be a finite partition of a GDS's output space <italic>W</italic>, given by <inline-formula id="ilm2-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math2-0954410011409980"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:mi>W</mml:mi> </mml:mrow><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>:</mml:mo><mml:mi>Σ</mml:mi><mml:mo>→</mml:mo><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>π</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. Let <italic>Q</italic><sub>π</sub> describe a partition of <italic>Q</italic> defined as an inverse image of <italic>W</italic><sub>π</sub> through <italic>g</italic>
<disp-formula id="disp-formula22-0954410011409980"><graphic xlink:href="10.1177_0954410011409980-eq22.tif"/></disp-formula>
and let <italic>TQU</italic><sub>π</sub> describe a partition of <italic>T</italic> × <italic>Q</italic> × <italic>U</italic> defined as an inverse image of <italic>Q</italic><sub>π</sub> through <italic>f</italic>
<disp-formula id="disp-formula23-0954410011409980"><graphic xlink:href="10.1177_0954410011409980-eq23.tif"/></disp-formula>
Then, <italic>Q</italic><sub>π</sub> is a maximal admissible partition of <italic>Q</italic>, and <italic>TQU</italic><sub>π</sub> is an admissible partition of <italic>T</italic> × <italic>Q</italic> × <italic>U</italic>.</p></statement><statement>
<title>Proof</title>
<p>If the mapping χ<sub><italic>Q</italic></sub> : <italic>Q</italic> → <inline-formula id="ilm28-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="mml-math28-0954410011409980"><mml:mi mathvariant="script">Q</mml:mi></mml:math></inline-formula> assigns a <inline-formula id="ilm29-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="mml-math29-0954410011409980"><mml:mi mathvariant="script">Q</mml:mi></mml:math></inline-formula><italic><sub>i</sub></italic> to each class <inline-formula id="ilm3-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math3-0954410011409980"><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msubsup><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:mi>W</mml:mi> </mml:mrow><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and γ assigns <italic>w</italic><sub><italic>i</italic></sub> to <inline-formula id="ilm30-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="mml-math30-0954410011409980"><mml:mi mathvariant="script">Q</mml:mi></mml:math></inline-formula><italic><sub>i</sub></italic>, by construction
<disp-formula id="disp-formula24-0954410011409980"><graphic xlink:href="10.1177_0954410011409980-eq24.tif"/></disp-formula>
The second half of the proof is similar. ▪</p></statement></p>
<p>In effect:
<list id="list6-0954410011409980" list-type="alpha-lower">
<list-item><p>a critical hypersurface of partition in <italic>Q</italic> is an image of the partition in <italic>W</italic> through <italic>g</italic> <sup>−1</sup>;</p></list-item>
<list-item><p>a critical hypersurface partitioning <italic>T</italic> × <italic>Q</italic> × <italic>U</italic> is an image of the partition in <italic>Q</italic> through <italic>f</italic> <sup>−1</sup>.</p></list-item>
</list><statement>
<title>Lemma 3.2</title>
<p>The abstraction function χ defines a congruence relation.</p></statement><statement>
<title>Proof</title>
<p>Let an equivalence relation <inline-graphic xlink:href="10.1177_0954410011409980-img1.tif"/> over the elements of the dynamical system be defined as belonging to the same admissible partition, for example <italic>q</italic><sub>1</sub><inline-graphic xlink:href="10.1177_0954410011409980-img2.tif"/><italic>q</italic><sub>2</sub> ⇒ <italic>q</italic><sub>1</sub>, <italic>q</italic><sub>2</sub> ∈ <italic>Q</italic><sub><italic>i</italic></sub>. If (<italic>t</italic><sub>1</sub> × <italic>q</italic><sub>1</sub> × <italic>u</italic><sub>1</sub>) <inline-graphic xlink:href="10.1177_0954410011409980-img3.tif"/> (<italic>t</italic><sub>2</sub> × <italic>q</italic><sub>2</sub> × <italic>u</italic><sub>2</sub>), then <italic>f</italic> (<italic>t</italic><sub>1</sub>, <italic>q</italic><sub>1</sub>, <italic>u</italic><sub>1</sub>) <inline-graphic xlink:href="10.1177_0954410011409980-img4.tif"/> <italic>f</italic> (<italic>t</italic><sub>2</sub>, <italic>q</italic><sub>2</sub>, <italic>u</italic><sub>2</sub>), because χ<sub><italic>Q</italic></sub> (<italic>q</italic><sub>1</sub>) = χ<sub><italic>Q</italic></sub>(<italic>q</italic><sub>2</sub>) = <inline-formula id="ilm31-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="mml-math31-0954410011409980"><mml:mi mathvariant="script">Q</mml:mi></mml:math></inline-formula><sub><italic>i</italic></sub> (say), and χ<sub><italic>TQU</italic></sub>(<italic>t</italic><sub>1</sub>, <italic>q</italic><sub>1</sub>, <italic>u</italic><sub>1</sub>) = χ<sub><italic>TQU</italic></sub>(<italic>t</italic><sub>2</sub>, <italic>q</italic><sub>2</sub>, <italic>u</italic><sub>2</sub>) = λ<sub><italic>j</italic></sub> (say), then from the consistency postulates,
<disp-formula id="disp-formula25-0954410011409980"><graphic xlink:href="10.1177_0954410011409980-eq25.tif"/></disp-formula>
 ▪</p></statement><statement>
<title>Lemma 3.3</title>
<p>The QDS is related to the GDS through a homomorphism.</p></statement><statement>
<title>Proof</title>
<p>A homomorphism can be associated with every congruence and admissible partitions [<bold><xref ref-type="bibr" rid="bibr24-0954410011409980">24</xref></bold>]. ▪</p></statement></p>
<p>If the system model, i.e. the equations governing the GDS is known, the critical hypersurfaces or partitions can be analytically evaluated and utilized as delineated in the preceding section. However, in the absence of model equations, this scheme is of little practical use, unless
<list id="list7-0954410011409980" list-type="alpha-lower">
<list-item><p>there is an alternate means of constructing the phase space purely from output, without using the model equations; or</p></list-item>
<list-item><p>there is an alternate means of arriving at the proposed partition without information about the state transition function <italic>f</italic> and the output function <italic>g</italic>.</p></list-item>
</list>The next two subsections delineate a method for achieving these ends in an approximate way.</p>
<sec id="sec6-0954410011409980"><title>3.2.1 Phase space construction</title>
<p>Starting from the output signal captured by suitable instrumentation, a pseudo phase space can be constructed from delay vectors using Taken's theorem [<bold><xref ref-type="bibr" rid="bibr25-0954410011409980">25</xref></bold>]. The embedded phase space can be denoted by
<disp-formula id="disp-formula26-0954410011409980"><graphic xlink:href="10.1177_0954410011409980-eq26.tif"/></disp-formula>
where τ is the time lag and <italic>m</italic> the embedding dimension. Takens' theorem guarantees that, at least in the noise-free case, a system of state dimension <italic>s</italic> may be embedded using a maximum of <italic>m</italic><sub><italic>T</italic></sub> lags where <italic>m</italic><sub><italic>T</italic></sub> ⩽ 2<italic>s</italic> + 1.</p>
<p>In order to find optimum values of the embedding parameters <italic>m</italic>, <italic>n</italic>, and τ, the literature reports many optimization routines. In this case, following [<bold><xref ref-type="bibr" rid="bibr26-0954410011409980">26</xref></bold>] the Kozachenko–Leonenko (KL) [<bold><xref ref-type="bibr" rid="bibr27-0954410011409980">27</xref></bold>] estimate of the differential entropy
<disp-formula id="disp-formula15-0954410011409980"><label>(15)</label><graphic xlink:href="10.1177_0954410011409980-eq15.tif"/></disp-formula>
is first calculated, where <italic>N</italic> is the number of samples, <italic>ρ</italic><sub><italic>j</italic></sub> the Euclidian distance of the <italic>j</italic>th delay vector to its nearest neighbour, and <italic>C</italic><sub><italic>E</italic></sub> the Euler constant: <inline-formula id="ilm4-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math4-0954410011409980"><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>E</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mo>∫</mml:mo></mml:mrow><mml:mrow><mml:mn>0</mml:mn> </mml:mrow><mml:mrow><mml:mi>∞</mml:mi></mml:mrow></mml:msubsup><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mo>-</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msup><mml:mi>ln</mml:mi><mml:mi>t</mml:mi><mml:mi>dt</mml:mi><mml:mo>≈</mml:mo><mml:mn>0</mml:mn><mml:mo>.</mml:mo><mml:mn>5772</mml:mn></mml:mrow></mml:math></inline-formula>. Then
<disp-formula id="disp-formula27-0954410011409980"><graphic xlink:href="10.1177_0954410011409980-eq27.tif"/></disp-formula>
is defined using surrogates (see reference [<bold><xref ref-type="bibr" rid="bibr26-0954410011409980">26</xref></bold>] for details) and finally the entropy ratio (ER) is defined as
<disp-formula id="disp-formula16-0954410011409980"><label>(16)</label><graphic xlink:href="10.1177_0954410011409980-eq16.tif"/></disp-formula>
by superimposing the minimum description length (MDL) method to penalize higher dimensions. This ratio is minimized to find the optimal set of embedding parameters (<italic>m</italic>*, τ*).</p></sec>
<sec id="sec7-0954410011409980"><title>3.2.2 Partitioning</title>
<p>Sensor time series are obtained from the input and output data streams of the dynamical system <inline-formula id="ilm32-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="mml-math32-0954410011409980"><mml:mi mathvariant="script">D</mml:mi></mml:math></inline-formula><sub>0</sub> under a nominal condition for different input conditions. Let <inline-formula id="ilm33-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="mml-math33-0954410011409980"><mml:mi mathvariant="script">Y</mml:mi></mml:math></inline-formula> = {<italic>y</italic><sub>1</sub>, <italic>y</italic><sub>2</sub>,…}, <italic>y</italic><sub><italic>k</italic></sub> ∈ Σ denote the discretized output sequence. Probabilistic finite state automata (PFSA) are constructed next, with states defined by symbol blocks of length <italic>D</italic> from <inline-formula id="ilm34-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="mml-math34-0954410011409980"><mml:mi mathvariant="script">Y</mml:mi></mml:math></inline-formula>. Such PFSA are called <italic>D</italic>-Markov machines; the reader is referred to references [<bold><xref ref-type="bibr" rid="bibr12-0954410011409980">12</xref></bold>–<bold><xref ref-type="bibr" rid="bibr14-0954410011409980">14</xref></bold>] for an in-depth description of the procedure.</p>
<p>The state space is constructed from the output space by using Taken's theorem as discussed in the final section. In the very next step, the phase space and the input space are individually discretized. The crux of the method is to place the boundaries of the partition segments in such a way, that a change in both input and output symbols is synchronized. The phase space and input variables hold the last symbol till there is a change in the output state sequence. Periodicity (or at least quasi-periodicity) guarantees that the number of phase space and input symbols will not explode. The partitioning scheme is illustrated in <xref ref-type="fig" rid="fig2-0954410011409980">Fig. 2</xref>.<statement>
<title>Remark</title>
<p>A partition constructed in this way is admissible, but may not be maximal, since this partition is a subpartition of the original partition proposed in Theorem 3.1.</p></statement>
<fig id="fig2-0954410011409980" position="float"><label>Fig. 2</label><caption><p>Partitioning scheme</p></caption><graphic xlink:href="10.1177_0954410011409980-fig2.tif"/></fig></p>
<p>Let <inline-formula id="ilm35-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="mml-math35-0954410011409980"><mml:mi mathvariant="script">U</mml:mi></mml:math></inline-formula> = {<italic>u</italic><sub>(1)</sub>, <italic>u</italic><sub>(2)</sub>, …} denote the discretized input data sequence. Similarly let <inline-formula id="ilm36-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="mml-math36-0954410011409980"><mml:mi mathvariant="script">Q</mml:mi></mml:math></inline-formula> = {<italic>q</italic><sub>(1)</sub>, <italic>q</italic><sub>(2)</sub>, …} denote the discretized state variable sequence. It is noted that the state space can be multi-dimensional depending on the embedding dimension <italic>m</italic>*. Once the input and state spaces are both discretized, they can be combined to form the discretized augmented input space Λ = {λ<sub>(1)</sub>, λ<sub>(2)</sub>, …}, where each λ<sub>(<italic>i</italic> )</sub> = {<italic>q</italic><sub>(<italic>i</italic> )</sub>, <italic>u</italic><sub>(<italic>i</italic> )</sub>}.</p>
<p>The transition function used in the current methodology has a stochastic structure. Specifically, <italic>δ</italic> : <inline-formula id="ilm37-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="mml-math37-0954410011409980"><mml:mi mathvariant="script">Q</mml:mi></mml:math></inline-formula> × Λ → <italic>Pr</italic>{<inline-formula id="ilm38-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="mml-math38-0954410011409980"><mml:mi mathvariant="script">Q</mml:mi></mml:math></inline-formula>} yields the probability distribution of transition from state <italic>q</italic><sub><italic>i</italic></sub> to {<italic>q</italic><sub>1</sub>, <italic>q</italic><sub>2</sub>, … , <italic>q</italic><sub><italic>f</italic></sub> } upon receiving an input λ<sub><italic>j</italic></sub>. A grammar constructed in this way has the advantage over the context-sensitive grammar, described in reference [<bold><xref ref-type="bibr" rid="bibr28-0954410011409980">28</xref></bold>], where the number of production rules may become inconveniently large. However, the function γ : <italic>Q</italic> → Σ, which maps the current state <italic>q</italic><sub><italic>i</italic></sub> to the current output symbol <italic>σ</italic><sub><italic>i</italic></sub> is deterministic, which is really an artifact of the state construction procedure [<bold><xref ref-type="bibr" rid="bibr12-0954410011409980">12</xref></bold>].</p></sec></sec>
<sec id="sec8-0954410011409980"><title>3.3 Identification</title>
<p>The learning scheme, depicted in <xref ref-type="fig" rid="fig3-0954410011409980">Fig. 3</xref>, explains identification of the state transition function δ from the input–output symbol sequences obtained from experiment on the plant while it is under nominal condition. The fixed structure automata model is trained during the learning phase and outputs <italic><bold>p</bold></italic> and <inline-formula id="ilm5-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math5-0954410011409980"><mml:mrow><mml:mover><mml:mstyle mathsize="normal" mathvariant="bold"><mml:mi>p</mml:mi></mml:mstyle><mml:mi>~</mml:mi></mml:mover></mml:mrow></mml:math></inline-formula> (shown using dotted arrows) are obtained during testing (fault detection) phase and will be described later.
<fig id="fig3-0954410011409980" position="float"><label>Fig. 3</label><caption><p>Overall scheme for learning and fault detection</p></caption><graphic xlink:href="10.1177_0954410011409980-fig3.tif"/></fig></p>
<p>It is assumed that inputs and outputs are time-synchronized. The state transition function δ can be expanded into two dimensional matrices δ<sup>λ<sub><italic>i</italic></sub></sup>, indexed by the input variable alphabets. That means
<disp-formula id="disp-formula17-0954410011409980"><label>(17)</label><graphic xlink:href="10.1177_0954410011409980-eq17.tif"/></disp-formula>
where δ<sup>λ<sub><italic>i</italic></sub></sup> : <italic>q</italic><sub><italic>j</italic></sub> × λ<sub><italic>i</italic></sub> → <italic>Pr</italic>{<inline-formula id="ilm39-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="mml-math39-0954410011409980"><mml:mi mathvariant="script">Q</mml:mi></mml:math></inline-formula>} maps the current state and input to the probability distribution over all possible states. The algorithm for estimating the matrices δ<sup>λ<sub><italic>i</italic></sub></sup> is straightforward and involves counting the frequency of each transition in the learning phase. Since the state transition matrices are constructed simply by counting, this method is ideal for implementing in the sensor electronics for real-time prognoses.</p>
<p>The learning algorithm has to make sure that the probability values of δ<sup><italic>i</italic></sup> converge. The convergence depends on the length of the input–output symbol sequences. In this study, a stopping rule [<bold><xref ref-type="bibr" rid="bibr12-0954410011409980">12</xref></bold>] has been used for detecting the optimal data length.</p>
<p>In the learning phase, it has to be ensured that the grammar <inline-formula id="ilm40-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="mml-math40-0954410011409980"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula> is trained with sufficient input data belonging to a particular equivalence class. This is the so-called <italic>coverage problem</italic>.</p></sec></sec>
<sec id="sec9-0954410011409980"><title>4 FAULT DETECTION SCHEME</title>
<p>The concept of fault detection is largely similar to that of the learning phase in <xref ref-type="fig" rid="fig3-0954410011409980">Fig. 3</xref> with the following exception. The input and output time series data from the actual plant are discretized to form symbol sequences, which are fed to the trained fixed structure automaton. The discretization is performed using the same partitioning as was done during the learning phase. It is noted that the resulting finite state automaton (FSA) uses the output from the actual system in addition to the input, and hence cannot serve as an independent ‘system identification’ procedure in the classical sense of the term. Nevertheless, the automaton can serve as a system emulator if the state transition function δ is completely deterministic. That is, given the current state <italic>q</italic><sub><italic>j</italic></sub> and the current input symbol λ<sub><italic>i</italic></sub>
<disp-formula id="disp-formula18-0954410011409980"><label>(18)</label><graphic xlink:href="10.1177_0954410011409980-eq18.tif"/></disp-formula>
<disp-formula id="disp-formula19-0954410011409980"><label>(19)</label><graphic xlink:href="10.1177_0954410011409980-eq19.tif"/></disp-formula>
<disp-formula id="disp-formula20-0954410011409980"><label>(20)</label><graphic xlink:href="10.1177_0954410011409980-eq20.tif"/></disp-formula>
</p>
<p>It can be shown that by a proper redefinition of partitioning and depth used for the construction of states, a stochastic automaton can be converted to a deterministic finite state automata [<bold><xref ref-type="bibr" rid="bibr29-0954410011409980">29</xref></bold>]. But that transformation inevitably leads to state explosion and uneconomical growth in the computational complexity.</p>
<p>Instead, in the current scheme, the state transition probability vectors <inline-formula id="ilm6-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math6-0954410011409980"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>π</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub> </mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>, which are the rows of the state transition matrix δ, serve as feature vectors, and are used for the purpose of fault detection. An extremely convenient feature of using state transition probabilities as feature vectors, and using stochastic methods to define distances between nominal and off-nominal behaviours of plants is that this technique is very robust to noise.</p>
<p>This article proposes a <italic>Pseudo-Learning</italic> technique of utilizing the stochastic state transition function δ for the purpose of fault detection. In this method, the actual state transitions inside the fixed-structure automaton in the fault detection phase occur according to the output symbol sequence obtained from the actual system; and, at each instant of state transition, the trained automaton produces a state transition probability vector π<sub><italic>n</italic></sub> [<bold><xref ref-type="bibr" rid="bibr29-0954410011409980">29</xref></bold>] that represents the characteristics of the nominal system corresponding to inputs at this <italic>n</italic>th instant.</p>
<p>It is noted that the pattern vector π<sub><italic>n</italic></sub>, produced by the trained automaton, is characteristic of the nominal behaviour of the plant given the past history of input, state, and output. The current (possibly off-nominal) condition of the plant is characterized by another state probability vector <inline-formula id="ilm7-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math7-0954410011409980"><mml:mrow><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>π</mml:mi></mml:mrow><mml:mi>~</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. This is defined for the actual system output at an instant <italic>n</italic>, for which only one element of the vector will be 1, rest are zeros. The next step is to use the sequences of instantaneous state probability vectors {<bold>π</bold><sub><italic>n</italic></sub>} and <inline-formula id="ilm8-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math8-0954410011409980"><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mstyle mathsize="normal" mathvariant="bold"><mml:mi>π</mml:mi></mml:mstyle></mml:mrow><mml:mi>~</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math></inline-formula> obtained at each time instant, to construct a pattern vector. Under the assumption of ergodicity of the system, a pattern can be generated from frequency count of the state visits over a wide time window in case of symbolic time series analysis [<bold><xref ref-type="bibr" rid="bibr12-0954410011409980">12</xref></bold>]. The equivalent process in the present case would be calculation of mean state probability vectors <bold><italic>p</italic></bold> and <inline-formula id="ilm9-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math9-0954410011409980"><mml:mrow><mml:mover><mml:mstyle mathsize="normal" mathvariant="bold"><mml:mi>p</mml:mi></mml:mstyle><mml:mi>~</mml:mi></mml:mover></mml:mrow></mml:math></inline-formula> from the collections {<bold>π</bold><sub>1</sub>, <bold>π</bold><sub>2</sub>, … , <bold>π</bold><sub><italic>n</italic></sub>} and <inline-formula id="ilm10-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math10-0954410011409980"><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mstyle mathsize="normal" mathvariant="bold"><mml:mi>π</mml:mi></mml:mstyle></mml:mrow><mml:mi>~</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mstyle mathsize="normal" mathvariant="bold"><mml:mi>π</mml:mi></mml:mstyle></mml:mrow><mml:mi>~</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mstyle mathsize="normal" mathvariant="bold"><mml:mi>π</mml:mi></mml:mstyle></mml:mrow><mml:mi>~</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math></inline-formula> respectively over time instants 1, 2, … , n. During the fault detection phase, the fixed structure automata model (already trained), as shown in <xref ref-type="fig" rid="fig3-0954410011409980">Fig. 3</xref> is used and state probability vectors <bold><italic>p</italic></bold> and <inline-formula id="ilm11-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math11-0954410011409980"><mml:mrow><mml:mover><mml:mstyle mathsize="normal" mathvariant="bold"><mml:mi>p</mml:mi></mml:mstyle><mml:mi>~</mml:mi></mml:mover></mml:mrow></mml:math></inline-formula> are obtained.</p>
<p>It may be noted that in an ideal case, <bold><italic>p</italic></bold> should converge to <inline-formula id="ilm12-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math12-0954410011409980"><mml:mrow><mml:mover><mml:mstyle mathsize="normal" mathvariant="bold"><mml:mi>p</mml:mi></mml:mstyle><mml:mi>~</mml:mi></mml:mover></mml:mrow></mml:math></inline-formula>, while they should start to diverge from each other as the fault progresses. Thus, any measure of divergence of the two probability vectors, such as the difference, <inline-formula id="ilm13-0954410011409980"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math13-0954410011409980"><mml:mrow><mml:mstyle mathsize="normal" mathvariant="bold"><mml:mi>p</mml:mi></mml:mstyle><mml:mo>-</mml:mo><mml:mover><mml:mstyle mathsize="normal" mathvariant="bold"><mml:mi>p</mml:mi></mml:mstyle><mml:mi>~</mml:mi></mml:mover></mml:mrow></mml:math></inline-formula> is a natural choice (similar to residuals in Bayesian filtering based fault detection schemes [<bold><xref ref-type="bibr" rid="bibr30-0954410011409980">30</xref></bold>]) for constructing the pattern vector corresponding to that specific fault condition. Once the pattern vectors for a fault condition are obtained, a suitable classification algorithm, such as a support vector machine can be utilized to create the hyperplane separating the nominal patterns from the possibly off-nominal pattern vectors.<statement>
<title>Remark</title>
<p>In the <italic>Learning Automata</italic> literature, <italic>learning</italic> [<bold><xref ref-type="bibr" rid="bibr29-0954410011409980">29</xref></bold>] is done by continuous feedback from environment to the automaton at each time instant. Here, also similar feedback technique is taken but not for learning or changing the structure or internal functions of the finite state machine, but only to provide actual history of past outputs to the nominal automaton based model. Hence, the technique can be called a <italic>Pseudo-Learning Technique</italic>.</p></statement></p></sec>
<sec id="sec10-0954410011409980"><title>5 RESULTS AND DISCUSSION</title>
<p>Time series data have been collected for different sensors under persistent excitation of TRA inputs that have truncated triangular profiles. To simulate different operating conditions, each TRA input profile has been designed to have a wide range of mean values, amplitude, and frequency of excitation. Specifically, the algorithm has been tested for a mean TRA angle of 40 °, 60 °, and 80 °, with amplitude ranging from ±1 °, ±2 ° and ±3 ° and the frequency of input excitation varying between 0.1, 0.06, and 0.04 Hz. Also, the effects of altitude and aircraft speed have been taken into account by collecting data, while the aircraft is at sea-level (i.e. altitude <italic>a</italic> = 0.0, Mach number <italic>M</italic> = 0.0) when the engine is on the ground for fault monitoring and maintenance by the engineering personnel, as well as when it is in flight at ∼3000 m with Mach number <italic>M</italic> = 0.3. So, the entire learning set comprises of 3 × 3 × 3 × 2 = 54 operating conditions. <xref ref-type="fig" rid="fig4-0954410011409980">Figure 4</xref> shows readings from sensor <italic>P</italic><sub>24</sub> at different operating conditions for a nominal engine. <xref ref-type="fig" rid="fig5-0954410011409980">Figure 5</xref> illustrates the process of learning a PFSA from input–output signal pairs. However, the figure shows a simplified generic automata in order to explain the underlying concept. There is no direct correspondence to the actual automata used for fault detection. Data corresponding to only 4 out of the 54 operating conditions considered, are shown here to preserve clarity of presentation.
<fig id="fig4-0954410011409980" position="float"><label>Fig. 4</label><caption><p>Sensor reading at several operating conditions; in each set: solid lines imply input TRA oscillation amplitude = ±1° and frequency = 0.1 Hz; dotted lines imply amplitude = ±2° and frequency = 0.06 Hz; and dashed lines imply amplitude = ±3° and frequency = 0.04 Hz</p></caption><graphic xlink:href="10.1177_0954410011409980-fig4.tif"/></fig>
<fig id="fig5-0954410011409980" position="float"><label>Fig. 5</label><caption><p>Input (TRA) and output (Pressure) signals at different operating conditions and the learnt PFSA model</p></caption><graphic xlink:href="10.1177_0954410011409980-fig5.tif"/></fig></p>
<p>The engine simulation is conducted at a frequency of 66.67 Hz (i.e. inter-sample time of 15 <italic>ms</italic>) and the length of the simulation time window is 150 s, which generate 10 000 data points for each learning or test case, out of which the last 8000 data points are used to reduce the effects of initial transience.</p>
<p>An engine component <italic>C</italic> is considered to be in nominal condition when both ψ<sub><italic>C</italic></sub> and ζ<sub><italic>C</italic></sub> are equal to 1. Fault is injected in the fan by simultaneously reducing both ψ<sub><italic>C</italic></sub> and ζ<sub><italic>C</italic></sub> by same amount in the results reported in this article. For example, ψ<sub><italic>F</italic></sub> = ζ<sub><italic>F</italic></sub> = 0.98 signifies a 2 per cent relative loss in efficiency and flow capacity for fan.</p>
<sec id="sec11-0954410011409980"><title>5.1 Detection of a single fault</title>
<p>To analyse a representative single component fault situation in the current engine model, fault in fan has been considered, which is realized by modifying fan efficiency (ψ<sub><italic>F</italic></sub>) and flow modifier (ζ<sub><italic>F</italic></sub>). For both learning (i.e. forward problem) and testing (i.e. inverse problem), time series data from relevant sensor (<italic>P</italic>24 in this case) are generated with ψ<sub><italic>F</italic></sub> and ζ<sub><italic>F</italic></sub> ranging from 1.0 to 0.96 (i.e. 4 per cent relative loss in fan efficiency) in steps of 0.005.</p>
<p>The learning set comprises of the input signal profile of TRA and the output signal profile of <italic>P</italic>24 for all 54 operating conditions. The output data <italic>P</italic>24 from all these operating conditions are first normalized and then concatenated to form the complete output set. Such data are then discretized using a maximum entropy partitioning [<bold><xref ref-type="bibr" rid="bibr12-0954410011409980">12</xref></bold>]. The number of states in the PFSA is selected to be 15. Following the procedure outlined in <xref ref-type="sec" rid="sec3-0954410011409980">section 3</xref>, the augmented input space is constructed by discretizing the input and phase space. In this case, the output itself suffices as the phase space, i.e. <italic>m</italic>* = 1. The input specific probabilistic state transition matrices are next constructed, which conclude the learning process of the PFSA.</p>
<p>In the validation part, the input and output data corresponding to a single fault level (for example, when the fan efficiency level is, say, 0.995) but for all different input and operating conditions, are fed into the algorithm. The pattern vector cluster corresponding to this fault condition is calculated according to the algorithm described in <xref ref-type="sec" rid="sec3-0954410011409980">section 3</xref>. The success or failure of the algorithm depends on the distinguishability of these patterns from the pattern cluster generated by the machine when the engine was running in its nominal health state, albeit at different operating conditions.</p>
<p>A support vector machine (SVM) classifier with linear kernel [<bold><xref ref-type="bibr" rid="bibr31-0954410011409980">31</xref></bold>] has been used to classify the nominal from the off-nominal cases. The validation is done by choosing one of the datasets as test data and using the remaining data as the learning data, and noting whether it could be classified correctly. This is repeated for all the datasets to yield a true positive rate (TPR), true negative rate (TNR), false positive rate (FPR), and false negative rate (FNR). Here, ‘positive’ denotes nominal condition and ‘negative’ denotes off-nominality. Thus, false positive implies a missed event, i.e. a faulty engine is classified as healthy, and a false negative implies a false alarm, i.e. a healthy engine is misclassified as faulty.</p>
<p>In order to estimate the robustness of the technique with noisy data [<bold><xref ref-type="bibr" rid="bibr32-0954410011409980">32</xref></bold>, <bold><xref ref-type="bibr" rid="bibr33-0954410011409980">33</xref></bold>], the data are contaminated with additive white gaussian noise. The SNR in dB is decreased from 100 dB in the first run to 10 dB in steps of 10 dB. <xref ref-type="fig" rid="fig6-0954410011409980">Figure 6</xref> shows the output signals contaminated with white Gaussian noise for four different signal-to-noise intensity.
<fig id="fig6-0954410011409980" position="float"><label>Fig. 6</label><caption><p>Effects of additive white noise on pressure sensor data: signal- to noise ratio (SNR) decreasing from left to right</p></caption><graphic xlink:href="10.1177_0954410011409980-fig6.tif"/></fig></p>
<p><xref ref-type="fig" rid="fig7-0954410011409980">Figure 7</xref> displays the results of the SVM classifier when applied to patterns corresponding to different fan efficiencies. It is noted in <xref ref-type="fig" rid="fig7-0954410011409980">Fig. 7(a)</xref> that even a decrease of 0.5 per cent in fan efficiency can be detected with TPR = 100 per cent and FPR = 0 per cent for noise contamination at SNR = 40 dB. Even for SNR = 30 dB, the receiver operating characteristic (ROC) curve [<bold><xref ref-type="bibr" rid="bibr34-0954410011409980">34</xref></bold>] closely approaches the left-hand top corner. There is a significant decrease in performance for noise contamination at SNR = 20 dB and beyond.<statement>
<title>Remark</title>
<p>A typical use of an ROC graph is to enable the operator to assess the risk versus the gain potential of a decision. For example, the typical results from a certain risk-analysis study are as follows. A 2 per cent probability of failure to detect a degraded fan performance is acceptable for a certain kind of aircraft operation.</p></statement>
<fig id="fig7-0954410011409980" position="float"><label>Fig. 7</label><caption><p>ROC of symbolic identification classifier at different SNRs</p></caption><graphic xlink:href="10.1177_0954410011409980-fig7.tif"/></fig></p>
<p>The corresponding result for a relatively larger fault, corresponding to a decrease of 2.5 per cent in fan efficiency, is shown in <xref ref-type="fig" rid="fig7-0954410011409980">Fig. 7(b)</xref>. As expected, the noise tolerance for this classification is much higher, since the fault signature is also less subtle. It can be seen that an almost sure classification can be performed even when SNR = 20 dB.</p>
<p><xref ref-type="table" rid="table2-0954410011409980">Table 2</xref> displays the probability of actually detecting failures for an allowable FPR of 2 per cent for three different fault levels and several SNR conditions. It is noted that for very noisy signals (SNR = 20 dB), subtle faults (e.g. efficiency decrease of 0.5 per cent) are almost impossible to detect if the probability of missed detection is kept below 2 per cent. However, for slightly more degraded conditions (efficiency decrease of 3 per cent), failures can be detected with 100 per cent confidence while guaranteeing that missed detection rate is kept below 2 per cent.
<table-wrap id="table2-0954410011409980" position="float"><label>Table 2</label><caption><p>Fault detection rates for an allowable false positive rate of 2 per cent for different fault levels and several SNR conditions</p></caption>
<graphic alternate-form-of="table2-0954410011409980" xlink:href="10.1177_0954410011409980-table2.tif"/>
<table frame="hsides"><thead>
<tr>
<th/>
<th align="center" colspan="8">Fan efficiencies<hr/></th></tr>
<tr>
<th>SNR</th>
<th>0.995%</th>
<th>0.990%</th>
<th>0.985%</th>
<th>0.980%</th>
<th>0.975%</th>
<th>0.970%</th>
<th>0.965%</th>
<th>0.960%</th></tr></thead>
<tbody>
<tr>
<td>20</td>
<td>9.26%</td>
<td>35.19%</td>
<td>66.67%</td>
<td>88.89%</td>
<td>98.15%</td>
<td>100.00%</td>
<td>100.00%</td>
<td>100.00%</td></tr>
<tr>
<td>30</td>
<td>70.37%</td>
<td>100.00%</td>
<td>100.00%</td>
<td>100.00%</td>
<td>100.00%</td>
<td>100.00%</td>
<td>100.00%</td>
<td>100.00%</td></tr>
<tr>
<td>40</td>
<td>100.00%</td>
<td>100.00%</td>
<td>100.00%</td>
<td>100.00%</td>
<td>100.00%</td>
<td>100.00%</td>
<td>100.00%</td>
<td>100.00%</td></tr>
</tbody>
</table>
</table-wrap></p></sec>
<sec id="sec12-0954410011409980"><title>5.2 Detection of multiple faults</title>
<p>In an interconnected system (e.g. an gas turbine engine), detection of multiple faults is inherently a difficult problem, because a failure in one of the components, say <italic>Component A</italic> essentially changes the input conditions to some other component, say <italic>Component B</italic> and then off-nominal performance of <italic>Component B</italic> can either be due to an actual fault in <italic>Component B</italic> or due to the off-nominal input received by it. Thus, probabilities of missed detections and/or false alarms tend to rise. To resolve this problem, the key idea here is to treat possible fault conditions of <italic>Component A</italic> as different operating conditions for <italic>Component B</italic> and then to follow the similar procedure as before. In order to test the reliability of the algorithm against simultaneously occurring faults, two components have been chosen. The fan is assumed to be slowly deteriorating in terms of its efficiency as both ψ<sub><italic>F</italic></sub> and ζ<sub><italic>F</italic></sub> are decreased from their nominal values of 1. However, in contrast to the last simulation study, three levels of faults are considered here:
<list id="list8-0954410011409980" list-type="alpha-lower">
<list-item><p>‘low’, where ψ<sub><italic>F</italic></sub> = ζ<sub><italic>F</italic></sub> = 0.995;</p></list-item>
<list-item><p>‘medium’, where ψ<sub><italic>F</italic></sub> = ζ<sub><italic>F</italic></sub> = 0.975;</p></list-item>
<list-item><p>‘high’, where ψ<sub><italic>F</italic></sub> = ζ<sub><italic>F</italic></sub> = 0.960.</p></list-item>
</list></p>
<p>At the same time, further down the gas path, the low-pressure turbine also undergoes similar types of faults, i.e. ψ<sub><italic>LPT</italic></sub> = ζ<sub><italic>LPT</italic></sub> = 0.995, 0.975, and 0.960 progressively. The low-pressure turbine has been chosen as the second component to fail, because not only the turbine inlet temperature and pressure are dependent on the fan operation but also the turbine is directly mechanically linked to the fan through a shaft. This close interconnection obviously makesthe problem of unambiguous detection much harder.</p>
<p>Similar to the last simulation study, the robustness of the algorithm is tested by running the engine at different operating conditions. The main actuator input TRA is again varied to have a wide range in mean, amplitude as well as frequency. The mean takes on three different values, 40 °, 60 °, and 80 °, with amplitude ranging from ±1 °, ±2 °, and ±3 ° and the frequency of input excitation varying between 0.1, 0.06, and 0.04 Hz. Altitude and mach number are changed to simulate both ground operation and flight at ∼ 3600 m. These two testing environments combined together with 3 × 3 × 3 = 27 types of throttle inputs result in 54 operating conditions in all. However, the four health conditions (nominal and three fault conditions as defined before) of the fan appear as four new operating condition for the low-pressure turbine, since faults in the fan effectively change the input condition downstream. The same holds for LPT faults also. Hence, effectively, the number of operating conditions for which each component is tested turns out to be 54 × 4 = 216.</p>
<p>The simulation studies are divided into two parts:
<list id="list9-0954410011409980" list-type="alpha-lower">
<list-item><p>Part 1, where faults in the fan are identified in the presence of faults in the LPT;</p></list-item>
<list-item><p>Part 2, where faults in the LPT are identified in the presence of faults in the fan.</p></list-item>
</list></p>
<p>The signals monitored for detection of fan faults remain the same as those in the final section, i.e. <italic>TRA</italic> is used as the input signal profile, while <italic>P</italic>24 as the output signal. The output signal is discretized into 15 states with maximum entropy partitioning. The procedure explained in <xref ref-type="sec" rid="sec3-0954410011409980">section 3</xref> is followed exactly, and the results obtained are displayed in the left-hand side of <xref ref-type="fig" rid="fig8-0954410011409980">Fig. 8</xref>.
<fig id="fig8-0954410011409980" position="float"><label>Fig. 8</label><caption><p>Receiver-operating characteristics of the symbolic identification classifier. From top to bottom, fault level increases from <italic>low</italic> → <italic>medium</italic> → <italic>high</italic>; left and right panels are fault detection performance in fan and LPT, respectively, in (possible) presence of fault in the other</p></caption><graphic xlink:href="10.1177_0954410011409980-fig8.tif"/></fig></p>
<p>Temperature sensors at the input and output of the low-pressure turbine, <italic>T</italic>48 and <italic>T</italic> 50, respectively, are simultaneously monitored for change detection in the LPT. Although sensors to monitor <italic>T</italic> 50 are not generally used in commercial engines, they could be mounted easily as LPT exit typically does not present any harsher environment compared to those at the other usual sensor locations. A similar processing yields the pattern vectors corresponding to each operating conditions.</p>
<p>For a faulty condition of the component under investigation, say a drop in relative efficiency of 0.005, the pattern vectors generated for all 216 operating conditions are tested for their ‘classifiability’ from pattern vectors generated by the healthy component for the same 216 operating conditions. The top row in <xref ref-type="fig" rid="fig8-0954410011409980">Fig. 8</xref> shows the receiver-operating characteristics, i.e. the rate of correct and false diagnoses when the components have failed to a very small degree. <xref ref-type="fig" rid="fig8-0954410011409980">Figures 8(a) and (b)</xref> shows that the algorithm becomes less and less trustworthy as the noise level increases for ‘low’ level faults. Compared to the last simulation study with single faults, where even at <italic>SNR</italic> = 40 dB, 100 per cent correct classification was possible, this simulation is conducted in the presence of faults in other components having several trade-offs between TPR and FPR. As the fault signatures become stronger, almost certain detection of faults is possible even in the presence of substantial noise (i.e. SNR = 40 dB). This is illustrated for ‘medium’ level faults (i.e. efficiency = 0.975) in both fan and <italic>LPT</italic> in <xref ref-type="fig" rid="fig8-0954410011409980">Figs 8(c) and (d)</xref>, respectively. For ‘high’ level faults (i.e. efficiency= 0.960), the same trend is visible in <xref ref-type="fig" rid="fig8-0954410011409980">Figs 8(e) and (f)</xref>. Similar to <xref ref-type="table" rid="table2-0954410011409980">Table 2</xref> for single-component faults, <xref ref-type="table" rid="table3-0954410011409980">Table 3</xref> provides the probability of actually detecting failures for an allowable FPR of 2 per cent for three different fault levels and several SNR conditions.
<table-wrap id="table3-0954410011409980" position="float"><label>Table 3</label><caption><p>Fault detection rates for both FAN and LPT for an allowable false positive rate of 2 per cent</p></caption>
<graphic alternate-form-of="table3-0954410011409980" xlink:href="10.1177_0954410011409980-table3.tif"/>
<table frame="hsides"><thead>
<tr>
<th/>
<th align="center" colspan="3">Fan degradation level<hr/></th>
<th align="center" colspan="3">LPT degradation level<hr/></th></tr>
<tr>
<th/>
<th align="center">Low (%)</th>
<th align="center">Medium (%)</th>
<th align="center">High (%)</th>
<th align="center">Low (%)</th>
<th align="center">Medium (%)</th>
<th align="center">High (%)</th></tr></thead>
<tbody>
<tr>
<td>40</td>
<td>14.35</td>
<td>93.06</td>
<td>95.83</td>
<td>31.48</td>
<td>100.00</td>
<td>100.00</td></tr>
<tr>
<td>60</td>
<td>57.87</td>
<td>100.00</td>
<td>100.00</td>
<td>46.76</td>
<td>100.00</td>
<td>100.00</td></tr>
<tr>
<td>80</td>
<td>97.69</td>
<td>100.00</td>
<td>100.00</td>
<td>81.48</td>
<td>100.00</td>
<td>100.00</td></tr>
<tr>
<td>100</td>
<td>100.00</td>
<td>100.00</td>
<td>100.00</td>
<td>100.00</td>
<td>100.00</td>
<td>100.00</td></tr>
</tbody>
</table>
</table-wrap></p>
<p>For very small faults, the fault signature is hidden in the noisy signal; particularly the simultaneous presence of other faults affect the information stream throughout the complex system. However, even for relatively small changes in efficiency, as small as 2.5 per cent, the algorithm can effectively detect and isolate faults in closely linked components.</p></sec></sec>
<sec id="sec13-0954410011409980"><title>6 SUMMARY, CONCLUSIONS AND FUTURE WORK</title>
<p>A syntactic method has been proposed for the detection of single- and multi-component faults in aircraft gas turbine engines. The two primary features of this fault detection method are: (a) <italic>symbolic identification</italic> and (b) <italic>pseudo-learning</italic>. A PFSA model of the process dynamics is constructed from the input–output data; the PFSA representation is analogous to a non-linear system model that is functionally equivalent to a linear system transfer function. The reported work is a step towards building a real-time data-driven tool for estimation of parametric conditions in complex dynamical systems. Scalability may become a critical issue for this method of fault detection with increase in number of components and fault levels. However, a natural way to circumvent this problem is to perform isolation of a faulty subsystem with a relatively small number of components before detection of a fault in a particular component [<bold><xref ref-type="bibr" rid="bibr14-0954410011409980">14</xref></bold>, <bold><xref ref-type="bibr" rid="bibr15-0954410011409980">15</xref></bold>].</p>
<p>Further theoretical, computational, and experimental work is necessary before this fault detection tool can be considered for incorporation into the instrumentation and control system of aircraft engines. For example, real flight record data and environmental condition data need to be incorporated to investigate the effects of atmospheric temperature and pressure variations on the fault detection algorithm. The following theoretical topics are currently under investigation:
<list id="list10-0954410011409980" list-type="alpha-lower">
<list-item><p>development of a multi-dimensional partitioning for a MIMO system, which should be computationally inexpensive;</p></list-item>
<list-item><p>development of a comprehensive sensor fusion algorithm to handle multiple sensor data simultaneously for detection;</p></list-item>
<list-item><p>estimation of a theoretical bound on the error incurred in this process of fault detection;</p></list-item>
<list-item><p>extension of the symbolic identification technique to incorporate transient engine operations, i.e. during take-off, climb, or landing;</p></list-item>
<list-item><p>generation of the health status at the vehicle level <italic>via</italic> linguistic methods [<bold><xref ref-type="bibr" rid="bibr35-0954410011409980">35</xref></bold>].</p></list-item>
</list></p></sec>
</body>
<back>
<sec id="sec14-0954410011409980"><title>FUNDING</title>
<p>This work has been supported in part by NASA under Cooperative Agreement No. NNX07AK49A, and by the U.S. Army Research Laboratory and Army Research Office under Grant No. W911NF-07-1-0376. Any opinions, findings and conclusions or recommendations expressed in this publication are those of the authors and do not necessarily reflect the views of the Sponsoring agencies.</p></sec>
<ref-list>
<title>REFERENCES</title>
<ref id="bibr1-0954410011409980"><label>1</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Broersen</surname><given-names>P.</given-names></name></person-group> <article-title>Estimation of parameters of non-linear dynamical systems</article-title>. <source>Int. J. Non-linear Mech.</source>, <year>1974</year>, <volume>9</volume>, <fpage>355</fpage>–<lpage>361</lpage>.</citation></ref>
<ref id="bibr2-0954410011409980"><label>2</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Van Lith</surname><given-names>P.</given-names></name><name><surname>Witteveen</surname><given-names>H.</given-names></name><name><surname>Betlem</surname><given-names>B.</given-names></name><name><surname>Roffel</surname><given-names>B.</given-names></name></person-group> <article-title>Multiple nonlinear parameter estimation using pi feedback control</article-title>. <source>Control Eng. Pract.</source>, <year>2001</year>, <volume>9</volume>, <fpage>517</fpage>–<lpage>531</lpage>.</citation></ref>
<ref id="bibr3-0954410011409980"><label>3</label><citation citation-type="book"><person-group person-group-type="author"><name><surname>Wan</surname><given-names>E.</given-names></name><name><surname>Van der Merwe</surname><given-names>R.</given-names></name></person-group> <article-title>The unscented kalman filter for nonlinear estimation</article-title>. <source><italic>In Proceedings of the IEEE Symposium 2000 ASSPCC, Lake Louise, Alta, Canada</italic></source>, <year>1–4 October 2000</year>, <fpage>153</fpage>–<lpage>158</lpage>.</citation></ref>
<ref id="bibr4-0954410011409980"><label>4</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Julier</surname><given-names>S.</given-names></name><name><surname>Uhlmann</surname><given-names>J.</given-names></name></person-group> <article-title>A new extension of the kalman filter to nonlinear systems</article-title>. <source>Proc. SPIE</source>, <year>1997</year>, <volume>3068</volume>, <fpage>182</fpage>–<lpage>193</lpage>.</citation></ref>
<ref id="bibr5-0954410011409980"><label>5</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Ching</surname><given-names>J.</given-names></name><name><surname>Beck</surname><given-names>J.</given-names></name><name><surname>PorterChin</surname><given-names>K.</given-names></name></person-group> <article-title>Bayesian state and parameter estimation of uncertain dynamical systems</article-title>. <source>Prob. Eng. Mech.</source>, <year>2006</year>, <volume>21</volume>(<issue>1</issue>), <fpage>81</fpage>–<lpage>96</lpage>.</citation></ref>
<ref id="bibr6-0954410011409980"><label>6</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Bremer</surname><given-names>C.</given-names></name><name><surname>Kaplan</surname><given-names>D.</given-names></name></person-group> <article-title>Markov chain Monte Carlo estimation of nonlinear dynamics from time series</article-title>. <source>Physica D</source>, <year>2001</year>, <volume>160</volume>, <fpage>116</fpage>–<lpage>126</lpage>.</citation></ref>
<ref id="bibr7-0954410011409980"><label>7</label><citation citation-type="confproc"><person-group person-group-type="author"><name><surname>Wang</surname><given-names>Y.</given-names></name><name><surname>Geng</surname><given-names>L.</given-names></name></person-group> <article-title>Bayesian network based fault section estimation in power systems</article-title>. <year>14–17 November 2006</year>, <conf-name>IEEE Region 10 Annual International Conference, TENCON</conf-name>. <publisher-loc>Hong Kong, China</publisher-loc>.</citation></ref>
<ref id="bibr8-0954410011409980"><label>8</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Hoffman</surname><given-names>A.</given-names></name><name><surname>van der Merwe</surname><given-names>N.</given-names></name></person-group> <article-title>The application of neural networks to vibrational diagnostics for multiple fault conditions</article-title>. <source>Comput. Stand. Interfaces</source>, <year>2002</year>, <volume>24</volume>(<issue>2</issue>), <fpage>139</fpage>–<lpage>149</lpage>.</citation></ref>
<ref id="bibr9-0954410011409980"><label>9</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>David</surname><given-names>B.</given-names></name><name><surname>Bastin</surname><given-names>G.</given-names></name></person-group> <article-title>Parameter estimation in nonlinear systems with auto and crosscorrelated noise</article-title>. <source>Automatica</source>, <year>2002</year>, <volume>38</volume>, <fpage>81</fpage>–<lpage>90</lpage>.</citation></ref>
<ref id="bibr10-0954410011409980"><label>10</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Ghanem</surname><given-names>R.</given-names></name><name><surname>Romeo</surname><given-names>F.</given-names></name></person-group> <article-title>A wavelet-based approach for model and parameter identification of non-linear systems</article-title>. <source>Int. J. Non-linear Mech.</source>, <year>2001</year>, <volume>36</volume>, <fpage>835</fpage>–<lpage>859</lpage>.</citation></ref>
<ref id="bibr11-0954410011409980"><label>11</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Yao</surname><given-names>L.</given-names></name><name><surname>Sethares</surname><given-names>W.</given-names></name></person-group> <article-title>Nonlinear parameter estimation via the genetic algorithm</article-title>. <source>IEEE Trans. Signal Process.</source>, <year>1994</year>, <volume>42</volume>(<issue>4</issue>), <fpage>927</fpage>–<lpage>935</lpage>.</citation></ref>
<ref id="bibr12-0954410011409980"><label>12</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Ray</surname><given-names>A.</given-names></name></person-group> <article-title>Symbolic dynamic analysis of complex systems for anomaly detection</article-title>. <source>Signal Process.</source>, <year>2004</year>, <volume>84</volume>(<issue>7</issue>), <fpage>1115</fpage>–<lpage>1130</lpage>.</citation></ref>
<ref id="bibr13-0954410011409980"><label>13</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Rajagopalan</surname><given-names>V.</given-names></name><name><surname>Ray</surname><given-names>A.</given-names></name></person-group> <article-title>Symbolic time series analysis via waveletbased partitioning</article-title>. <source>Signal Process.</source>, <year>2006</year>, <volume>86</volume>(<issue>11</issue>), <fpage>3309</fpage>–<lpage>3320</lpage>.</citation></ref>
<ref id="bibr14-0954410011409980"><label>14</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Gupta</surname><given-names>S.</given-names></name><name><surname>Ray</surname><given-names>A.</given-names></name><name><surname>Sarkar</surname><given-names>S.</given-names></name><name><surname>Yasar</surname><given-names>M.</given-names></name></person-group> <article-title>Fault detection and isolation in aircraft gas turbine engines. Part 1: Underlying concept</article-title>. <source>Proc. IMechE, Part G: J. Aerospace Engineering</source>, <year>2008</year>, <volume>222</volume>(<issue>3</issue>), <fpage>307</fpage>–<lpage>318</lpage>.</citation></ref>
<ref id="bibr15-0954410011409980"><label>15</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Sarkar</surname><given-names>S.</given-names></name><name><surname>Yasar</surname><given-names>M.</given-names></name><name><surname>Gupta</surname><given-names>S.</given-names></name><name><surname>Ray</surname><given-names>A.</given-names></name><name><surname>Mukherjee</surname><given-names>K.</given-names></name></person-group> <article-title>Fault detection and isolation in aircraft gas turbine engines. Part 2: Validation on a simulationtest bed</article-title>. <source>Proc. IMechE, Part G: J. Aerospace Engineering</source>, <year>2008</year>, <volume>222</volume>(<issue>3</issue>), <fpage>319</fpage>–<lpage>330</lpage>.</citation></ref>
<ref id="bibr16-0954410011409980"><label>16</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Sarkar</surname><given-names>S.</given-names></name><name><surname>Rao</surname><given-names>C.</given-names></name><name><surname>Ray</surname><given-names>A.</given-names></name></person-group> <article-title>Statistical estimation of multiple faults in aircraft gas turbine engines</article-title>. <source>Proc I MechE Part G: J. Aerospace Engineering</source>, <year>2009</year>, <volume>223</volume>(<issue>4</issue>), <fpage>415</fpage>–<lpage>424</lpage>.</citation></ref>
<ref id="bibr17-0954410011409980"><label>17</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Rao</surname><given-names>C.</given-names></name><name><surname>Ray</surname><given-names>A.</given-names></name><name><surname>Sarkar</surname><given-names>S.</given-names></name><name><surname>Yasar</surname><given-names>M.</given-names></name></person-group> <article-title>Review and comparative evaluation of symbolic dynamic filtering for detection of anomaly patterns</article-title>. <year>2008</year>, <comment>DOI 10.1007/s11760-008-0061-8</comment>.</citation></ref>
<ref id="bibr18-0954410011409980"><label>18</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Subbu</surname><given-names>A.</given-names></name><name><surname>Ray</surname><given-names>A.</given-names></name></person-group> <article-title>Space partitioning via Hilbert transform for symbolic time series analysis</article-title>. <source>Appl. Phys. Lett.</source>, <year>2008</year>, <volume>92</volume>(<issue>08</issue>), <fpage>084107</fpage>–<lpage>084107</lpage>.</citation></ref>
<ref id="bibr19-0954410011409980"><label>19</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Frederick</surname><given-names>D.</given-names></name><name><surname>DeCastro</surname><given-names>J.</given-names></name><name><surname>Litt</surname><given-names>J.</given-names></name></person-group> <article-title>Users guide for the commercial modular aero-propulsion system simulation (c-mapss)</article-title>. <year>October 2007</year>, <comment>NASA/TM2007-215026</comment>.</citation></ref>
<ref id="bibr20-0954410011409980"><label>20</label><citation citation-type="other"><comment>C-MAPSS: Commercial modular aero-propulsion system simulation, NASA GRC Software Repository, 2007</comment>.</citation></ref>
<ref id="bibr21-0954410011409980"><label>21</label><citation citation-type="confproc"><person-group person-group-type="author"><name><surname>Kobayashi</surname><given-names>T.</given-names></name><name><surname>Simon</surname><given-names>D.</given-names></name></person-group> <article-title>A hybrid neural network-genetic algorithm technique for aircraft engine performance diagnostics</article-title>. <year>8–11 July 2001</year>, <conf-name>Proceedings of the 37th Joint Propulsion Conference and Exhibit co-sponsored by the AIAA, ASME, SAE, and ASEE</conf-name>. <publisher-loc>Salt Lake City, Utah</publisher-loc>.</citation></ref>
<ref id="bibr22-0954410011409980"><label>22</label><citation citation-type="book"><person-group person-group-type="author"><name><surname>Hopcroft</surname><given-names>J.</given-names></name><name><surname>Motwani</surname><given-names>R.</given-names></name><name><surname>Ullman</surname><given-names>J.</given-names></name></person-group> <source>Introduction to automata theory, languages, and computation</source>, <edition>3rd edition</edition>. <publisher-loc>Boston, Massachusetts, USA</publisher-loc>, <publisher-name>Addison-Wesley Longman Publishing Co., Inc</publisher-name>, <year>2006</year>.</citation></ref>
<ref id="bibr23-0954410011409980"><label>23</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Kokar</surname><given-names>M.</given-names></name></person-group> <article-title>On consistent symbolic representations of general dynamic systems</article-title>. <source>IEEE Trans. Syst. Man Cybernetics</source>, <year>1995</year>, <volume>25</volume>(<issue>8</issue>), <fpage>1231</fpage>–<lpage>1242</lpage>.</citation></ref>
<ref id="bibr24-0954410011409980"><label>24</label><citation citation-type="book"><person-group person-group-type="author"><name><surname>Levy</surname><given-names>L.</given-names></name></person-group> <source>Discrete structures of computer science</source>. <publisher-loc>New York</publisher-loc>, <publisher-name>John Wiley &amp; Sons</publisher-name>, <year>1980</year>.</citation></ref>
<ref id="bibr25-0954410011409980"><label>25</label><citation citation-type="book"><person-group person-group-type="author"><name><surname>Takens</surname><given-names>F.</given-names></name></person-group> <source>Detecting strange attractors in turbulence</source>, <year>1981</year>, <volume>Vol. 898/1981</volume>, <publisher-loc>Berlin/ Heidelberg</publisher-loc>, <publisher-name>Springer</publisher-name>.</citation></ref>
<ref id="bibr26-0954410011409980"><label>26</label><citation citation-type="confproc"><person-group person-group-type="author"><name><surname>Gautama</surname><given-names>T.</given-names></name><name><surname>Mandic</surname><given-names>D.</given-names></name><name><surname>Hulle</surname><given-names>M. V.</given-names></name></person-group> <article-title>A differential entropy based method for determining the optimal embedding parameters of a signal. In Proceedings of the</article-title>. <comment>IEEE International Conference on Acoustics, speech, and signal processing, Hong Kong, China, Vol. 6 (6–10) pp. VI-29-32, 6–10 April 2003</comment>.</citation></ref>
<ref id="bibr27-0954410011409980"><label>27</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Beirlant</surname><given-names>J.</given-names></name><name><surname>Dudewicz</surname><given-names>E. J.</given-names></name><name><surname>Gyrfi</surname><given-names>L.</given-names></name><name><surname>Meulen</surname><given-names>E. C.</given-names></name></person-group> <article-title>Nonparametric entropy estimation: An overview</article-title>. <source>Int. J. Math. Stat. Sci.</source>, <year>1997</year>, <volume>6</volume>, <fpage>17</fpage>–<lpage>39</lpage>.</citation></ref>
<ref id="bibr28-0954410011409980"><label>28</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Martins</surname><given-names>J.</given-names></name><name><surname>Dente</surname><given-names>J.</given-names></name><name><surname>Pires</surname><given-names>A.</given-names></name><name><surname>Mendes</surname><given-names>R.</given-names></name></person-group> <article-title>Language identification of controlled systems: Modeling, control, and anomaly detection</article-title>. <source>IEEE Trans. Syst. Man Cybernetics, Part C: Applications And Reviews</source>, <year>2007</year>, <comment>May</comment>.</citation></ref>
<ref id="bibr29-0954410011409980"><label>29</label><citation citation-type="book"><person-group person-group-type="author"><name><surname>Narendra</surname><given-names>K.</given-names></name><name><surname>Thathachar</surname><given-names>M.</given-names></name></person-group> <source>Learning automata an introduction</source>. <publisher-loc>Upper Saddle River, New Jersey, USA</publisher-loc>, <publisher-name>Prentice-Hall</publisher-name>, <year>1989</year>.</citation></ref>
<ref id="bibr30-0954410011409980"><label>30</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Kobayashi</surname><given-names>T.</given-names></name><name><surname>Simon</surname><given-names>D. L.</given-names></name></person-group> <article-title>Hybrid kalman filter approach for aircraft engine in-flight diagnostics: Sensor fault detection case</article-title>. <source>J. Eng. Gas Turbines Power</source>, <year>2007</year>, <volume>129</volume>, <fpage>746</fpage>–<lpage>754</lpage>.</citation></ref>
<ref id="bibr31-0954410011409980"><label>31</label><citation citation-type="book"><person-group person-group-type="author"><name><surname>Duda</surname><given-names>R.</given-names></name><name><surname>Hart</surname><given-names>P.</given-names></name><name><surname>Stork</surname><given-names>D.</given-names></name></person-group> <source>Pattern classification</source>. <publisher-loc>New York</publisher-loc>, <publisher-name>John Wiley &amp; Sons Inc</publisher-name>, <year>2001</year>.</citation></ref>
<ref id="bibr32-0954410011409980"><label>32</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Simon</surname><given-names>D. L.</given-names></name><name><surname>Garg</surname><given-names>S.</given-names></name></person-group> <article-title>Optimal tuner selection for kalman filterbased aircraft engine performance estimation</article-title>. <source>J. Eng. Gas Turbines Power</source>, <year>2010</year>, <volume>132</volume>(<issue>3</issue>), <fpage>031601</fpage>–<lpage>031601</lpage>.</citation></ref>
<ref id="bibr33-0954410011409980"><label>33</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Lu</surname><given-names>P.</given-names></name><name><surname>Zhang</surname><given-names>M.</given-names></name><name><surname>Hsu</surname><given-names>T.</given-names></name><name><surname>Zhang</surname><given-names>J.</given-names></name></person-group> <article-title>An evaluation of engine faults diagnostics using artificial neural networks</article-title>. <source>J. Eng. Gas Turbines Power</source>, <year>2001</year>, <volume>123</volume>(<issue>2</issue>), <fpage>340</fpage>–<lpage>346</lpage>.</citation></ref>
<ref id="bibr34-0954410011409980"><label>34</label><citation citation-type="book"><person-group person-group-type="author"><name><surname>Poor</surname><given-names>V.</given-names></name></person-group> <source>An introduction to signal detection and estimation</source>, <edition>2nd edition</edition>. <publisher-loc>New York, USA</publisher-loc>, <publisher-name>Springer-Verlag</publisher-name>, <year>1988</year>.</citation></ref>
<ref id="bibr35-0954410011409980"><label>35</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Yang</surname><given-names>T.</given-names></name></person-group> <article-title>Computational verb theory: Ten years later</article-title>. <source>Int. J. Comput. Cognit.</source>, <year>2007</year>, <volume>5</volume>, <fpage>63</fpage>–<lpage>86</lpage>.</citation></ref>
</ref-list>
</back>
</article>