<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD Journal Publishing DTD v2.3 20070202//EN" "journalpublishing.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">CER</journal-id>
<journal-id journal-id-type="hwp">spcer</journal-id>
<journal-title>Concurrent Engineering</journal-title>
<issn pub-type="ppub">1063-293X</issn>
<issn pub-type="epub">1531-2003</issn>
<publisher>
<publisher-name>SAGE Publications</publisher-name>
<publisher-loc>Sage UK: London, England</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1177/1063293X11435345</article-id>
<article-id pub-id-type="publisher-id">10.1177_1063293X11435345</article-id>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Articles</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>View updates and constraint validations in collaborative design environments</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" corresp="yes">
<name><surname>Yoo</surname><given-names>Sang B</given-names></name>
</contrib>
<contrib contrib-type="author">
<name><surname>Kim</surname><given-names>Ki C</given-names></name>
</contrib>
<contrib contrib-type="author">
<name><surname>Yoo</surname><given-names>Hyeong S</given-names></name>
</contrib>
<aff id="aff1-1063293X11435345">Inha University, Incheon, Republic of Korea</aff>
</contrib-group>
<author-notes>
<corresp id="corresp1-1063293X11435345">Sang B Yoo, Department of Computer Science and Information Technology, Inha University, 253 Yonghyun-dong, Nam-gu, Incheon 402-751, Republic of Korea Email: <email>syoo@inha.ac.kr</email></corresp>
<fn fn-type="other" id="bio1-1063293X11435345">
<p>Dr. Sang Bong Yoo received a B.S. degree in Control and Instrumentation Engineering from Seoul National University in 1982, and M.S. degree in Electrical and Computer Engineering from the University of Arizona in 1986, and a Ph.D. degree in Electrical and Computer Engineering from Purdue University in 1990. Currently, he is a Professor of Department of Computer Science and Information Technology at Inha University, Inchon, Korea. Previously, he was a technical manager at Samsung Electronics Co., Seoul, Korea. His research interests include Collaborative Design, Engineering Databases, Semantic Web, and Knowledge Management.</p>
</fn>
<fn fn-type="other" id="bio2-1063293X11435345">
<p>Dr. Ki Chang Kim received the B.S. in computer science from California Polytechnique State University, Pomona, in 1986. He received the Ph.D. degree in computer science from University of California at Irvine, in 1992. He is currently a Professor in the Department of Information and Communication Engineering, Inha University, Korea. His research interests include computer security and operating systems.</p>
</fn>
<fn fn-type="other" id="bio3-1063293X11435345">
<p>Dr. Hyeong Seon Yoo is a professor in Department of Computer Science and Information Technology at Inha University, Korea. He received MS from the Department of Mechanical Engineering at the Korea Advanced Institute of Science and Technology and Ph.D from the Department of Mechanical Engineering at University of Ghent, Belgium. His main research areas are numerical analysis, computer security, and applied cryptography.</p>
</fn>
</author-notes>
<pub-date pub-type="epub-ppub">
<month>3</month>
<year>2012</year>
</pub-date>
<volume>20</volume>
<issue>1</issue>
<fpage>69</fpage>
<lpage>80</lpage>
<permissions>
<copyright-statement>© The Author(s) 2012</copyright-statement>
<copyright-year>2012</copyright-year>
<copyright-holder content-type="sage">SAGE Publications</copyright-holder>
</permissions>
<abstract>
<p>In collaborative designs that are either intracompany or intercompany, data security and integrity validation are two major concerns. Even though design views can be used effectively for access controls, view updates may cause violation of integrity constraints defined for the base designs. This article focuses on the validation of integrity constraints after view updates. Following standard for the exchange of product model data methodologies, information model is defined by EXPRESS and views are defined by EXPRESS-X. Shared design data are stored in a relational database system (e.g. Oracle 11g XE). The integrity constraints defined in EXPRESS schema are translated into UNIQUE and CHECK and triggers in SQL. Then, they are automatically validated after view updates. Because the paradigm presented in this article is based on open standards such as EXPRESS, EXPRESS-X, and SQL, it is independent from any proprietary system and suitable for collaborative design environments that consist of heterogeneous systems.</p>
</abstract>
<kwd-group>
<kwd>view updates</kwd>
<kwd>integrity validation</kwd>
<kwd>collaborative design</kwd>
<kwd>EXPRESS</kwd>
<kwd>EXPRESS-X</kwd>
<kwd>SQL</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="section1-1063293X11435345" sec-type="intro">
<title>Introduction</title>
<p>As the computer network proliferates over the whole world recently, collaborative designs that are either intracompany or intercompany become common practices. It is inevitable to share the design data among the participants in collaborative designs. Two major concerns on the data sharing in collaborative designs are data security and integrity validation. In order to collaborate in design processes, participating design units exchange their design results and some confidential design data can be included in the exchanges. When a single design unit is involved in a design process, the integrity of the design is more properly maintained because a design unit usually has proper expertise and methodologies for that. However, when two or more design units design a product collaboratively, a change of design specification of one part could conflict with some constraints of another part of the product.</p>
<p>In this article, we use design views to manage the security of design data in the process of collaborative designs. In database systems, views are virtual tables that control the accessibility of different users to the shared data. According to the role of a design unit, different views can be defined (<xref ref-type="bibr" rid="bibr4-1063293X11435345">Cera et al., 2004</xref>). For example, if a mechanical designer of a mouse button does not need to know the details of the electronic circuits inside, a view can be created without the circuits and provided for him (or her).</p>
<p>Integrity constraints are a set of rules to be validated by a database system after any change in the data. For example, there can be an upper limit of the total weight for an assembly block. When a part included in the assembly block is changed into a heavier part, the database system checks if the total weight of the assembly block is still below the upper limit. Even though the design rules cannot guarantee the integrity of a design 100%, they encode human expertise and prevent many unintentional or intentional flaws. Integrity constraints of EXPRESS (<xref ref-type="bibr" rid="bibr11-1063293X11435345">ISO 10303-11:2004, 2004</xref>) consist of both local rules and global rules and have the expressive power of high-level programming languages.</p>
<p>In this study, information modeling and view definition follow standard for the exchange of product model data (STEP) methodologies defined as ISO standards (<xref ref-type="bibr" rid="bibr10-1063293X11435345">ISO 10303-1:1994, 1994</xref>). The objective of STEP is to provide a mechanism that is capable of describing product data throughout the life cycle of a product, independent from any particular system. The architecture of collaborative design environment is depicted in <xref ref-type="fig" rid="fig1-1063293X11435345">Figure 1</xref>, where multiple design units share an engineering database and work cooperatively. Standard data access interface (SDAI) (<xref ref-type="bibr" rid="bibr13-1063293X11435345">ISO 10303-22:1998, 1998</xref>) is an application program interface (API) that enables heterogeneous information systems to access the shared database. In STEP, information model is defined by EXPRESS and views are defined by EXPRESS-X (<xref ref-type="bibr" rid="bibr12-1063293X11435345">ISO 10303-14:2005, 2005</xref>).</p>
<fig id="fig1-1063293X11435345" position="float">
<label>Figure 1.</label>
<caption>
<p>Collaborative design environment.</p>
<p>SDAI: standard data access interface.</p>
</caption>
<graphic xlink:href="10.1177_1063293X11435345-fig1.tif"/>
</fig>
<p>A relational database system such as Oracle 11g XE (<xref ref-type="bibr" rid="bibr19-1063293X11435345">Oracle, 2011</xref>) is used for the shared database system. Relational database systems support SQL (<xref ref-type="bibr" rid="bibr14-1063293X11435345">ISO/IEC 9075-1:2008, 2008</xref>), which is the standard query language. Information model and integrity constraints defined by EXPRESS and views defined by EXPRESS-X are translated into SQL so that they can be validated by a relational database system. Because views are updatable in relational database systems, any change of view results in changes in base tables, and integrity constraints associated with the table are validated. Database triggers are used in order to handle integrity constraints that are not supported by other features of relational database systems.</p>
<p>This article is organized as follows. The “Related work” section summarizes related work. In the “Integrity constraints and validation” section, each integrity constraint supported by EXPRESS is translated into SQL schema so that they can be validated in relational database systems. The “View definitions” section describes view definition in EXPRESS-X. Because we focus on view updates, only updatable views in relational database systems are included. The “Working scenario” section explains a working scenario using a collaborative design example. Finally, conclusions and future work are discussed in the “Conclusion” section.</p>
</sec>
<sec id="section2-1063293X11435345">
<title>Related work</title>
<p>STEP is an international effort to promote information sharing across heterogeneous engineering environments. EXPRESS was originally developed as a part of the STEP project, and as such most of the information models developed in STEP can be defined by EXPRESS. Besides its use in standardization, EXPRESS is also used in various research areas and industries for product modeling and system integration purposes (Eberl; <xref ref-type="bibr" rid="bibr8-1063293X11435345">Feng et al., 2009</xref>). Validation of the integrity constraints via EXPRESS for the shared data—stored in file systems or database management system (DBMS)—has been carried out differently by different researches. Various approaches include multiprocessing (<xref ref-type="bibr" rid="bibr18-1063293X11435345">Mueller et al., 1993</xref>), view materialization (<xref ref-type="bibr" rid="bibr2-1063293X11435345">Alt, 1994</xref>), and distributed database systems (<xref ref-type="bibr" rid="bibr22-1063293X11435345">Yoo and Suh, 1999</xref>).</p>
<p>Due to the evolutionary nature of design processes, integrity management of collaborative design often requires that the details of design history should be properly handled. In <xref ref-type="bibr" rid="bibr9-1063293X11435345">Goonetillake et al. (2002)</xref>, a hierarchical database architecture is adopted, which supports the collaborative nature of design. It separates private and shared work by means of global and local workspaces/databases, respectively, and provides enough flexibility for individual designers to work on their local databases while collaborating with other designers. <xref ref-type="bibr" rid="bibr8-1063293X11435345">Feng et al. (2009)</xref> propose a network version model in order to properly handle the evolutionary data and object management in complex engineering design projects. The version control operations included in the network version model include version creation, browsing, comparison, querying and submission of object in process, and version mirroring.</p>
<p>On the other hand, Semantic Web technologies are adopted in order to capture more formal knowledge. <xref ref-type="bibr" rid="bibr15-1063293X11435345">Kim et al. (2006)</xref> address the ontology-based assembly design (AsD) to support collaborative product development such that design intent can be well understood by other designers, and the applications can reason assembly knowledge without any semantic ambiguity. AsD ontology, defining shared conceptualization of AsD modeling, is developed in their research to make assembly knowledge accurate and machine interpretable. <xref ref-type="bibr" rid="bibr1-1063293X11435345">Ahmed et al. (2007)</xref> develop ontology for engineering design for knowledge sharing among engineers to assist engineers in indexing, searching, and retrieving design knowledge. In <xref ref-type="bibr" rid="bibr16-1063293X11435345">Li and Yoo (2011)</xref>, a collaborative engineering design environment has been devised based on Semantic Web technologies. The domain knowledge of design objects is expressed by Web Ontology Language (OWL) and validated when associated design data change. Rule bases should be carefully designed because the reasoning process of the first-order logic is indeterministic.</p>
<p>In collaborative design processes, design data and knowledge should be shared among the participants. However, uncontrolled sharing of information may result in improper protection for the intellectual properties. Design views are adopted in order to control the access privilege to 3D models by a role-based mechanism (<xref ref-type="bibr" rid="bibr4-1063293X11435345">Cera et al., 2004</xref>). Using the role-based viewing, individual users see only the data they are allowed to see at the level of detail they are permitted to see it. For concurrent engineering and PLM, details of multiple view management issues are further elaborated in <xref ref-type="bibr" rid="bibr3-1063293X11435345">Bouikni et al. (2008)</xref>. Throughout the life cycle of a product, views are not only newly generated but also they are recuperated or updated. Processes for each view management operations are analyzed in detail stages.</p>
<p>As a summary, the related work is compared from various aspects in <xref ref-type="table" rid="table1-1063293X11435345">Table 1</xref>. In CAD/PLM systems, the terminology “view” is used more broadly than it is used in database systems. A design may have different views such as schematic view and layout view. A three-dimensional model also has multiple view drawings depending on the directions. In database systems, on the other hand, all derived virtual tables are referred as views. The views defined in this article are close to the views in database systems. Using STEP technologies, information model and views are defined by EXPRESS and EXPRESS-X, respectively. Because the STEP technologies are open international standards, they can be employed for implementations without any permission. In this study, we also use the view update features that are supported in relational database systems. In particular, the codes presented in this article are implemented and tested in Oracle 11g XE.</p>
<table-wrap id="table1-1063293X11435345" position="float">
<label>Table 1</label>
<caption>
<p>Comparison of related work</p>
</caption>
<graphic alternate-form-of="table1-1063293X11435345" xlink:href="10.1177_1063293X11435345-table1.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="left"/>
<col align="left"/>
<col align="left"/>
<col align="left"/>
<col align="left"/>
</colgroup>
<thead>
<tr>
<th/>
<th align="left">Researches on multiple views<sup>1,17</sup></th>
<th align="left">Researches on integrity validation<sup>13,16</sup></th>
<th align="left">CAD/PLM<sup>18,19</sup></th>
<th align="left">Database systems<sup>6,20</sup></th>
<th align="left">System proposed in this article</th>
</tr>
</thead>
<tbody>
<tr>
<td>View management features</td>
<td>—Role-based access control<break/>—View generation, recuperation, and update</td>
<td>Not available</td>
<td>—Multiple view drawings<break/>—Different views (schematic and layout)</td>
<td>—View retrievals<break/>—View updates<break/>—Materialized views</td>
<td>—Restriction/projection of base entity<break/>—Join of base entities<break/>—Union/intersection of base entities</td>
</tr>
<tr>
<td>Integrity validation features</td>
<td>Not available</td>
<td>—Constraints (range, enumeration, and relationship) <break/>—Constraints in rules</td>
<td>—Place constraints<break/>—Geometric constraints<break/>—Dimensional constraints</td>
<td>—Attribute constraints<break/>—Keys (primary and foreign) <break/>—Check constraints<break/>—Triggers</td>
<td>—Uniqueness constraints<break/>—Local constraints<break/>—Existence constraints<break/>—Global rules</td>
</tr>
<tr>
<td>Formal methods employed</td>
<td>—Role-based access control<break/>—Product feature evolution validation</td>
<td>—First-order logic<break/>—Version management</td>
<td>—Proprietary API</td>
<td>—SQL</td>
<td>—EXPRESS<break/>—EXPRESS-X</td>
</tr>
</tbody>
</table>
<table-wrap-foot>
<fn id="table-fn1-1063293X11435345">
<p>API: application program interface.</p>
</fn>
</table-wrap-foot>
</table-wrap>
</sec>
<sec id="section3-1063293X11435345">
<title>Integrity constraints and validation</title>
<p>EXPRESS has quite strong expressive power of defining integrity constraints, which can include general algorithms. The more powerful expression we have, the more computation power we require. The algorithms included in integrity constraints are translated into executable functions separately. These functions can be called during the validation of integrity constraints. In EXPRESS, we have four types of integrity constraints: uniqueness constraints, local constraints, existence constraints, and global rules. In this section, we present how to validate each type of integrity constraints in relational database systems.</p>
<sec id="section4-1063293X11435345">
<title>Uniqueness constraints</title>
<p>UNIQUE clauses declare the uniqueness constraints on a single attribute or a set of multiple attributes of an entity type. If a UNIQUE is defined on a single attribute, no two or more entity instances can have the same value for that attribute. A UNIQUE definition on a set of multiple attributes restricts the same combination of values for the named attributes.</p>
<p>The uniqueness constraints on a single attribute in EXPRESS have the same semantics as the PRIMARY KEY and the UNIQUE clause in SQL base table constraints. SQL base table constraints are specified on either CREATE TABLE or ALTER TABLE. The PRIMARY KEY and UNIQUE clause in SQL is defined as follows:</p>
<p>PRIMARY KEY ( &lt;column name commalist&gt; )</p>
<p>UNIQUE ( &lt;column name commalist&gt; )</p>
<p>The uniqueness constraints on a set of multiple attributes of an entity type in EXPRESS, however, do not have the corresponding constraints in SQL. In order to check such constraints, database triggers can be used. A database trigger is a procedure that is run automatically when a specified event occurs. This event could be an insert, a deletion, or an update of data in a table. Triggers provide a facility to autonomously react to database events by evaluating a data-dependent condition and by executing a reaction whenever the condition is satisfied. Such triggers are regarded as an important database feature and are implemented by most major database vendors.</p>
<p>As an example, consider an entity <italic>part</italic> that contains general management information such as identifier, name, and the quantities included in an assembly. The following entity definition has a UNIQUE clause, where <italic>ur1</italic> is a label and <italic>id</italic> specifies the attribute to be unique. It is declared that all the instances for the entity <italic>part</italic> could not have the same identifier.</p>
<p>ENTITY part;</p>
<p> id : STRING;</p>
<p> name: STRING;</p>
<p> alternate_name: STRING;</p>
<p> quantities_in_superitem: INTEGER;</p>
<p>UNIQUE</p>
<p> ur1: id;</p>
<p> ur2: name, alternate_name;</p>
<p>END_ENTITY;</p>
<p>EXPRESS entities are defined as tables in relational database systems. In the following SQL statement, a table named <italic>part</italic> is created along with four attributes. Because the attribute <italic>id</italic> is a primary key, it is not necessary to define a UNIQUE constraint additionally.</p>
<p>CREATE TABLE part</p>
<p> ( id VARCHAR2(8),</p>
<p> name VARCHAR2(8),</p>
<p> alternate_name VARCHAR2(8),</p>
<p> quantities_ in_superitem INTEGER,</p>
<p> PRIMARY KEY (id) );</p>
<p>As for the uniqueness constraint <italic>ur2</italic> in entity <italic>part</italic>, the following trigger is defined. Whenever the table <italic>part</italic> is inserted or updated, the result of two queries is counted and compared. Because the second query eliminates any duplicate rows, the two counts are different if the attributes <italic>name</italic> and <italic>alternate_name</italic> have duplicate values.</p>
<p>CREATE OR REPLACE TRIGGER “part_ur2”</p>
<p>AFTER insert OR update ON “part” FOR EACH ROW</p>
<p>BEGIN</p>
<p> if ( count (SELECT name, alternate_name FROM part) &lt;&gt;</p>
<p> count (SELECT DISTINCT name, alternate_name FROM part) )</p>
<p> then dbms_output.put_line(‘Warning: uniqueness constraint <italic>ur2</italic> is violated’);</p>
<p>END;</p>
</sec>
<sec id="section5-1063293X11435345">
<title>Local constraints</title>
<p>WHERE clauses in EXPRESS define the local constraints that apply to each instance of an entity. The local constraints specify the valid value of an attribute or a combination of multiple attributes. The local constraints correspond to CHECK constraints in SQL as follows:</p>
<p> CHECK ( <italic>&lt;bool exp&gt;</italic> )</p>
<p>Let <italic>CC</italic> be a check constraint for base table <italic>T</italic>. Then <italic>T</italic> is considered to violate <italic>CC</italic> if and only if it currently contains at least one row and the current value of <italic>T</italic> makes the <italic>&lt;bool exp&gt;</italic> for <italic>CC</italic> evaluate to FALSE. SQL specification allows arbitrarily complex expressions for the <italic>&lt;bool exp&gt;</italic>. However, Oracle 11g XE allows only simple comparison for a single attribute; triggers are used for checking local constraints that include general expressions.</p>
<p>The WHERE clause in the following example includes two local constraints: constraint <italic>positive_a</italic> allows only positive values for attribute <italic>a</italic>, and constraint <italic>length_1</italic> specifies that the length of every instance of entity <italic>unit_vector</italic> should be 1.</p>
<p>ENTITY unit_vector;</p>
<p> a, b, c : REAL;</p>
<p>WHERE</p>
<p> positive_a : a &gt; 0;</p>
<p> length_1 : a**2 + b**2 + c**2 = 1.0;</p>
<p>END_ENTITY;</p>
<p>Because the constraint <italic>positive_a</italic> contains only simple comparison for a single attribute, it can be implemented using a CHECK constraint in SQL CREATE TABLE statement. On the other hand, a database trigger is defined in order to check the constraint <italic>length_1</italic>.</p>
<p>CREATE TABLE unit_vector</p>
<p> a decimal, b decimal, c decimal,</p>
<p> CHECK ( a &gt; 0 );</p>
<p>CREATE OR REPLACE TRIGGER “unit_vector_length_1”</p>
<p>AFTER insert OR update ON “unit_vector” FOR EACH ROW</p>
<p>BEGIN</p>
<p> if (SQUARE (a) + SQUARE (b) + SQUARE (c) &lt;&gt; 1.0)</p>
<p> then dbms_output.put_line(‘Warning: local constraint <italic>length_1</italic> is violated’);</p>
<p>END;</p>
</sec>
<sec id="section6-1063293X11435345">
<title>Existence constraints</title>
<p>The question here is whether the existence of an instance of one entity is dependent upon the existence of an instance of another related entity. If another entity has established a relationship with the current entity by way of an explicit attribute, an inverse attribute may be used to describe that relationship in the context of the current entity. SQL includes assertions for general constraints as follows:</p>
<p>CREATE ASSERTION <italic>&lt;constraint name&gt;</italic></p>
<p>CHECK ( <italic>&lt;bool exp&gt;</italic> )</p>
<p>Most commercial database systems including Oracle 11g XE do not support assertions because validating assertions could affect the database performance significantly. Database triggers are used instead for checking the existence constraints.</p>
<p>This example includes two entities, that is, <italic>bolt</italic> and <italic>nut.</italic> Entity <italic>bolt</italic> has <italic>fastener</italic> as an attribute, which specifies the matching nut. On the other hand, entity <italic>nut</italic> has an attribute <italic>fasten</italic>, which specifies the matching bolt. In order that the integrity of the database is properly maintained, a pair of instances of bolt and nut, which match each other, should exist in the database.</p>
<p>ENTITY bolt;</p>
<p> id: STRING;</p>
<p> size: STRING;</p>
<p> fastener: nut;</p>
<p>END_ENTITY;</p>
<p>ENTITY nut;</p>
<p> id: STRING;</p>
<p> size: STRING;</p>
<p>INVERSE</p>
<p> fasten: bolt FOR fastener;</p>
<p>END_ENTITY;</p>
<p>The entities <italic>bolt</italic> and <italic>nut</italic> are defined as relational tables. Attributes <italic>fastener</italic> and <italic>fasten</italic> are defined as foreign keys because they have values that are keys in other tables. In order to validate the inverse constraint, the trigger <italic>nut_inverse</italic> is defined.</p>
<p>CREATE TABLE bolt</p>
<p> id VARCHAR2(8),</p>
<p> size VARCHAR2(8),</p>
<p> fastener VARCHAR2(8),</p>
<p>FOREIGN KEY (fastener) REFERENCES nut;</p>
<p>CREATE TABLE nut</p>
<p> id VARCHAR2(8),</p>
<p> size VARCHAR2(8),</p>
<p> fasten VARCHAR2(8),</p>
<p>FOREIGN KEY (fasten) REFERENCES bolt;</p>
<p>CREATE OR REPLACE TRIGGER "nut_inverse"</p>
<p>AFTER insert OR update on "NUT" for each row</p>
<p>DECLARE</p>
<p> matfastner VARCHAR2(8);</p>
<p>BEGIN</p>
<p> select fastner into matfastner from bolt where bolt.id = :new.fasten;</p>
<p> if (:new.id &lt;&gt; matfastner)</p>
<p> then dbms_output.put_line(‘Warning: an existence constraint is violated’);</p>
<p> end if;</p>
<p>END;</p>
<p>Database assertion for the above existence constraint is defined in the following. It is more straightforward than the trigger because it can be defined declaratively.</p>
<p>CREATE ASSERTION nut_inverse CHECK</p>
<p> ( NOT EXIST (SELECT * FROM nut WHERE</p>
<p>  id != (SELECT fastener FROM bolt WHERE bolt.id = fasten) ) );</p>
</sec>
<sec id="section7-1063293X11435345">
<title>Global rules</title>
<p>Global rules can be defined by EXPRESS RULEs, which specify the constraints among a set of instances of an entity type or of multiple entity types. A RULE consists of executable statements and a WHERE clause, which decides the validity of data by the results of the executables. A RULE declaration includes the list of entities, which are referenced by the rule. Similarly to the existence constraints, database assertions are suitable for validating the global rules. However, database triggers are used instead because assertions are not supported in commercial database systems.</p>
<p>The following rule specifies that the number of points in the first octant should be the same as the number of points in the seventh octant:</p>
<p>RULE point_match FOR (point);</p>
<p>LOCAL</p>
<p> first_oct, seventh_oct : SET OF POINT := []; – initialized as empty set of point</p>
<p>END_LOCAL;</p>
<p> first_oct := QUERY (temp &lt;* point | (temp.x&gt;0) AND (temp.y&gt;0) AND (temp.z&gt;0));</p>
<p> seventh_oct := QUERY (temp &lt;* point | (temp.x&lt;0) AND (temp.y&lt;0) AND (temp.z&lt;0));</p>
<p>WHERE</p>
<p> SIZEOF(first_oct) = SIZEOF(seventh_oct);</p>
<p>END_RULE;</p>
<p>In order to validate this global rule, a database trigger is defined as follows:</p>
<p>CREATE OR REPLACE TRIGGER “point_match”</p>
<p>
AFTER insert OR delete OR update ON “point” FOR EACH ROW</p>
<p>BEGIN</p>
<p> if ( count (SELECT * FROM point WHERE x&gt;0 AND y&gt;0 AND z&gt;0) &lt;&gt;</p>
<p>  count (SELECT * FROM point WHERE x&lt;0 AND y&lt;0 AND z&lt;0) )</p>
<p> then dbms_output.put_line(‘Warning: global rule point_match is violated’);</p>
<p>END;</p>
<p>Database assertion for the above global rule would be defined as follows:</p>
<p>CREATE ASSERTION point_match CHECK</p>
<p> (COUNT (SELECT * FROM point WHERE (x&gt;0) AND (y&gt;0) AND (z&gt;0)) =</p>
<p> COUNT (SELECT * FROM point WHERE (x&lt;0) AND (y&lt;0) AND (z&lt;0)));</p>
</sec>
</sec>
<sec id="section8-1063293X11435345">
<title>View definitions</title>
<p>Views are not base entities, but they are virtual entities that are derived from base entities. The derivation process can involve such relational operations as union, intersect, difference, restrict, project, extend, join, product, divide, and summarize. Once a view is defined and populated, it can be considered the same as a base entity for using its values. Depending on the relationship among a view and its base entities, some views cannot be updated due to semantic ambiguity. For example, a view containing aggregate functions such as <italic>sum( )</italic> and <italic>average( )</italic> cannot be updated.</p>
<p>SQL regards the following views as updatable (<xref ref-type="bibr" rid="bibr6-1063293X11435345">Date, 2004</xref>):</p>
<list id="list1-1063293X11435345" list-type="order">
<list-item><p>Views defined as a restriction and/or projection of a single base table</p></list-item>
<list-item><p>Views defined as a one-to-one or one-to-many join of two base tables (in the one-to-many case, only the “many” side is updatable)</p></list-item>
<list-item><p>Views defined as a union or intersect of two distinct base tables</p></list-item>
</list>
<p>In order to avoid those ambiguities that can be involved in view updates, we consider only those views that are updatable in SQL. In the following subsections, an example for each updatable view is explained. For the examples in the remaining of this section, all the entities in this article as well as the following entities are assumed to be included in <italic>base_schema</italic>:</p>
<p>ENTITY dept;</p>
<p> name : STRING; budget : REAL;</p>
<p>END_ENTITY;</p>
<p>ENTITY manager;</p>
<p> id : STRING; name : STRING; manages : dept;</p>
<p>END_ENTITY;</p>
</sec>
<sec id="section9-1063293X11435345">
<title>Restriction of a single base entity</title>
<p>Let entity <italic>a</italic> have attributes <italic>X</italic> and <italic>Y</italic> (and possibly others), and let θ be an operator—typically “=,”“&lt;&gt;,”“&gt;,”“&lt;,” and so on—such that the Boolean expression <italic>X</italic>θ<italic>Y</italic> evaluates to TRUE or FALSE. Then the restriction</p>
<p><italic>a</italic> WHERE <italic>X</italic>θ<italic>Y</italic></p>
<p>is an entity that includes all the instances of <italic>a</italic> such that the expression <italic>X</italic>θ<italic>Y</italic> evaluates to TRUE. In the following example, view <italic>emp_eng</italic> includes all the employee’s names working in engineering department:</p>
<p>SCHEMA_VIEW example;</p>
<p> REFERENCE FROM base_schema;</p>
<p> VIEW emp_eng;</p>
<p> FROM e : emp;</p>
<p> WHERE e.work_in = ‘engineering’;</p>
<p> SELECT</p>
<p>  id : e.id;</p>
<p>  name : e.name;</p>
<p>  work_in : e.work_in;</p>
<p>END_VIEW;</p>
<p>END_SCHEMA_VIEW;</p>
<p>In relational databases, views are defined by SQL. The above-mentioned view is defined by SQL as follows:</p>
<p>CREATE VIEW emp_eng (id, name, work_in) AS</p>
<p> SELECT id, name, work_in</p>
<p> FROM emp</p>
<p> WHERE work_in = ‘engineering’;</p>
<sec id="section10-1063293X11435345">
<title>Projection of a single base entity</title>
<p>Let entity <italic>a</italic> have attributes <italic>X</italic>, <italic>Y</italic>, …, <italic>Z</italic> (and possibly others). Then the projection of entity <italic>a</italic> on <italic>X</italic>, <italic>Y</italic>, …, <italic>Z</italic></p>
<p>a { X, Y, …, Z }</p>
<p>is an entity that includes all the instances in <italic>a</italic> with only the attributes mentioned in the set {<italic>X</italic>, <italic>Y</italic>, …, <italic>Z</italic>}. In the following example, view <italic>dept_name</italic> derived from entity <italic>dept</italic> by removing attributes other than <italic>name</italic>:</p>
<p>SCHEMA_VIEW example;</p>
<p> REFERENCE FROM base_schema;</p>
<p> VIEW dept_name;</p>
<p>  FROM d : dept;</p>
<p>  SELECT</p>
<p>   name : d.name;</p>
<p> END_VIEW;</p>
<p>END_SCHEMA_VIEW;</p>
<p>The above-mentioned view is defined by SQL as follows:</p>
<p>CREATE VIEW dept_name (name) AS</p>
<p> SELECT name</p>
<p> FROM dept;</p>
</sec>
<sec id="section11-1063293X11435345">
<title>One-to-one join of two base entities</title>
<p>Join operation combines two entities into one on the basis of join condition. Let entity <italic>a</italic> have an attribute <italic>X</italic> and let entity <italic>b</italic> have an attribute <italic>Y</italic>. Then a join given by</p>
<p>(<italic>a</italic> TIMES <italic>b</italic>) WHERE <italic>X</italic>θ<italic>Y</italic></p>
<p>is the Cartesian product of <italic>a</italic> and <italic>b</italic>, and includes only the instances for which the expression <italic>X</italic>θ<italic>Y</italic> evaluates to TRUE. In mathematics, the Cartesian product of two sets is the set of all ordered pairs such that, in each pair, the first element comes from the first set and the second element comes from the second set. Thus, the Cartesian product of two entities would be a set of ordered pairs of instances.</p>
<p>Join can be classified into three types depends on the cardinality ratios that specify the number of relationship instances that an entity can participate in, that is, one-to-one, one-to-many, and many-to-many. Consider an example of join between two entities <italic>bolt</italic> and <italic>nut</italic> with join condition <italic>bolt.fastener = nut.id</italic>. Assuming that a bolt has at most one matching nut and a nut also has at most one matching bolt, this join is one-to-one.</p>
<p>SCHEMA_VIEW example;</p>
<p> REFERENCE FROM base_schema;</p>
<p> VIEW boltnnut;</p>
<p>  FROM b: bolt; n:nut;</p>
<p>  WHERE b.fastener = nut.id;</p>
<p>  SELECT</p>
<p>   bolt_id : b.id;</p>
<p>   nut_id: n.id;</p>
<p> END_VIEW;</p>
<p>END_SCHEMA_VIEW;</p>
<p>In relational databases, the above-mentioned view is defined in SQL as follows:</p>
<p>CREATE VIEW boltnnut (bolt_id, nut_id) AS</p>
<p> SELECT bolt.id, nut.id</p>
<p> FROM bolt, nut</p>
<p> WHERE bolt.fastener = nut.id;</p>
</sec>
<sec id="section12-1063293X11435345">
<title>One-to-many join of two base entities</title>
<p>As an example of one-to-many join, consider the join between entities <italic>emp</italic> and <italic>dept</italic>. With the join condition <italic>emp.work_in = dept.name</italic>, it relates an employee with a department in which the employee is working. Assuming that an employee is working in at most one department and a department has multiple employees, the cardinality ratio of this join is one-to-many.</p>
<p>SCHEMA_VIEW example;</p>
<p> REFERENCE FROM base_schema;</p>
<p> VIEW empndept;</p>
<p>  FROM e: emp; d:dept;</p>
<p>  WHERE e.work_in = d.name;</p>
<p>  SELECT</p>
<p>   emp_id : e.id;</p>
<p>   dept_name : d.name;</p>
<p>   dept_budget : d.budget;</p>
<p> END_VIEW;</p>
<p>END_SCHEMA_VIEW;</p>
<p>In relational databases, the above-mentioned view is defined in SQL as follows:</p>
<p>CREATE VIEW empndept (emp_id, dept_name, dept_budget) AS</p>
<p> SELECT emp.id, dept.name, dept.budget</p>
<p> FROM emp, dept</p>
<p> WHERE emp.work_in = dept.name;</p>
<p>Note that only the “many” side is updatable in the one-to-many join. This means that the attribute <italic>dept_budget</italic> in view <italic>empndept</italic> cannot be changed. Suppose that there are three instances in view <italic>empndept</italic>.</p>
<p>#1=EMPNDEPT(‘emp1’,’Engineering’,10.1);</p>
<p>#2=EMPNDEPT (‘emp2’,‘Smith’,’Sales’,30.3);</p>
<p>#3=EMPNDEPT (‘emp3’,’Engineering’,10.1);</p>
<p>If we change the <italic>dept_budget</italic> (which is “one” side of the join) of instance #1 from 10.1 to 20.2, the instance #1 becomes as follows:</p>
<p>#1=EMPNDEPT(‘emp1’,’Engineering’,20.2);</p>
<p>It results an inconsistency that the budget of engineering department is 20.2 in instance <italic>#1</italic> and 10.1 in instance <italic>#3</italic>. This is why such updates are not allowed in relational databases.</p>
</sec>
<sec id="section13-1063293X11435345">
<title>Union of two distinct base entities</title>
<p>In mathematics, the union of two sets is the set of all elements belonging to either or both of the given sets. Since an entity contains a set of instances, it is obviously possible to construct the union of two entities. In order to define unions, we use view partitions in EXPRESS-X. A view partition is a subset of a view extent. In other words, a view extent is the union of its partitions. A view declaration consists of one or more partition declarations, each partition declaration having its own FROM and WHERE clauses.</p>
<p>The following example defines a view <italic>emp_union_manager</italic>, which include two partitions <italic>from_emp</italic> and <italic>from_manager</italic>. Partition <italic>from_emp</italic> includes all the employees included in the entity <italic>emp</italic>, and partition <italic>from_manager</italic> includes all the managers included in the entity <italic>manager</italic>. As a result, the view <italic>emp_union_manager</italic> includes all the employees in the entity <italic>emp</italic> and all the managers included in the entity <italic>manager</italic>.</p>
<p>SCHEMA_VIEW example;</p>
<p> REFERENCE FROM base_schema;</p>
<p> VIEW emp_union_manager;</p>
<p>  PARTITION from_emp;</p>
<p>   FROM e: emp;</p>
<p>   SELECT</p>
<p>    id : e.id;</p>
<p>    name : e.name;</p>
<p>  PARTITION from_manager;</p>
<p>   FROM m: manager;</p>
<p>   SELECT</p>
<p>   id : m.id;</p>
<p>   name : m.name;</p>
<p> END_VIEW;</p>
<p>END_SCHEMA_VIEW;</p>
<p>In relational databases, the above-mentioned view is defined in SQL as follows:</p>
<p>CREATE VIEW emp_union_manager (id, name) AS</p>
<p> SELECT id, name</p>
<p> FROM emp</p>
<p> UNION</p>
<p> SELECT id, name</p>
<p> FROM manager;</p>
<p>Entities cannot contain a mixture of different kinds of instances, that is, they must be “instance-homogeneous.” As a consequence, two entities should have the same type in order to be inputs to union. It means that the two entities have the same number of attributes, and each corresponding attributes have the same type. This requirement is termed as union compatibility.</p>
</sec>
<sec id="section14-1063293X11435345">
<title>Intersect of two base entities</title>
<p>Given two entities <italic>a</italic> and <italic>b</italic> of the same type, the intersection of those two entities, <italic>a</italic> INTERSECT <italic>b</italic>, is an entity of the same type, with instances consisting of all instances <italic>i</italic> such that <italic>i</italic> appears in both <italic>a</italic> and <italic>b</italic>. To be intersecting, two entities should be union compatible. In the following example, view <italic>emp_intersect_manager</italic> includes all the employees who are managers at the same time.</p>
<p>SCHEMA_VIEW example;</p>
<p> REFERENCE FROM base_schema;</p>
<p> VIEW emp_intersect_manager;</p>
<p>  FROM e: emp; m: manager;</p>
<p>  WHERE</p>
<p>   e.id = m.id;</p>
<p>   e.name = m.name;</p>
<p>   e.work_in = m.manages;</p>
<p>  SELECT</p>
<p>   id : e.id;</p>
<p>   name : e.name;</p>
<p>   department : e.work_in;</p>
<p> END_VIEW;</p>
<p>END_SCHEMA_VIEW;</p>
<p>In relational databases, the above-mentioned view is defined by SQL as follows:</p>
<p>CREATE VIEW emp_intersect_manager (id, name, department) AS</p>
<p> SELECT id, name, work_in</p>
<p> FROM emp</p>
<p> INTERSECT</p>
<p> SELECT id, name, manages</p>
<p> FROM manager;</p>
</sec>
</sec>
<sec id="section15-1063293X11435345">
<title>Working scenario</title>
<p>Design procedure of headlamps for automobiles is presented in this section as an example of collaborative design. Because the functions of headlamps are controlled by strict regulations and closely related to the safety of automobiles, the design of a new headlamp requires both high level of technical expertise and careful consideration of all the requirements. As an example of such regulations, some countries require automobiles to be equipped with automatic daytime running lamps (DRLs), which are intended to increase the conspicuity of vehicles in motion during the daytime (<xref ref-type="bibr" rid="bibr20-1063293X11435345">Paine, 2003</xref>). DRL may consist of the manual or automatic illumination of the low beams at full or reduced intensity, or the high beams at reduced intensity, or may not involve the headlamps at all.</p>
<p>Design procedure of headlamps is outlined in <xref ref-type="fig" rid="fig2-1063293X11435345">Figure 2</xref>, where three design teams—that is, body design team, optical design team, and engineering team—work collaboratively. Once the design team styles a body, the body profile for the car is received by the optical design team. The optical design team designs the major components such as lenses, reflectors, and housing. Before the new design is finalized, it is required that the heat flow is analyzed by the engineering team. At this stage, the design data of headlamp need to be sent from the optical design team to the engineering team. Because the details of optical design are sensitive technical properties, it is better to send only the minimum information that is required to the heat flow analysis. In order to protect the technical details, only the simplified headlamp view can be sent to the engineering team. After the engineering team analyzes the heat flow of each component, the power consumption can be adjusted in order to prevent any overheat. At the final stage of the design process, all deign constraints are conformed to be validated. If any violation is found, the design process returns to the initial stage and resolves it.</p>
<fig id="fig2-1063293X11435345" position="float">
<label>Figure 2.</label>
<caption>
<p>Collaborative design procedure of headlamps.</p>
</caption>
<graphic xlink:href="10.1177_1063293X11435345-fig2.tif"/>
</fig>
<p>Information model of headlamp consists of two schemas, that is, a source schema and a view schema. The source schema includes an entity that includes the details of headlamp design as shown in <xref ref-type="fig" rid="fig3-1063293X11435345">Figure 3(a)</xref>. As an local constraint, the entity <italic>headlamp</italic> includes a WHERE clause that specifies the attribute <italic>bulb</italic> should be equal to the <italic>matching_bulb</italic> of the reflector. The detailed specifications of headlamp design are substituted by simplified view in the view <italic>headlamp_enginering</italic>.</p>
<fig id="fig3-1063293X11435345" position="float">
<label>Figure 3.</label>
<caption>
<p>Example of headlamp design: (a) exploded parts and (b) result of thermal flow analysis.</p>
</caption>
<graphic xlink:href="10.1177_1063293X11435345-fig3.tif"/>
</fig>
<p>SCHEMA source_schema; – An EXPRESS schema</p>
<p>ENTITY headlamp;</p>
<p> item_number : INTEGER;</p>
<p> bulb : bulb_type;</p>
<p> reflector : reflector_type;</p>
<p> lens : lens_type;</p>
<p>WHERE</p>
<p> bulb_match: reflector.matching_bulb = bulb;</p>
<p>END_ENTITY;</p>
<p>END_SCHEMA;</p>
<p>
SCHEMA_VIEW view_schema; – An EXPRESS-X view schema</p>
<p>REFERENCE FROM source_schema;</p>
<p>VIEW headlamp_engineering;</p>
<p> FROM h : headlamp;</p>
<p> SELECT</p>
<p>  item_number : INTEGER := h.item_number;</p>
<p>  bulb : bulb_type := h.bulb;</p>
<p> reflector_simplified : reflector_simplified_type := h.reflector.simplified_shape;</p>
<p>  lens : lens_type := h.lens;</p>
<p>END_VIEW;</p>
<p>END_SCHEMA_VIEW;</p>
<p>The entity and view defined in EXPRESS and EXPRESS-X, respectively, are implemented as a table and view in a relational database system. An SQL schema for the relational database system is given in the following. The WHERE clause in entity <italic>headlamp</italic> is translated into a database trigger.</p>
<p>CREATE TABLE headlamp</p>
<p> item_number varchar2(8) NOT NULL,</p>
<p> bulb_id varchar2(8),</p>
<p> reflector_id varchar2(8),</p>
<p> lens_id varchar2(8);</p>
<p>
CREATE OR REPLACE TRIGGER "bulb_match"</p>
<p>
AFTER insert OR update on "headlamp" for each row</p>
<p>DECLARE</p>
<p> mb VARCHAR2(8);</p>
<p>BEGIN</p>
<p> select matching_bulb into mb from reflector where reflector_id = :new.reflector_id;</p>
<p> if (:new.bulb_id &lt;&gt; mb)</p>
<p> then dbms_output.put_line(‘Warning: Bulb does not match with reflector’);</p>
<p> end if;</p>
<p>END;</p>
<p>
The view <italic>headlamp_simplified</italic> is defined by SQL as follows:</p>
<p>SELECT headlamp.item_number,</p>
<p> headlamp.bulb_id,</p>
<p> reflector.reflector_simplified,</p>
<p> headlamp.lens_id</p>
<p>FROM headlamp, reflector</p>
<p>WHERE headlamp.reflector_id =</p>
<p> reflector.reflector_id;</p>
<p>The view <italic>headlamp_simplified</italic> is sent to the engineering team, where heat flow analysis of the headlamp is performed. Suppose that an excessively hot area is found as in <xref ref-type="fig" rid="fig3-1063293X11435345">Figure 3(b)</xref>, and the halogen bulb is replaced from 9005/HB3 (65 W, 12.8 V) to 9006/HB4 (55 W, 12.8 V). In order to perform this change, the view <italic>headlamp_simplified</italic> is updated as follows:</p>
<p>UPDATE headlamp_simplified</p>
<p>SET bulb_id = ‘9006/HB4’</p>
<p>WHERE item_number = ‘H111’;</p>
<p>As a result of the above-mentioned view update, the bulb is changed to 9006/HB4 for the headlamp with identifier “H111” in the base table <italic>headlamp</italic>. This update fires the execution of the trigger <italic>bulb_match</italic>, and a warning message is printed because the new bulb is not equal to the <italic>matchng_bulb</italic> of the headlamp with identifier “H111” (as shown in <xref ref-type="fig" rid="fig4-1063293X11435345">Figure 4</xref>).</p>
<fig id="fig4-1063293X11435345" position="float">
<label>Figure 4.</label>
<caption>
<p>Warning message is printed after a view is updated.</p>
</caption>
<graphic xlink:href="10.1177_1063293X11435345-fig4.tif"/>
</fig>
</sec>
<sec id="section16-1063293X11435345" sec-type="conclusions">
<title>Conclusion</title>
<p>View updates and integrity validation in collaborative design environments have been discussed. Information schemas and views are specified in terms of EXPRESS and EXPRESS-X, respectively, which are international standards developed by STEP project. As for the database systems through which participants of the collaborative design share design data, a relational database system is used.</p>
<p>In this article, we first discuss how to validate the integrity constraints given by EXPRESS in a relational database system. Integrity constraints defined by EXPRESS schema are translated into UNIQUE and CHECK and triggers in SQL database programming language. View definition in EXPRESS-X is discussed in the following. Because we focus on view updates, only updatable views in relational database systems are included. Whenever any view is updated, the UNIQUE, CHECK, and triggers that have been defined in relational database systems are validated automatically. Contribution of this article can be summarized as follows:</p>
<list id="list2-1063293X11435345" list-type="order">
<list-item><p>For integrity constraints specified by EXPRESS, validation methods in relational database systems are presented.</p></list-item>
<list-item><p>Updatable views defined by EXPRESS-X are translated into SQL schema so that view updates are validated automatically in relational database systems.</p></list-item>
</list>
<p>Because the paradigm presented in this article is based on open standards such as EXPRESS, EXPRESS-X, and SQL, it is independent from any proprietary system and suitable for collaborative design environments that consist of heterogeneous systems. Especially, for products that have long life cycle such as power plants and airplanes, using open standards is more important because proprietary systems may not be supported anytime. Future work should include various optimization mechanisms to minimize the overheads involved in integrity validation.</p>
</sec>
</body>
<back>
<fn-group>
<fn fn-type="financial-disclosure">
<p>This work was supported by Inha University.</p>
</fn>
</fn-group>
<ref-list>
<title>References</title>
<ref id="bibr1-1063293X11435345">
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Ahmed</surname><given-names>S</given-names></name>
<name><surname>Kim</surname><given-names>S</given-names></name>
<name><surname>Wallace</surname><given-names>KM</given-names></name>
</person-group> (<year>2007</year>) <article-title>A methodology for creating ontologies for engineering design</article-title>. <source>Journal of Computing and Information Science in Engineering</source> <volume>7</volume>(<issue>2</issue>): <fpage>132</fpage>–<lpage>140</lpage>.</citation>
</ref>
<ref id="bibr2-1063293X11435345">
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Alt</surname><given-names>J</given-names></name>
</person-group> (<year>1994</year>) <article-title>Optimizing EXPRESS rule evaluation with file-grained dynamic materialization in CAD applications</article-title>. In: <conf-name>Proceedings of fourth international EXPRESS user group conference</conf-name>. <publisher-loc>Clifton Park, NY</publisher-loc>: <publisher-name>Meeting Associates</publisher-name>.</citation>
</ref>
<ref id="bibr3-1063293X11435345">
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Bouikni</surname><given-names>N</given-names></name>
<name><surname>Rivest</surname><given-names>L</given-names></name>
<name><surname>Desrochers</surname><given-names>Y</given-names></name>
</person-group> (<year>2008</year>) <article-title>A multiple views management system for concurrent engineering and PLM</article-title>. <source>Concurrent Engineering: Research and Applications</source> <volume>16</volume>(<issue>1</issue>): <fpage>61</fpage>–<lpage>72</lpage>.</citation>
</ref>
<ref id="bibr4-1063293X11435345">
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Cera</surname><given-names>CD</given-names></name>
<name><surname>Kim</surname><given-names>T</given-names></name>
<name><surname>Han</surname><given-names>J</given-names></name>
<etal/>
</person-group>. (<year>2004</year>) <article-title>Role-based viewing envelopes for information protection in collaborative modeling</article-title>. <source>Computer-Aided Design</source> <volume>36</volume>(<issue>9</issue>): <fpage>873</fpage>–<lpage>886</lpage>.</citation>
</ref>
<ref id="bibr5-1063293X11435345">
<citation citation-type="web">
<comment>Dassault Systems, <ext-link ext-link-type="uri" xlink:href="http://www.3ds.com/products/catia">http://www.3ds.com/products/catia</ext-link></comment></citation>
</ref>
<ref id="bibr6-1063293X11435345">
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Date</surname><given-names>CJ</given-names></name>
</person-group> (<year>2004</year>) <source>An Introduction to Database Systems</source>. <edition>8th ed.</edition> <publisher-loc>Boston, MA</publisher-loc>: <publisher-name>Addison Wesley</publisher-name>.</citation>
</ref>
<ref id="bibr7-1063293X11435345">
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Eberl</surname><given-names>M</given-names></name>
</person-group>. <article-title>Integrated system for furniture manufacturing</article-title>. In: <conf-name>Proceedings of international conference on data and knowledge systems for manufacturing and engineering</conf-name>. <conf-date>2-4, May</conf-date> <conf-loc>Hong Kong</conf-loc>, <conf-date>May 1994</conf-date>, pp.<fpage>383</fpage>–<lpage>388</lpage>.</citation>
</ref>
<ref id="bibr8-1063293X11435345">
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Feng</surname><given-names>G</given-names></name>
<name><surname>Cui</surname><given-names>D</given-names></name>
<name><surname>Wang</surname><given-names>C</given-names></name>
<etal/>
</person-group>. (<year>2009</year>) <article-title>Integrated data management in complex product collaborative design</article-title>. <source>Computers in Industry</source> <volume>60</volume>(<issue>1</issue>): <fpage>48</fpage>–<lpage>63</lpage>.</citation>
</ref>
<ref id="bibr9-1063293X11435345">
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Goonetillake</surname><given-names>JS</given-names></name>
<name><surname>Carnduff</surname><given-names>TW</given-names></name>
<name><surname>Gray</surname><given-names>WA</given-names></name>
</person-group> (<year>2002</year>) <article-title>An integrity constraint management framework in engineering design</article-title>. <source>Computers in Industry</source> <volume>48</volume>(<issue>1</issue>): <fpage>29</fpage>–<lpage>44</lpage>.</citation>
</ref>
<ref id="bibr10-1063293X11435345">
<citation citation-type="journal">
<collab>ISO 10303-1:1994</collab> (<year>1994</year>) <article-title>Industrial automation systems and integration—product data representation and exchange—part 1: overview and fundamental principles</article-title>.</citation>
</ref>
<ref id="bibr11-1063293X11435345">
<citation citation-type="journal">
<collab>ISO 10303-11:2004</collab> (<year>2004</year>) <article-title>Industrial automation systems and integration—product data representation and exchange—part 11: description methods: the EXPRESS language reference manual</article-title>.</citation>
</ref>
<ref id="bibr12-1063293X11435345">
<citation citation-type="journal">
<collab>ISO 10303-14:2005</collab> (<year>2005</year>) <article-title>Industrial automation systems and integration—product data representation and exchange—part 14: description methods: the EXPRESS-X language reference manual</article-title>.</citation>
</ref>
<ref id="bibr13-1063293X11435345">
<citation citation-type="journal">
<collab>ISO 10303-22:1998</collab> (<year>1998</year>) <article-title>Industrial automation systems and integration—product data representation and exchange—part 22: implementation methods: standard data access interface</article-title>.</citation>
</ref>
<ref id="bibr14-1063293X11435345">
<citation citation-type="journal">
<collab>ISO/IEC 9075-1:2008</collab> (<year>2008</year>) <article-title>Information technology—database languages—SQL—part 1: framework</article-title>.</citation>
</ref>
<ref id="bibr15-1063293X11435345">
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Kim</surname><given-names>KY</given-names></name>
<name><surname>Manley</surname><given-names>DG</given-names></name>
<name><surname>Yang</surname><given-names>H</given-names></name>
</person-group> (<year>2006</year>) <article-title>Ontology-based assembly design and information sharing for collaborative product development</article-title>. <source>Computer-Aided Design</source> <volume>38</volume>(<issue>12</issue>): <fpage>1233</fpage>–<lpage>1250</lpage>.</citation>
</ref>
<ref id="bibr16-1063293X11435345">
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Li</surname><given-names>X</given-names></name>
<name><surname>Yoo</surname><given-names>SB</given-names></name>
</person-group> (<year>2011</year>) <article-title>Integrity validation in semantic engineering design environment</article-title>. <source>Computers in Industry</source> <volume>62</volume>(<issue>3</issue>): <fpage>281</fpage>–<lpage>291</lpage>.</citation>
</ref>
<ref id="bibr17-1063293X11435345">
<citation citation-type="web">
<comment>Microsoft Corporation, <ext-link ext-link-type="uri" xlink:href="http://www.microsoft.com/sqlserver/en/us/default.aspx">http://www.microsoft.com/sqlserver/en/us/default.aspx</ext-link></comment></citation>
</ref>
<ref id="bibr18-1063293X11435345">
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Mueller</surname><given-names>W</given-names></name>
<name><surname>Lehrenfeld</surname><given-names>G</given-names></name>
<name><surname>Wiechers</surname><given-names>N</given-names></name>
</person-group> (<year>1993</year>) <article-title>Parallel validation of STEP files</article-title>. In: <conf-name>Proceedings of third international EXPRESS user group conference</conf-name>. <publisher-loc>Clifton Park, NY</publisher-loc>: <publisher-name>Meeting Associates</publisher-name>.</citation>
</ref>
<ref id="bibr19-1063293X11435345">
<citation citation-type="journal">
<collab>Oracle</collab> (<year>2011</year>) <article-title>Oracle Database Documentation Library 11g Release 2</article-title>.</citation>
</ref>
<ref id="bibr20-1063293X11435345">
<citation citation-type="web">
<person-group person-group-type="author">
<name><surname>Paine</surname><given-names>M</given-names></name>
</person-group> (<year>2003</year>) <source>A Review of Daytime Running Light</source>. <comment>Vehicle Design and Research Pty Limited. <ext-link ext-link-type="uri" xlink:href="http://www.luces24horas.com/estudios/nrma_racv_031118_drlreport.pdf">http://www.luces24horas.com/estudios/nrma_racv_031118_drlreport.pdf</ext-link></comment> (<access-date>accessed June 2003</access-date>).</citation>
</ref>
<ref id="bibr21-1063293X11435345">
<citation citation-type="web">
<collab>PTC</collab>, <comment><ext-link ext-link-type="uri" xlink:href="http://creo.ptc.com/">http://creo.ptc.com/</ext-link></comment></citation>
</ref>
<ref id="bibr22-1063293X11435345">
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Yoo</surname><given-names>SB</given-names></name>
<name><surname>Suh</surname><given-names>HW</given-names></name>
</person-group> (<year>1999</year>) <article-title>Integrity validation of product data in a distributed concurrent engineering environment</article-title>. <source>Concurrent Engineering: Research and Applications</source> <volume>7</volume>(<issue>3</issue>): <fpage>201</fpage>–<lpage>214</lpage>.</citation>
</ref>
</ref-list>
</back>
</article>