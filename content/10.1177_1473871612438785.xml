<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD Journal Publishing DTD v2.3 20070202//EN" "journalpublishing.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" xml:lang="en">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">IVI</journal-id>
<journal-id journal-id-type="hwp">spivi</journal-id>
<journal-title>Information Visualization</journal-title>
<issn pub-type="ppub">1473-8716</issn>
<issn pub-type="epub">1473-8724</issn>
<publisher>
<publisher-name>SAGE Publications</publisher-name>
<publisher-loc>Sage UK: London, England</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1177/1473871612438785</article-id>
<article-id pub-id-type="publisher-id">10.1177_1473871612438785</article-id>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Articles</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>Understanding software evolution with software cities</article-title>
</title-group>
<contrib-group content-type="issue">
<contrib contrib-type="guest-editor">
<name><surname>Telea</surname><given-names>Alexandru C.</given-names></name>
</contrib>
<contrib contrib-type="guest-editor">
<name><surname>Görg</surname><given-names>Carsten</given-names></name>
</contrib>
<contrib contrib-type="guest-editor">
<name><surname>Reiss</surname><given-names>Steven</given-names></name>
</contrib>
</contrib-group>
<contrib-group>
<contrib contrib-type="author">
<name><surname>Steinbrückner</surname><given-names>Frank</given-names></name>
</contrib>
<contrib contrib-type="author" corresp="yes">
<name><surname>Lewerentz</surname><given-names>Claus</given-names></name>
</contrib>
<aff id="aff1-1473871612438785">Brandenburg University of Technology Cottbus, Cottbus, Germany</aff>
</contrib-group>
<author-notes>
<corresp id="corresp1-1473871612438785">Claus Lewerentz, Platz der Deutschen Einheit 1, 03046 Cottbus, Germany. Email: <email>cl@tu-cottbus.de</email></corresp>
</author-notes>
<pub-date pub-type="epub-ppub">
<month>4</month>
<year>2013</year>
</pub-date>
<volume>12</volume>
<issue>2</issue>
<issue-title>Special issue: Software Visualization</issue-title>
<fpage>200</fpage>
<lpage>216</lpage>
<permissions>
<copyright-statement>© The Author(s) 2012</copyright-statement>
<copyright-year>2012</copyright-year>
<copyright-holder content-type="sage">SAGE Publications</copyright-holder>
</permissions>
<abstract>
<p>Software cities are visualizations of software systems in the form of virtual cities. They are used as platforms to integrate a large variety of product- and process-related analysis data. Their usability, however, for real-world software development often suffers from their inability to appropriately deal with software changes. Even small structural changes can disrupt the overall structure of the city, which in turn corrupts the mental maps of its users. In this article we describe a systematic approach to utilize the city metaphor for the visualization of evolving software systems as growing software cities. The main contribution is a new layout approach which explicitly takes the development history of software systems into account. The approach has two important effects: first, it creates a stable gestalt of software cities even when the underlying software systems evolve; thus, by preserving its users’ mental maps these cities are especially suitable for use during ongoing system development. Second, it makes history directly visible in the city layouts, which allows for supporting novel analysis scenarios. We illustrate such scenarios by presenting several thematic cities’ maps, each capturing specific development history aspects.</p>
</abstract>
<kwd-group>
<kwd>Software cities</kwd>
<kwd>software landscapes</kwd>
<kwd>software evolution</kwd>
<kwd>software visualization</kwd>
<kwd>metrics</kwd>
<kwd>software comprehension</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="section1-1473871612438785" sec-type="intro">
<title>Introduction<sup><xref ref-type="fn" rid="fn1-1473871612438785">*</xref></sup></title>
<p>Teams of many different people with strongly varying interests, roles, responsibilities, and backgrounds are involved in the development of large software systems. How do they communicate about the software they are defining, constructing, maintaining, and administrating? Owing to the complex and intangible character of software it is very difficult to create a commonly shared picture or mental map of the software system. Software visualization, and in particular the visualization of software structures as given by the existing program code and enhanced with additional development information (see refs. 2, 3), aims at creating materializations of software systems to provide a common basis for the localization of product properties (such as size or quality indicators) and process events (such as errors found or changes made).</p>
<p>To serve as such a common basis for a broad range of different application scenarios, software visualizations should specifically meet the following requirements (besides more general visualization requirements):</p>
<list id="list1-1473871612438785" list-type="bullet">
<list-item><p>The visualization should provide a specific and meaningful gestalt for each software system to support orientation and spatial memory.</p></list-item>
<list-item><p>The visualization should allow for representing the software system at different levels of detail (e.g. architectural components, code components) and at different development stages in a uniform and consistent way.</p></list-item>
<list-item><p>The visualization needs to be robust against small changes in the software system. It has to support the observation of evolving systems over many different versions, i.e. it has to reflect structural and property changes without disrupting the overall picture.</p></list-item>
<list-item><p>The visualization should allow for easily integrating many different data in a consistent and systematic way.</p></list-item>
<list-item><p>The visualization process and the visualizations themselves should scale up to systems of several million lines of code.</p></list-item>
</list>
<p>In literature a large variety of different approaches and visual metaphors for the visualization of large software systems are proposed. As discussed in previous work (e.g. refs 2,3,4–6), the metaphors of maps, cities, and landscapes very well meet most of the requirements outlined above. However, only a few approaches explicitly address the question of how to produce robust visualizations for evolving software systems. In contrast to these solutions, in our approach robustness will be achieved by explicitly representing the development history in the software cities layouts.</p>
<p>The “Related work” section reviews the most relevant related work on the use of map, city, and landscape metaphors in software visualization. “The EvoStreets approach” section explains and illustrates the concepts of our visualization approach, which is the main contribution of this paper. In the “Comprehension scenarios” section we discuss and illustrate new application scenarios supported by our approach. The “Discussion” discusses advantages, shortcomings, and open issues of our approach. “Tool support” gives some details on our visualization prototype and, finally, “Experiences” summarizes this article and points out ongoing work.</p>
</sec>
<sec id="section2-1473871612438785">
<title>Related work</title>
<p>Knight and Munro<sup><xref ref-type="bibr" rid="bibr5-1473871612438785">5</xref>,<xref ref-type="bibr" rid="bibr7-1473871612438785">7</xref></sup> describe software worlds as consisting of countries, cities, districts and fine-grained elements such as houses and gardens. These hierarchically structured elements are used to visualize hierarchically structured Java programs with methods, classes, files, and directories being mapped onto buildings, districts, cities, and countries, respectively. In ref. 8 a variant of this metaphor is presented to visualize more abstract software components in component cities.</p>
<p>Panas et al.<sup><xref ref-type="bibr" rid="bibr9-1473871612438785">9</xref></sup> explore the city metaphor at a very detailed level. They indicate the wide range of visual elements (cars, clouds, fire, flashes, etc.) the city metaphor provides, and they discuss their applicability to visualize static, dynamic, and production cost-related information. Elements such as trees, streets and street lamps are added to support intuitive interpretation and increase realism.</p>
<p>Later, Panas et al.<sup><xref ref-type="bibr" rid="bibr2-1473871612438785">2</xref></sup> use the city metaphor to provide single-view visualizations designed to address the information needs of different software development and maintenance stakeholders. Their cities represent software systems at different levels from coarse-grained directories to fine-grained class member functions. The cities layouts are computed using two methods: coarse-grained elements are positioned by a force-directed algorithm whereas fine-grained elements (buildings) are laid out compactly in a grid-based manner. The resulting cities are augmented with data obtained from analyses (runtime, metric, static/structure, and repository analyses).</p>
<p>Alam and Dugerdil<sup><xref ref-type="bibr" rid="bibr10-1473871612438785">10</xref><xref ref-type="bibr" rid="bibr11-1473871612438785"/>–<xref ref-type="bibr" rid="bibr12-1473871612438785">12</xref></sup> describe an approach in which software artifacts are represented by office buildings or city halls. These elements may be organized in cities whose layouts are computed by several different layout strategies (concentric and chessboard layouts,<sup><xref ref-type="bibr" rid="bibr11-1473871612438785">11</xref></sup> containment layouts<sup><xref ref-type="bibr" rid="bibr12-1473871612438785">12</xref></sup>). Animated solid pipes can interactively be displayed to show element references and their directions.<sup><xref ref-type="bibr" rid="bibr11-1473871612438785">11</xref></sup> In ref. 10 this approach is enhanced by a highlighting technique called night view to point out elements involved in a given execution trace.</p>
<p>In the literature more approaches (e.g. refs 4,13,31) for visualizing software systems as maps, cities, or landscapes, or in 2.5-dimensional (2.5D) space are proposed. However, to the best of our knowledge, only a few approaches explicitly consider the evolution of software systems. Kuhn et al.<sup><xref ref-type="bibr" rid="bibr3-1473871612438785">3</xref></sup> describe thematic software maps that position software artifacts on a two-dimensional (2D) map according to their vocabulary. Their layout algorithm produces relatively stable maps of evolving systems. These maps are used as consistent platform to locate additional analysis data.</p>
<p>Wettel and Lanza<sup><xref ref-type="bibr" rid="bibr6-1473871612438785">6</xref></sup> propose an approach in which the software decomposition and artifacts are mapped onto city districts and buildings, respectively. Building size is derived from basic size measures using a boxplot-based mapping technique.<sup><xref ref-type="bibr" rid="bibr14-1473871612438785">14</xref></sup> The resulting cities serve as a platform that can be enriched by more sophisticated analysis data to support the identification of design problems<sup><xref ref-type="bibr" rid="bibr15-1473871612438785">15</xref></sup> and to gain insight into the structural evolution of software systems.<sup><xref ref-type="bibr" rid="bibr16-1473871612438785">16</xref></sup> They present a set of techniques to visualize evolutionary data on both a fine- and a coarse-grained abstraction level. Their time traveling technique allows one to step backwards and forwards in time, and thus to visualize the software system at its different development stages. For this purpose, each software artifact is uniquely assigned a fixed area in the city. As a result, this approach yields stable layouts sequences, which, however, can only be achieved because all versions of the software system are known in advance. As soon as new versions become available, new visualization sequences must be computed, which in turn can differ significantly from the original sequence and the mental models constructed by its users so far. A similar approach, though based on treemaps, is described by Langelier et al.<sup><xref ref-type="bibr" rid="bibr17-1473871612438785">17</xref></sup></p>
<p>The approach described in the following sections aims at providing stable software cities without knowing the development history in advance. In contrast to previous work in the field of dynamic graph drawing (e.g. refs 18–20) this will be achieved by explicitly capturing the development history in the city shape itself.</p>
</sec>
<sec id="section3-1473871612438785">
<title>The EvoStreets approach</title>
<p>Using a geographical metaphor (as cities) for the visualization of software systems guided us to adopt techniques developed by cartographers over many years. A basic process in map making is the use of a three-staged representation chain. The original geographic data of a landscape or city are collected in a so-called <italic>primary model</italic>. These data are used to create a <italic>secondary model</italic> that comprises all aspects of the primary model that should be represented as a common view (2D as well as 2.5D models) for the geographic reality. The secondary model is used as basis from which <italic>tertiary models</italic> or <italic>thematic maps</italic> are derived. Thematic maps represent and emphasize particular aspects of the real-world system (landscape, city). Typical techniques for building thematic maps from secondary models are selections, projections, coloring, or superposition of symbols and diagrams.<sup><xref ref-type="bibr" rid="bibr21-1473871612438785">21</xref></sup> Thus, a secondary model typically plays the central role to provide a stable reference map for a large variety of particular visualization scenarios for the very same geographic reality. We adopt this process because it helps to fully exploit the capabilities of cartographic city and landscape modeling, as will be shown in the following sections.</p>
<sec id="section4-1473871612438785">
<title>Logical primary model</title>
<p>The primary model for software cities captures structural and analysis data. Structural data refer to the static software structure, i.e. the decomposition into subsystems and modules, as well as dependencies among modules. For Java systems, structural data typically include the package hierarchy, classes, and inheritance, aggregated method usage, and attribute and type access relations between classes. Even though in this article all of our examples are Java systems, we will consistently use the terms <italic>subsystem</italic> and <italic>module</italic> to indicate decomposition elements (such as Java packages) and decomposition leafs (such as Java classes), respectively, as these terms are not associated to a specific programming language or abstraction level. Thus, subsystem and module can also denote directories and header and implementation files for C++ systems, or even such coarse-grained units as hierarchically structured architectural components. We use the more general terms <italic>system element</italic> or <italic>element</italic> to denote both subsystems and modules.</p>
<p>The structural information is enriched by additional analysis data, which can be distinguished into product-related analysis data, gained from a variety of different software analysis tools (e.g. Findbugs, PMD, Checkstyle), as well as process-related analysis data such as developer activities, development effort, or test coverage. Whereas structural data about the system decomposition are essential for our visualization approach, analysis data can optionally be integrated to support particular usage scenarios.</p>
<p>The primary model is populated with structural and analysis data for several versions of the software systems. These versions can be selected arbitrarily, for example on a calendar time basis (daily, weekly, etc.), by revision number from a version control system such as subversion (SVN) or concurrent versioning system (CVS), or according to defined project milestones. Thus, the primary model contains product- and process-related data for a series of different development stages.</p>
<p>The primary model internally is represented as a dynamic, attributed graph and serves as a central data model to exchange data between project analysis tools and the visualization tools. All secondary and tertiary models are derived completely from data in the primary model. Thus, throughout this paper, any discussions on evolutionary aspects of software systems refer to the systems evolution as captured in the primary model: when we talk about <italic>new</italic> and <italic>deleted</italic> elements, this refers to the difference to the previous version contained in the primary model.</p>
</sec>
<sec id="section5-1473871612438785">
<title>Geometric secondary model</title>
<p>The secondary model is a 2.5D geometric model, representing primary model data, that captures the main structural and evolutionary properties of the software system. It has to fulfill the aforementioned requirements, particularly to provide a specific, stable gestalt for each software system. This gestalt is mainly influenced by the particular layout of the system elements.</p>
<p>There are at least three different aspects of the primary model that are usually used to generate the layout:</p>
<list id="list2-1473871612438785" list-type="bullet">
<list-item><p>the decomposition hierarchy (e.g. package and class nesting);</p></list-item>
<list-item><p>dependencies (e.g. call and access relations, type–inheritance relation); and</p></list-item>
<list-item><p>element properties (e.g. type, size).</p></list-item>
</list>
<p>Whereas most other (graph) layout approaches are based on decomposition hierarchy plus element properties (e.g. Code City<sup><xref ref-type="bibr" rid="bibr6-1473871612438785">6</xref></sup>) or decomposition hierarchy plus structural dependency relations (e.g. Software Landscapes<sup><xref ref-type="bibr" rid="bibr4-1473871612438785">4</xref>,<xref ref-type="bibr" rid="bibr20-1473871612438785">20</xref></sup>), the layout approach described in the next section (called EvoStreets) combines decomposition hierarchy, element properties, and development time. Making creation time of system elements a first-class property of the layout is the main novel aspect of this approach. A consequences of including development time in layout strategies is stronger requirements on the stability of layouts over different stages in a system’s version history.</p>
<p>In the following sections we describe how such secondary models are derived from primary models. We use the source code of our visualization tool <italic>CrocoCosmos</italic><sup><xref ref-type="bibr" rid="bibr22-1473871612438785">22</xref></sup> as an example system throughout this document.</p>
<sec id="section6-1473871612438785">
<title>The EvoStreets layout</title>
<p>In the secondary model the decomposition hierarchy is represented by a hierarchical street system, as shown in <bold><xref ref-type="fig" rid="fig1-1473871612438785">Figure 1</xref></bold>. Each street represents a certain subsystem. Contained subsystems form orthogonal branching streets. The system level is represented by a main road from which the top-level subsystems branch off. The width of the subsystem streets is inversely proportional to the subsystem’s depth in the hierarchy</p>
<fig id="fig1-1473871612438785" position="float">
<label>Figure 1.</label>
<caption>
<p>A hierarchical street layout representing the decomposition of the visualization tool CrocoCosmos (Revision 0, 389 Java classes).</p>
</caption>
<graphic xlink:href="10.1177_1473871612438785-fig1.tif"/>
</fig>
<p>Modules are represented as square building plots that are attached to the street representing their containing subsystem. For Java systems, a street with attached building plots shows a package with its contained classes.</p>
<p>The size of the building plots is used to represent any important property of the corresponding modules. In this article, it is proportional to the coupling between the represented module and the rest of the system (number of incoming and outgoing static dependencies from/to all other classes of the system), i.e. the number of method calls, attribute and type accesses, and inheritance relations. Besides the content size of modules, their coupling is a central basic property for many application scenarios because it indicates the potential impact that changes to this module may have to the rest of the system.</p>
</sec>
<sec id="section7-1473871612438785">
<title>System evolution and layout stability</title>
<p>So far, the secondary model provides layouts representing modules, their dependency property, and the hierarchical system decomposition. During a software system’s life cycle the program structure undergoes many changes. New elements are added, elements are removed or relocated to other subsystems, and element properties change.</p>
<p>Such system modifications are reflected in the geometry of the secondary model. As the secondary model’s purpose is to serve as a stable geometric base representation for the system during its entire lifetime, the overall structure of the geometric model must not be disrupted by such changes. We addressed this robustness or geometric stability requirement by taking an incremental layout approach with the following design decisions:</p>
<list id="list3-1473871612438785" list-type="bullet">
<list-item><p>New elements are represented by new building plots and streets. They are attached to the (outer) end of the street representing their containing subsystem. In general, for this purpose the street must be extended. Sets of new elements that are jointly added to the same street are evenly distributed to both sides of the street.</p></list-item>
<list-item><p>Building plots and streets remain on the same side of the street to which they are initially attached. Their initial order along that street is preserved in all subsequent layouts.</p></list-item>
<list-item><p>If an element is removed from the software system its representation is not removed from the secondary model but marked as disused.</p></list-item>
<list-item><p>The information whether an element was relocated to another subsystem or removed from the system is not stored in our primary models. Thus, elements that were moved to another subsystem are treated as removed elements in the context of their source subsystem and as new elements in the context of their target subsystem.</p></list-item>
<list-item><p>If the size of a building plot changes (e.g. due to changes in the corresponding element property), the following neighbor plots down the same side of the street are shifted along the street. These shifts can induce further shifts if a street has to be extended.</p></list-item>
</list>
<p><xref ref-type="fig" rid="fig2-1473871612438785">Figure 2</xref> illustrates the effects of these design decisions for our example system visualized at three different revision points. The system grows from initially 389 classes to 439 classes in revision 100 and to 466 classes in revision 200. Streets represent Java packages and building plots represent Java classes.</p>
<fig id="fig2-1473871612438785" position="float">
<label>Figure 2.</label>
<caption>
<p>Three development stages of CrocoCosmos.</p>
</caption>
<graphic xlink:href="10.1177_1473871612438785-fig2.tif"/>
</fig>
<list id="list4-1473871612438785" list-type="bullet">
<list-item><p>New elements: Between revision 0 and 100 two new packages, P1 and P2, are added. Their representations are attached to the end of the street, which represents their parent package. This street has to be extended. However, the rest of the layout remains unaffected by this modification.</p></list-item>
<list-item><p>New elements: Between revision 0 and 100 another package, P3, is added. Because there is enough empty space available for its representation, this modification has no impact on the rest of the layout.</p></list-item>
<list-item><p>Growing elements: Between revision 100 and 200 package P2 grows (a new sub-package is added). As its representation now requires more space, the representation for package P1 must be shifted upwards. Similarly, if in revision 100 one more sibling to P3 would be added to the containing package, and assuming that there would not be enough space for its representation, some streets would have to be shifted. In both cases, the layout has to be adapted locally, but the rest of the layout remains unaffected.</p></list-item>
<list-item><p>Removed elements: Between revision 0 and 100 package P4 is removed from the system. This modification has no effect on the layout as representations of removed elements are not removed from the secondary model. In <xref ref-type="fig" rid="fig2-1473871612438785">Figure 2</xref> these elements are drawn in light gray color. If the representation for P4 would be removed from the secondary model, packages P1 and P2 could be moved downwards. This would yield more compact layouts at the cost of lower stability.</p></list-item>
<list-item><p>As the example illustrates, the layouts are not fixed in the sense that each representation remains at its absolute position. Instead, changes in the primary model may cause local layout adaptations that result in shifting building plots and streets. However, as the order of neighboring representations is preserved, the overall structure of the layout is not disrupted from one version to another.</p></list-item>
</list>
<p>A small empirical study<sup><xref ref-type="bibr" rid="bibr23-1473871612438785">23</xref></sup> showed that the EvoStreets approach yields rather stable layouts for typical development histories. We compared the layouts produced by three different approaches (EvoStreets, a packing approach similar to ref. 6, and a force-directed graph drawing approach<sup><xref ref-type="bibr" rid="bibr20-1473871612438785">20</xref></sup>) with respect to layout stability. In the study we used five similarity measures from the literature,<sup><xref ref-type="bibr" rid="bibr24-1473871612438785">24</xref>,<xref ref-type="bibr" rid="bibr25-1473871612438785">25</xref></sup> each addressing a specific similarity aspect (such as changes in positions, orderings, or neighborhoods) and applied them to five small to medium-sized software systems (up to 3023 classes and in a total of 55 versions). The results show that the EvoStreets approach yielded the best stability results by providing the highest similarity values for 82% of all layout transitions. The issue of layout stability, however, still needs more comprehensive investigations.</p>
</sec>
<sec id="section8-1473871612438785">
<title>Representing development history</title>
<p>The above-described layout approach for adding new elements produces a geometrical ordering of system element representations along streets according to their creation time. However, as entire sets of elements may be added between two observed versions, the location order of their representations cannot be strictly interpreted as the chronological order of creation times. Elements in continuous segments of streets may have been added in the same version, i.e. have the same creation time.</p>
<p>The street on the left-hand side of <xref ref-type="fig" rid="fig3-1473871612438785">Figure 3</xref> represents a Java package that contains six sub-packages. They were added as two sets in two successive versions. In the first version, the five upper-left sub-packages (three above and two below the street) were added jointly. In the second version sub-package P (containing only one sub-package) was added. One standard way to represent this information would be to use coloring in a thematic map on the tertiary model level. To represent the development history defined by creation time, i.e. the age of elements already as a geometric secondary model property, we extend our flat city space to a leveled landscape. Creation time of an element is mapped to an elevation level. Older elements are positioned on higher levels than younger ones. As a consequence, streets and their attached plots will stretch over different elevation levels. In the example below, sub-package P is younger than the other sub-packages. Therefore, its representation is less elevated. As a consequence, the street representing the containing package declines, as indicated on the right-hand side of <xref ref-type="fig" rid="fig3-1473871612438785">Figure 3</xref>.</p>
<fig id="fig3-1473871612438785" position="float">
<label>Figure 3.</label>
<caption>
<p>Using elevation levels to visualize creation time.</p>
</caption>
<graphic xlink:href="10.1177_1473871612438785-fig3.tif"/>
</fig>
<p>The fact that our incremental layout approach creates a chronological order of representation elements allows for combining all elevation levels into a landscape with a rather continuous terrain on which the city elements, streets, and building plots are positioned (see <xref ref-type="fig" rid="fig4-1473871612438785">Figure 4(b)</xref>).</p>
<fig id="fig4-1473871612438785" position="float">
<label>Figure 4.</label>
<caption>
<p>Using terrain to visualize evolution (CrocoCosmos at revision 800, 463 Java classes): (a) perspective 2D view without elevation levels, (b) perspective view including elevation levels, and (c) perspective view including terrain.</p>
</caption>
<graphic xlink:href="10.1177_1473871612438785-fig4.tif"/>
</fig>
<p>The terrains are constructed following an approach presented in ref. 26 for the generation of implicit surfaces. Implicit surfaces are described by a set of arbitrary generator objects that influence a global density field. An implicit surface is defined as the set of those points where the density field equals a certain predefined threshold. In our context, building plots and streets are interpreted as generator objects that influence the global density field depending on their position and height. In contrast to ref. 26, the resulting global density field is not compared against a threshold to compute an implicit surface. Instead, density is interpreted as height, which yields smooth terrain surfaces.</p>
<p>As shown in <xref ref-type="fig" rid="fig4-1473871612438785">Figure 4(c)</xref> secondary models can show several visual patterns that reflect particular situations in development history:</p>
<list id="list5-1473871612438785" list-type="order">
<list-item><p><italic>Disused sites</italic> are regions of empty plots representing parts of the system that have been removed from the system or which migrated to another subsystem.</p></list-item>
<list-item><p><italic>Suburbs</italic> represent local system extensions, i.e. sets of modules that were added to a subsystem during a relatively short period of time.</p></list-item>
<list-item><p><italic>High plateaus</italic> represent subsystems that have been part of the software for a relatively long time but which were not extended after their initial creation.</p></list-item>
<list-item><p>In contrast to high plateaus, <italic>mountain slopes</italic>, i.e. streets that continuously descend on hill sides, represent continuously extended subsystems.</p></list-item>
</list>
<p>The overall approach is based on two decisions regarding the growing directions. First, new structures are added toward the far end of their containing element’s street representation; as a result, the city tends to grow at its periphery. Alternatively, new structures could be placed at the beginning of each containing element’s street representation; as a result, the city would tend to grow from its center. This, however, would cause instabilities to existing structures as they would be shifted toward the outside.</p>
<p>Second, we decided to place older structures on higher elevation levels; as a result, the city grows from top to bottom. Alternatively, we could have decided to place newer structures on higher elevation levels. Given the decision that the city grows at its periphery, growing from bottom to top would cause the city center to be placed in a valley surrounded by mountains for each suburb. The streets would be embedded in deep valleys, which would create much more occlusion of streets and buildings.</p>
<p>We decided for the combination of growth at the periphery and growth from top to bottom because it creates stable city layouts with a coherent shape and less occlusion. Thus, the resulting secondary model provides stable, coherent city layouts representing modules and their properties, the hierarchical system decomposition, and the structural system evolution.</p>
</sec>
</sec>
<sec id="section9-1473871612438785">
<title>Thematic tertiary models</title>
<p>As in cartography, our secondary models are used as stable bases to derive tertiary models or so-called thematic maps. They are designed to support specific application scenarios by visualizing particular aspects of a given software system and its development history. Typical transformations from secondary to tertiary models are selections, projections, generalization, coloring, and superposition of symbols and diagrams. In the following sections we will outline typical transformations and thematic map elements used in our approach.</p>
<p>Our geometric base model is a 2.5D terrain model which can be visualized and explored in an interactive three-dimensional (3D) environment. This allows for using further 3D elements to represent properties. On the other hand one has to care for appropriate projections of such 2.5D terrain models into 2D representations.</p>
<p>All maps described below can be viewed interactively for any point in development time, which additionally supports the comprehension of when components were created or deleted and how the component content changes over time.<sup><xref ref-type="bibr" rid="bibr16-1473871612438785">16</xref></sup></p>
<sec id="section10-1473871612438785">
<title>Map projections</title>
<p>We use two types of projections for building thematic maps, namely city plans (flat topographical maps) and panoramas (perspective maps).</p>
<p>City plans are produced by a simple orthogonal projection of the terrain onto the base level. They have a standard orientation and avoid any problems caused by occlusion or perspective distortion. Highlighting and coloring of streets and areas and the use of text labels are standard ways of representing properties of system elements. City plans (as in <xref ref-type="fig" rid="fig5-1473871612438785">Figure 5</xref>) are used for all purposes that require an easy system overview, structure comprehension, and navigation. They serve as the base map to position additional categorical or ordered information such as current development hot spots or the degree of test coverage.</p>
<fig id="fig5-1473871612438785" position="float">
<label>Figure 5.</label>
<caption>
<p>2D city plan projection.</p>
</caption>
<graphic xlink:href="10.1177_1473871612438785-fig5.tif"/>
</fig>
<p>Panoramas are projections from an arbitrary viewing perspective (angle and viewpoint) and create some degree of occlusion and perspective distortion (see <xref ref-type="fig" rid="fig4-1473871612438785">Figure 4</xref>). Typically, a bird’s-eye perspective with a viewing angle of 45° is used. The orientation may vary depending on which parts of the system are to be emphasized.</p>
<p>Panoramas allow for creating both system overview and detailed views and are particularly well suited to show 2.5D terrains and cityscapes. This allows us to use “buildings” as additional 3D representation elements. We use panorama views whenever the age of software elements, i.e. the terrain level in the secondary model plays an important role for the intended application scenario.</p>
<p>In city plans as well as on panoramas standard cartographic generalization techniques for representing such maps on different scale levels could be applied.</p>
</sec>
<sec id="section11-1473871612438785">
<title>Contour line</title>
<p>In cartography color and contour maps are used to represent smooth,continuous phenomena.The use of contour lines is the right choice if the number of data values is high and coloring is to be used for representing other properties.<sup><xref ref-type="bibr" rid="bibr21-1473871612438785">21</xref></sup> We use contour lines for visualizing the elevation of the terrain in the same way as it is done in topographical maps. Every contour line connects points of a certain elevation. The spacing of elevation values and the form of contours can be chosen such that a good readability is achieved (e.g. draw every fifth contour with a stronger line).</p>
<p>Contour lines can be embedded into city plans as well as in panoramas. In city plans they allow for representing elevation levels in the flat projection. In panoramas contour lines considerably enhance the readability of the terrains particularly to overcome perspective distortion in terrain elevation. They allow for an exact comparison of altitudes in distant regions of the scene. Relatively dense contour lines can even completely replace the solid terrain surface (<xref ref-type="fig" rid="fig6-1473871612438785">Figure 6</xref>).</p>
<fig id="fig6-1473871612438785" position="float">
<label>Figure 6.</label>
<caption>
<p>Contour lines on a 2.5D terrain.</p>
</caption>
<graphic xlink:href="10.1177_1473871612438785-fig6.tif"/>
</fig>
<p>In our geometric model elevation encodes creation time in terms of versions stored the primary model. Therefore, we can represent each of these versions by a contour line. If, for example, the primary model is populated on a daily or weekly basis then each contour line represents a corresponding day or week, respectively.</p>
</sec>
<sec id="section12-1473871612438785">
<title>Module properties</title>
<p>In city plans modules are represented simply by their corresponding build plot (which already represents one property). Additional module properties can be represented only by coloring the building plot or by positioning simple 2D icons or labels at a module location.</p>
<p>In panoramas, however, we can make use of the third dimension and allow for arbitrary geometric bodies such as cylinders or cuboids to represent module properties as “buildings”. A set of module properties can be mapped to geometric and visual building properties (see <xref ref-type="fig" rid="fig7-1473871612438785">Figure 7(a)</xref>) such as height (e.g. for module size), base area (e.g. for module coupling), and color (e.g. for subsystem membership).</p>
<fig id="fig7-1473871612438785" position="float">
<label>Figure 7.</label>
<caption>
<p>Property towers and evolution towers.</p>
</caption>
<graphic xlink:href="10.1177_1473871612438785-fig7.tif"/>
</fig>
<p>A more generalized and expressive form of buildings is a so-called property tower (<xref ref-type="fig" rid="fig7-1473871612438785">Figure 7b</xref>). They consist of a configurable number of <italic>segments</italic> in the form of cylinders or cuboids which are stacked on each other. Height, radius, color and transparency of each segment (in the case of using cuboids’ depth and width instead of radius) can be used to encode specific properties of the module.</p>
<p>Property towers have to be tailored to each application scenario. One possibility to do this is by specifying the number of segments to be stacked above each other in advance and by defining a separate mapping from module properties (such as size, complexity) onto each segment’s visual properties. In this case each segment represents a particular set of module properties.</p>
<p>Another possibility is to represent each module version with a separate segment and to stack these segments for each module as the module evolves. Then each segment represents the same set of module properties for a particular version of the software system. These specialized property towers are called <italic>Evolution Towers</italic> because they reveal the evolution of module properties. Two examples of such evolution towers are shown <xref ref-type="fig" rid="fig7-1473871612438785">Figure 7(c)</xref> and <xref ref-type="fig" rid="fig7-1473871612438785">(d)</xref>. Both represent 25 versions (from bottom to top) of an example module but with different visual mappings. In the left tower we can see a correlation between segment color and segment size, i.e. the respective properties (Lines-Of-Code [LOC] represented by color, module coupling represented by size) evolve similarly. In contrast, in the right tower both properties are not correlated (LOC represented by color and complexity represented by size) but evolve independently for this module.</p>
<p>By statically representing module properties for a sequence of module versions, evolution towers easily allow for detecting evolutionary patterns such as pulsar, supernova, or white dwarf (as described in ref. 27). Thus, they are especially useful during fine-grained analysis of a particular module’s evolution.</p>
<p>We used this basic concept for visualizing software modules in various ways for building a number of different towers tailored toward representing specific sets of information.</p>
</sec>
<sec id="section13-1473871612438785">
<title>Module dependencies</title>
<p>In software city visualizations logical (i.e. syntactic or semantic) dependencies between modules are usually displayed as arcs between buildings. As this often leads to occlusion when too many relations are displayed at once, techniques such as edge bundling<sup><xref ref-type="bibr" rid="bibr28-1473871612438785">28</xref></sup> can be used. Besides this standard dependency representation in the EvoStreets approach, we use the hierarchical street system for routing and bundling module interconnections along the street system. An example can be found in <bold><xref ref-type="fig" rid="fig14-1473871612438785">Figure 14</xref></bold>.</p>
</sec>
</sec>
</sec>
<sec id="section14-1473871612438785">
<title>Comprehension scenarios</title>
<p>Software city visualizations in general provide an overall picture of a software systems structure. They support building a common mental map by providing a unique location for each system element. As discussed in the literature (see “Related work” section), this can be used for the illustration and communication of properties of system elements.</p>
<p>The EvoStreets approach particularly focuses on aspects of evolution by capturing the information about the creation time of system elements in the layout and by creating stable layout sequences during the evolution of systems. This allows for supporting several application scenarios which are based on information about the history of development activities and their effects on the system structure. Typical questions developers and project managers in this context ask are “How did this component evolve?”, “Who is working on what?”,<sup><xref ref-type="bibr" rid="bibr29-1473871612438785">29</xref></sup> or “Who owns a piece of code?” and “What is the history of a piece of code?”.<sup><xref ref-type="bibr" rid="bibr30-1473871612438785">30</xref></sup></p>
<p>In the sequel we illustrate how the EvoStreets thematic maps can help to answer such questions.</p>
<sec id="section15-1473871612438785">
<title>Metrics and system evolution</title>
<p>A first example is the <italic>evolution map</italic> (<xref ref-type="fig" rid="fig8-1473871612438785">Figure 8</xref>), which uses contour lines to show the versions of each subsystem and module. Simple property towers represent modules. Their base area is proportional to the module’s dependencies, the height is proportional to the module’s size (number of contained elements), and the color indicates the containing top-level subsystem.</p>
<fig id="fig8-1473871612438785" position="float">
<label>Figure 8.</label>
<caption>
<p>Size-based evolution map for CrocoCosmos.</p>
</caption>
<graphic xlink:href="10.1177_1473871612438785-fig8.tif"/>
</fig>
<p>On the evolution map (<xref ref-type="fig" rid="fig8-1473871612438785">Figure 8</xref>) one can easily recognize the visual patterns mentioned before: (1) regions of empty plots represent parts of the system that were removed or migrated to other subsystems; (2) a steadily growing subsystem is represented by a continuously declining street. The buildings along that street are relatively small, and some of them even have been removed again; (3) peripheral suburbs represent local system extensions that were added to the system during a certain period of time. The red suburb in <xref ref-type="fig" rid="fig8-1473871612438785">Figure 8</xref> mainly consists of small buildings representing small modules with low coupling. In contrast, the yellow suburb consists of some relatively large buildings which represent large and strongly coupled modules. Thus, the yellow suburb represents a larger functional extension of the system than the red suburb does.</p>
<p>Another example of an evolution map is shown in <xref ref-type="fig" rid="fig9-1473871612438785">Figure 9</xref>. Here each module is represented by a tower with two segments. The height of each segment represents the modules incoming (blue) and outgoing (yellow) structural dependencies, i.e. number of modules using the module or being used by the module. As the base area is proportional to the dependencies, this property is strongly emphasized in this type of map. It can easily be seen that there is one subsystem in the center which contains several old modules with very high incoming coupling. These old modules implement the system’s central data structure.</p>
<fig id="fig9-1473871612438785" position="float">
<label>Figure 9.</label>
<caption>
<p>Dependency-based evolution map for CrocoCosmos.</p>
</caption>
<graphic xlink:href="10.1177_1473871612438785-fig9.tif"/>
</fig>
<p>As these examples show, evolution maps on the one hand give a high-level overview of a systems decomposition and structural evolution, and thus they can be very helpful, especially for project newcomers. Besides that, evolution maps allow one to study particular aspects such as size or dependencies in the context of the systems evolution: it becomes apparent whether quality problems such as complex, large, or strongly coupled modules affect mainly new parts of the system or whether these are old problems, which is especially important for directing restructuring efforts.</p>
</sec>
<sec id="section16-1473871612438785">
<title>Understanding modification history</title>
<p>Another application scenario uses a panorama map together with simple property towers depicting the number of modifications as height and being colored according to their last modification date. The resulting <italic>modification history map</italic> (<xref ref-type="fig" rid="fig10-1473871612438785">Figure 10</xref>) shows three modification history properties for each component, i.e. creation date, last modification date, and number of modifications.</p>
<fig id="fig10-1473871612438785" position="float">
<label>Figure 10.</label>
<caption>
<p>Modification history map for CrocoCosmos.</p>
</caption>
<graphic xlink:href="10.1177_1473871612438785-fig10.tif"/>
</fig>
<p>On the modification history map one can easily distinguish different situations: (1) flat blue buildings on high elevation levels, often located on separated plateaus, represent modules which have been part of the system for a long time, which have barely been modified after their initial creation, and which have not been modified for a long time. There are two possible reasons for such a situation – either these modules implement very stable functionality or their functionality is not used any longer, and therefore they are not maintained at all. In this case these modules and subsystems could be candidates for being removed from the system. (2) Tall yellow buildings at high elevation levels represent old modules that have been part of the system for a very long time; they have been changed a lot since their initial creation but were modified very recently. Buildings like these might indicate potential design problems.</p>
<p>Modification history maps can be used in different application scenarios. For example, they support the identification of code regions which are often changed, and thus might be candidates for reviews and reengineering activities. They can also support the communication between developers, managers, and customers, e.g. when illustrating potential risks of customer-side feature requests. They help to discuss which parts of the system would have to be modified and whether these parts are well understood (as they were often and very recently modified) or whether they are old and rarely modified parts for which expertise might be missing.</p>
</sec>
<sec id="section17-1473871612438785">
<title>Understanding authorship</title>
<p>Another set of questions is addressed by the <italic>authorship map</italic>. Again, a panorama map is used as the basis. Modules are represented by so-called <italic>authorship towers</italic> (see <xref ref-type="fig" rid="fig11-1473871612438785">Figure 11</xref>). Authorship towers show module modifications made by a selected set of authors. For this purpose, they consist of several colored segments, each of which indicates an author-specific modification of the respective module. The color of each segment is used to encode the author who made the respective modification. Authors can be selected interactively; modifications by authors not contained in this selected author set are represented by transparent segments. Thus, the total height of each authorship tower always represents the number of all modifications applied to the corresponding module.</p>
<fig id="fig11-1473871612438785" position="float">
<label>Figure 11.</label>
<caption>
<p>Authorship towers.</p>
</caption>
<graphic xlink:href="10.1177_1473871612438785-fig11.tif"/>
</fig>
<p>There are two possibilities for ordering the segments. First, they are sorted by author, i.e. all segments for modifications performed by the same author are stacked to form one composite segment for that author (<xref ref-type="fig" rid="fig11-1473871612438785">Figure 11(a)</xref>). Second, segments are sorted in ascending temporal modification order and displayed bottom up, i.e. segments for old modifications are displayed at the bottom whereas new modifications are displayed on top of the tower (<xref ref-type="fig" rid="fig11-1473871612438785">Figure 11(b)</xref>). Whereas the first kind of ordering supports to rate the familiarity of authors with particular modules, the second kind of ordering is particularly useful to detect drifts in code ownership.</p>
<p><xref ref-type="fig" rid="fig12-1473871612438785">Figure 12</xref> shows the authorship map for our example system. The contributions of the main developer are shown in dark green. From the early days of the project until now he is the author and main contributor of many classes throughout the system. In contrast, the dark-brown and the light-brown developers are authors of more recent extensions of the system. Both are specialists for local and clearly separated parts of the system. The yellow developer was the author of an early extension of the system, which also required some adaptations in many existing classes. This developer was active for only a certain period of the development history.</p>
<fig id="fig12-1473871612438785" position="float">
<label>Figure 12.</label>
<caption>
<p>Authorship map for CrocoCosmos.</p>
</caption>
<graphic xlink:href="10.1177_1473871612438785-fig12.tif"/>
</fig>
<p>The authorship map for a part of the 3D graphics library jMonkeyEngine in <xref ref-type="fig" rid="fig13-1473871612438785">Figure 13</xref> shows a different situation with respect to code ownership and the contributions of different developers. Six developers were modifying almost all classes of the system. There seem to be no clear responsibilities of developers for particular parts of the system.</p>
<fig id="fig13-1473871612438785" position="float">
<label>Figure 13.</label>
<caption>
<p>Authorship map for jMonkeyEngine.</p>
</caption>
<graphic xlink:href="10.1177_1473871612438785-fig13.tif"/>
</fig>
<p>Besides analyzing code ownership, authorship maps can be used to detect implicit dependencies among subsystems, i.e. dependencies that are not explicitly encoded as structural dependencies. <xref ref-type="fig" rid="fig14-1473871612438785">Figure 14</xref> shows all structural module dependencies for those two subsystems that were developed by the light-brown developer. Obviously there is no direct structural dependency between these subsystems. Instead they are related to some old modules developed by the dark-green developer.</p>
<fig id="fig14-1473871612438785" position="float">
<label>Figure 14.</label>
<caption>
<p>Structural dependencies between (a) layout subsystem and central data structure. (b) central data structure and analysis subsystem.</p>
</caption>
<graphic xlink:href="10.1177_1473871612438785-fig14.tif"/>
</fig>
<p>The reason for this is that the light-brown developer first developed a new graph layout approach and added this implementation to the layout subsystem at the lower-right region of <xref ref-type="fig" rid="fig14-1473871612438785">Figure 14(a)</xref>. The results of this computation are stored in the central data structure. Later on he developed an analysis subsystem to evaluate layout properties such as stability and compactness of his new approach and added this implementation to the analysis subsystem at the lower-left region of <xref ref-type="fig" rid="fig14-1473871612438785">Figure 14(b)</xref>. For this purpose all layout results must be read from the central data structure again. This created an indirect data dependency between the computation subsystem and the analysis subsystem.</p>
<p>While this example very clearly points to a non-syntactical data dependency among two subsystems hidden dependencies certainly cannot be detected as clearly as shown above for the general case. This is especially true because programmers usually work on several distinct and independent parts of the software. Thus, when studying authorships to detect such dependencies it might be reasonable to consider only those modifications of a particular author that were performed during a relatively short period of time.</p>
</sec>
</sec>
<sec id="section18-1473871612438785" sec-type="discussion">
<title>Discussion</title>
<sec id="section19-1473871612438785">
<title>Complex comprehension scenarios</title>
<p>Each of the comprehension scenarios described above concentrates on a specific aspect of the underlying software system (such as authorship, modifications, module coupling, etc.). Many different approaches for the analysis of several aspects of software systems such as quality and team organization are described in the literature. The unique strength of the EvoStreets approach is that it allows for visualizing all of these aspects in an explicit relation to the systems evolution. The uniform way of representing these aspects in thematic maps coherently derived from a common geographical base model supports the cognitive process for integrating formerly separated aspects consistently into more complex mental maps. This provides deeper insights and allows for mastering more complex comprehension tasks.</p>
<p>Examples of such complex analysis scenarios are, for instance, the identification of correlations (such as test coverage with authorship) or the identification of critical system components (e.g. old parts of the software system with strong incoming dependencies that were not modified over a long period of time and for which the responsible authors are no longer available). All this information can be obtained by flipping between maps. Besides that, the approach allows for filtering the visualization for each of the data types mentioned above, e.g. to show only modules modified by a given author or in the recent past or to show modules that were executed by a given test suite. For this purpose test-related data are represented by two specific property towers. For each module test coverage can be represented by two segments indicating the number of lines of code covered and uncovered, respectively, by all test suites. Test suites, i.e. modules that implement test cases, are represented by mapping the number of successful and failed test cases onto both segments in a similar way. To distinguish modules and test suites different forms of towers (cuboid and cylinder) are used.</p>
<p>Filtering the set of represented modules based on test data within other thematic maps helps to focus on particular parts of the system for understanding.</p>
<p>In the same way, run-time data collected during the execution of particular system functions (e.g. execution time, memory usage) can be used as filters for thematic maps. This would, for instance, allow easily combining the information on error-prone executions with information on the modification history or authorship. The CrocoCosmos<sup><xref ref-type="bibr" rid="bibr22-1473871612438785">22</xref></sup> tool, which implements the EvoStreets approach, supports such a dynamic analysis for Java systems. It uses online code instrumentation to record execution data and integrates these data into the primary model during program runtime.</p>
</sec>
<sec id="section20-1473871612438785">
<title>Re-engineering and refactoring</title>
<p>Primary models capture the structure of software systems in several versions. They do not, however, include restructuring information such as moving modules among subsystems. Thus, none of our models allows to distinguish between whether a given system element is removed from the system or whether the system was restructured, i.e. the element moved to another subsystem. As a consequence, visualizations of systems which are often and heavily restructured tend to contain many disused plots.</p>
<p>An example of such a system is the PMD analysis tool. <xref ref-type="fig" rid="fig15-1473871612438785">Figure 15</xref> shows the evolution history map for PMD at its SVN repository revision 7000. PMD is written in Java; thus, streets represent Java packages and plots represent the 619 Java classes. During its development the system has been heavily restructured. Many of the elements originally positioned on the now-disused plots actually moved to the upper-right subsystem. An example is the huge tower at the upper right, which originally was positioned on the large empty plot at the lower left.</p>
<fig id="fig15-1473871612438785" position="float">
<label>Figure 15.</label>
<caption>
<p>Size-based evolution history map for a heavily restructured system.</p>
</caption>
<graphic xlink:href="10.1177_1473871612438785-fig15.tif"/>
</fig>
<p>After such major restructurings, it could make sense to also restructure the secondary model by releasing the disused plots and creating a new layout starting from this point in development history.</p>
</sec>
<sec id="section21-1473871612438785">
<title>Layout compactness and stability</title>
<p>In some situations the current layout approach produces very long streets, which make the layout very spacious. The compactness of layouts (i.e. the area actually used for building plots in relation to the total area spanned by the city) is an important factor for readability and orientation. There are two main reasons for very long streets. First, a subsystem contains many elements that are sequentially arranged along its street representation. An example for such a layout is shown in <xref ref-type="fig" rid="fig17-1473871612438785">Figure 17</xref>. Second, during system evolution elements are frequently added to and removed from a subsystem. Adding a new element increases the length of its subsystem street by extending it and attaching the new element at its end. On the other hand, removing the element from the subsystem does not decrease its street length. Thus, even small subsystems with a changeful history might be represented by long streets, which have negative impact on the layout compactness. An example for such a layout is shown in <xref ref-type="fig" rid="fig15-1473871612438785">Figure 15</xref>.</p>
<p>To overcome these compactness problems we modified our layout algorithm by combining it with a packing-based layout in such a way that neighboring building plots on the same elevation level are arranged as rectangular districts along the street. <xref ref-type="fig" rid="fig16-1473871612438785">Figure 16(a)</xref> shows the EvoStreets layout for one revision of the ArgoUML software system. Owing to some very long streets this layout creates a lot of empty space. In contrast, the lower part of <xref ref-type="fig" rid="fig16-1473871612438785">Figure 16(b)</xref> shows a layout of the same system that was obtained by placing buildings as close as possible to the street origin, which yields circular districts on both sides of each street. As this example shows, reducing the length of streets significantly reduces the overall layout size and yields more compact layouts, possibly at the cost of more occlusion and less stability.</p>
<fig id="fig16-1473871612438785" position="float">
<label>Figure 16.</label>
<caption>
<p>ArgoUML (1585 Java classes). (a) Long streets causing low layout compactness. (b) Compact layout based on a shortest-distance packing strategy.</p>
</caption>
<graphic xlink:href="10.1177_1473871612438785-fig16.tif"/>
</fig>
<p>As neighboring buildings can be grouped together into the same district only if they are positioned on the same elevation level, this effect strongly depends on the temporal resolution of the primary model. If the primary model is populated on a daily basis, then in general only a few new modules are added to the system during this short period of time. If, however, the primary model is populated for each major project milestone only, then presumably many more modules will be added to the system during this long period of time. In the first case, the visualization contains many elevation levels and relatively small districts. In the latter case, the visualization contains relatively few elevation levels and larger districts. Thus, the use of districts has a larger effect on layout compactness for coarse-grained temporal resolution of the primary model.</p>
</sec>
<sec id="section22-1473871612438785">
<title>Fields of application</title>
<p>The examples in this paper represent software systems on a relatively fine-grained abstraction level, i.e. the module level. These modules (classes for Java systems and files for C/C++ systems) are, however, mainly the domain of programmers. In contrast, software architects or project managers are more interested in architectural units such as components and component hierarchies. The EvoStreets approach is essentially built on general graph-based primary models, which are independent from the programming language and abstraction level. It can easily be adapted to represent multi-language software systems on an architectural level just by populating the primary model with architectural units instead of design-level modules. The derived secondary and tertiary models visualize the system from an architecture perspective. This, however, requires the architectural components to be organized in a strict hierarchy tree so they can be mapped onto the hierarchical street system. Consequently, shared components would have to be represented redundantly.</p>
<p>The use of a general graph-based primary model basically allows for visualizing any kind of hierarchically structured and evolving data, for example organizational structures in companies. Thus, the approach presented in this article is not restricted to the visualization of software systems.</p>
</sec>
</sec>
<sec id="section23-1473871612438785">
<title>Tool support</title>
<p>The EvoStreets approach is completely tool supported: primary models are automatically extracted from project repositories using the Eclipse IDE or the Sotograph analysis tool. Secondary and tertiary models are created using our visualization tool CrocoCosmos.<sup><xref ref-type="bibr" rid="bibr22-1473871612438785">22</xref>,<xref ref-type="bibr" rid="bibr20-1473871612438785">20</xref></sup> It implements all visualization concepts presented in this paper and provides rich interactive parameterization capabilities for the generation of the secondary and tertiary models.</p>
<p>Each of the representation elements can be configured interactively. In authorship towers, for example, the authors to be visualized can be selected interactively. For the interaction with and navigation in the 3D scene standard navigation techniques, coordinated views, stereo projection, and the use of special input devices (e.g. 3D mouse) are provided. These interaction and navigation capabilities are crucial in 3D scenes to overcome occlusion problems and to fully explore the visualization. Additionally, the tool features interactive animations for stepping forward and backward through the development history to study a software systems evolution in detail.</p>
<p>The visualization part of CrocoCosmos is build on top of the jMonkeyEngine, an open-source graphics library written in Java. It proved to be very capable of handling the visualization of large real-world systems of more than 10,000 classes (<xref ref-type="fig" rid="fig17-1473871612438785">Figure 17</xref>).</p>
<fig id="fig17-1473871612438785" position="float">
<label>Figure 17.</label>
<caption>
<p>Java Development Kit (JDK 6), ca. 14.000 Java classes.</p>
</caption>
<graphic xlink:href="10.1177_1473871612438785-fig17.tif"/>
</fig>
</sec>
<sec id="section24-1473871612438785">
<title>Experiences</title>
<p>We conducted an exploratory study to determine the strengths and weaknesses of the city layouts. For this purpose we visualized 21 open-source systems with sizes ranging from only a few hundred classes to approximately 14,000 classes in the JDK 6 system shown in <xref ref-type="fig" rid="fig17-1473871612438785">Figure 17</xref>.</p>
<p>An important finding of this study is that low compactness is in fact a rather serious problem that often appears, especially in larger systems. As described above, this problem can significantly be reduced by arranging neighboring buildings on the same elevation level in rectangular districts.</p>
<p>The landscape patterns described above are not specific phenomena of our example systems. We found all the patterns during this exploratory study, although not every pattern appeared in each system. There were strongly restructured systems as the PMD system described above. Also, we found systems that continuously grew without any major restructurings.</p>
<p>For systems where much of the growth takes place at the beginning, most of the city structure is placed on high elevation levels; only a few new structures are added on lower elevation levels. For such situations we observed that evolution became rather difficult to see as the larger older structures dominate the visualization. Generally speaking, this problem arises whenever relatively small modifications are applied to relatively large systems. On the one hand, this behavior might be desirable as small changes do not disrupt the overall city structure. On the other hand, we conclude a need for additional means supporting the readability of particularly smaller software modifications expressed in the layout.</p>
<p>We conducted a second study with an industrial partner, a large logistics company. On the company side, the study involved the quality assurance team, which is responsible for monitoring the quality of externally developed code. The study included two iterations.</p>
<p>During the first iteration we looked at a medium-sized Java system with 354 Java classes in five major project releases. We produced static visualizations for several scenarios and returned them together with a brief textual description for each. We discussed these visualizations with the quality assurance team and obtained the following results.</p>
<p>From a representational point of view, the team pointed out the aesthetics and readability of the visualizations, though the latter still should be improved. On the one hand, the readability of the hierarchical system decomposition represented by the city layout was highly appreciated. On the other hand, it would be rather difficult to read the elevation information of the landscape provided via contour lines. In part this may be due to the small number of versions we looked at, but nonetheless it also suggests that another additional support mechanism, such as the use of cartographic height coloring or labeling, is necessary.</p>
<p>When inspecting the first system, we identified many areas of zero-height buildings distributed throughout the city for those scenarios where typical-quality data such as bug numbers were mapped onto the building heights. At first we supposed this to be a blind spot caused by a faulty configuration of the quality system and asked for the reasons. But, in fact, this blind spot is intentional as it points to test code and generated code that are not monitored with analysis tools. We offered to remove this code from the visualization, but the team explicitly rejected this idea as it would be important to know about this code and how it is distributed in the system; however, it would be rather helpful for distinguishing among hand-written code, generated code, and test code representations by using additional means such as shape or surrounding ground color.</p>
<p>One of the responsibilities of the quality assurance team is to monitor the evolution of so-called risky code and unfinished code. Both qualities can numerically be quantified using specific metrics. We obtained the respective data, integrated them into our primary models, and derived respective tertiary models to support this customer-requested scenario during the second iteration.</p>
<p>For the second iteration we used a larger system with about 1500 classes again in five major project releases. Again we provided static visualizations for several scenarios including the additional risky code and unfinished code scenarios and discussed them in an informal interview session.</p>
<p>The avoidance of risky code has explicitly been stated as a quality requirement, and the number of occurrences of unfinished code should decline to zero at least until the final project revision is reached. The visualizations largely matched both expectations: risky code has been very rare throughout the whole evolution, and the unfinished code continuously decreased until the final version has been reached. The quality assurance team explicitly pointed out that the major advantage of using these visualizations is that it takes only a few moments to obtain an overview of risky and unfinished code parts, their distribution throughout the system, and their development compared with the previous revision. It would be very much like watching a movie when clicking along the versions and seeing, for example, unfinished code continuously decrease to zero. This is, in fact, a quality that results from the visualization’s stability against structural changes.</p>
<p>We provided both 2D and 3D maps and asked for an assessment and preference. Because building height is not visible in 2D maps, we included building shadows to indicate high buildings. Interestingly, 3D maps were assessed as more valuable as they would allow for identifying correlations between quality attributes more easily. Occlusion occurred, but it would not be problematic for two reasons: first, from the quality assurance perspective, interesting parts are usually represented as higher buildings; second, if the visualization can interactively be viewed from different angles then occluded buildings could easily be detected by rotating the scene once.</p>
</sec>
<sec id="section25-1473871612438785">
<title>Summary and outlook</title>
<p>In this article we described a three-staged visualization approach adopted from cartography for the systematic visualization of large software systems which fosters a systematic use of map-making techniques. Each of these stages deals with a specific model. The primary model captures the structure of software systems and product- and process-related data, and their evolution over time. Primary models are the logical base model of all visualizations.</p>
<p>The secondary model adds geometric information to the primary model. In this context, the main contribution of this paper, the novel EvoStreets layout approach for software cities based on the hierarchical system, decomposition and component ages were presented. This approach produces geometrically stable city layouts for evolving software systems, i.e. systems that are still being developed. It uses landscape elevations to directly represent a software systems development history in the layout. Owing to this design decision and the addition of a 2.5D terrain model underlying the hierarchical street system, novel thematic maps can be designed.</p>
<p>The layout approach, however, has some shortcomings. Visualizations of systems that are often restructured or that have large subsystems tend to be not very compact. Therefore, we are currently studying modifications of our layout algorithm to achieve both stable and compact layouts. Furthermore, the stability and compactness of EvoStreets layouts has to be compared with other approaches proposed in the literature. An initial study<sup><xref ref-type="bibr" rid="bibr23-1473871612438785">23</xref></sup> is being extended to cover more layout approaches and a larger set of real-world examples.</p>
<p>Tertiary models are derived from secondary models by transformations such as projections, coloring, or superposition of symbols and diagrams. Such thematic maps are designed to support specific application scenarios. To represent various module properties in a uniform way we designed so-called property towers. We explored several such specific application scenarios and demonstrated how our specific maps can support these scenarios. Such application or comprehension scenarios were (and still are) derived and discussed in cooperation with several industrial<sup><xref ref-type="bibr" rid="bibr31-1473871612438785">31</xref></sup> partners.</p>
</sec>
</body>
<back>
<fn-group>
<fn fn-type="financial-disclosure">
<label>Funding</label>
<p>This research received no specific grant from any funding agency in the public, commercial, or not-for-profit sectors.</p>
</fn>
</fn-group>
<notes>
<fn-group>
<fn fn-type="other" id="fn1-1473871612438785">
<label>*</label>
<p>This article is an extended and revised version of Ref. 1</p>
</fn>
</fn-group></notes>
<ref-list>
<title>References</title>
<ref id="bibr1-1473871612438785">
<label>1.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Steinbrückner</surname><given-names>F</given-names></name>
<name><surname>Lewerentz</surname><given-names>C</given-names></name>
</person-group>. <article-title>Representing development history in software cities</article-title>. In: <conf-name>Proceedings of the 5th international symposium on software visualization (SOFTVIS ’10)</conf-name>, <year>2010</year>, <conf-loc>Salt Lake City, USA</conf-loc>, <conf-date>25–26 October 2010</conf-date>, pp.<fpage>193</fpage>–<lpage>202</lpage>. <conf-loc>New York: ACM Press</conf-loc>.</citation>
</ref>
<ref id="bibr2-1473871612438785">
<label>2.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Panas</surname><given-names>T</given-names></name>
<name><surname>Epperly</surname><given-names>T</given-names></name>
<name><surname>Quinlan</surname><given-names>D</given-names></name>
<etal/>
</person-group>. <article-title>Communicating software architecture using a unified single-view visualization</article-title>. In: <source>ICECCS, 12th IEEE international conference on engineering complex computer systems (ICECCS 2007)</source>, <conf-loc>Auckland, New Zealand</conf-loc>, <day>11–14</day> <month>July</month> <year>2007</year>, pp.<fpage>217</fpage>–<lpage>228</lpage>. <conf-loc>DC, USA: IEEE Computer Society Washington</conf-loc>.</citation>
</ref>
<ref id="bibr3-1473871612438785">
<label>3.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Kuhn</surname><given-names>A</given-names></name>
<name><surname>Loretan</surname><given-names>P</given-names></name>
<name><surname>Nierstrasz</surname><given-names>O</given-names></name>
</person-group>. <article-title>Consistent layout for thematic software maps</article-title>. In: <conf-name>Proceedings of 15th working conference on reverse engineering</conf-name>, <conf-loc>Antwerp, Belgium</conf-loc>, <conf-date>15–18 October 2008</conf-date>, pp.<fpage>209</fpage>–<lpage>218</lpage>. <conf-loc>Los Alamitos, CA: IEEE Computer Society Press</conf-loc>.</citation>
</ref>
<ref id="bibr4-1473871612438785">
<label>4.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Balzer</surname><given-names>M</given-names></name>
<name><surname>Noack</surname><given-names>A</given-names></name>
<name><surname>Deussen</surname><given-names>O</given-names></name>
<etal/>
</person-group>. <article-title>Software landscapes: visualizing the structure of large software systems</article-title>. In: <source>VisSym 2004, symposium on visualization</source>, <year>2004</year>, pp.<fpage>261</fpage>–<lpage>266</lpage>. <conf-name>Eurographics Association</conf-name>.</citation>
</ref>
<ref id="bibr5-1473871612438785">
<label>5.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Knight</surname><given-names>C</given-names></name>
<name><surname>Munro</surname><given-names>M.</given-names></name>
</person-group> <article-title>Comprehension with[in] virtual environment visualisations</article-title>. In: <conf-name>Proceedings of the IEEE 7th international workshop on program comprehension</conf-name>, <conf-loc>Pittsburgh, PA</conf-loc>, <conf-loc>5 to 7 May 1999</conf-loc>, pp.<fpage>4</fpage>–<lpage>11</lpage>. <conf-loc>Washington, DC: IEEE Computer Society</conf-loc>.</citation>
</ref>
<ref id="bibr6-1473871612438785">
<label>6.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Wettel</surname><given-names>R</given-names></name>
<name><surname>Lanza</surname><given-names>M.</given-names></name>
</person-group> <article-title>Visualizing software systems as cities</article-title>. In: <conf-name>Proceedings of VISSOFT 2007 (4th IEEE international workshop on visualizing software for understanding and analysis)</conf-name>, <conf-loc>Banff, Canada</conf-loc>, <conf-date>24–25 June 2007</conf-date>, pp.<fpage>92</fpage>–<lpage>99</lpage>. <conf-loc>Los Alamitos, CA: IEEE Computer Society</conf-loc>.</citation>
</ref>
<ref id="bibr7-1473871612438785">
<label>7.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Knight</surname><given-names>C</given-names></name>
<name><surname>Munro</surname><given-names>MC.</given-names></name>
</person-group> <article-title>Virtual but visible software</article-title>. In: <source>International conference on information visualization</source>, <conf-loc>London, UK</conf-loc>, <conf-date>19–21 July 2000</conf-date>, pp. <fpage>198</fpage>–<lpage>205</lpage>. <conf-loc>Los Alamitos, CA: IEEE Computer Society</conf-loc>.</citation>
</ref>
<ref id="bibr8-1473871612438785">
<label>8.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Charters</surname><given-names>SM</given-names></name>
<name><surname>Knight</surname><given-names>C</given-names></name>
<name><surname>Thomas</surname><given-names>N</given-names></name>
<etal/>
</person-group>. <article-title>Visualisation for informed decision making: from code to components</article-title>. In: <source>International conference on software engineering and knowledge engineering (SEKE ’02)</source>, <year>2002</year>, pp.<fpage>765</fpage>–<lpage>772</lpage>. <conf-loc>New York: ACM Press</conf-loc>.</citation>
</ref>
<ref id="bibr9-1473871612438785">
<label>9.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Panas</surname><given-names>T</given-names></name>
<name><surname>Berrigan</surname><given-names>R</given-names></name>
<name><surname>Grundy</surname><given-names>J</given-names></name>
</person-group>. <article-title>A 3D metaphor for software production visualization</article-title>. In: <source>International conference on information visualization</source>, <conf-loc>London, England</conf-loc>, <day>16–18</day> <month>July</month> <year>2003</year>, pp.<fpage>314</fpage>–<lpage>319</lpage>. <conf-loc>Los Alamitos, CA: IEEE Computer Society</conf-loc>.</citation>
</ref>
<ref id="bibr10-1473871612438785">
<label>10.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Alam</surname><given-names>S</given-names></name>
<name><surname>Dugerdil</surname><given-names>P.</given-names></name>
</person-group> <article-title>EvoSpaces visualization tool: exploring software architecture in 3D</article-title>. In: <conf-name>Proceedings of 14th working conference on reverse engineering (WCRE 2007)</conf-name>, <conf-loc>Vancouver, Canada</conf-loc>, <conf-date>28–31 October 2007</conf-date>, pp.<fpage>269</fpage>–<lpage>270</lpage>. <conf-loc>Washington, DC: IEEE Computer Society</conf-loc>.</citation>
</ref>
<ref id="bibr11-1473871612438785">
<label>11.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Alam</surname><given-names>S</given-names></name>
<name><surname>Dugerdil</surname><given-names>P.</given-names></name>
</person-group> <article-title>EvoSpaces: 3D visualization of software architecture</article-title>. In <conf-name>Proceedings of SEKE 2007 (the 19th international conference on software engineering and knowledge engineering)</conf-name>, <year>2007</year>, pp.<fpage>500</fpage>–<lpage>505</lpage>. <conf-loc>Washington, DC: IEEE Computer Society</conf-loc>.</citation>
</ref>
<ref id="bibr12-1473871612438785">
<label>12.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Dugerdil</surname><given-names>P</given-names></name>
<name><surname>Alam</surname><given-names>S.</given-names></name>
</person-group> <article-title>Execution trace visualization in a 3D space</article-title>. In: <conf-name>Proceedings of ITNG 2008 (5th international conference on information technology: new generations) Third international conference on information technology: new generations</conf-name>, <conf-loc>Las Vegas, NV</conf-loc>, <conf-date>7–9 April 2008</conf-date>, pp. <fpage>38</fpage>–<lpage>43</lpage>. <conf-loc>Los Alamitos, CA: IEEE Computer Society</conf-loc>.</citation>
</ref>
<ref id="bibr13-1473871612438785">
<label>13.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Langelier</surname><given-names>G</given-names></name>
<name><surname>Sahraoui</surname><given-names>H</given-names></name>
<name><surname>Poulin</surname><given-names>P</given-names></name>
</person-group>. <article-title>Visualization-based analysis of quality for large-scale software systems</article-title>. In: <conf-name>Proceedings of the 20th IEEE/ACM international conference on automated software engineering (ASE ’05)</conf-name>, <year>2005</year>, <conf-loc>Long Beach, CA</conf-loc>, pp.<fpage>214</fpage>–<lpage>223</lpage>. <conf-loc>New York: ACM Press</conf-loc>.</citation>
</ref>
<ref id="bibr14-1473871612438785">
<label>14.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Wettel</surname><given-names>R</given-names></name>
<name><surname>Lanza</surname><given-names>M.</given-names></name>
</person-group> <article-title>Program comprehension through software habitability</article-title>. In: <conf-name>Proceedings of ICPC 2007 (15th international conference on program comprehension)</conf-name>, <year>2007</year>, <conf-loc>Banff, Alberta</conf-loc>, pp.<fpage>231</fpage>–<lpage>240</lpage>. <conf-loc>Washington, DC: IEEE Computer Society</conf-loc>.</citation>
</ref>
<ref id="bibr15-1473871612438785">
<label>15.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Wettel</surname><given-names>R</given-names></name>
<name><surname>Lanza</surname><given-names>M.</given-names></name>
</person-group> <article-title>Visually localizing design problems with disharmony maps</article-title>. In: <conf-name>Proceedings of the 4th ACM symposium on software visualization</conf-name>, <year>2008</year>, pp. <fpage>155</fpage>–<lpage>164</lpage>. <conf-loc>New York: ACM Press</conf-loc>.</citation>
</ref>
<ref id="bibr16-1473871612438785">
<label>16.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Wettel</surname><given-names>R</given-names></name>
<name><surname>Lanza</surname><given-names>M</given-names></name>
</person-group>. <article-title>Visual exploration of large-scale system evolution</article-title>. In: <conf-name>Proceedings of the 15th working conference on reverse engineering (WCRE ’08)</conf-name>, <conf-loc>Antwerp, Belgium</conf-loc>, <conf-date>5–18 October 2008</conf-date>, pp.<fpage>219</fpage>–<lpage>228</lpage>. <conf-loc>Washington, DC: IEEE Computer Society</conf-loc>.</citation>
</ref>
<ref id="bibr17-1473871612438785">
<label>17.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Langelier</surname><given-names>G</given-names></name>
<name><surname>Sahraoui</surname><given-names>H</given-names></name>
<name><surname>Poulin</surname><given-names>P</given-names></name>
</person-group>. <article-title>Exploring the evolution of software quality with animated visualization</article-title>. In: <conf-name>Proceedings of the 2008 IEEE symposium on visual languages and human-centric computing (VLHCC ’08)</conf-name>, <conf-loc>Herrsching am Ammersee, Germany</conf-loc>, <conf-date>15–19 September 2008</conf-date>, pp.<fpage>13</fpage>–<lpage>20</lpage>. <conf-loc>Washington, DC: IEEE Computer Society</conf-loc>.</citation>
</ref>
<ref id="bibr18-1473871612438785">
<label>18.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Diehl</surname><given-names>S</given-names></name>
<name><surname>Görg</surname><given-names>C.</given-names></name>
</person-group> <article-title>Graphs, they are changing</article-title>. In: <conf-name>Revised papers from the 10th international symposium on graph drawing</conf-name> (eds <person-group person-group-type="editor">
<name><surname>Kobourov</surname><given-names>SG</given-names></name>
<name><surname>Goodrich</surname><given-names>MT</given-names></name></person-group>), <source>Lecture Notes in Computer Science</source>, <year>2002</year>, <volume>vol. 2528</volume>, pp.<fpage>23</fpage>–<lpage>30</lpage>. <publisher-loc>London</publisher-loc>: <publisher-name>Springer-Verlag</publisher-name>.</citation>
</ref>
<ref id="bibr19-1473871612438785">
<label>19.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Collberg</surname><given-names>C</given-names></name>
<name><surname>Kobourov</surname><given-names>S</given-names></name>
<name><surname>Nagra</surname><given-names>J</given-names></name>
<etal/>
</person-group>. <article-title>A system for graph-based visualization of the evolution of software</article-title>. In: <conf-name>Proceedings of the 2003 ACM symposium on software visualization (SoftVis ’03)</conf-name>, <year>2003</year>, <conf-loc>Las Vegas, Nevada</conf-loc>, pp.<fpage>77</fpage>–<lpage>ff</lpage>. <conf-loc>New York: ACM Press</conf-loc>.</citation>
</ref>
<ref id="bibr20-1473871612438785">
<label>20.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Noack</surname><given-names>A.</given-names></name>
</person-group> <source>Unified quality measures for clusterings, layouts, and orderings of graphs, and their application as software design criteria</source>. PhD Thesis, <publisher-name>Brandenburg University of Technology at Cottbus</publisher-name>, <publisher-loc>Cottbus, Germany</publisher-loc>, <year>2007</year> (URN: urn:nbn:de:kobv:co1-opus-4046).</citation>
</ref>
<ref id="bibr21-1473871612438785">
<label>21.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Slocum</surname><given-names>TA</given-names></name>
<name><surname>McMaster</surname><given-names>RB</given-names></name>
<name><surname>Kessler</surname><given-names>FC</given-names></name><etal/>
</person-group>. <source>Thematic cartography and geovisualization</source>. <edition>3rd ed.</edition> <publisher-loc>Upper Saddle River, NJ and London</publisher-loc>: <publisher-name>Pearson Prentice Hall</publisher-name>, <year>2010</year>, p.<fpage>561</fpage>.</citation>
</ref>
<ref id="bibr22-1473871612438785">
<label>22.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Lewerentz</surname><given-names>C</given-names></name>
<name><surname>Noack</surname><given-names>A.</given-names></name>
</person-group> <article-title>CrocoCosmos—3D visualization of large object-oriented programs</article-title>. In: <person-group person-group-type="editor">
<name><surname>Jünger</surname><given-names>M</given-names></name>
<name><surname>Mutzel</surname><given-names>P</given-names></name>
</person-group> (eds) <source>Graph drawing software</source>, <year>2003</year>, pp. <fpage>279</fpage>–<lpage>297</lpage>. <publisher-name>Springer-Verlag</publisher-name>.</citation>
</ref>
<ref id="bibr23-1473871612438785">
<label>23.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Mannl</surname><given-names>U.</given-names></name>
</person-group> <source>Evaluation of layout stability of software cities</source>. Master Thesis, <publisher-name>University of Technology</publisher-name>, <publisher-loc>Cottbus, Germany</publisher-loc>, <year>2010</year>.</citation>
</ref>
<ref id="bibr24-1473871612438785">
<label>24.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Bridgeman</surname><given-names>S</given-names></name>
<name><surname>Tamassia</surname><given-names>R</given-names></name>
</person-group>. <article-title>Difference metrics for interactive orthogonal graph drawing algorithms</article-title>. In: <source>Graph drawing, volume 1547, Lecture Notes in Computer Science</source>, pp.<fpage>57</fpage>–<lpage>71</lpage>. <publisher-loc>Berlin/Heidelberg</publisher-loc>: <publisher-name>Springer</publisher-name>, <year>1998</year>.</citation>
</ref>
<ref id="bibr25-1473871612438785">
<label>25.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Lyons</surname><given-names>KA</given-names></name>
<name><surname>Meijer</surname><given-names>H</given-names></name>
<name><surname>Rappaport</surname><given-names>D.</given-names></name>
</person-group> <article-title>Algorithms for cluster busting in anchored graph drawing</article-title>. <source>J Graph Algorithm Appl</source> <year>1998</year>; <volume>2</volume>: <fpage>7</fpage>–<lpage>17</lpage>.</citation>
</ref>
<ref id="bibr26-1473871612438785">
<label>26.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Balzer</surname><given-names>M</given-names></name>
<name><surname>Deussen</surname><given-names>O</given-names></name>
</person-group>. <article-title>Level-of-detail visualization of clustered graph layouts</article-title>. In: <conf-name>APVIS 07, 6th international Asia-Pacific symposium on visualization</conf-name>, <conf-loc>Sydney, Australia</conf-loc>, <conf-date>5–7 February 2007</conf-date>, pp.<fpage>133</fpage>–<lpage>140</lpage>. IEEE.</citation>
</ref>
<ref id="bibr27-1473871612438785">
<label>27.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Lanza</surname><given-names>M</given-names></name>
</person-group>. <article-title>The evolution matrix: recovering software evolution using software visualization techniques</article-title>. In: <conf-name>Proceedings of the 4th international workshop on principles of software evolution (IWPSE ’01)</conf-name>, <year>2001</year>, <conf-loc>Vienna University of Technology, Austria</conf-loc>, pp.<fpage>37</fpage>–<lpage>42</lpage>. <conf-loc>New York: ACM Press</conf-loc>.</citation>
</ref>
<ref id="bibr28-1473871612438785">
<label>28.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Holten</surname><given-names>D.</given-names></name>
</person-group> <article-title>Hierarchical edge bundles: visualization of adjacency relations in hierarchical data</article-title>. <source>IEEE Trans Visual Comput Graphics</source> <year>2006</year>; <volume>12</volume>(<issue>5</issue>): <fpage>741</fpage>–<lpage>748</lpage>.</citation>
</ref>
<ref id="bibr29-1473871612438785">
<label>29.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Fritz</surname><given-names>T</given-names></name>
<name><surname>Murphy</surname><given-names>GC</given-names></name>
</person-group>. <article-title>Using information fragments to answer the questions developers ask</article-title>. In: <conf-name>Proceedings ICSE 2010 (32th international conference on software engineering)</conf-name>, <conf-loc>Cape Town, South Africa</conf-loc>, <conf-date>2–8 May 2010</conf-date>, pp. <fpage>175</fpage>–<lpage>184</lpage>. <conf-loc>Washington, DC: IEEE Computer Society</conf-loc>.</citation>
</ref>
<ref id="bibr30-1473871612438785">
<label>30.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>DeLine</surname><given-names>R</given-names></name>
<name><surname>Venolia</surname><given-names>G</given-names></name>
<name><surname>LaToza</surname><given-names>TD</given-names></name>
</person-group>. <article-title>Maintaining mental models: a study of developer work habits</article-title>. In: <conf-name>Proceedings of 28th international conference on software engineering (ICSE’06)</conf-name>, <year>2006</year>, pp. <fpage>492</fpage>–<lpage>501</lpage>.</citation>
</ref>
<ref id="bibr31-1473871612438785">
<label>31.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Lewerentz</surname><given-names>C</given-names></name>
<name><surname>Steinbrückner</surname><given-names>F.</given-names></name>
</person-group> <article-title>SoftUrbs: visualizing software systems as urban structures</article-title>. Computer Science Reports 02/2009, <month>December</month>
 <year>2009</year>. <publisher-loc>Cottbus</publisher-loc>: <publisher-name>Brandenburg University of Technology at Cottbus</publisher-name>.</citation>
</ref>
</ref-list>
</back>
</article>