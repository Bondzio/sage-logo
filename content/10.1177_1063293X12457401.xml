<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD Journal Publishing DTD v2.3 20070202//EN" "journalpublishing.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">CER</journal-id>
<journal-id journal-id-type="hwp">spcer</journal-id>
<journal-title>Concurrent Engineering</journal-title>
<issn pub-type="ppub">1063-293X</issn>
<issn pub-type="epub">1531-2003</issn>
<publisher>
<publisher-name>SAGE Publications</publisher-name>
<publisher-loc>Sage UK: London, England</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1177/1063293X12457401</article-id>
<article-id pub-id-type="publisher-id">10.1177_1063293X12457401</article-id>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Articles</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>Hybrid solving algorithms for an extended dynamic constraint satisfaction problem based configuration system</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" corresp="yes">
<name><surname>Wang</surname><given-names>Lin</given-names></name>
</contrib>
<contrib contrib-type="author">
<name><surname>Ng</surname><given-names>Wee-Keong</given-names></name>
</contrib>
<aff id="aff1-1063293X12457401">CAIS, School of Computer Engineering, Nanyang Technological University, Singapore</aff>
</contrib-group>
<author-notes>
<corresp id="corresp1-1063293X12457401">Lin Wang, CAIS, School of Computer Engineering, Nanyang Technological University, 50 Nanyang Avenue, Singapore 639798. Email: <email>wang0328@e.ntu.edu.sg</email></corresp>
</author-notes>
<pub-date pub-type="epub-ppub">
<month>9</month>
<year>2012</year>
</pub-date>
<volume>20</volume>
<issue>3</issue>
<fpage>223</fpage>
<lpage>236</lpage>
<permissions>
<copyright-statement>© The Author(s) 2012</copyright-statement>
<copyright-year>2012</copyright-year>
<copyright-holder content-type="sage">SAGE Publications</copyright-holder>
</permissions>
<abstract>
<p>In modern manufacturing, constraint satisfaction problem based product configuration systems have been recognized as an effective and promising approach to represent and solve product family design tasks. In this article, based on an extended dynamic constraint satisfaction problem based product configuration system, a hybrid constraint satisfaction problem solving algorithm with forward checking and backjumping with fail-first heuristic is proposed. To control backtracking occurrence in this hybrid solving algorithm when new active variables are introduced into dynamic constraint satisfaction problem, a hybrid heuristic (a combination of an amended most-constrained heuristic and fail-first heuristic) is integrated with forward checking and backjumping for better solution efficiency. Experiments on both algorithms have been performed on a dynamic constraint satisfaction problem based PC configuration task.</p>
</abstract>
<kwd-group>
<kwd>Forward checking</kwd>
<kwd>backjumping</kwd>
<kwd>fail-first heuristic</kwd>
<kwd>amended most-constrained heuristic</kwd>
<kwd>dynamic constraint satisfaction problem based product configuration</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="section1-1063293X12457401" sec-type="intro">
<title>Introduction</title>
<p>In the last two decades, many markets have fragmented into more but smaller market niches and have presented more uncertainty due to increasing demand heterogeneity (<xref ref-type="bibr" rid="bibr7-1063293X12457401">Jiao et al., 2007</xref>). That is, customers do not just want a product; they want a product that meets their specific requirements. Thus, manufacturers face a dilemma of providing various products that meet diverse customer requirements with prices that can compete with mass produced products (<xref ref-type="bibr" rid="bibr5-1063293X12457401">Du et al., 2001</xref>). Mass customization (<xref ref-type="bibr" rid="bibr5-1063293X12457401">Du et al., 2001</xref>; <xref ref-type="bibr" rid="bibr7-1063293X12457401">Jiao et al., 2007</xref>), which seeks a combination of a variety of customer-oriented products with mass production efficiency, has become a trend in modern manufacturing. Product family (PF) design has been widely adopted as one of the most effective methods for mass customization by providing a variety of products while maintaining high production volumes to reduce production costs (<xref ref-type="bibr" rid="bibr5-1063293X12457401">Du et al., 2001</xref>; <xref ref-type="bibr" rid="bibr7-1063293X12457401">Jiao et al., 2007</xref>). In PF design, product configuration problem representation and resolution are two main issues. Among various product configuration methodologies, constraint satisfaction problem (CSP) solving approach, due to its highly declarative feature, generality, and flexibility, has been accepted as a promising method for modeling and solving configuration tasks (<xref ref-type="bibr" rid="bibr4-1063293X12457401">Chenouard et al., 2009</xref>; <xref ref-type="bibr" rid="bibr10-1063293X12457401">Razgon, 2005</xref>).</p>
<p>In this article, we briefly introduce an extended dynamic CSP (DCSP) based product configuration system that has been presented earlier by <xref ref-type="bibr" rid="bibr12-1063293X12457401">Wang et al. (2011)</xref> for modeling configuration problems. We then propose a hybrid solving algorithm that combines forward checking and backjumping with fail-first heuristic (FC-BJ-FF) to effectively solve this extended DCSP-based configuration system. We also propose a hybrid heuristic (i.e. a combination of an amended most-constrained heuristic and FF heuristic) integrating with algorithm FC-BJ to address the issue of FC-BJ-FF on the extended DCSP system.</p>
<p>This article is organized as follows: Section “Literature review” provides backgrounds on PF and CSP-based configuration systems. Section “An extended DCSP-based product configuration system” briefly introduces an extended DCSP-based product configuration system. Section “A hybrid solving algorithm for the extended DCSP-based configuration system” elaborates a hybrid solving algorithm, an augmented FC-BJ-FF, for the extended DCSP-based configuration system to achieve good solving efficiency. To address the issue of the hybrid solving algorithm, section “A hybrid heuristic for the extended DCSP-based configuration system” proposes a hybrid heuristic, that is, a combination of an amended most-constrained heuristic and FF. Section “Experiments” describes our experience in implementing the two algorithms on an extended DCSP-based PC configuration task. Finally, conclusions are drawn in section “Conclusions.”</p>
</sec>
<sec id="section2-1063293X12457401">
<title>Literature review</title>
<p>A PF consists of a set of similar products, called <italic>product variants</italic>, which share some common functionality, structures, or production technologies, and possess specific features to meet particular customer requirements (<xref ref-type="bibr" rid="bibr7-1063293X12457401">Jiao et al., 2007</xref>). While a PF aims at certain market segment, each product variant within a PF meets a particular set of customer needs within the market segment. Modularity, commonality, and variety are three main concerns in PF design (<xref ref-type="bibr" rid="bibr6-1063293X12457401">Fujita and Yoshida, 2004</xref>; <xref ref-type="bibr" rid="bibr7-1063293X12457401">Jiao et al., 2007</xref>; Simpson and D’Souza, 2004). Modularity defines module types in a PF and provides flexibility for the generation of product by module combinations for different needs. Commonality characterizes the grouping of similar modules under specific module types, which are shared by product variants within a PF, and exhibits the difference of PF design from single product design. Variety provides diversity among product variants within a PF by plugging in modules for specific functions.</p>
<p>Specifically, a PF consists of <italic>modules</italic> that can be classified into common and differentiation modules (<xref ref-type="bibr" rid="bibr6-1063293X12457401">Fujita and Yoshida, 2004</xref>; Simpson and D’Souza, 2004). While common modules are mandatorily shared by all product variants within a PF, differentiation modules are optional and are the source of variety in PF design. Each module holds a set of properties. The hierarchy of modules in a PF is represented as product family architecture (PFA) that refers to the conceptual structure and overall logical organization of a PF (<xref ref-type="bibr" rid="bibr5-1063293X12457401">Du et al., 2001</xref>). In general, a PFA is a tree structure where each nonleaf module (parent module) has at least two composition modules (child modules). A product variant consists of <italic>components</italic>, each of which is an instance of a corresponding module in PF, and thus, inherits all module properties but has different values. It also organizes the components according to PFA. Therefore, a product variant can be viewed as an instantiation of the corresponding PF by choosing feasible modules and component alternatives for particular needs with particular hierarchy.</p>
<p>Problem representing and solving are two key issues in product configuration within a PF. In PF design, designers need to take into account a huge amount of data with great heterogeneity, such as customer needs, product definition, functionality, manufacturing or assembly processes, resources, inventory, cost and supply chain. In addition, after-sale services, recycling, and disposal of product after use are gradually becoming manufacturers’ responsibility (<xref ref-type="bibr" rid="bibr13-1063293X12457401">Xu et al., 2004</xref>). How to efficiently and effectively represent all of these data is a challenge. After modeling a PF design task, product configuration within the PF can be performed. The core of product configuration is selecting and arranging combinations of components based on predefined configuration rules to satisfy given specifications (<xref ref-type="bibr" rid="bibr6-1063293X12457401">Fujita and Yoshida, 2004</xref>; <xref ref-type="bibr" rid="bibr7-1063293X12457401">Jiao et al., 2007</xref>; Simpson and D’Souza, 2004). How to efficiently and effectively achieve product configuration is another issue in PF design.</p>
<p>Due to its generality and flexibility, CSP has been recognized as a promising and efficient approach for modeling and solving product configuration tasks (<xref ref-type="bibr" rid="bibr4-1063293X12457401">Chenouard et al., 2009</xref>; <xref ref-type="bibr" rid="bibr10-1063293X12457401">Razgon, 2005</xref>). A CSP can be simply described as a finite set of variables with finite domains and a set of constraints restricting combinations of values that variables can simultaneously take. The task of a CSP is to find its solution(s), each of which assigns a value to each variable without conflicting with any constraint (<xref ref-type="bibr" rid="bibr2-1063293X12457401">Barták, 1999</xref>). The concept in PF design can be easily and straightforwardly modeled by the formalisms of CSP, that is, variables, domains, and constraints. Based on a CSP-represented PF design task, various CSP solving algorithms (such as generate-and-test, backtracking (BT), backjumping, backchecking, forward checking, consistency techniques, and heuristics; <xref ref-type="bibr" rid="bibr2-1063293X12457401">Barták, 1999</xref>; <xref ref-type="bibr" rid="bibr3-1063293X12457401">Barták, 2005</xref>) are performed without considering the specific domain of PF design task, that is, generality, and its results are easily understood. That is, values of variables in CSP results are the selected components for valid product configuration that meet specific requirements and compatibility restrictions. Specifically, in the first application of CSP on product configuration (<xref ref-type="bibr" rid="bibr9-1063293X12457401">Mittal and Frayman, 1989</xref>), a product is described as a combination of a fixed, finite set of component variables, each of which holds property variables and port variables that represent connections with other components. Domains of the variables, which include all values that the variables can take, are discrete and finite. Compatibility constraints are used to represent restrictions on component combinations in a valid configuration. Thus, the solution to CSP that assigns a value to each variable is the required configuration. However, as it requires predefined variables, the classical CSP-based model fails to represent more complex problems that are common in manufacturing, and where component number is not known <italic>a priori</italic>. It also fails to capture the hierarchy of components that is an inherent nature in PF design. To address the first issue of the classical model, the dynamic CSP (DCSP) based configuration system has been proposed (<xref ref-type="bibr" rid="bibr8-1063293X12457401">Mittal and Falkenhainer, 1990</xref>). In DCSP, there are two states for variables: active or inactive. Only active variables, a subset of all the variables, are involved in final solutions. Besides compatibility constraints, activity constraints specify conditions under which inactive variables become active. DCSP is more powerful as it is able to handle the condition that components involved in a configuration are not predetermined. However, it is still limited to the representation of component structures.</p>
</sec>
<sec id="section3-1063293X12457401">
<title>Hybrid solving algorithm for DCSP-based configuration system</title>
<p>In this section, first, we briefly introduce an extended DCSP-based product configuration system (<xref ref-type="bibr" rid="bibr12-1063293X12457401">Wang et al., 2011</xref>), which includes structural constraints representing the inherent hierarchy of components in PF, and activation constraints for DCSP extension. Then we propose two hybrid solving algorithms for the extended DCSP system to achieve better solution efficiency, that is, an augmented FC-BJ-FF heuristic, and an augmented FC-BJ with a hybrid heuristic.</p>
<sec id="section4-1063293X12457401">
<title>An extended DCSP-based product configuration system</title>
<p>In the extended DCSP-based product configuration system (presented earlier by <xref ref-type="bibr" rid="bibr12-1063293X12457401">Wang et al. (2011)</xref> and called “the extended DCSP system” for short in this article), concepts of PF design are all represented as variables in a DCSP. That is, modules of a PF, their instance components of product variants, properties and cost drivers associated with the modules and components are denoted as module variables <italic>V</italic><sub><italic>M</italic></sub>, component variables <italic>V</italic><sub><italic>CM</italic></sub>, property variables <italic>V</italic><sub><italic>P</italic></sub>, and cost variables <italic>V</italic><sub><italic>CT</italic></sub> (<italic>V</italic><sub><italic>CT</italic></sub> can be viewed as a special type of <italic>V</italic><sub><italic>P</italic></sub>, and we use the term “property variables” to represent both <italic>V</italic><sub><italic>CT</italic></sub> and <italic>V</italic><sub><italic>P</italic></sub> for short in this article) in a DCSP, respectively. Each variable is associated with a finite domain <italic>D</italic><sub><italic>i</italic></sub> and holds one of two states: active or inactive. Only a subset of all the variables, that is, active variables, is instantiated in a DCSP solving process and is involved in the final solution.</p>
<p>Structural constraints <italic>C</italic><sub><italic>s</italic></sub> capture the inherent hierarchy of modules in a PF and are inherited by product variants. In product variant generation, if a nonleaf module variable is active in a DCSP, all its common child modules must also be active, and several or no differentiation child modules are also activated for specific requirements. Activation constraints <italic>C</italic><sub><italic>a</italic></sub> trigger the activation of variables according to relationships between modules and associated properties. When a module variable is activated in DCSP, all its property variables are also activated in DCSP. Compatibility constraints represent restrictions on valid combinations of components in product variants. Equality or inequality constraints stipulate relationships among numerical or symbolic values of properties of modules by mathematical expressions and, consequently, are inherited by instance components of the module. Cost constraints in mathematical expressions represent quantity relationships among cost variables and other property variables. In a DCSP solving process, they calculate the result of cost estimation and are implemented as ordinary constraints for constraint consistency check. Preference constraints indicate which values or solutions in the DCSP are preferred. All these constraints, except <italic>C</italic><sub><italic>a</italic></sub> and <italic>C</italic><sub><italic>s</italic></sub>, are also referred to as generic constraints <italic>C</italic><sub><italic>g</italic></sub>. All these variables and constraints are stored in a configuration domain <inline-formula id="inline-formula1-1063293X12457401"><mml:math display="inline" id="math1-1063293X12457401"><mml:mrow><mml:mi>Φ</mml:mi></mml:mrow></mml:math></inline-formula> = <inline-formula id="inline-formula2-1063293X12457401"><mml:math display="inline" id="math2-1063293X12457401"><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>M</mml:mi></mml:mrow></mml:msub><mml:mo>;</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>CM</mml:mi></mml:mrow></mml:msub><mml:mo>;</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mo>;</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>CT</mml:mi></mml:mrow></mml:msub><mml:mo>;</mml:mo><mml:mi>D</mml:mi><mml:mo>;</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub><mml:mo>;</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>;</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>g</mml:mi></mml:mrow></mml:msub><mml:mo>〉</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, from which active variables and active constraints included in a DCSP solving process are derived. A DCSP-based configuration task is defined as <inline-formula id="inline-formula3-1063293X12457401"><mml:math display="inline" id="math3-1063293X12457401"><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mi>Φ</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>I</mml:mi></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>I</mml:mi></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>I</mml:mi></mml:mrow></mml:msup><mml:mo>〉</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, where <inline-formula id="inline-formula4-1063293X12457401"><mml:math display="inline" id="math4-1063293X12457401"><mml:mrow><mml:mi>Φ</mml:mi></mml:mrow></mml:math></inline-formula> refers to a configuration domain, <italic>V</italic><sup><italic>I</italic></sup> (<inline-formula id="inline-formula5-1063293X12457401"><mml:math display="inline" id="math5-1063293X12457401"><mml:mrow><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>I</mml:mi></mml:mrow></mml:msup><mml:mo>⊆</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>M</mml:mi></mml:mrow></mml:msub><mml:mo>∪</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>CM</mml:mi></mml:mrow></mml:msub><mml:mo>∪</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mspace width="0.25em"/><mml:mo>∪</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>CT</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>) is a finite set of initial active variables with corresponding domains <inline-formula id="inline-formula6-1063293X12457401"><mml:math display="inline" id="math6-1063293X12457401"><mml:mrow><mml:msup><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>I</mml:mi></mml:mrow></mml:msup><mml:mo>⊆</mml:mo><mml:mi>D</mml:mi></mml:mrow></mml:math></inline-formula>, and <italic>C</italic><sup><italic>I</italic></sup> (<inline-formula id="inline-formula7-1063293X12457401"><mml:math display="inline" id="math7-1063293X12457401"><mml:mrow><mml:msup><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>I</mml:mi></mml:mrow></mml:msup><mml:mo>⊆</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub><mml:mo>∪</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>∪</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>) is a finite set of initial constraints on <italic>V</italic><sup><italic>I</italic></sup>. A solution to the DCSP-based system is an assignment to a set of activated variables <italic>V</italic><sup><italic>a</italic></sup> (<inline-formula id="inline-formula8-1063293X12457401"><mml:math display="inline" id="math8-1063293X12457401"><mml:mrow><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msup><mml:mo>⊆</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>M</mml:mi></mml:mrow></mml:msub><mml:mo>∪</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>CM</mml:mi></mml:mrow></mml:msub><mml:mo>∪</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mo>∪</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>CT</mml:mi></mml:mrow></mml:msub><mml:mo>;</mml:mo><mml:mspace width="0.25em"/><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>I</mml:mi></mml:mrow></mml:msup><mml:mo>⊆</mml:mo><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>) such that all active constraints on <italic>V</italic><sup><italic>a</italic></sup> are satisfied. We refer the readers to more information in our earlier publication (<xref ref-type="bibr" rid="bibr12-1063293X12457401">Wang et al., 2011</xref>).</p>
</sec>
<sec id="section5-1063293X12457401">
<title>A hybrid solving algorithm for the extended DCSP-based configuration system</title>
<p>In this article, we propose a hybrid solving algorithm for the extended DCSP system, which combines three CSP solving algorithms in an augmented solving procedure; namely, an augmented FC-BJ-FF algorithm. The algorithm exhibits good search efficiency.</p>
<p>Instead of checking constraint consistency between two instantiated variables as in BT algorithm (<xref ref-type="bibr" rid="bibr2-1063293X12457401">Barták, 1999</xref>; <xref ref-type="bibr" rid="bibr3-1063293X12457401">Barták, 2005</xref>), FC algorithm (<xref ref-type="bibr" rid="bibr2-1063293X12457401">Barták, 1999</xref>; <xref ref-type="bibr" rid="bibr3-1063293X12457401">Barták, 2005</xref>) checks constraint consistency between an instantiated variable (the current variable <italic>cv</italic>) and a yet-to-be instantiated variable (a future variable <italic>fv</italic>) that has constraints with <italic>cv</italic>. Thereby, FC is able to detect conflicts before they really occur, that is, prevent future conflicts and thus address the issue of late conflict detection in BT. FC removes those <italic>fv</italic>’s values that conflict with <italic>cv</italic>’s assignment. Whenever <italic>fv</italic>’s domain becomes empty, it is detected that the current partial solution is inconsistent with <italic>fv</italic>. Then another available value is assigned to <italic>cv</italic>. If the domain of <italic>cv</italic> becomes empty, BT is performed on the last assigned variable in the solving process (one step backwards). In FC, when a variable is selected as <italic>cv</italic> to be assigned, all its available values are guaranteed to be consistent with the current partial solution (<xref ref-type="bibr" rid="bibr2-1063293X12457401">Barták, 1999</xref>), so it is not necessary to check its assignment against past assignments.</p>
<p>Algorithm BJ (<xref ref-type="bibr" rid="bibr3-1063293X12457401">Barták, 2005</xref>) identifies conflicting variables of a variable according to violated constraints. When a solving process prunes all the values of the current variable <italic>cv</italic> due to inconsistency with the current partial solution, BJ backtracks to the most recent conflicting variable of <italic>cv</italic>, instead of the last assigned variable like in BT and FC. Therefore, it is able to address the issue of thrashing in BT and FC, which refers to repeated failure in different parts of search space due to the same reason, because BT and FC do not identify the real conflict reason, that is, the conflicting variables (<xref ref-type="bibr" rid="bibr2-1063293X12457401">Barták, 1999</xref>; <xref ref-type="bibr" rid="bibr3-1063293X12457401">Barták, 2005</xref>).</p>
<p>In this section, we integrate these two algorithms into a hybrid algorithm for the extended DCSP system, that is, an augmented FC-BJ, which can backtrack more than one step when conflicts are detected (i.e. backjump; <xref ref-type="bibr" rid="bibr10-1063293X12457401">Razgon, 2005</xref>). Thus, the hybrid algorithm addresses the issues of late conflict detection and thrashing like in BT (<xref ref-type="bibr" rid="bibr2-1063293X12457401">Barták, 1999</xref>). In FC-BJ, each variable <italic>var</italic> corresponds to a <italic>conflict set conf</italic> (<italic>var</italic>) that records all variables whose value in the current partial solution is the reason for discarding <italic>var</italic>’s values, namely, conflict variables of <italic>var</italic>. The conflict set guides BJ in a search process. It is noted that in the original FC algorithm, it is not necessary to check constraint consistency between past and current variables (<xref ref-type="bibr" rid="bibr2-1063293X12457401">Barták, 1999</xref>). However, in the extended DCSP system, variables are dynamically activated into DCSP in different search phases (<xref ref-type="bibr" rid="bibr12-1063293X12457401">Wang et al., 2011</xref>). So when a new active variable <italic>nv</italic> is checked, constraints between <italic>nv</italic> and instantiated variables that are activated in previous search phases will be missed. Hence, in our augmented FC-BJ algorithm, these constraints must first be checked; if <italic>nv</italic> is inconsistent with the current partial solution, the solving process backjumps to the conflict instantiated variable.</p>
<p>In a CSP solving process, variable ordering can significantly affect search efficiency (<xref ref-type="bibr" rid="bibr2-1063293X12457401">Barták, 1999</xref>; <xref ref-type="bibr" rid="bibr3-1063293X12457401">Barták, 2005</xref>). In the best case, a good variable ordering may lead to a backtrack-free search (<xref ref-type="bibr" rid="bibr2-1063293X12457401">Barták, 1999</xref>). In the extended DCSP system, as the set of active variables extends dynamically (i.e. <italic>V</italic><sup><italic>a</italic></sup> is not fixed), static variable ordering is not feasible. Here, we employ a dynamic variable ordering heuristic called “FF” (<xref ref-type="bibr" rid="bibr2-1063293X12457401">Barták, 1999</xref>) with the augmented FC-BJ algorithm. In a DCSP search process, FF selects a variable with the smallest current domain size as the current variable <italic>cv</italic>, as it seems that the variable with the fewest remaining values is most likely to fail. If there is more than one variable with the smallest domain size, the selection is performed according to the lexicographic ordering. Then FC-BJ is applied on the current variable.</p>
<p>In general, the solving process we design for the augmented FC-BJ-FF on the extended DCSP system embeds structural constraint handler and activation constraint handler into a classical CSP solving procedure, both of which are able to trigger the extension of the extended DCSP system. It can be viewed as a sequence of stable phases, each of which is a fixed classical CSP <italic>N</italic> consisting of only active variables and associated active constraints whose variables are all active. A new phase is generated by the activation of variables with subsequent introduction of new active constraints. In each stable phase, FC-BJ-FF performs on <italic>N</italic>. If a consistent partial solution to <italic>N</italic> is reached without new variables activated, the partial solution is a final solution. Otherwise, DCSP continues with a new phase. The main loop of the augmented FC-BJ-FF is illustrated in <xref ref-type="fig" rid="fig1-1063293X12457401">Figure 1</xref>; the main steps are described as follows:</p>
<fig id="fig1-1063293X12457401" position="float">
<label>Figure 1.</label>
<caption>
<p>Flowchart for the augmented FC-BJ-FF solving process.</p>
<p>(FC-BJ-FF: forward checking and backjumping with fail-first heuristic).</p>
</caption>
<graphic xlink:href="10.1177_1063293X12457401-fig1.tif"/>
</fig>
<list id="list1-1063293X12457401" list-type="bullet">
<list-item>
<p>The solving process starts from an initial DCSP <italic>N</italic> = <inline-formula id="inline-formula9-1063293X12457401"><mml:math display="inline" id="math9-1063293X12457401"><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>I</mml:mi></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>I</mml:mi></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>I</mml:mi></mml:mrow></mml:msup><mml:mo>〉</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</p>
</list-item>
<list-item>
<p><italic>Step 1</italic>. In the structural constraint <italic>C</italic><sub><italic>s</italic></sub> handling phase, when a module variable <italic>m</italic> is chosen and activated into <italic>N</italic>, all its direct common child module variables are activated into <italic>N</italic>. According to specific requirements, some or all differentiation child modules of <italic>m</italic> are also activated into <italic>N</italic>. Component variables in the domain of each new active module variable are also added to <italic>N</italic>.</p>
</list-item>
<list-item>
<p><italic>Step 2</italic>. Using activation constraints <italic>C</italic><sub><italic>a</italic></sub>, an appropriate set of property variables associated with the new active modules in Step 1 are activated into <italic>N</italic>. Subsequently, active constraints whose variables are all active are also introduced into <italic>N</italic>. By now, a new fixed classical CSP <italic>N</italic> (i.e., a new stable phase) is generated. Initially, the conflict set of each active variable <italic>conf(v)</italic> is empty.</p>
</list-item>
<list-item>
<p><italic>Step 3</italic>. An unassigned active variable with the minimum domain size is chosen as current variable <italic>cv</italic> for checking (FF). If there are more than one variable with the same domain, then the selection is based on the lexicographic ordering.</p>
</list-item>
<list-item>
<p><italic>Step 4</italic>. Assuming that such an unassigned variable exists, if there are constraints between <italic>cv</italic> and instantiated variables <italic>pv</italic> in the current partial solution <italic>sol</italic>, these constraints must first be checked. If <italic>cv</italic>’s domain becomes empty, it means that <italic>cv</italic> is inconsistent with <italic>sol</italic>. The solving process backjumps to <italic>pv</italic>. Then the solving process jumps to Step 6, where <italic>cv</italic> refers to <italic>pv</italic> in Step 4 and <italic>fv</italic> refers to <italic>cv</italic> in Step 4.</p>
</list-item>
<list-item>
<p><italic>Step 5</italic>. A value <italic>val</italic> is assigned to <italic>cv</italic>, and assignment <inline-formula id="inline-formula10-1063293X12457401"><mml:math display="inline" id="math10-1063293X12457401"><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mi>cv</mml:mi><mml:mo>,</mml:mo><mml:mi>val</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> appends to <italic>sol</italic>.</p>
</list-item>
<list-item>
<p><italic>Step 6</italic>. FC is performed between <italic>cv</italic> and its direct future variables <italic>fv</italic>. Values of <italic>fv</italic>, which are incompatible with the assignment <inline-formula id="inline-formula11-1063293X12457401"><mml:math display="inline" id="math11-1063293X12457401"><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mi>cv</mml:mi><mml:mo>,</mml:mo><mml:mi>val</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, are (temporarily) deleted from <italic>fv</italic>’s current domain. In addition, <italic>cv</italic> is added into the conflict set of <italic>fv</italic>, that is, <italic>conf(fv)</italic><inline-formula id="inline-formula12-1063293X12457401"><mml:math display="inline" id="math12-1063293X12457401"><mml:mrow><mml:mo>∪</mml:mo></mml:mrow></mml:math></inline-formula> {<italic>cv</italic>}.</p>
</list-item>
<list-item>
<p><italic>Step 7</italic>. Whenever <italic>fv</italic>’s domain becomes empty, FC-BJ backtracks to the last conflict variable in <italic>conf(fv)</italic>, that is, <italic>cv</italic>. The solving process discards previous assignment <inline-formula id="inline-formula13-1063293X12457401"><mml:math display="inline" id="math13-1063293X12457401"><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mi>cv</mml:mi><mml:mo>,</mml:mo><mml:mi>val</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, reassigns <italic>cv</italic>, and updates <italic>conf(cv)</italic> to <italic>conf(cv)</italic><inline-formula id="inline-formula14-1063293X12457401"><mml:math display="inline" id="math14-1063293X12457401"><mml:mrow><mml:mo>∪</mml:mo></mml:mrow></mml:math></inline-formula><italic>conf(fv)</italic>\{<italic>cv</italic>} (<xref ref-type="bibr" rid="bibr10-1063293X12457401">Razgon, 2005</xref>). <italic>fv</italic>’s values removed by the assignment <inline-formula id="inline-formula15-1063293X12457401"><mml:math display="inline" id="math15-1063293X12457401"><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mi>cv</mml:mi><mml:mo>,</mml:mo><mml:mi>val</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> are all restored, and <italic>cv</italic> is removed from <italic>conf(fv)</italic>. Similarly, when <italic>cv</italic>’s domain becomes empty, FC-BJ backjumps to the last conflict variable <italic>pv</italic> in <italic>conf(cv)</italic>, reassigns <italic>pv</italic>, and updates <italic>conf(pv)</italic> to <italic>conf(pv)</italic><inline-formula id="inline-formula16-1063293X12457401"><mml:math display="inline" id="math16-1063293X12457401"><mml:mrow><mml:mo>∪</mml:mo></mml:mrow></mml:math></inline-formula><italic>conf(cv)</italic>\{<italic>pv</italic>}. Moreover, all assignments of variables that were performed between <italic>pv</italic> and <italic>cv</italic> are removed from <italic>sol</italic>. The values removed by these assignments are all restored, and these variables are removed from the corresponding conflict sets. If FC-BJ is implemented backward to each conflict variable and a consistent partial solution is still not found, there is no solution to the DCSP, and the solving process terminates.</p>
</list-item>
<list-item>
<p>Steps 4–7, referring to a FC-BJ searching procedure, iterate to assign a value to each active variable in <italic>N</italic>.</p>
</list-item>
<list-item>
<p><italic>Step 8</italic>. In Step 4, if no unassigned variable exists, that is, the current partial solution <italic>sol</italic> to all active variables is consistent, the solving process returns to Step 1. New child module variables of an existing module variable in <italic>N</italic> are added into <italic>N</italic> for a new searching phase, together with corresponding property variables and related active constraints. The solving process proposed above repeats.</p>
</list-item>
<list-item>
<p><italic>Step 9</italic>. If no new child module variable is added into <italic>N</italic>, the solving process ends, and <italic>sol</italic> is a final solution to the DCSP.</p>
</list-item>
</list>
<p>As FC checks the consistency between the current variable and future variables, it is able to detect inconsistency and thus prunes branches of the search tree at a relatively early time (<xref ref-type="bibr" rid="bibr2-1063293X12457401">Barták, 1999</xref>), and hopefully, reduces the overall amount of search. Furthermore, after FC, as remaining values of each future variable are consistent with the current partial solution, its size can be computed without any additional constraint checks (<xref ref-type="bibr" rid="bibr1-1063293X12457401">Bacchus and Grove, 1995</xref>). Thus, FF can be performed conveniently. In addition, BJ backtracks to conflicting variables directly and hence addresses the issue of thrashing (<xref ref-type="bibr" rid="bibr3-1063293X12457401">Barták 2005</xref>). However, BJ has to perform redundant work, as it does not remember conflicting values of variables for detecting the same conflict in a subsequent computation (<xref ref-type="bibr" rid="bibr3-1063293X12457401">Barták 2005</xref>). It also seems that FC may result in redundant checks, as it checks against future variables that may never be assigned (<xref ref-type="bibr" rid="bibr1-1063293X12457401">Bacchus and Grove, 1995</xref>). For example, after assigning <italic>v</italic><sub><italic>1</italic></sub>, FC against <italic>v</italic><sub><italic>5</italic></sub> is a wasted work if a search process terminates because <italic>v</italic><sub><italic>3</italic></sub> and <italic>v</italic><sub><italic>4</italic></sub> are incompatible with each other. Moreover, in the extended DCSP system, as variables are activated into different DCSP search phases incrementally, checking constraints between new active variables and instantiated variables may lead to BJ and thus more work. Hence, in the extended DCSP system, the augmented FC-BJ-FF algorithm is more suitable for the problem where there are few constraints between variables activated in different phases of the search process.</p>
</sec>
<sec id="section6-1063293X12457401">
<title>A hybrid heuristic for the extended DCSP-based configuration system</title>
<p>As mentioned in the last section, the augmented FC-BJ-FF may lead to a lot of BT when there are many constraints between variables activated in different search phases, which decreases search efficiency. To handle this condition, in this section, we propose a hybrid heuristic combining an amended most-constrained heuristic and FF heuristic, and integrate it with the augmented FC-BJ algorithm that is proposed in the last section for the extended DCSP system.</p>
<p>Compared with the general most-constrained heuristic that selects a variable involved with the largest number of constraints with <italic>unassigned</italic> variables (<xref ref-type="bibr" rid="bibr3-1063293X12457401">Barták 2005</xref>), the amended most-constrained heuristic adds module variables into the extended DCSP system and selects a current variable to assign, both of which are involved with the largest number of constraints on <italic>assigned</italic> variables activated in previous search phases. If there is no constraint between the current variable and assigned variables, FF heuristic is employed. The rationale is that in the extended DCSP system, variables are activated into DCSP incrementally. In general FC, constraint consistency check is only performed between the current variable and its direct future variables. When variables are activated, constraint consistency checks between new activated variables and assigned variables are missed in previous search phases, and must be performed first (i.e. complementary FC). Conflicts occurring in complementary FC may lead to a lot of BT. In the worst case, it may backtrack to the entire current partial solution. Thus, selecting the variable with the largest number of constraints on assigned variables is able to detect conflicts as early as possible, and thus, shortens the possible BT process.</p>
<p>Moreover, in the extended DCSP system, the activation of module variables is triggered according to PFA. A set of child module variables of an assigned module variables is activated into DCSP to form a new search phase step by step. When inactive module variables are to be activated, the amended most-constrained heuristic activates the set of child modules of an assigned module that has the largest total number of constraints on assigned variables instead of a single variable. In this set, the total number of constraints between each child module and assigned variables is the largest. Note that here we only consider active generic constraints <italic>C</italic><sub><italic>g</italic></sub>; we exclude structural constraints <italic>C</italic><sub><italic>s</italic></sub> and activation constraints <italic>C</italic><sub><italic>a</italic></sub>.</p>
<p>The reason to activate a set of child modules with the largest sum of constraints instead of a child module with the largest number of constraints on assigned variables together with its sibling modules can be explained as follows: First, in a stable search phase of the extended DCSP system, more constraints between new active variables and assigned variables are more likely to lead to more steps of BT in the augmented FC-BJ algorithm. Second, in each step, the extended DCSP system activates a set of child modules according to PFA. However, even if a child module is involved in the largest number of constraints on assigned variables, it does not mean that the total number of constraints between it and its sibling module variables and assigned variables is the largest.</p>
<p>The hybrid heuristic integrating with FC-BJ algorithm proposed in the last section is revised as follows:</p>
<list id="list2-1063293X12457401" list-type="bullet">
<list-item>
<p>The solving process starts from an initial DCSP <inline-formula id="inline-formula17-1063293X12457401"><mml:math display="inline" id="math17-1063293X12457401"><mml:mrow><mml:mi>N</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>I</mml:mi></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>I</mml:mi></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>I</mml:mi></mml:mrow></mml:msup><mml:mo>〉</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</p>
</list-item>
<list-item>
<p>Step 1: In the structural constraint <italic>C</italic><sub><italic>s</italic></sub> handling phase, when new variables are to be activated, a set of child modules of an assigned module will be activated into <italic>V</italic><sup><italic>a</italic></sup> based on the hybrid heuristic as follows:</p>
<list id="list3-1063293X12457401" list-type="bullet">
<list-item><p>For each assigned module variable <italic>m</italic>, we decide which child module variables will be activated, including all of <italic>m</italic>’s direct common child modules, and some of its differentiation child modules according to specific requirements.</p></list-item>
<list-item><p>Count the number of generic constraints <italic>C</italic><sub><italic>g</italic></sub> between each qualified child modules and all assigned variables <italic>pv</italic>s in the current partial solution. Note that here only <italic>C</italic><sub><italic>g</italic></sub> is considered, except structural constraints <italic>C</italic><sub><italic>s</italic></sub> and activation constraints <italic>C</italic><sub><italic>a</italic></sub> that are not checked in the searching process.</p></list-item>
<list-item><p>The set of child modules that have the largest total number of constraints on <italic>pv</italic>s are activated into <italic>N</italic>.</p></list-item>
<list-item><p>If there is no constraint, activation of new child modules follows the order of the last activation phase. That is, the child modules of the first activated module in the last phase are activated first.</p></list-item>
<list-item><p>Component variables in the domain of each new active module variable are also added to <italic>N</italic>.</p></list-item></list>
</list-item>
<list-item>
<p>Step 2: Using activation constraints <italic>C</italic><sub><italic>a</italic></sub>, a set of property variables associated with the new active module variables in Step 1 is activated into <italic>N</italic>. Subsequently, <italic>C</italic><sub><italic>g</italic></sub> whose variables are all activated is also introduced into <italic>N</italic>. By now, a new fixed classical CSP, that is, a new stable phase, is generated. Initially, the conflict set of each active variable <italic>conf(v)</italic> is empty.</p>
</list-item>
<list-item>
<p>Step 3: An unassigned variable is chosen as current variable <italic>cv</italic> for checking according to the hybrid heuristic that is described as follows:</p>
<list id="list4-1063293X12457401" list-type="bullet">
<list-item><p>Unassigned variables <italic>nv</italic>s that are involved in constraints on <italic>pv</italic>s are selected in a descending order in terms of the number of constraints involved; that is, the variable <italic>nv</italic> involved in the largest number of constraints on <italic>pv</italic>s is selected as <italic>cv</italic> first, and the least the latest.</p></list-item>
<list-item><p>If there is more than one <italic>nv</italic> with the same number of constraints on <italic>pv</italic>s, including when there is no constraint, then the variable ordering follows the rule of FF heuristic. This is, the variable within them with the minimum domain size is selected, or the variable is selected according to the lexicographic ordering if there is more than one variable with the same domain size.</p></list-item></list>
</list-item>
<list-item>
<p>The process that is the same as Steps 4–9 in the procedure of the augmented FC-BJ-FF algorithm proposed in the last section is performed to check back the consistency between <italic>cv</italic> and instantiated variables, and apply FC-BJ on <italic>cv</italic> and its direct future variables for final solutions.</p>
</list-item>
</list>
</sec>
</sec>
<sec id="section7-1063293X12457401">
<title>Experiments</title>
<p>Implementing the proposed two algorithms (i.e. the augmented FC-BJ with FF heuristic, and with the hybrid heuristic), we employ the extended DCSP-based system on a desktop computer configuration task (“the extended DCSP PC system” for short) that includes 16 modules, among which 4 modules (<italic>mFloppy, mGraphCd, mWebcam</italic>, and <italic>mSpeaker</italic>) are optional and the other 12 are mandatory (see <xref ref-type="table" rid="table1-1063293X12457401">Table 1</xref>).</p>
<table-wrap id="table1-1063293X12457401" position="float">
<label>Table 1.</label>
<caption>
<p>FC-BJ-FF searching process for a case of the extended DCSP PC system</p>
</caption>
<graphic alternate-form-of="table1-1063293X12457401" xlink:href="10.1177_1063293X12457401-table1.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="left"/>
<col align="left"/>
<col align="left"/>
<col align="left"/>
<col align="left"/>
<col align="left"/>
<col align="left"/>
<col align="left"/>
<col align="left"/>
</colgroup>
<thead>
<tr>
<th align="left">Step</th>
<th align="left">Current variable <italic>cv</italic></th>
<th align="left">Current domain</th>
<th align="left"><italic>conf(cv)</italic></th>
<th align="left">Unary constraints</th>
<th align="left">Current domain</th>
<th align="left">Other constraints</th>
<th align="left">Selected components</th>
<th align="left">Constraints in FC/checkback</th>
<th align="left">Added to <italic>conf(cv)</italic></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><italic>mPC</italic></td>
<td><italic>cFinalPC</italic></td>
<td/>
<td><italic>CR</italic><sub><italic>13</italic></sub></td>
<td><italic>cFinalPC</italic></td>
<td><italic>CC</italic><sub><italic>1</italic></sub></td>
<td><bold><italic>cFinalPC</italic></bold></td>
<td/>
<td/>
</tr>
<tr>
<td>2</td>
<td><italic>mAccess</italic></td>
<td><italic>cFinalAcs</italic></td>
<td/>
<td/>
<td><italic>cFinalAcs</italic></td>
<td><italic>CC</italic><sub><italic>4</italic></sub></td>
<td><bold><italic>cFinalAcs</italic></bold></td>
<td/>
<td/>
</tr>
<tr>
<td>3</td>
<td><italic>mMainfrm</italic></td>
<td><italic>cFinalMF</italic></td>
<td/>
<td/>
<td><italic>cFinalMF</italic></td>
<td><italic>CC</italic><sub><italic>3</italic></sub>, <italic>CP</italic><sub><italic>3</italic></sub></td>
<td><bold><italic>cFinalMF</italic></bold></td>
<td/>
<td/>
</tr>
<tr>
<td>4</td>
<td><italic>mMonitor</italic></td>
<td><italic>cM</italic><sub><italic>1</italic></sub><italic>–cM</italic><sub><italic>8</italic></sub></td>
<td/>
<td><italic>CR</italic><sub><italic>1</italic></sub>, <italic>CR</italic><sub><italic>2</italic></sub></td>
<td><italic>cM</italic><sub><italic>3</italic></sub>, <italic>cM</italic><sub><italic>8</italic></sub></td>
<td><italic>CC</italic><sub><italic>2</italic></sub>, <italic>CP</italic><sub><italic>6</italic></sub></td>
<td><italic>cM</italic><sub><italic>3</italic></sub></td>
<td/>
<td/>
</tr>
<tr>
<td>5</td>
<td><italic>Checkback</italic></td>
<td><italic>cMS</italic><sub><italic>1</italic></sub><italic>–cMS</italic><sub><italic>9</italic></sub></td>
<td><italic>mMonitor</italic></td>
<td/>
<td><italic>cMS</italic><sub><italic>3</italic></sub>, <italic>cMS</italic><sub><italic>6</italic></sub></td>
<td/>
<td/>
<td><italic>CE</italic><sub><italic>12</italic></sub></td>
<td/>
</tr>
<tr>
<td/>
<td><italic>mMouse</italic></td>
<td><italic>cMS</italic><sub><italic>3</italic></sub>, <italic>cMS</italic><sub><italic>6</italic></sub></td>
<td><italic>mMonitor</italic></td>
<td><italic>CR</italic><sub><italic>17</italic></sub>, <italic>CR</italic><sub><italic>18</italic></sub></td>
<td><italic>cMS</italic><sub><italic>6</italic></sub></td>
<td><italic>CC</italic><sub><italic>14</italic></sub>, <italic>CP</italic><sub><italic>6</italic></sub></td>
<td><italic>cMS</italic><sub>6</sub></td>
<td><italic>CE</italic><sub><italic>9</italic></sub>, <italic>CM</italic><sub><italic>2</italic></sub>, <italic>CM</italic><sub><italic>3</italic></sub></td>
<td><italic>mKeyBd</italic></td>
</tr>
<tr>
<td>6</td>
<td><italic>checkback</italic></td>
<td><italic>cKB</italic><sub><italic>1</italic></sub>, <italic>cKB</italic><sub><italic>7</italic></sub></td>
<td><italic>mMouse</italic></td>
<td/>
<td><italic>cKB</italic><sub><italic>1</italic></sub>, <italic>cKB</italic><sub><italic>7</italic></sub></td>
<td/>
<td/>
<td><italic>CE</italic><sub><italic>13</italic></sub></td>
<td/>
</tr>
<tr>
<td/>
<td><italic>mKeyBd</italic></td>
<td><italic>cKB</italic><sub><italic>1</italic></sub>, <italic>cKB</italic><sub><italic>7</italic></sub></td>
<td><italic>mMouse</italic></td>
<td><italic>CR</italic><sub><italic>19</italic></sub></td>
<td><italic>cKB</italic><sub><italic>7</italic></sub></td>
<td><italic>CC</italic><sub><italic>15</italic></sub>, <italic>CP</italic><sub><italic>6</italic></sub></td>
<td><italic>cKB</italic><sub>7</sub></td>
<td/>
<td/>
</tr>
<tr>
<td>7</td>
<td><italic>checkback</italic></td>
<td><italic>cSP</italic><sub><italic>1</italic></sub><italic>–cSP</italic><sub><italic>11</italic></sub></td>
<td><italic>mMonitor</italic></td>
<td/>
<td><italic>cSP</italic><sub><italic>3</italic></sub>, <italic>cSP</italic><sub><italic>9</italic></sub></td>
<td/>
<td/>
<td><italic>CE</italic><sub><italic>14</italic></sub></td>
<td/>
</tr>
<tr>
<td/>
<td><italic>mSpeaker</italic></td>
<td><italic>cSP</italic><sub><italic>3</italic></sub>, <italic>cSP</italic><sub><italic>9</italic></sub></td>
<td><italic>mMonitor</italic></td>
<td><italic>CR</italic><sub><italic>22</italic></sub>, <italic>CR</italic><sub><italic>23</italic></sub></td>
<td><italic>cSP</italic><sub><italic>3</italic></sub>, <italic>cSP</italic><sub><italic>9</italic></sub></td>
<td><italic>CC</italic><sub><italic>17</italic></sub>, <italic>CP</italic><sub><italic>5</italic></sub></td>
<td><italic>cSP</italic><sub>3</sub></td>
<td/>
<td/>
</tr>
<tr>
<td>8</td>
<td><italic>checkback</italic></td>
<td><italic>cWC</italic><sub><italic>1</italic></sub><italic>–cWC</italic><sub><italic>11</italic></sub></td>
<td><italic>mMonitor</italic></td>
<td/>
<td><italic>cWC</italic><sub><italic>4</italic></sub><italic>–cWC</italic><sub><italic>6</italic></sub></td>
<td/>
<td/>
<td><italic>CE</italic><sub><italic>10</italic></sub>, <italic>CE</italic><sub><italic>11</italic></sub></td>
<td/>
</tr>
<tr>
<td/>
<td><italic>mWebcam</italic></td>
<td><italic>cWC</italic><sub><italic>4</italic></sub><italic>–cWC</italic><sub><italic>6</italic></sub></td>
<td><italic>mMonitor</italic></td>
<td><italic>CR</italic><sub><italic>20</italic></sub>, <italic>CR</italic><sub><italic>21</italic></sub></td>
<td>{}</td>
<td/>
<td><bold><italic>BJ</italic></bold></td>
<td/>
<td/>
</tr>
<tr>
<td>9</td>
<td><italic>mMonitor</italic></td>
<td><italic>cM</italic><sub><italic>8</italic></sub></td>
<td/>
<td/>
<td/>
<td/>
<td><bold><italic>cM</italic><sub>8</sub></bold></td>
<td/>
<td/>
</tr>
<tr>
<td>10</td>
<td><italic>checkback</italic></td>
<td><italic>cMS</italic><sub><italic>1</italic></sub><italic>–cMS</italic><sub><italic>9</italic></sub></td>
<td><italic>mMonitor</italic></td>
<td/>
<td><italic>cMS</italic><sub><italic>2</italic></sub>, <italic>cMS</italic><sub><italic>3</italic></sub>, <italic>cMS</italic><sub><italic>6</italic></sub>, <italic>cMS</italic><sub><italic>8</italic></sub></td>
<td/>
<td/>
<td><italic>CE</italic><sub><italic>12</italic></sub></td>
<td/>
</tr>
<tr>
<td/>
<td><italic>mMouse</italic></td>
<td><italic>cMS</italic><sub><italic>2</italic></sub>, <italic>cMS</italic><sub><italic>3</italic></sub>, <italic>cMS</italic><sub><italic>6</italic></sub>, <italic>cMS</italic><sub><italic>8</italic></sub></td>
<td><italic>mMonitor</italic></td>
<td><italic>CR</italic><sub><italic>17</italic></sub>, <italic>CR</italic><sub><italic>18</italic></sub></td>
<td><italic>cMS</italic><sub><italic>2</italic></sub>, <italic>cMS</italic><sub><italic>6</italic></sub></td>
<td><italic>CC</italic><sub><italic>14</italic></sub>, <italic>CP</italic><sub><italic>6</italic></sub></td>
<td><bold><italic>cMS</italic><sub><italic>2</italic></sub></bold></td>
<td><italic>CE</italic><sub><italic>9</italic></sub>, <italic>CM</italic><sub><italic>2</italic></sub>, <italic>CM</italic><sub><italic>3</italic></sub></td>
<td><italic>mKeyBd</italic></td>
</tr>
<tr>
<td>11</td>
<td><italic>checkback</italic></td>
<td><italic>cKB</italic><sub><italic>5</italic></sub></td>
<td><italic>mMouse</italic></td>
<td/>
<td><italic>cKB</italic><sub><italic>5</italic></sub></td>
<td/>
<td/>
<td><italic>CE</italic><sub><italic>13</italic></sub></td>
<td/>
</tr>
<tr>
<td/>
<td><italic>mKeyBd</italic></td>
<td><italic>cKB</italic><sub><italic>5</italic></sub></td>
<td><italic>mMouse</italic></td>
<td><italic>CR</italic><sub><italic>19</italic></sub></td>
<td><italic>cKB</italic><sub><italic>5</italic></sub></td>
<td><italic>CC</italic><sub><italic>15</italic></sub>, <italic>CP</italic><sub><italic>6</italic></sub></td>
<td><bold><italic>cKB<sub>5</sub></italic></bold></td>
<td/>
<td/>
</tr>
<tr>
<td>12</td>
<td><italic>checkback</italic></td>
<td><italic>cSP</italic><sub><italic>1</italic></sub><italic>–cSP</italic><sub><italic>10</italic></sub></td>
<td><italic>mMonitor</italic></td>
<td/>
<td><italic>cSP</italic><sub><italic>1</italic></sub>, <italic>cSP</italic><sub><italic>6</italic></sub>, <italic>cSP</italic><sub><italic>9</italic></sub>, <italic>cSP</italic><sub><italic>10</italic></sub></td>
<td/>
<td/>
<td><italic>CE</italic><sub><italic>14</italic></sub></td>
<td/>
</tr>
<tr>
<td/>
<td><italic>mSpeaker</italic></td>
<td><italic>cSP</italic><sub><italic>1</italic></sub>, <italic>cSP</italic><sub><italic>6</italic></sub>, <italic>cSP</italic><sub><italic>9</italic></sub>, <italic>cSP</italic><sub><italic>10</italic></sub></td>
<td><italic>mMonitor</italic></td>
<td><italic>CR</italic><sub><italic>22</italic></sub>, <italic>CR</italic><sub><italic>23</italic></sub></td>
<td><italic>cSP</italic><sub><italic>6</italic></sub>, <italic>cSP</italic><sub><italic>9</italic></sub>, <italic>cSP</italic><sub><italic>10</italic></sub></td>
<td><italic>CC</italic><sub><italic>17</italic></sub>, <italic>CP</italic><sub><italic>5</italic></sub></td>
<td><bold><italic>cSP<sub>9</sub></italic></bold></td>
<td/>
<td/>
</tr>
<tr>
<td>13</td>
<td><italic>checkback</italic></td>
<td><italic>cWC</italic><sub><italic>1</italic></sub><italic>–cWC</italic><sub><italic>11</italic></sub></td>
<td><italic>mMonitor</italic></td>
<td/>
<td><italic>cWC</italic><sub><italic>2</italic></sub><italic>–cWC</italic><sub><italic>4</italic></sub></td>
<td/>
<td/>
<td><italic>CE</italic><sub><italic>10</italic></sub>, <italic>CE</italic><sub><italic>11</italic></sub></td>
<td/>
</tr>
<tr>
<td/>
<td><italic>mWebcam</italic></td>
<td><italic>cWC</italic><sub><italic>2</italic></sub><italic>–cWC</italic><sub><italic>4</italic></sub></td>
<td><italic>mMonitor</italic></td>
<td><italic>CR</italic><sub><italic>20</italic></sub>, <italic>CR</italic><sub><italic>21</italic></sub></td>
<td><italic>cWC</italic><sub><italic>2</italic></sub>, <italic>cWC</italic><sub><italic>3</italic></sub></td>
<td><italic>CC</italic><sub><italic>16</italic></sub>, <italic>CP</italic><sub><italic>4</italic></sub></td>
<td><bold><italic>cWC<sub><italic>2</italic></sub></italic></bold></td>
<td/>
<td/>
</tr>
<tr>
<td>14</td>
<td><italic>mChassis</italic></td>
<td><italic>cCH</italic><sub><italic>8</italic></sub></td>
<td><italic>mMonitor</italic></td>
<td><italic>CR</italic><sub><italic>4</italic></sub>, <italic>CR</italic><sub><italic>5</italic></sub></td>
<td><italic>cCH</italic><sub><italic>8</italic></sub></td>
<td><italic>CC</italic><sub><italic>5</italic></sub>, <italic>CP</italic><sub><italic>6</italic></sub></td>
<td><bold><italic>cCH<sub>8</sub></italic></bold></td>
<td><italic>CE</italic><sub><italic>1</italic></sub>, <italic>CM</italic><sub><italic>13</italic></sub></td>
<td><italic>mMainBd</italic></td>
</tr>
<tr>
<td>15</td>
<td><italic>mGraphCd</italic></td>
<td><italic>cGc</italic><sub><italic>1</italic></sub><italic>–cGc</italic><sub><italic>3</italic></sub></td>
<td/>
<td><italic>CR</italic><sub><italic>14</italic></sub></td>
<td><italic>cGC</italic><sub><italic>1</italic></sub>, <italic>cGC</italic><sub><italic>2</italic></sub></td>
<td><italic>CC</italic><sub><italic>12</italic></sub>, <italic>CP</italic><sub><italic>6</italic></sub></td>
<td><bold><italic>cGC<sub>1</sub></italic></bold></td>
<td><italic>CE</italic><sub><italic>8</italic></sub></td>
<td><italic>mMainBd</italic></td>
</tr>
<tr>
<td>16</td>
<td><italic>mDVD</italic></td>
<td><italic>cDV</italic><sub><italic>1</italic></sub><italic>–cDV</italic><sub><italic>4</italic></sub></td>
<td/>
<td><italic>CR</italic><sub><italic>15</italic></sub>, <italic>CR</italic><sub><italic>16</italic></sub></td>
<td><italic>cDV</italic><sub><italic>3</italic></sub></td>
<td><italic>CC</italic><sub><italic>11</italic></sub>, <italic>CP</italic><sub><italic>6</italic></sub></td>
<td><bold><italic>cDV</italic><sub><italic>3</italic></sub></bold></td>
<td/>
<td/>
</tr>
<tr>
<td>17</td>
<td><italic>mMainBd</italic></td>
<td><italic>cMB</italic><sub><italic>2</italic></sub>, <italic>cMB</italic><sub><italic>5</italic></sub><italic>–cMB</italic><sub><italic>7</italic></sub></td>
<td><italic>mChassis, mGraphCd</italic></td>
<td><italic>CR</italic><sub><italic>6</italic></sub>, <italic>CR</italic><sub><italic>7</italic></sub></td>
<td><italic>cMB</italic><sub><italic>2</italic></sub></td>
<td><italic>CC</italic><sub><italic>6</italic></sub>, <italic>CP</italic><sub><italic>6</italic></sub></td>
<td><italic>cMB</italic><sub><italic>2</italic></sub><italic>/</italic><bold><italic>BJ</italic></bold></td>
<td><italic>CE</italic><sub><italic>2</italic></sub><italic>–CE</italic><sub><italic>5</italic></sub>, <italic>CE</italic><sub><italic>7</italic></sub>, <italic>CM</italic><sub><italic>7</italic></sub></td>
<td><italic>mCPU</italic>, <bold><italic>mMemory</italic></bold></td>
</tr>
<tr>
<td>18</td>
<td><italic>mMainBd</italic></td>
<td/>
<td><italic>mChassis, mGraphCd</italic></td>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
</tr>
<tr>
<td>19</td>
<td><italic>mGraphCd</italic></td>
<td><italic>cGc</italic><sub><italic>2</italic></sub>, <italic>cGc</italic><sub><italic>3</italic></sub></td>
<td><italic>mChassis</italic></td>
<td><italic>CR</italic><sub><italic>14</italic></sub></td>
<td><italic>cGC</italic><sub><italic>2</italic></sub></td>
<td><italic>CC</italic><sub><italic>12</italic></sub>, <italic>CP</italic><sub><italic>6</italic></sub></td>
<td><bold><italic>cGC<sub>2</sub></italic></bold></td>
<td><italic>CE</italic><sub><italic>8</italic></sub></td>
<td><italic>mMainBd</italic></td>
</tr>
<tr>
<td>20</td>
<td><italic>mMainBd</italic></td>
<td><italic>cMB</italic><sub><italic>3</italic></sub>, <italic>cMB</italic><sub><italic>4</italic></sub></td>
<td><italic>mChassis, mGraphCd</italic></td>
<td><italic>CR</italic><sub><italic>6</italic></sub>, <italic>CR</italic><sub><italic>7</italic></sub></td>
<td><italic>cMB</italic><sub><italic>3</italic></sub>, <italic>cMB</italic><sub><italic>4</italic></sub></td>
<td><italic>CC</italic><sub><italic>6</italic></sub>, <italic>CP</italic><sub><italic>6</italic></sub></td>
<td><bold><italic>cMB<sub>3</sub></italic></bold></td>
<td><italic>CE</italic><sub><italic>2</italic></sub><italic>–CE</italic><sub><italic>5</italic></sub>, <italic>CE</italic><sub><italic>7</italic></sub>, <italic>CM</italic><sub><italic>7</italic></sub></td>
<td><italic>mCPU, mMemory</italic></td>
</tr>
<tr>
<td>21</td>
<td><italic>mCPU</italic></td>
<td><italic>cCPU<sub>2</sub>, cCPU<sub>3</sub></italic></td>
<td><italic>mMainBd</italic></td>
<td><italic>CR<sub>8</sub></italic></td>
<td><italic>cCPU</italic><sub><italic>2</italic></sub>, <italic>cCPU</italic><sub><italic>3</italic></sub></td>
<td><italic>CC</italic><sub><italic>7</italic></sub>, <italic>CP</italic><sub><italic>6</italic></sub></td>
<td><bold><italic>cCPU</italic><sub><italic>3</italic></sub></bold></td>
<td><italic>CE</italic><sub><italic>4</italic></sub></td>
<td/>
</tr>
<tr>
<td>22</td>
<td><italic>mMemory</italic></td>
<td><italic>cMM</italic><sub><italic>4</italic></sub><italic>–cMM</italic><sub><italic>6</italic></sub></td>
<td><italic>mMainBd</italic></td>
<td><italic>CE</italic><sub><italic>6</italic></sub>, <italic>CR</italic><sub><italic>9</italic></sub></td>
<td><italic>cMM</italic><sub><italic>6</italic></sub></td>
<td><italic>CC</italic><sub><italic>8</italic></sub>, <italic>CC</italic><sub><italic>9</italic></sub></td>
<td><bold><italic>cMM</italic><sub><italic>6</italic></sub></bold></td>
<td/>
<td/>
</tr>
<tr>
<td>23</td>
<td><italic>mDVD</italic></td>
<td><italic>cDV</italic><sub><italic>1</italic></sub><italic>–cDV</italic><sub><italic>4</italic></sub></td>
<td/>
<td><italic>CR</italic><sub><italic>15</italic></sub>, <italic>CR</italic><sub><italic>16</italic></sub></td>
<td><italic>cDV</italic><sub><italic>3</italic></sub></td>
<td><italic>CC</italic><sub><italic>11</italic></sub>, <italic>CP</italic><sub><italic>6</italic></sub></td>
<td><bold><italic>cDV</italic><sub><italic>3</italic></sub></bold></td>
<td/>
<td/>
</tr>
<tr>
<td>24</td>
<td><italic>mHardDk</italic></td>
<td><italic>cHD</italic><sub><italic>1</italic></sub><italic>–cHD</italic><sub><italic>10</italic></sub></td>
<td/>
<td><italic>CR</italic><sub><italic>11</italic></sub>, <italic>CR</italic><sub><italic>12</italic></sub></td>
<td><italic>cHD</italic><sub><italic>2</italic></sub></td>
<td><italic>CC</italic><sub><italic>10</italic></sub>, <italic>CP</italic><sub><italic>6</italic></sub></td>
<td><bold><italic>cHD<sub>2</sub></italic></bold></td>
<td/>
<td/>
</tr>
</tbody>
</table>
<table-wrap-foot>
<fn id="table-fn1-1063293X12457401">
<p>FC-BJ-FF: forward checking and backjumping with fail-first heuristic; DCSP: dynamic constraint satisfaction problem.</p>
</fn>
</table-wrap-foot>
</table-wrap>
<sec id="section8-1063293X12457401">
<title>DCSP-based PC configuration using the augmented FC-BJ-FF algorithm</title>
<p>To explain the solving process of the augmented FC-BJ-FF, we implement a specific case of the extended DCSP PC system including all 12 common modules and 3 differentiation modules (<italic>mGraphCd, mWebcam</italic>, and <italic>mSpeaker</italic>) required by customers. <xref ref-type="table" rid="table1-1063293X12457401">Table 1</xref> lists the steps of the solving process. Each step represents operations on current variable <italic>cv. cv</italic>’s current domain (Column 3) refers to its left values after FC performed by previous assigned variables. The conflict set <italic>conf(cv)</italic> (Column 4) involves conflicting variables of <italic>cv</italic> to which the solving process backjumps when <italic>cv</italic>’s domain becomes empty. Unary constraints on <italic>cv</italic> mainly generated from customers’ requirements are checked separately (Column 5) as they are defined on a singular variable, remove infeasible values, and thus directly prune the search space. The assignment for <italic>cv</italic> in each step is listed in column “Selected components”.</p>
<p>For each <italic>cv</italic>, the solving process first checks constraints on past variables activated in previous phases, and then, if there are still value(s) available, checks its direct future variables. In column “Constraints in FC/checkback”, constraints for backchecking (complementary FC) and FC are listed for different operations, respectively. If in backchecking, <italic>cv</italic>’s values are removed by an assignment of past variable <italic>pv</italic>, then <italic>pv</italic> is added into <italic>conf(cv)</italic> in Column 4. Similarly, in FC, <italic>cv</italic> is added to <italic>conf(x)</italic> in the last column, if it removes values of a future variable <italic>x</italic>. For example, in Step 5 of <xref ref-type="table" rid="table1-1063293X12457401">Table 1</xref>, as there is a constraint (<italic>CE</italic><sub><italic>12</italic></sub> in column “Constraints in FC/checkback”) between the current variable <italic>mMouse</italic> and a past variable <italic>mMonitor, CE</italic><sub><italic>12</italic></sub> must first be checked (first row in Step 5). After backchecking, <italic>mMonitor</italic> is added to <italic>conf(mMouse)</italic> as it removes some values of <italic>mMouse</italic>. If <italic>mMouse</italic>’s current domain (the 6th column) is not empty, then FC-BJ is performed (second row in Step 5). Constraints checked in FC are listed in column “Constraints in FC/checkback”. Otherwise, BJ occurs (e.g. in Step 8).</p>
<p>In the extended DCSP PC system, variables involved in the final solution are activated into the search space dynamically. New active module variables in each phase are separated by blank lines in <xref ref-type="table" rid="table1-1063293X12457401">Table 1</xref>. The corresponding components, property variables, and related constraints are also activated into DCSP. Specifically, in <xref ref-type="table" rid="table1-1063293X12457401">Table 1</xref>, initial DCSP only includes module <italic>mPC</italic> (Step 1), then its common child modules <italic>mAccess, mMainfrm</italic>, and <italic>mMonitor</italic> are introduced into DCSP by structural constraint <italic>CS</italic><sub><italic>1</italic></sub>, together with corresponding variables and constraints activated by activation constraints, and checked in Steps 2–4. Subsequently, child modules of <italic>mAccess</italic> and <italic>mMainfrm</italic> are activated in following phases, respectively. In each phase, the ordering of the new active variables for checking is based on fail-first heuristic.</p>
<p>In Step 17, <italic>mMainBd</italic> is selected as the current variable for its minimum domain size cut by FC of <italic>mChassis</italic> and <italic>mGraphCd</italic>, and these two variables are added into <italic>conf(mMainBd)</italic>. After the assignment <inline-formula id="inline-formula18-1063293X12457401"><mml:math display="inline" id="math18-1063293X12457401"><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mi>mMainBd</mml:mi><mml:mo>,</mml:mo><mml:mi>cM</mml:mi><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>〉</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, FC is performed on its future variables <italic>mMemory</italic> and <italic>mCPU</italic>, whose inconsistent values are discarded. Then <italic>mMainBd</italic> is added into <italic>conf(mMemory)</italic> and <italic>conf(mCPU)</italic>. However, the assignment results in an empty domain of <italic>mMemory</italic> (denoted by <bold><italic>conf(x)</italic></bold> in step 17). Hence, in Step 18, the solving process backjumps to <italic>mMainBd</italic> (the last conflict variable in <italic>conf(mMemory)</italic>), discards its last assignment <italic>cMB</italic><sub><italic>2</italic></sub>, removes <italic>mMainBd</italic> from <italic>conf(mMemory)</italic> and <italic>conf(mCPU)</italic>, and resets <italic>conf (mMainBd)</italic> as {<italic>mChassis, mGraphCd</italic>} (<italic>conf(mMainBd)</italic><inline-formula id="inline-formula19-1063293X12457401"><mml:math display="inline" id="math19-1063293X12457401"><mml:mrow><mml:mo>∪</mml:mo></mml:mrow></mml:math></inline-formula><italic>conf (mMemory)</italic>\{<italic>mMainBd</italic>}). Consequently, <italic>mMainBd</italic> is reassigned.</p>
<p>However, its current domain becomes empty after the removal of <italic>cMB</italic><sub><italic>2</italic></sub>, then the solving process backjumps to <italic>mGraphCd</italic>, the last conflict variable in <italic>conf(mMainBd)</italic>, instead of <italic>mDVD</italic>, the last assigned variable (Step 16). <italic>conf(mGraphCd)</italic> is reset as {<italic>mChassis</italic>} ({} <inline-formula id="inline-formula20-1063293X12457401"><mml:math display="inline" id="math20-1063293X12457401"><mml:mrow><mml:mo>∪</mml:mo></mml:mrow></mml:math></inline-formula><italic>conf(mMainBd)</italic>\<italic>{mGraphCd})</italic> in Step 19. Its last assignment <italic>cGC</italic><sub><italic>1</italic></sub> is discarded, and <italic>mGraphCd</italic> is removed from <italic>conf</italic>(<italic>mMainBd</italic>). The values of <italic>mMainBd</italic> removed by the assignment <inline-formula id="inline-formula21-1063293X12457401"><mml:math display="inline" id="math21-1063293X12457401"><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mi>mGraphCd</mml:mi><mml:mo>,</mml:mo><mml:mi>cG</mml:mi><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>〉</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> are also restored. Subsequently, <italic>mGraphCd</italic> is reassigned, and the solving process continues to reach final solution. In <xref ref-type="table" rid="table1-1063293X12457401">Table 1</xref>, the final solution is represented by a set of the selected component for each module, which is in bold in column “Selected components”.</p>
<p>We note that the variable ordering in the solving process is dynamic. For example, in <xref ref-type="table" rid="table1-1063293X12457401">Table 1</xref>, after the assignment of <italic>mGraphCd</italic> in Step 15, both <italic>mDVD</italic> and <italic>mMainBd</italic> have the same smallest domain size 4. Using lexicographical ordering, <italic>mDVD</italic> is assigned before <italic>mMainBd</italic>. However, when <italic>mGraphCd</italic> is reassigned in Step 19, the domain size of <italic>mMainBd</italic> becomes 2, which is smaller than <italic>mDVD</italic>. Then, it is selected to be assigned. After FC by <italic>mMainBd</italic>, the domain size of <italic>mCPU</italic> and <italic>mMemory</italic> is cut to 2 and 3, respectively. Hence, <italic>mDVD</italic>, which has four values in its domain, is assigned after <italic>mCPU</italic> and <italic>mMemory</italic>.</p>
</sec>
<sec id="section9-1063293X12457401">
<title>DCSP-based PC configuration using the augmented FC-BJ with the hybrid heuristic</title>
<p>To compare the solving efficiency of the two proposed algorithms, we compare the solving process of these two algorithms. <xref ref-type="table" rid="table2-1063293X12457401">Table 2</xref> lists a part of the solving process of FC-BJ with the hybrid heuristic on the same case as <xref ref-type="table" rid="table1-1063293X12457401">Table 1</xref>, which only includes module variables constrained with past variables. In <xref ref-type="table" rid="table2-1063293X12457401">Table 2</xref>, although the activation order of variables is the same as that in FC-BJ-FF (<xref ref-type="table" rid="table1-1063293X12457401">Table 1</xref>), the reason is different. After Step 4, where all variables in this search phase are assigned, the child modules of <italic>mAccess</italic> are activated before those of <italic>mMainfrm</italic> as they have the largest total number 8 of constraints on assigned variables (Steps 1–4). In FC-BJ-FF (<xref ref-type="table" rid="table1-1063293X12457401">Table 1</xref>), the activation order is based on the assignment order of their parent module variables, that is, <italic>mAccess</italic> is assigned earlier than <italic>mMainfrm</italic> according to lexicographical order as both of them have the smallest domain size.</p>
<table-wrap id="table2-1063293X12457401" position="float">
<label>Table 2.</label>
<caption>
<p>The searching process of FC-BJ-hybrid for a case of the extended DCSP PC system (partial)</p>
</caption>
<graphic alternate-form-of="table2-1063293X12457401" xlink:href="10.1177_1063293X12457401-table2.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="left"/>
<col align="left"/>
<col align="left"/>
<col align="left"/>
<col align="left"/>
<col align="left"/>
<col align="left"/>
<col align="left"/>
<col align="left"/>
</colgroup>
<thead>
<tr>
<th align="left">Step</th>
<th align="left">Current variable <italic>cv</italic></th>
<th align="left">Current domain</th>
<th align="left"><italic>conf(cv)</italic></th>
<th align="left">Unary constraint</th>
<th align="left">Current domain</th>
<th align="left">Other constraint</th>
<th align="left">Selected component</th>
<th align="left">Constraints in FC/checkback</th>
<th align="left">Added to <italic>conf(cv)</italic></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><italic>mPC</italic></td>
<td><italic>cFinalPC</italic></td>
<td/>
<td><italic>CR</italic><sub><italic>13</italic></sub></td>
<td><italic>cFinalPC</italic></td>
<td><italic>CC</italic><sub><italic>1</italic></sub></td>
<td><bold><italic>cFinalPC</italic></bold></td>
<td/>
<td/>
</tr>
<tr>
<td>2</td>
<td><italic>mAccess</italic></td>
<td><italic>cFinalAcs</italic></td>
<td/>
<td/>
<td><italic>cFinalAcs</italic></td>
<td><italic>CC</italic><sub><italic>4</italic></sub></td>
<td><bold><italic>cFinalAcs</italic></bold></td>
<td/>
<td/>
</tr>
<tr>
<td>3</td>
<td><italic>mMainfrm</italic></td>
<td><italic>cFinalMF</italic></td>
<td/>
<td/>
<td><italic>cFinalMF</italic></td>
<td><italic>CC</italic><sub><italic>3</italic></sub>, <italic>CP</italic><sub><italic>3</italic></sub></td>
<td><bold><italic>cFinalMF</italic></bold></td>
<td/>
<td/>
</tr>
<tr>
<td>4</td>
<td><italic>mMonitor</italic></td>
<td><italic>cM</italic><sub><italic>1</italic></sub><italic>–cM</italic><sub><italic>8</italic></sub></td>
<td/>
<td><italic>CR</italic><sub><italic>1</italic></sub>, <italic>CR</italic><sub><italic>2</italic></sub></td>
<td><italic>cM</italic><sub><italic>3</italic></sub>, <italic>cM</italic><sub><italic>8</italic></sub></td>
<td><italic>CC</italic><sub><italic>2</italic></sub>, <italic>CP</italic><sub><italic>6</italic></sub></td>
<td><italic>cM</italic><sub><italic>3</italic></sub></td>
<td/>
<td/>
</tr>
<tr>
<td>5</td>
<td><italic>checkback</italic></td>
<td><italic>cWC</italic><sub><italic>1</italic></sub><italic>–cWC</italic><sub><italic>11</italic></sub></td>
<td><italic>mMonitor</italic></td>
<td/>
<td><italic>cWC</italic><sub><italic>4</italic></sub><italic>-cWC</italic><sub><italic>6</italic></sub></td>
<td/>
<td/>
<td><italic>CE</italic><sub><italic>10</italic></sub>, <italic>CE</italic><sub><italic>11</italic></sub></td>
<td/>
</tr>
<tr>
<td/>
<td><italic>mWebcam</italic></td>
<td><italic>cWC</italic><sub><italic>4</italic></sub><italic>–cWC</italic><sub><italic>6</italic></sub></td>
<td><italic>mMonitor</italic></td>
<td><italic>CR</italic><sub><italic>20</italic></sub>, <italic>CR</italic><sub><italic>21</italic></sub></td>
<td>{}</td>
<td/>
<td><bold><italic>BJ</italic></bold></td>
<td/>
<td/>
</tr>
<tr>
<td>6</td>
<td><italic>mMonitor</italic></td>
<td><italic>cM</italic><sub><italic>8</italic></sub></td>
<td/>
<td/>
<td/>
<td/>
<td><bold><italic>cM</italic><sub><italic>8</italic></sub></bold></td>
<td/>
<td/>
</tr>
<tr>
<td>7</td>
<td><italic>checkback</italic></td>
<td><italic>cWC</italic><sub><italic>1</italic></sub><italic>–cWC</italic><sub><italic>11</italic></sub></td>
<td><italic>mMonitor</italic></td>
<td/>
<td><italic>cWC</italic><sub><italic>2</italic></sub><italic>-cWC</italic><sub><italic>4</italic></sub></td>
<td/>
<td/>
<td><italic>CE</italic><sub><italic>10</italic></sub>, <italic>CE</italic><sub><italic>11</italic></sub></td>
<td/>
</tr>
<tr>
<td/>
<td><italic>mWebcam</italic></td>
<td><italic>cWC</italic><sub><italic>2</italic></sub><italic>–cWC</italic><sub><italic>4</italic></sub></td>
<td><italic>mMonitor</italic></td>
<td><italic>CR</italic><sub><italic>20</italic></sub>, <italic>CR</italic><sub><italic>21</italic></sub></td>
<td><italic>cWC</italic><sub><italic>2</italic></sub>, <italic>cWC</italic><sub><italic>3</italic></sub></td>
<td><italic>CC</italic><sub><italic>16</italic></sub>, <italic>CP</italic><sub><italic>4</italic></sub></td>
<td><bold><italic>cWC</italic><sub><italic>2</italic></sub></bold></td>
<td/>
<td/>
</tr>
<tr>
<td>8</td>
<td><italic>checkback</italic></td>
<td><italic>cMS</italic><sub><italic>1</italic></sub><italic>–cMS</italic><sub><italic>9</italic></sub></td>
<td><italic>mMonitor</italic></td>
<td/>
<td><italic>cMS</italic><sub><italic>2</italic></sub>, <italic>cMS</italic><sub><italic>3</italic></sub>, <italic>cMS</italic><sub><italic>6</italic></sub>, <italic>cMS</italic><sub><italic>8</italic></sub></td>
<td/>
<td/>
<td><italic>CE</italic><sub><italic>12</italic></sub></td>
<td/>
</tr>
<tr>
<td/>
<td><italic>mMouse</italic></td>
<td><italic>cMS</italic><sub><italic>2</italic></sub>, <italic>cMS</italic><sub><italic>3</italic></sub>, <italic>cMS</italic><sub><italic>6</italic></sub>, <italic>cMS</italic><sub><italic>8</italic></sub></td>
<td><italic>mMonitor</italic></td>
<td><italic>CR</italic><sub><italic>17</italic></sub>, <italic>CR</italic><sub><italic>18</italic></sub></td>
<td><italic>cMS</italic><sub><italic>2</italic></sub>, <italic>cMS</italic><sub><italic>6</italic></sub></td>
<td><italic>CC</italic><sub><italic>14</italic></sub>, <italic>CP</italic><sub><italic>6</italic></sub></td>
<td><bold><italic>cMS</italic><sub><italic>2</italic></sub></bold></td>
<td><italic>CE</italic><sub><italic>9</italic></sub>, <italic>CM</italic><sub><italic>2</italic></sub>, <italic>CM</italic><sub><italic>3</italic></sub></td>
<td><italic>mKeyBd</italic></td>
</tr>
<tr>
<td>9</td>
<td><italic>checkback</italic></td>
<td><italic>cKB</italic><sub><italic>5</italic></sub></td>
<td><italic>mMouse</italic></td>
<td/>
<td><italic>cKB</italic><sub><italic>5</italic></sub></td>
<td/>
<td/>
<td><italic>CE</italic><sub><italic>13</italic></sub></td>
<td/>
</tr>
<tr>
<td/>
<td><italic>mKeyBd</italic></td>
<td><italic>cWC</italic><sub><italic>4</italic></sub><italic>-cWC</italic><sub><italic>6</italic></sub></td>
<td><italic>mMouse</italic></td>
<td><italic>CR</italic><sub><italic>19</italic></sub></td>
<td><italic>cKB</italic><sub><italic>5</italic></sub></td>
<td><italic>CC</italic><sub><italic>15</italic></sub>, <italic>CP</italic><sub><italic>6</italic></sub></td>
<td><bold><italic>cKB</italic></bold><sub><italic>5</italic></sub></td>
<td/>
<td/>
</tr>
<tr>
<td>10</td>
<td><italic>checkback</italic></td>
<td><italic>cSP</italic><sub><italic>1</italic></sub><italic>–cSP</italic><sub><italic>10</italic></sub></td>
<td><italic>mMonitor</italic></td>
<td/>
<td><italic>cSP</italic><sub><italic>1</italic></sub>, <italic>cSP</italic><sub><italic>6</italic></sub>,<italic>cSP</italic><sub><italic>9</italic></sub>, <italic>cSP</italic><sub><italic>10</italic></sub></td>
<td/>
<td/>
<td><italic>CE</italic><sub><italic>14</italic></sub></td>
<td/>
</tr>
<tr>
<td/>
<td><italic>mSpeaker</italic></td>
<td><italic>cSP</italic><sub><italic>1</italic></sub>, <italic>cSP</italic><sub><italic>6</italic></sub>, <italic>cSP</italic><sub><italic>9</italic></sub>, <italic>cSP</italic><sub><italic>10</italic></sub></td>
<td><italic>mMonitor</italic></td>
<td><italic>CR</italic><sub><italic>22</italic></sub>, <italic>R</italic><sub><italic>23</italic></sub></td>
<td><italic>cSP</italic><sub><italic>6</italic></sub>, <italic>cSP</italic><sub><italic>9</italic></sub>, <italic>cSP</italic><sub><italic>10</italic></sub></td>
<td><italic>CC</italic><sub><italic>17</italic></sub>, <italic>CP</italic><sub><italic>5</italic></sub></td>
<td><bold><italic>cSP</italic><sub><italic>9</italic></sub></bold></td>
<td/>
<td/>
</tr>
<tr>
<td>11</td>
<td>…</td>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
</tr>
</tbody>
</table>
<table-wrap-foot>
<fn id="table-fn2-1063293X12457401">
<p>FC-BJ-hybrid: forward checking and backjumping with the hybrid heuristic; DCSP: dynamic constraint; satisfaction problem.</p>
</fn>
</table-wrap-foot>
</table-wrap>
<p>In these two processes, the first four steps are the same, where after the activation of <italic>mAccess, mMainfrm</italic>, and <italic>mMonitor</italic>, as there are no constraints between them and the previous active variable <italic>mPC</italic>, the order of them for assignment is based on the FF heuristic. Subsequently, child modules of <italic>mAccess</italic> are activated into the DCSP, and the following variable order is different in these two algorithm solving processes.</p>
<p>Based on the FF heuristic, in <xref ref-type="table" rid="table1-1063293X12457401">Table 1</xref>, FC-BJ-FF assigned these new active variables according to their domain sizes, that is, <italic>mMouse, mKeyBd, mSpeaker</italic>, and <italic>mWebcam</italic> are assigned sequentially in Steps 5–8. However, after backchecking and unary constraint checking, <italic>mWebcam</italic>’s domain becomes empty (Step 8), and BJ occurs. The solving process backjumps to <italic>mWebcam</italic>’s last conflict variable <italic>mMonitor</italic> (assigned in Step 4), and reassigns it (Step 9) and all these four child module variables (Steps 10–13).</p>
<p>In the solving process of FC-BJ with the hybrid heuristic (<xref ref-type="table" rid="table2-1063293X12457401">Table 2</xref>), <italic>mWebcam</italic> (Step 5) is first checked as it is involved in the largest number of constraints on past variables, then the conflict is detected. In Step 6, the FC-BJ-hybrid heuristic solving process backjumps to its last conflict variable <italic>mMonitor</italic> (assigned in Step 4) and reassigned <italic>mMonitor</italic> (Step 6) and <italic>mWebcam</italic> (Step 7). Subsequently, as the other three child module variables are involved in the same number of constraints on past variables, they are instantiated from Steps 8 to 10, according to their domain size. From this simple comparison, it has been observed that FC-BJ-hybrid heuristic outperforms FC-BJ-FF in terms of BT avoidance.</p>
</sec>
<sec id="section10-1063293X12457401">
<title>Experimental results</title>
<p>To test the solving efficiency of the augmented FC-BJ with both the FF heuristic and the hybrid heuristic implemented on the extended DCSP PC system, comparisons are conducted between algorithm FC-BJ-FF heuristic on the extended DCSP PC system (denoted as “DCSP + FC-BJ-FF” in experimental results) and a classical CSP-based configuration system with standard BT algorithm (denoted as “CSP”), between “DCSP + FC-BJ-FF” and an augmented BT algorithm (see <xref ref-type="bibr" rid="bibr12-1063293X12457401">Wang et al., 2011</xref>) on the extended DCSP PC system (denoted as “DCSP + BT”), and between “DCSP + FC-BJ-FF” and algorithm FC-BJ with the hybrid heuristic (denoted as “DCSP + FC-BJ-hybrid”). In all experiments, the configuration domain <inline-formula id="inline-formula22-1063293X12457401"><mml:math display="inline" id="math22-1063293X12457401"><mml:mrow><mml:mi>Φ</mml:mi></mml:mrow></mml:math></inline-formula> of the extended DCSP PC system is stored in a Microsoft SQL Server database and costumers’ requirements are parsed into Extensible Markup Language (XML) files (<xref ref-type="bibr" rid="bibr12-1063293X12457401">Wang et al., 2011</xref>). An open source, Java-based CSP solving library <italic>Choco</italic> handling constraint implement is applied in DCSP solving process to generate valid configuration results. All experiments are implemented on an Intel Core 2 Quad Q9400 system at 2.66 GHz with 4 GB of random access memory (RAM).</p>
<p>Experimental results are listed in <xref ref-type="table" rid="table3-1063293X12457401">Table 3</xref> and illustrated in <xref ref-type="fig" rid="fig2-1063293X12457401">Figure 2</xref>. In order to compare, the abscissa “number of selected modules” in <xref ref-type="fig" rid="fig2-1063293X12457401">Figure 2</xref> refers to the number of modules involved in final solutions to a CSP/DCSP-based configuration system, and varies from 12 (only includes all common modules) to 16 (includes all optional modules), that is, points of the abscissa represent different customer requirements on modules. It also represents the number of module variables involved in the searching process of the extended DCSP PC system. Consequently, the number of components variables, property variables, and constraints in the DCSP searching process varies in accordance to the selected module variables. However, in classical CSP-based system, all 16 modules and all components, properties, and constraints (except structural and activation constraints) are involved in the searching process. At each point of the abscissa, experiments on different systems and algorithms are conducted product configuration on the same customers’ requirements, that is, the same module variables and property requirements.</p>
<table-wrap id="table3-1063293X12457401" position="float">
<label>Table 3.</label>
<caption>
<p>Experimental results</p>
</caption>
<graphic alternate-form-of="table3-1063293X12457401" xlink:href="10.1177_1063293X12457401-table3.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="left"/>
<col align="left"/>
<col align="left"/>
<col align="char" char="."/>
<col align="char" char="."/>
<col align="char" char="."/>
<col align="char" char="."/>
<col align="char" char="."/>
</colgroup>
<thead>
<tr>
<th align="left" colspan="4">The number of module variables</th>
<th align="left">12</th>
<th align="left">13</th>
<th align="left">14</th>
<th align="left">15</th>
<th align="left">16</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="3">Results for generating the first feasible configuration solution (the number of visited nodes)</td>
<td>CSP</td>
<td>61</td>
<td>72</td>
<td>125</td>
<td>169</td>
<td>285</td>
</tr>
<tr>
<td colspan="3"/>
<td>DCSP + BT</td>
<td>34</td>
<td>41</td>
<td>70</td>
<td>86</td>
<td>129</td>
</tr>
<tr>
<td colspan="3"/>
<td>DCSP + FC-BJ-FF</td>
<td>22</td>
<td>26</td>
<td>38</td>
<td>53</td>
<td>105</td>
</tr>
<tr>
<td colspan="3"/>
<td>DCSP + FC-BJ-hybrid</td>
<td>22</td>
<td>26</td>
<td>32</td>
<td>43</td>
<td>86</td>
</tr>
<tr>
<td rowspan="2">Results for generating all solutions</td>
<td>CSP versus DCSP + FC-BJ-FF</td>
<td>Visited nodes number</td>
<td>CSP</td>
<td>48,192</td>
<td>62,247</td>
<td>1,00,062</td>
<td>2,63,108</td>
<td>5,69,279</td>
</tr>
<tr>
<td/>
<td/>
<td>DCSP + FC-BJ-FF</td>
<td>3732</td>
<td>4997</td>
<td>9,859</td>
<td>22,071</td>
<td>70,534</td>
</tr>
<tr>
<td/>
<td/>
<td>CPU times</td>
<td>CSP</td>
<td>22,238</td>
<td>25,642</td>
<td>49,088</td>
<td>1,21,667</td>
<td>2,75,010</td>
</tr>
<tr>
<td/>
<td/>
<td/>
<td>DCSP + FC-BJ-FF</td>
<td>3532</td>
<td>3997</td>
<td>6159</td>
<td>11071</td>
<td>42,534</td>
</tr>
<tr>
<td/>
<td>DCSP + BT versus DCSP + FC-BJ-FF</td>
<td>Visited nodes number</td>
<td>DCSP + BT</td>
<td>6166</td>
<td>10,964</td>
<td>25,168</td>
<td>78,043</td>
<td>1,14,010</td>
</tr>
<tr>
<td/>
<td/>
<td/>
<td>DCSP + FC-BJ-FF</td>
<td>3732</td>
<td>4997</td>
<td>9859</td>
<td>22,071</td>
<td>70,534</td>
</tr>
<tr>
<td/>
<td/>
<td>CPU times</td>
<td>DCSP + BT</td>
<td>6596</td>
<td>7592</td>
<td>12,433</td>
<td>34,521</td>
<td>58,950</td>
</tr>
<tr>
<td/>
<td/>
<td/>
<td>DCSP + FC-BJ-FF</td>
<td>3532</td>
<td>3997</td>
<td>6159</td>
<td>11,071</td>
<td>42,534</td>
</tr>
<tr>
<td/>
<td>DCSP+FC-BJ-FF versus DCSP + FC-BJ-hybrid</td>
<td>Visited nodes number</td>
<td>DCSP + FC-BJ-FF</td>
<td>5278</td>
<td>8596</td>
<td>18,323</td>
<td>40,796</td>
<td>1,09,221</td>
</tr>
<tr>
<td/>
<td/>
<td/>
<td>DCSP + FC-BJ-hybrid</td>
<td>4091</td>
<td>6597</td>
<td>10,259</td>
<td>23,071</td>
<td>67,138</td>
</tr>
<tr>
<td/>
<td/>
<td>CPU times</td>
<td>DCSP + FC-BJ-FF</td>
<td>4515</td>
<td>5297</td>
<td>10,915</td>
<td>28506</td>
<td>66,301</td>
</tr>
<tr>
<td/>
<td/>
<td/>
<td>DCSP + FC-BJ-hybrid</td>
<td>3932</td>
<td>4497</td>
<td>7559</td>
<td>13,971</td>
<td>43,834</td>
</tr>
</tbody>
</table>
<table-wrap-foot>
<fn id="table-fn3-1063293X12457401">
<p>CSP: Constraint Satisfaction Problem; CPU: central processing unit; DCSP: Dynamic CSP; FC: forward checking; BT: backtracking; FC-BJ-FF: forward checking and backjumping with fail-first heuristic.</p>
</fn>
</table-wrap-foot>
</table-wrap>
<fig id="fig2-1063293X12457401" position="float">
<label>Figure 2.</label>
<caption>
<p>Experimental results. (a) Results for generating a feasible configuration solution, (b) and (c) results for generating all solutions on visited nodes number &amp; on CPU times respectively (CSP vs DCSP-FC-BJ-FF); (d) and (e) results for generating all solutions on visited nodes number &amp; on CPU times (DCSP-BT vs DCSP-FC-BJ-FF); (f) and (g) results for generating all solutions on visited nodes number &amp; on CPU times (DCSP-FC-BJ-FF vs DCSP-FC-BJ-hybrid).</p>
<p>(CPU: central processing unit; CSP: constraint satisfaction problem; DCSP: Dynamic CSP; FC: forward checking; BT: backtracking; BJ: backjumping; FF: fail-first).</p>
</caption>
<graphic xlink:href="10.1177_1063293X12457401-fig2.tif"/>
</fig>
<p>In experiments for generating the first feasible solution (<xref ref-type="fig" rid="fig2-1063293X12457401">Figure 2(a)</xref>), the augmented FC-BJ with both heuristics (FF and the hybrid heuristic) applied to the extended DCSP PC system outperforms both algorithms “DCSP + BT” and “CSP”; FC-BJ with the hybrid heuristic has the best performance. Specifically, in terms of visited nodes in a search process, “DCSP + FC-BJ-FF” decreases around 65% than “CSP” and decreases 18.5%–45.7% than “DCSP + BT”. Moreover, the number of visited nodes in “DCSP + FC-BJ-hybrid” is about 80% of that in “DCSP + FC-BJ-FF”. In the performance curve of both FC-BJ algorithms, when the number of module variables ranges from 15 to 16, there is a relatively sharp increase in the number of visited nodes, as there are several constraints between assigned variables and the new active variables that are not yet assigned. Consistency of the constraints needs to be checked before FC performance to guarantee that there is at least one value in the domain of new active variables consistent with the current partial solution. Otherwise, the solving process backtracks to the assigned variable in the constraint and reassigns it, and all variables after the assigned variable in the current partial solution must also be reevaluated. This results in more work.</p>
<p>
<xref ref-type="fig" rid="fig2-1063293X12457401">Figure 2(b)</xref> and <xref ref-type="fig" rid="fig2-1063293X12457401">(c)</xref> illustrate experimental results implementing comparison between algorithm CSP and “DCSP + FC-BJ-FF” for generating all configuration solutions with respect to the number of visited nodes in the searching process and CPU time, respectively. “DCSP + FC-BJ-FF” offers significant improvement compared with “CSP”, as the number of selected module variables, together with components, property variables, and constraints increases. Specifically, compared with “CSP”, “DCSP + FC-BJ-FF” reduces 87.6%–92.3% visited nodes and 84.1%–90.2% CPU times. Similar experiments are conducted on implementations of “DCSP + BT” and “DCSP + FC-BJ-FF” and are illustrated in <xref ref-type="fig" rid="fig2-1063293X12457401">Figure 2(d)</xref> and <xref ref-type="fig" rid="fig2-1063293X12457401">(e)</xref>. FC-BJ-FF also achieves better performance in both aspects. Compared with “DCSP + BT”, “DCSP + FC-BJ-FF” reduces 38.1%–71.7% visited nodes and 27.9%–67.9% CPU times. It is observed that its performance becomes higher as the number of active variables increases, but the outperformance may be counteracted due to the increase of constraints between variables activated in different solving phases.</p>
<p>Finally, the performance of “DCSP + FC-BJ-FF” is compared with that of “DCSP + FC-BJ-hybrid.”<xref ref-type="fig" rid="fig2-1063293X12457401">Figure 2(f)</xref> and <xref ref-type="fig" rid="fig2-1063293X12457401">(g)</xref> illustrate experimental results for generating all configuration solutions in terms of the number of visited nodes in the searching process and CPU time. When there is no constraint between variables activated in different searching phases (e.g. when there are 12 and 13 module variables in a searching process), these two algorithms are the same and thus, their performance has no difference. However, as constraints between variables activated in different searching phases increase, “DCSP + FC-BJ-hybrid” achieves a better performance than “DCSP + FC-BJ-FF.” Specifically, as active variables involved in the searching process change from 13 to 16, the performance curve of “DCSP + FC-BJ-hybrid” presents a smaller curvature than that of “DCSP + FC-BJ-FF”, that is, “DCSP+FC-BJ-hybrid” visits less nodes (about 22.5%–44%) and spends less CPU time (about 12.9%–51%) in the searching process. Similar condition exists in <xref ref-type="fig" rid="fig2-1063293X12457401">Figure 2(a)</xref>. Moreover, performance improvement is monotonically increasing, since the difference of the number of visited nodes and CPU time between these two algorithms becomes larger with the increase of constraints between variables activated in different searching phases.</p>
<p>Hence, it is observed that comparing with CSP-based system solved by classical BT, “DCSP + FC-BJ-FF” significantly improves the configuration efficiency and generally outperforms “DCSP + BT,” although it needs to handle more work when a new active variable is added into a DCSP, especially when multiple solutions are required. Furthermore, “DCSP + FC-BJ-hybrid” is proved to improve the performance of “DCSP + FC-BJ-FF” by reducing the BT that may occur in the searching process when there are constraints between variables activated in different searching phases.</p>
</sec>
</sec>
<sec id="section11-1063293X12457401" sec-type="conclusions">
<title>Conclusions</title>
<p>In this article, based on an extended DCSP-based product configuration system proposed in a previous work, we propose a hybrid solving algorithm—FC-BJ with FF heuristic. In the extended DCSP system, the hybrid algorithm is implemented on a sequence of stable phases extending incrementally, each of which refers to a classical CSP. In each phase, FC is applied on a set of active variables, constraint consistency is checked between the just-assigned variable and its direct future variables, and finally, a value is assigned to each active variable without violating any active constraints in the classical CSP. In the FC process, if the domain of a future variable becomes empty, the solving process backjumps to its last conflicting variable, instead of the last assigned variable, to avoid thrashing. FF heuristic is also applied in the solving process to improve solving efficiency. However, as the extended DCSP system is incrementally extended by activation of new active variables and constraints, the efficiency of the hybrid algorithm is greatly reduced when there are many constraints between instantiated variables and new active ones, which may incur a lot of BT.</p>
<p>To address this issue, we propose a hybrid heuristic that is a combination of FF heuristic and an amended most-constrained heuristic. Using the hybrid heuristic, the activation of variables and the selection of variable to be assigned follow a descending order of the number of constraints, if they exist, between instantiated variables and new active variables; otherwise, they follow the rules of FF heuristic. In this way, the variable that is most likely to incur BT is first checked. Implementations of both the proposed algorithms and heuristics on an extended DCSP-based PC configuration system have been elaborated, and good solving efficiency has been achieved.</p>
</sec>
</body>
<back>
<bio>
<title>Author Biographies</title>
<p><bold>Lin Wang</bold> is currently a PhD candidate at the School of Computer Engineering, Nanyang Technological University, Singapore. She received her BS degree in Computer Software from Tsinghua University, P.R. China. Her research interests include product configuration, cost estimation, and constraint satisfaction problems.</p>
<p><bold>Wee-Keong Ng</bold> is Associate Professor at the School of Computer Engineering, Nanyang Technological University, Singapore. He received his PhD from the University of Michigan at Ann Arbor, USA. He has published more than 200 refereed journal and conference articles in the area of data mining, web information systems, database and data warehousing, and software agents. He is currently Associate Editor of the <italic>International Journal of Artificial Intelligence</italic> and Member of Editorial Review Boards of the <italic>Journal of Database Management</italic> (JDM), the <italic>International Journal of Applied Decision Sciences</italic> (IJADS), the <italic>International Journal of Intelligent Data Analysis</italic> (IJIDA), the <italic>International Journal of Intelligent Information and Database Systems</italic> (IJIIDS), and the <italic>International Journal of Intelligent Information Technologies</italic> (IJIIT). Dr. Ng was Program Committee Vice Chair (PRICAI’ 2010), Asia Pacific Liaison Chair (I3E’2008); Program Co-chair (ICSSSM’08), Area Chair (PAKDD’08, PAKDD’07); Program Chair (PAKDD’06), Area Chair (PRICAI’06), and Industrial Chair (PAKDD’05). Dr. Ng is a member of IEEE Computer Society and a member of ACM.</p>
</bio>
<ref-list>
<title>References</title>
<ref id="bibr1-1063293X12457401">
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Bacchus</surname><given-names>F</given-names></name>
<name><surname>Grove</surname><given-names>A</given-names></name>
</person-group> (<year>1995</year>) <article-title>On the forward checking algorithm</article-title>. <conf-name>CP ’95 proceedings of the 1st international conference on principles and practice of constraint programming, Lecture Notes in Computer Science</conf-name>, vol. <volume>976</volume>, pp. <fpage>292</fpage>–<lpage>309</lpage>.</citation>
</ref>
<ref id="bibr2-1063293X12457401">
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Barták</surname><given-names>R</given-names></name>
</person-group> (<year>1999</year>) <article-title>Constraint programming—what is behind?</article-title> In: <conf-name>Proceedings of the workshop on constraint programming in decision and control</conf-name> (ed <person-group person-group-type="editor">
<name><surname>Figwer</surname><given-names>J</given-names></name>
</person-group>), <conf-loc>Gliwice, Poland</conf-loc>, <conf-date>June</conf-date>.</citation>
</ref>
<ref id="bibr3-1063293X12457401">
<citation citation-type="web">
<person-group person-group-type="author">
<name><surname>Barták</surname><given-names>R</given-names></name>
</person-group> (<year>2005</year>) <article-title>Constraint propagation and backtracking-based search—a brief introduction to mainstream techniques of constraint satisfaction</article-title>. <conf-name>Lecture Note of the first international summer school on Constraint Programming of Charles University</conf-name>, <conf-date>September 11–15, 2005</conf-date>, <conf-loc>Maratea, Italy</conf-loc>. <comment>Available at: <ext-link ext-link-type="uri" xlink:href="http://kti.mff.cuni.cz/;bartak/downloads/CPschool05notes.pdf">http://kti.mff.cuni.cz/;bartak/downloads/CPschool05notes.pdf</ext-link></comment>.</citation>
</ref>
<ref id="bibr4-1063293X12457401">
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Chenouard</surname><given-names>R</given-names></name>
<name><surname>Granvilliers</surname><given-names>L</given-names></name>
<name><surname>Sebastian</surname><given-names>P</given-names></name>
</person-group> (<year>2009</year>) <article-title>Search heuristics for constraint-aided embodiment design</article-title>. <source>Artificial Intelligence for Engineering Design, Analysis and Manufacturing</source> <volume>23</volume>(<issue>2</issue>): <fpage>175</fpage>–<lpage>195</lpage>.</citation>
</ref>
<ref id="bibr5-1063293X12457401">
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Du</surname><given-names>XH</given-names></name>
<name><surname>Jiao</surname><given-names>JX</given-names></name>
<name><surname>Tseng</surname><given-names>MM</given-names></name>
</person-group> (<year>2001</year>) <article-title>Architecture of product family: fundamental and methodology</article-title>. <source>Concurrent Engineering: Research and Applications</source> <volume>9</volume>(<issue>4</issue>): <fpage>309</fpage>–<lpage>325</lpage>.</citation>
</ref>
<ref id="bibr6-1063293X12457401">
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Fujita</surname><given-names>K</given-names></name>
<name><surname>Yoshida</surname><given-names>H</given-names></name>
</person-group> (<year>2004</year>) <article-title>Product variety optimization: simultaneously designing module combination and module attributes</article-title>. <source>Concurrent Engineering: Research and Applications</source> <volume>12</volume>(<issue>2</issue>): <fpage>105</fpage>–<lpage>118</lpage>.</citation>
</ref>
<ref id="bibr7-1063293X12457401">
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Jiao</surname><given-names>JX</given-names></name>
<name><surname>Simpson</surname><given-names>TW</given-names></name>
<name><surname>Siddique</surname><given-names>Z</given-names></name>
</person-group> (<year>2007</year>) <article-title>Product family design and platform-based product development: a state-of-the-art review</article-title>. <source>Journal of Intelligent Manufacturing</source> <volume>18</volume>(<issue>1</issue>): <fpage>4</fpage>–<lpage>29</lpage>.</citation>
</ref>
<ref id="bibr8-1063293X12457401">
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Mittal</surname><given-names>S</given-names></name>
<name><surname>Falkenhainer</surname><given-names>B</given-names></name>
</person-group> (<year>1990</year>) <article-title>Dynamic constraint satisfaction problems</article-title>. In: <conf-name>Proceedings of the 8th national conference on artificial intelligence (AAAI-90)</conf-name>, <conf-loc>Boston, MA</conf-loc>, <conf-date>July 29–August 3</conf-date>, pp. <fpage>25</fpage>–<lpage>32</lpage>. <publisher-name>AAAI Press</publisher-name>.</citation>
</ref>
<ref id="bibr9-1063293X12457401">
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Mittal</surname><given-names>S</given-names></name>
<name><surname>Frayman</surname><given-names>F</given-names></name>
</person-group> (<year>1989</year>) <article-title>Towards a generic model of configuration tasks</article-title>. In: <conf-name>Proceedings of the 11th international joint conference of artificial intelligence</conf-name>, <conf-loc>Detroit, MI</conf-loc>, <conf-date>August 20–26</conf-date>, pp. <fpage>1395</fpage>–<lpage>1401</lpage>. <publisher-name>Morgan Kaufmann Publishers Inc.</publisher-name> <publisher-loc>San Francisco, CA, USA</publisher-loc>.</citation>
</ref>
<ref id="bibr10-1063293X12457401">
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Razgon</surname><given-names>I</given-names></name>
</person-group> (<year>2005</year>) <article-title>Complexity analysis of heuristic CSP search algorithms</article-title>. In: <conf-name>Joint annual workshop of ERCIM/CoLogNet on constraint solving and constraint logic programming</conf-name>, <conf-loc>Uppsala, Sweden</conf-loc>, <conf-date>June 20–22</conf-date>, pp. <fpage>88</fpage>–<lpage>99</lpage>. <publisher-name>Springer-Verlag Berlin Heidelberg</publisher-name>.</citation>
</ref>
<ref id="bibr11-1063293X12457401">
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Simpson</surname><given-names>TW</given-names></name>
<name><surname>D’Souza</surname><given-names>B</given-names></name>
</person-group> (<year>2001</year>) <article-title>Assessing variable levels of platform commonality within a product family using a multiobjective genetic algorithm</article-title>. <source>Concurrent Engineering: Research and Applications</source> <volume>12</volume>(<issue>2</issue>): <fpage>119</fpage>–<lpage>130</lpage>.</citation>
</ref>
<ref id="bibr12-1063293X12457401">
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Wang</surname><given-names>L</given-names></name>
<name><surname>Ng</surname><given-names>WK</given-names></name>
<name><surname>Song</surname><given-names>B</given-names></name>
</person-group> (<year>2011</year>) <article-title>Extended DCSP approach on product configuration with cost estimation</article-title>. <source>Concurrent Engineering: Research and Applications</source> <volume>19</volume>(<issue>2</issue>): <fpage>123</fpage>–<lpage>138</lpage>.</citation>
</ref>
<ref id="bibr13-1063293X12457401">
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Xu</surname><given-names>X</given-names></name>
<name><surname>Chen</surname><given-names>JLQ</given-names></name>
<name><surname>Xie</surname><given-names>SQ</given-names></name>
</person-group> (<year>2004</year>) <article-title>Framework of a product lifecycle costing system</article-title>. <source>Journal of Computing and Information Science in Engineering</source> <volume>6</volume>: <fpage>69</fpage>–<lpage>77</lpage>.</citation>
</ref>
</ref-list>
</back>
</article>