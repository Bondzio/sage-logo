<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD Journal Publishing DTD v2.3 20070202//EN" "journalpublishing.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" xml:lang="en">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">TIM</journal-id>
<journal-id journal-id-type="hwp">sptim</journal-id>
<journal-title>Transactions of the Institute of Measurement and Control</journal-title>
<issn pub-type="ppub">0142-3312</issn>
<issn pub-type="epub">1477-0369</issn>
<publisher>
<publisher-name>SAGE Publications</publisher-name>
<publisher-loc>Sage UK: London, England</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1177/0142331212444916</article-id>
<article-id pub-id-type="publisher-id">10.1177_0142331212444916</article-id>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Articles</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>A method for application reconfiguration in wireless sensor networks</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" corresp="yes">
<name><surname>Wu</surname><given-names>Xu</given-names></name>
<xref ref-type="aff" rid="aff1-0142331212444916">1</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Li</surname><given-names>Feng</given-names></name>
<xref ref-type="aff" rid="aff2-0142331212444916">2</xref>
</contrib>
</contrib-group>
<aff id="aff1-0142331212444916"><label>1</label>Department of Computer Science, Xi’an University of Posts and Telecommunications, Xi’an, China</aff>
<aff id="aff2-0142331212444916"><label>2</label>School of Engineering and Technology, Indiana University-Purdue University, Indianapolis, USA</aff>
<author-notes>
<corresp id="corresp1-0142331212444916">Xu Wu, Department of Computer Science, Xi’an University of Posts and Telecommunications, Xi’an, China. Email: <email>xrdz2005@163.com</email></corresp>
</author-notes>
<pub-date pub-type="epub-ppub">
<month>5</month>
<year>2013</year>
</pub-date>
<volume>35</volume>
<issue>3</issue>
<fpage>301</fpage>
<lpage>309</lpage>
<permissions>
<copyright-statement>© The Author(s) 2012</copyright-statement>
<copyright-year>2012</copyright-year>
<copyright-holder content-type="sage">SAGE Publications</copyright-holder>
</permissions>
<abstract>
<p>Wireless sensor networks are often deployed in physical environments that change over time. For this reason, wireless sensor networks need to be aware of these changes automatically and make a reconfiguration decisions to adapt to new applications. However, the existing approaches mainly focus on client/server-based reconfiguration architecture for sensor nodes. They are not flexible enough to cope automatically with unexpected changes in the environment. Moreover, periodically information exchanges between sensor nodes and the central control server produces expensive communication consumption and long response delays. In addition, client/server-based reconfiguration techniques need a wireless sensor network to maintain stable network connectivity. In order to solve this problem, this paper proposes a mobile agent-based application reconfiguration method (MAAR) for wireless sensor networks. The main advantage of the proposed method is to change application requirements to adapt to new applications in dynamic environments. Experiments have been carried out to study the effectiveness and the benefits of the MAAR. An application scenario is implemented in the environment monitoring of intelligence building. A client/server-based application reconfiguration method (CSAR) and MAAR are used separately. We choose to use two metrics, the communication time and the energy cost, to evaluate the performance of CSAR and MAAR in the application reconfiguration. The simulation results show that the MAAR provides greater flexibility for collaboration between the sensors and a better performance than CSAR in terms of the communication time and energy cost.</p>
</abstract>
<kwd-group>
<kwd>Mobile agent</kwd>
<kwd>reconfiguration</kwd>
<kwd>wireless sensor networks</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="section1-0142331212444916" sec-type="intro">
<title>Introduction</title>
<p>Wireless sensor networks (WSNs), in general, consist of a large number of inexpensive wireless devices (sensor nodes) densely distributed over the region of interest. Sensor nodes have wireless connectivity and can be tied to a backbone network such as the Internet (<xref ref-type="bibr" rid="bibr13-0142331212444916">Ruiz et al., 2005</xref>). Recently, WSNs have been used in various applications such as monitoring, disaster recovery, smart homes and many others. These sensor networks are often deployed in physical environments that change over time. For example, in a weather monitoring system, most nodes only collect temperature data, moisture date and wind date under normal situation, but under certain situations, such as an abnormal rainy season, some sensor nodes need to collect rainfall data adaptively. Finally, the programs that need to run on these sensor nodes may evolve as a result of changing application requirements. Therefore, a WSN must be able to operate under very dynamic conditions. However, it is not possible to have precise information about all future operation scenarios of a sensor network before deployment. Furthermore, sensor nodes cannot store all possible applications in their local memories due to memory constraints. Hence, the design should be flexible enough to accommodate the new requirements, while simultaneously respecting the severe resource constraints imposed by typical sensor nodes. However, the task of reconfiguring the application adaptively in environments where there will be tens of thousands of network elements with particular features and organization is not trivial. This task becomes harder due to the resource restrictions of these unattended sensor nodes.</p>
<p>Application reconfigurations can have two main forms, which include the value changes of certain application parameters and the change of the entire application. Regardless of the type of change involved, considerable research has been performed in applying run-time reconfigurable component models to WSNs (<xref ref-type="bibr" rid="bibr9-0142331212444916">Horre et al., 2009</xref>). These reconfiguration services and protocols allow a network administrator to specify new configurations to be run on sensor nodes in the network. However, these approaches mainly focus on client/server-based reconfiguration architecture for sensor nodes. They are not flexible enough to cope with unexpected changes in environment automatically. Moreover, periodically information exchanging between sensor nodes and the central control sever brings expensive communication consumption and long response delay. In addition, the client/server-based reconfiguration technique need a WSN with stable network connectivity. For large networks, it is likely that connectivity will affect the method and especially the time required for reconfiguration.</p>
<p>This paper proposes a mobile agent-based application reconfiguration (MAAR) method for WSNs. Our approach uses highly distributed agents to help their sensor nodes in reconfiguration decision-making. Reconfiguration is triggered by the changes in the application requirements and is performed by transitioning to a new configuration. If a reconfiguration is needed, the mobile agent will send new application codes to these sensor nodes. Based on the mobile agents, the WSN can adaptively change application requirements to adapt to new applications in dynamic environments. The mobile agent-based method provides greater flexibility for collaboration between sensors and better performance than client/server reprogramming methods in terms of the communication time and energy cost.</p>
<p>The remainder of this paper is structured as follows: the next section provides background on distributed reconfiguration approaches for WSNs and agent-based computing techniques. Then details of the mobile agent architecture are given, followed by the proposed method. The performance of the proposed method discussed and some conclusions are presented.</p>
</sec>
<sec id="section2-0142331212444916">
<title>Related work</title>
<p>Recently, some distributed reconfiguration approaches have been proposed for WSNs. Agilla (<xref ref-type="bibr" rid="bibr7-0142331212444916">Fok et al., 2005</xref>) is an exemplary framework, which provides reprogramming mechanisms that enable users to inject new instructions into a sensor network. A reconfiguration solution called Human-In-The-Loop stabilization is presented in <xref ref-type="bibr" rid="bibr3-0142331212444916">Bapat and Arora (2006)</xref>. This approach uses local detectors and correctors that can detect version inconsistencies and prevent their propagation in a timely and efficient manner, while ultimately allowing the human operator to restore the network to the correct configuration. <xref ref-type="bibr" rid="bibr2-0142331212444916">Balani et al. (2006)</xref> presents a system that supports software reconfiguration in embedded sensor networks at multiple levels. The system architecture is based on an operating system consisting of a fixed tiny static kernel and binary modules that can be dynamically inserted, updated or removed. An approach (<xref ref-type="bibr" rid="bibr10-0142331212444916">Kogekar et al., 2005</xref>) for software reconfiguration is proposed based on exploration of the design space of the application. The reconfiguration architecture supports to change the functionality of individual nodes in the network in response to changes in the environment, and allows sensor nodes to derive a suitable configuration on-line. A reconfiguration approach using ontologies is presented in <xref ref-type="bibr" rid="bibr4-0142331212444916">Bispo et al. (2009)</xref>. This approach enables the enrichment of data by the association of its significance, as well as the automatic processing of temporal and spatial aspects related to data.</p>
<p>Although these solutions can be easily incorporated into existing reconfiguration protocols, they have some limitations. First, they mainly focus on client/server-based reconfiguration architecture for sensor nodes. Periodically, information exchanging between sensor nodes and the central control sever brings expensive communication consumption and long response delay. Second, they cannot automatically cope with unexpected changes in the sensing environment. Third, the client/server-based reconfiguration technique needs the WSN to keep stable network connectivity. For large networks, it is likely that connectivity will affect the method and especially the time required for reconfiguration.</p>
<p>Agent systems and multi-agent systems are a new and robust paradigm for designing flexible architectures for systems with disparate needs. Agents provide a certain level of abstraction for achieving goals in a system, thereby potentially simplifying the design of a complex system. Agents are gaining popularity because of their flexibility, modularity and their general applicability especially in the field of distributed computing (<xref ref-type="bibr" rid="bibr1-0142331212444916">Anthony and Jannett, 2010</xref>). Recently, agents have been used in sensor networks. For example, Sheu et al. (2010) proposed an Adaptive Peer-to-Peer Agent Architecture (APPA) for sensor networks. The purpose is to provide context-driven situational awareness to help command and control commanders in decision-making. The mobile agent is a special kind of software that propagates over the network either periodically or on demand (when required by the applications). The use of agents in computer networks has certain advantages and disadvantages (<xref ref-type="bibr" rid="bibr15-0142331212444916">Vigna, 2004</xref>), such as code caching, safety and security, depending on the particular scenario. Regardless, they have been successful deployed in many applications ranging from e-commerce to military situation awareness.</p>
<p>To date, there has been minimal research published on low power consumption. <xref ref-type="bibr" rid="bibr5-0142331212444916">De Vito et al. (2011)</xref> present the implementation of power saving sensor censoring strategies on a novel wireless electronic nose platform specifically designed for co-operative chemical sensing and based on TinyOS. An on-board sensor fusion component complements its software architecture with the capability of locally estimate air quality and chemicals concentrations. Each node is hence capable to decide the informative content of sampled data extending the operative lifespan of the entire network. Actual power savings are modelled and estimated with a measurement approach in experimental scenarios.</p>
<p><xref ref-type="bibr" rid="bibr12-0142331212444916">Maleki et al. (2011)</xref> considered a combined sleeping and censoring scheme as an energy efficient spectrum sensing technique for cognitive sensor networks. Their objective is to minimize the energy consumed in distributed sensing subject to constraints on the detection performance, by optimally choosing the sleeping and censoring design parameters. The constraint on the detection performance is given by a minimum target probability of detection and a maximum permissible probability of false alarm. Depending on the availability of prior knowledge about the probability of primary user presence, two cases are considered. The case where <italic>a priori</italic> knowledge is not available defines the blind set-up; otherwise the set-up is called knowledge-aided. By considering a sensor network based on IEEE 802.15.4/ZigBee radios, they show that significant energy savings can be achieved by the proposed scheme.</p>
</sec>
<sec id="section3-0142331212444916">
<title>Mobile agent architecture</title>
<p>The mobile agent is a special kind of software that propagates over the network either periodically or on demand (when required by the applications). It performs data processing autonomously while migrating from node to node. As described in <xref ref-type="bibr" rid="bibr11-0142331212444916">Konstantopoulos et al. (2010)</xref>, many inherent advantages (e.g. scalability, extensibility, energy awareness, reliability) of the mobile agent architecture make it more suitable for WNSs than the client/server architecture. In the section, we present the details of mobile agent framework used in MAAR.</p>
<sec id="section4-0142331212444916">
<title>Existing agent framework (EMAA)</title>
<p>Before detail our mobile agent framework, we first provide some preliminaries. Our work is based on an existing agent framework EMAA (Extensible Mobile Agent Architecture; <xref ref-type="bibr" rid="bibr8-0142331212444916">Hofmann et al., 2001</xref>). Core EMAA technology provides a family of software libraries that enable the creation and deployment of robust and reliable distributed agent integration solutions. EMAA supplies an operating environment for the agents. EMAA consists of three primary types of components: docks, agents and services. The dock serves as the operating environment where the agents perform their tasking on a particular host. To gain access to its services, an agent must be received and authenticated by the dock. Each dock relies on four basic components in realizing the agent operating environment: the Agent Manager, Service Manager, Event Manager and Agent Transporter. The Agent Manager provides thread access and scheduling services for the agents at the dock. The Service Manager provides look-up and access to services installed within the dock. The Event Manager provides an asynchronous, event-based, communication mechanism for use by any component within the dock. The Agent Transporter handles the transmission of agents to and from a dock. A P2P communication architecture is employed between mobile agents in order to share the application codes and sample values, so application codes and sample values in a rule-engine are updated constantly.</p>
</sec>
<sec id="section5-0142331212444916">
<title>Our mobile agent framework</title>
<p>The major difference of our mobile agent architecture from EMMA is that the extension is designed to support the specific needs as anticipated in peer-to-peer, agent-based applications such as field-deployed sensor networks. A peer-to-peer agent environment is employed between mobile agents. In a peer-to-peer agent environment, there is no common known server such as a directory server node. Our mobile agent framework’s extension to EMAA will eliminate the need for an EMAA service to do directory management. The agents within the same peer-to-peer network will have to be equipped with the capability to autonomously discover each other and detect if any of its peer member agents have dropped out. With the discovery and detection capability among the peer agents, the intelligent agents within the WSNs will be able to autonomously collaborate and co-ordinate with one other. The goal is to share the application codes and sample values between mobile agents to assist sensor nodes in better decision support. To provide this capability, our framework’s agents are ‘intelligent’ agents. An intelligent agent is defined as a persistent software process that is able to interact with its environment to perform tasks on behalf of a user or sensor node. An intelligent agent has the following three key characteristics:</p>
<list id="list1-0142331212444916" list-type="bullet">
<list-item>
<p>The agent is autonomous because it is given a set of instructions to perform without direct control of a human operator.</p>
</list-item>
<list-item>
<p>In addition, the agent is adaptive because it is able to adjust what it will do based on its environment.</p>
</list-item>
<list-item>
<p>Finally, the agent is co-operative because it can work together with other agents or with a human operator to accomplish its goals.</p>
</list-item>
</list>
<p>Given these capabilities, our agents will be able to perform in a peer-to-peer environment.</p>
</sec>
<sec id="section6-0142331212444916">
<title>Agent service for sensor node</title>
<p>One of the main challenges is to enable non-agent-based sensor nodes to participate in agent-based sensor networks, given that different sensor nodes may have different controls and interfaces. Our approach is to use an agent-based service for a sensor node as a proxy for the management of the sensor node’s context, environmental data, capability, operations and status. The proxy agents for sensor nodes in our architecture should not only be state-full services but also provide proactive actions on behalf of the underneath sensor nodes. That is, agents should allow one another persistent queries for information. For example, a persistent agent-to-agent query might be: ‘whenever there is an abnormal high temperature, please notify me’. Without the use of the agent service to enable the underneath sensor node, persistent queries are not easy to achieve. Another main concept of the agent service is to provide a generic, peer-to-peer negotiation interface pattern and template. This allows sensor developers to simply fill in the callback hooks with sensor specific states, capabilities and run-time information. The proposed architecture will have the implemented protocol engines for every service agent representing the sensor.</p>
</sec>
<sec id="section7-0142331212444916">
<title>Agent mobility</title>
<p>An agent system consists of one or more machines that contain a dock that manages when an agent is launched. When the dock launches an agent, it determines where its workflow tasks need to run and paths where the agent migrates to another dock. Workflows model an agent’s process as a finite state machine where ‘reconfiguration tasks’ represent states, ‘paths’ represent transitions and the workflow is the state machine. For example, when a service agent recognizes a change in environmental data of its sensor node, it dynamically recomposes the workflow following expertise captured in a rule-engine. The rule-engine is used to guide the dynamic reconfiguration process to pick the right application codes to send to its sensor node. During the execution of the agent system, agents can detect whether it would be to run their processing on different network nodes and, if so, will migrate automatically to perform reconfiguration based on the paths determined by dock. This activity is critical to sensor networks because often times there are limited bandwidth and processing capabilities on the sensor’s node or local LAN. Thus, the mobility agent may help sensor nodes to reconfigure application, thus minimizing the bandwidth and processing power the actual sensor node requires.</p>
</sec>
</sec>
<sec id="section8-0142331212444916">
<title>The MAAR method</title>
<sec id="section9-0142331212444916">
<title>Model of the MAAR method</title>
<p>The MAAR method introduces three new functions for a mobile agent including Recognizing, Decision-making and Sending codes. A mobile agent can be equipped with a rule-engine module. It is composed of four components: conversion component, sample value base, reconfiguration trigger and code base. During a monitoring system initialization, the regular sample values of environmental changes are deployed in rule-engines. When a mobile agent recognizes a change in the environment condition of its sensor node, it dynamically makes a reconfiguration decision following sample values of environmental data in a rule-engine. For instance, at an abnormal high temperature, should some sensor nodes need to collect smoke data adaptively? The environmental information is converted to logic expressions by a conversion component in a rule-engine. The rule-engine analyses the logic expressions, and matches them with sample values of environmental change, and then determines whether reconfiguration or not. If yes, it will send new application codes to the sensor node. The rule-engines are used to guide the reconfiguration decision-making process to pick the right application codes to adapt to new situation. Users may develop new application codes and upload them to a mobile agent by traditional networks. The model of MAAR method is described in <xref ref-type="fig" rid="fig1-0142331212444916">Figure 1</xref>. The rule-engine module is shown in <xref ref-type="fig" rid="fig2-0142331212444916">Figure 2</xref>.</p>
<fig id="fig1-0142331212444916" position="float">
<label>Figure 1</label>
<caption>
<p>Mobile agent-based application reconfiguration method (MAAR) model.</p>
</caption>
<graphic xlink:href="10.1177_0142331212444916-fig1.tif"/>
</fig>
<fig id="fig2-0142331212444916" position="float">
<label>Figure 2</label>
<caption>
<p>The rule-engine module.</p>
</caption>
<graphic xlink:href="10.1177_0142331212444916-fig2.tif"/>
</fig>
<p>Sample value base stores sample values of environmental change defined by the system. Sample values express the relationship between environmental change and corresponding applications. We denote sample value as the following formula: (C<sub>1</sub>, C<sub>2</sub>, C<sub>3</sub>….C<sub>n</sub>)→A, where</p>
<list id="list2-0142331212444916" list-type="order">
<list-item>
<p>C is a logic expression, which represents change of certain environment parameter;</p>
</list-item>
<list-item>
<p>A is an application requirement, which denotes an application requirement in certain current environment conditions.</p>
</list-item>
</list>
<p>Utilizing the sample value and the environmental data from sensor nodes, the rule-engine can make a reconfiguration decision, and send the reconfiguration request to the reconfiguration trigger. The reconfiguration trigger based on sample values determine how, when and where to reconfigure, and then pick the right application codes from code base in order to adapt to new situation. If environmental data cannot match with sample values in a rule-engine, the mobile agent will send them to other mobile agents. If no any result, it will send them to user, then user will decide whether reconfiguration or not. If yes, the new application codes are uploaded to mobile agent by user. The reconfiguration is triggered, and the mobile agent will add the record of environmental change into sample value base.</p>
</sec>
<sec id="section10-0142331212444916">
<title>Process of the MAAR method</title>
<p>Based on the above model and concepts, the overall application reconfiguration process of the MAAR method can be divided into three phases: recognize, decision-making, application codes detection and sending codes.</p>
<list id="list3-0142331212444916" list-type="bullet">
<list-item>
<p><bold>Recognize phase</bold> – In the first phase, the mobility agent recognizes a change in environmental data of its sensor node</p>
</list-item>
<list-item>
<p><bold>Decision-making phase</bold> – The second phase involves determining whether it would be necessary to reconfigure. The rule-engine analyses the logic expressions, matches them with sample values of environmental change, and judges whether environment has changed. Thus, Reconfiguration trigger determines whether a reconfiguration should be taken referring to the result. If it is necessary to reconfigure, the mobile agent will send new application codes to these sensor nodes.</p>
</list-item>
<list-item>
<p><bold>Application codes detection phase</bold> – The third phase involves detecting new application codes. If environmental data cannot match the sample values in a rule-engine, the mobile agent will send them to other mobile agents. If there is no result, it will send them to the user, and the user will decide whether to reconfigure. If yes, the new application codes are uploaded to the mobile agent by the user. The reconfiguration is triggered, and the mobile agent will add the record of environmental change into the sample value base.</p>
</list-item>
<list-item>
<p><bold>Sending codes phase</bold> – The final phase is an acquirement, distribution process and executing of codes. In this phase, the mobile agent sends new application codes to these sensor nodes. So, application reconfiguration is implemented.</p>
</list-item>
</list>
<p><xref ref-type="fig" rid="fig3-0142331212444916">Figure 3</xref> illustrates the state transition diagram of the MAAR method in sensor networks. In general, a sensor network system can be in one of the four states: recognize, decision-making, application codes detection and sending codes. A sensor network starts at the recognizing state. It enters the decision-making state if a mobile agent recognizes a change in the environment condition of its surrounding sensor nodes, which indicates that some nodes need to be reconfigured. A sensor network enters the application codes detection state if a mobile agent finds that environmental data cannot match the sample values in its rule-engine. It enters the sending codes state if the reconfiguration is needed, then it returns to the recognizing state once new environment data have been collected.</p>
<fig id="fig3-0142331212444916" position="float">
<label>Figure 3</label>
<caption>
<p>State transition diagram of mobile agent-based application reconfiguration method (MAAR) method.</p>
</caption>
<graphic xlink:href="10.1177_0142331212444916-fig3.tif"/>
</fig>
</sec>
</sec>
<sec id="section11-0142331212444916">
<title>Application example</title>
<p>Environment monitoring is one of the most key application fields of sensor networks. Because the environment data is various and complicated, this kind of application takes advantage of MAAR. We have utilized sensor networks to establish an environment monitoring system for smart building, with one sensor per room to monitor the environment data, such as temperature, light and smoke. With the introduction of MAAR, the application running on sensor networks can automatically adjust with the changes of the environment, and reconfigure the applications.</p>
<sec id="section12-0142331212444916">
<title>Hardware platform and mobile agent-based computing architecture</title>
<p>Our system has been implemented and tested on MicaZ motes; each node is configured with three basic sensors such as light, temperature and smoke. Referring to EMAA architecture (<xref ref-type="bibr" rid="bibr8-0142331212444916">Hofmann et al., 2001</xref>), we have designed mobile agent-based reconfiguration architecture, which is illustrated in <xref ref-type="fig" rid="fig4-0142331212444916">Figure 4</xref>. <xref ref-type="fig" rid="fig4-0142331212444916">Figure 4</xref> illustrates the difference between the client/server-based reconfiguration architecture and mobile-agent based reconfiguration architecture. In application reconfiguration, the most commonly used architecture is client/server-based where individual sensors (the clients) send a reconfiguration request or pre-processed data to a sink node (the server) and reconfiguration or data integration is finished at the sink node. In mobile-agent based reconfiguration architecture, instead of each sensor node sending the reconfiguration request or pre-processed data to the sink node, the reconfiguration is processed by mobile agents, the data is moved to the sink node through mobile agents and the sink node is responsible for data integration. So the reconfiguration architecture can satisfy the need of adaptive reconfiguration.</p>
<fig id="fig4-0142331212444916" position="float">
<label>Figure 4</label>
<caption>
<p>Different reconfiguration architecture: (a) client/server-based reconfiguration architecture; (b) mobile agent-based reconfiguration architecture.</p>
</caption>
<graphic xlink:href="10.1177_0142331212444916-fig4.tif"/>
</fig>
<p>A mobile agent is a special kind of ‘software’. It can migrate from node to node, performing data processing autonomously. The structure of a mobile agent has four parts: identification, pointer to path, pointer to data and pointer to rule-engine module. Identification uniquely identifies each mobile agent. Data is collected by the sensors. The data is carried by the agent’s data buffer. The path is the route information. It can be fixed or dynamically determined based on the current network status and the information gain. The rule-engine module has been described previously.</p>
</sec>
<sec id="section13-0142331212444916">
<title>An implementation scenario</title>
<p>Here is an application scenario in environment monitoring of an intelligent building, which gives a detail implementation of MAAR. In order to simplify the steps, we assume that if temperature data is beyond the threshold, reconfiguration is needed. For instance, in fire monitoring the sensor nodes are in a temperature monitoring state. When a mobile agent finds that the temperature is higher than a threshold, it enters a decision-making state. If a reconfiguration is needed, the mobile agent will send new application codes to these sensor nodes in order to monitor both smoke and temperature. This will be more useful to judge whether fire has occurred around this node. In this case, the system can analyse the environment temperature, and automatically run a smoke monitoring state to satisfy the needs of the application reconfiguration. We describe the operations as the following steps.</p>
<list id="list4-0142331212444916" list-type="order">
<list-item>
<p><bold>Step 1</bold>: A sensor network deploys the initial temperature monitoring program.</p>
</list-item>
<list-item>
<p><bold>Step 2</bold>: A mobile agent will analyse the temperature data with a rule-engine, and output the result. The environmental information is converted to logic expressions by a conversion component in a rule-engine. The rule-engine analyses the logic expressions, and matches them with sample values of environmental change, and then determines whether to reconfigure. If the temperature data is beyond the threshold, the reconfiguration is needed. It will send new application codes to these sensor nodes.</p>
</list-item>
<list-item>
<p><bold>Step 3:</bold> Sensor nodes deploy and run the new application codes. Then sensor nodes will collect temperature data and smoke data synchronously, thus complete the application reconfiguration.</p>
</list-item>
</list>
</sec>
</sec>
<sec id="section14-0142331212444916">
<title>Experiment study</title>
<p>Experiments have been carried out to study the effectiveness and the benefits of the MAAR. An application scenario is implemented in environment monitoring of intelligent building. The client/server-based application reconfiguration method (CSAR) and MAAR are used separately. We choose to use two metrics, the communication time and the energy cost, to evaluate the performance of CSAR and MAAR in the application reconfiguration. Three parameters determine the application reconfiguration time and the overhead in different reconfiguration methods with their typical value selected for the application scenario. These parameters include the number of sensor nodes, the number of mobile agents and the reconfiguration code size. The communication time is the time to finish an application reconfiguration task. In MAAR, it starts from the time a mobile agent recognizes the environmental changes to the time the reconfiguration decision is made and the application codes are sent by the mobile agent. In the CSAR, it is from the time the clients find physical environmental changes to the time the reconfigure request is processed and application codes are sent at the server.</p>
<p>In order to better illustrate how these two methods complete the application reconfiguration, we introduce the life cycle concept of their reconfiguration units. We assume there are three nodes (<inline-formula id="inline-formula1-0142331212444916">
<mml:math display="inline" id="math1-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula>, <inline-formula id="inline-formula2-0142331212444916">
<mml:math display="inline" id="math2-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula> and <inline-formula id="inline-formula3-0142331212444916">
<mml:math display="inline" id="math3-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>k</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula>) and we assign <inline-formula id="inline-formula4-0142331212444916">
<mml:math display="inline" id="math4-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula> as the sink node (processing centre). <inline-formula id="inline-formula5-0142331212444916">
<mml:math display="inline" id="math5-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula> is assigned as the mobile agent created and dispatched by the dock in the case of MAAR. <inline-formula id="inline-formula6-0142331212444916">
<mml:math display="inline" id="math6-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>k</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula> is assigned as the sensor node in the two methods. The life cycle of the CSAR units is composed of three components, <inline-formula id="inline-formula7-0142331212444916">
<mml:math display="inline" id="math7-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula>, <inline-formula id="inline-formula8-0142331212444916">
<mml:math display="inline" id="math8-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>p</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula> and <inline-formula id="inline-formula9-0142331212444916">
<mml:math display="inline" id="math9-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula>. We use <inline-formula id="inline-formula10-0142331212444916">
<mml:math display="inline" id="math10-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula> to represent the time of sending reconfiguration request. <inline-formula id="inline-formula11-0142331212444916">
<mml:math display="inline" id="math11-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>p</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula> represents the reconfiguration processing time. Finally, <inline-formula id="inline-formula12-0142331212444916">
<mml:math display="inline" id="math12-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula> represents the time application reconfiguration codes are sent. The life cycle of the MAAR units is composed of two components, <inline-formula id="inline-formula13-0142331212444916">
<mml:math display="inline" id="math13-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>p</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula> and <inline-formula id="inline-formula14-0142331212444916">
<mml:math display="inline" id="math14-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula>.</p>
<p>In the CSAR, the client <inline-formula id="inline-formula15-0142331212444916">
<mml:math display="inline" id="math15-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>k</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula> first perceives the environment changes, and then sends the reconfiguration request to the sink node <inline-formula id="inline-formula16-0142331212444916">
<mml:math display="inline" id="math16-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula> using <inline-formula id="inline-formula17-0142331212444916">
<mml:math display="inline" id="math17-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula>. After receiving the request, the sink node can start processing, which would take a <inline-formula id="inline-formula18-0142331212444916">
<mml:math display="inline" id="math18-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>p</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula> amount of time. Finally, the sink node sends the application reconfiguration codes to sensor nodes <inline-formula id="inline-formula19-0142331212444916">
<mml:math display="inline" id="math19-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>k</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula> using <inline-formula id="inline-formula20-0142331212444916">
<mml:math display="inline" id="math20-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula>.</p>
<p>In the MAAR, a mobile agent <inline-formula id="inline-formula21-0142331212444916">
<mml:math display="inline" id="math21-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula> is created by the dock. It recognizes a change in the environment conditions of its surrounding sensor nodes, and then the mobile agent starts to process the reconfiguration using <inline-formula id="inline-formula22-0142331212444916">
<mml:math display="inline" id="math22-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>p</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula>. Finally, the mobile agent <inline-formula id="inline-formula23-0142331212444916">
<mml:math display="inline" id="math23-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula> sends the application reconfiguration codes to sensor nodes <inline-formula id="inline-formula24-0142331212444916">
<mml:math display="inline" id="math24-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>k</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula> using <inline-formula id="inline-formula25-0142331212444916">
<mml:math display="inline" id="math25-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula>.</p>
<p>A few factors that can affect the communication time include the data transfer rate <inline-formula id="inline-formula26-0142331212444916">
<mml:math display="inline" id="math26-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>v</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula>, the application reconfiguration processing rate <inline-formula id="inline-formula27-0142331212444916">
<mml:math display="inline" id="math27-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>v</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula>, the request file size <inline-formula id="inline-formula28-0142331212444916">
<mml:math display="inline" id="math28-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula>, the reconfiguration code size <inline-formula id="inline-formula29-0142331212444916">
<mml:math display="inline" id="math29-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula>, the number of sensor nodes <inline-formula id="inline-formula30-0142331212444916">
<mml:math display="inline" id="math30-0142331212444916">
<mml:mrow>
<mml:mi>l</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula> and the number of mobile agents <inline-formula id="inline-formula31-0142331212444916">
<mml:math display="inline" id="math31-0142331212444916">
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula>. Thus, for the CSAR, the time of sending reconfiguration request is <inline-formula id="inline-formula32-0142331212444916">
<mml:math display="inline" id="math32-0142331212444916">
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:mi>l</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>v</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:math>
</inline-formula>, the application reconfiguration processing time is <inline-formula id="inline-formula33-0142331212444916">
<mml:math display="inline" id="math33-0142331212444916">
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:mi>l</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>v</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:math>
</inline-formula> and the time of sending the application reconfiguration codes is <inline-formula id="inline-formula34-0142331212444916">
<mml:math display="inline" id="math34-0142331212444916">
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:mi>l</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>v</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:math>
</inline-formula>. Therefore, the total communication time using CSAR is</p>
<p><disp-formula id="disp-formula1-0142331212444916">
<label>(1)</label>
<mml:math display="block" id="math35-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>to</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mfrac>
<mml:mrow>
<mml:mi>l</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>v</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfrac>
<mml:mo>+</mml:mo>
<mml:mfrac>
<mml:mrow>
<mml:mi>l</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>v</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfrac>
<mml:mo>+</mml:mo>
<mml:mfrac>
<mml:mrow>
<mml:mi>l</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>v</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula1-0142331212444916" xlink:href="10.1177_0142331212444916-eq1.tif"/>
</disp-formula></p>
<p>For the MAAR, the time used to process the reconfiguration is <inline-formula id="inline-formula35-0142331212444916">
<mml:math display="inline" id="math36-0142331212444916">
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>v</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:math>
</inline-formula>, and the time of sending the application reconfiguration codes is <inline-formula id="inline-formula36-0142331212444916">
<mml:math display="inline" id="math37-0142331212444916">
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>v</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:math>
</inline-formula>. Therefore, the total communication time using MAAR is</p>
<p><disp-formula id="disp-formula2-0142331212444916">
<label>(2)</label>
<mml:math display="block" id="math38-0142331212444916">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>to</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>v</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfrac>
<mml:mo>+</mml:mo>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>v</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula2-0142331212444916" xlink:href="10.1177_0142331212444916-eq2.tif"/>
</disp-formula></p>
<p>In the analytical model described above, the component that is most difficult to measure is the data transfer rate, where retransmission and error control are not considered. Unfortunately, these factors occur quite often in sensor networks because of the use of wireless links. Therefore, we develop simulation models for more accurate estimation of the data transfer rate.</p>
<p>Sensor nodes are normally composed of four basic units: a sensing unit, a processing unit, a communication unit and a power unit. Among these units, communication and sensing consume most of the energy. The energy cost is computed with the method in <xref ref-type="bibr" rid="bibr6-0142331212444916">Feeney and Nilsson (2001)</xref>. We design three experiments to evaluate the effect of three parameters on the communication time and energy cost using the two reconfiguration architectures. In each experiment, we only change the value of one parameter but keep the others fixed.</p>
<sec id="section15-0142331212444916">
<title>Effect of the number of sensor nodes</title>
<p>In this experiment, we change the number of sensor nodes from five to 50 and use one mobile agent. The result is shown in <xref ref-type="fig" rid="fig5-0142331212444916">Figure 5</xref>.</p>
<fig id="fig5-0142331212444916" position="float">
<label>Figure 5</label>
<caption>
<p>Effect of number of sensor nodes: (a) communication time; (b) energy cost.</p>
</caption>
<graphic xlink:href="10.1177_0142331212444916-fig5.tif"/>
</fig>
<p>We observe that both the communication time and the energy cost using either reconfiguration method grow as the number of sensor nodes increases, but the communication time of MAAR is always lower than the CSAR. This is because as the number of sensor nodes increases, the server has to deal with more reconfiguration requested by the clients (sensor nodes) at the same time, which extends the communication time cost. On the other hand, the MAAR is less influenced by the number of sensor nodes because the reconfiguration is finished by a mobile agent for the MAAR. The clients do not need send the reconfiguration request to the server. The figure also shows that, when the number of the sensor nodes is larger than 10, the energy cost of CSAR grows much faster than the MAAR. The reason is that CSAR needs more connections than the MAAR in order to send and receive reconfiguration requests.</p>
</sec>
<sec id="section16-0142331212444916">
<title>Effect of the number of mobile agents</title>
<p>In this experiment, we fix the sensor node number at 60 but change the number of mobile agents from one to 25. Without loss of generality, we assume the same number of sensor nodes has a mobile agent. We expect a constant profile from the CSAR since it is irrelevant to the number of mobile agents.</p>
<p>We can see from <xref ref-type="fig" rid="fig6-0142331212444916">Figure 6</xref> that the communication time of the MAAR is always less than that of the CSAR because the server has to deal with these reconfigurations requested by the clients (sensor nodes) at the same time for the CSAR. Interestingly, the communication time of the MAAR decreases as the number of mobile agents increases and reaches the lowest point when there are 25 mobile agents. This is because more mobile agents will reduce the number of sensor nodes each agent manages, thus reducing the communication time. However, more mobile agents also cause more connections and more overheads. As the number of mobile agents increases, the energy cost also increases in linear and the MAAR actually consumes more energy than CSAR when the number of mobile agents is more than eight.</p>
<fig id="fig6-0142331212444916" position="float">
<label>Figure 6</label>
<caption>
<p>Effect of number of mobile agents: (a) communication time; (b) energy cost.</p>
</caption>
<graphic xlink:href="10.1177_0142331212444916-fig6.tif"/>
</fig>
</sec>
<sec id="section17-0142331212444916">
<title>Effect of size of the reconfiguration code</title>
<p>In these experiments, we change the size of the reconfiguration code at each sensor from 0.5 kB to 4.5 kB in 1-kB intervals and using a mobile agent. The sensor nodes are 35 for the MAAR and the CSAR.</p>
<p><xref ref-type="fig" rid="fig7-0142331212444916">Figure 7</xref> shows that both the communication time and energy cost of the MAAR and the CSAR grow as size of reconfiguration code increases. <xref ref-type="fig" rid="fig6-0142331212444916">Figure 6</xref> also shows that when the size of the reconfiguration code is greater than 2.0 kB, MAAR starts to consume more energy; when the size of the reconfiguration code is greater than 1.5 kB, the CSAR starts to take more communication time.</p>
<fig id="fig7-0142331212444916" position="float">
<label>Figure 7</label>
<caption>
<p>Effect of size of reconfiguration code: (a) communication time; (b) energy cost.</p>
</caption>
<graphic xlink:href="10.1177_0142331212444916-fig7.tif"/>
</fig>
</sec>
</sec>
<sec id="section18-0142331212444916" sec-type="conclusions">
<title>Conclusion and future work</title>
<p>In this paper, a mobile agent-based application reconfiguration method (MAAR) for WSNs is proposed. Our approach uses highly distributed agents to help the sensor nodes in reconfiguration decision-making. Reconfiguration is triggered by the changes of application requirements and is performed by transitioning to a new configuration. If a reconfiguration is needed, the mobile agent will send new application codes to these sensor nodes. Based on the mobile agents, the WSN can adaptively change application requirements to adapt to new applications in dynamic environments. The mobile agent-based method provides greater flexibility for collaboration between sensors and better performance than client/server reprogramming methods in terms of the communication time and energy cost.</p>
</sec>
</body>
<back>
<ack>
<p>The work in this paper has been supported by Scientific Research program funded by Natural Science Basis Research Plan in Shaanxi Province of China (program number 2011JQ8006) and Shanxi Provincial Education Department (program number 11JK1060).</p>
</ack>
<fn-group>
<fn fn-type="financial-disclosure">
<label>Funding</label>
<p>This research received no specific grant from any funding agency in the public, commercial, or not-for-profit sectors.</p>
</fn>
</fn-group>
<ref-list>
<title>References</title>
<ref id="bibr1-0142331212444916">
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Anthony</surname><given-names>A</given-names></name>
<name><surname>Jannett</surname><given-names>T</given-names></name>
</person-group> (<year>2010</year>) <article-title>A framework for using agents in distributed sensor networks</article-title>. <source>Proceedings of the IEEE SoutheastCon</source>, p. <fpage>337</fpage>.</citation>
</ref>
<ref id="bibr2-0142331212444916">
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Balani</surname><given-names>R</given-names></name>
<name><surname>Han</surname><given-names>C</given-names></name>
<name><surname>Rengaswamy</surname><given-names>RK</given-names></name>
<name><surname>Tsigkogiannis</surname><given-names>I</given-names></name>
<name><surname>Srivastava</surname><given-names>MB</given-names></name>
</person-group> (<year>2006</year>) <article-title>Multilevel software reconfiguration for sensor networks</article-title>. <conf-name>Proceedings of the International Conference on Embedded Software</conf-name>, pp. <fpage>112</fpage>–<lpage>121</lpage>.</citation>
</ref>
<ref id="bibr3-0142331212444916">
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Bapat</surname><given-names>S</given-names></name>
<name><surname>Arora</surname><given-names>A</given-names></name>
</person-group> (<year>2006</year>) <article-title>Stabilizing reconfiguration in wireless sensor networks</article-title>. <conf-name>Proceedings of the IEEE International Conference on Sensor Networks, Ubiquitous, and Trustworthy Computing</conf-name>, pp. <fpage>52</fpage>–<lpage>59</lpage>.</citation>
</ref>
<ref id="bibr4-0142331212444916">
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Bispo</surname><given-names>KA</given-names></name>
<name><surname>Freitas</surname><given-names>LHAD</given-names></name>
<name><surname>Rosa</surname><given-names>NS</given-names></name>
<name><surname>Cunha</surname><given-names>PRF</given-names></name>
<name><surname>Ribeiro</surname><given-names>CMFDA</given-names></name>
</person-group> (<year>2009</year>) <article-title>A reconfiguration approach using ontologies to save energy on WSNs</article-title>. <conf-name>Proceedings of the Third International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies</conf-name>, pp. <fpage>182</fpage>–<lpage>187</lpage>.</citation>
</ref>
<ref id="bibr5-0142331212444916">
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>De Vito</surname><given-names>S</given-names></name>
<name><surname>Di Palma</surname><given-names>P</given-names></name>
<name><surname>Ambrosino</surname><given-names>C</given-names></name>
<name><surname>Massera</surname><given-names>E</given-names></name>
<name><surname>Burrasca</surname><given-names>G</given-names></name>
<name><surname>Miglietta</surname><given-names>ML</given-names></name>
<name><surname>Di Francia</surname><given-names>G</given-names></name>
</person-group> (<year>2011</year>) <article-title>Wireless sensor networks for distributed chemical sensing: addressing power consumption limits with on-board intelligence</article-title>. <source>IEEE Sensors Journal</source> <volume>11</volume>: <fpage>947</fpage>–<lpage>955</lpage>.</citation>
</ref>
<ref id="bibr6-0142331212444916">
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Feeney</surname><given-names>LM</given-names></name>
<name><surname>Nilsson</surname><given-names>M</given-names></name>
</person-group> (<year>2001</year>) <article-title>Investigating the energy consumption of a wireless network interface in an ad hoc networking environment</article-title>. <conf-name>Proceedings of the IEEE International Conference on Computer Communications</conf-name>, pp. <fpage>1548</fpage>–<lpage>1557</lpage>.</citation>
</ref>
<ref id="bibr7-0142331212444916">
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Fok</surname><given-names>CL</given-names></name>
<name><surname>Roman</surname><given-names>GC</given-names></name>
<name><surname>Lu</surname><given-names>C</given-names></name>
</person-group> (<year>2005</year>) <article-title>Rapid development and flexible deployment of adaptive wireless sensor network applications</article-title>. <conf-name>Proceedings of the 25th International Conference on Distributed Computing Systems (ICDCS’05)</conf-name>, pp. <fpage>653</fpage>–<lpage>662</lpage>.</citation>
</ref>
<ref id="bibr8-0142331212444916">
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Hofmann</surname><given-names>MO</given-names></name>
<name><surname>Chacon</surname><given-names>D</given-names></name>
<name><surname>Mayer</surname><given-names>G</given-names></name>
<name><surname>Whitebread</surname><given-names>K</given-names></name>
<name><surname>Hendler</surname><given-names>J</given-names></name>
</person-group> (<year>2001</year>) <article-title>Cast agents: network-centric fires unleashed</article-title>. <conf-name>Proceedings of the National Fire Control Symposium</conf-name>, pp. <fpage>12</fpage>–<lpage>30</lpage>.</citation>
</ref>
<ref id="bibr9-0142331212444916">
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Horre</surname><given-names>W</given-names></name>
<name><surname>Lee</surname><given-names>K</given-names></name>
<name><surname>Hughes</surname><given-names>D</given-names></name>
<name><surname>Michiels</surname><given-names>S</given-names></name>
<name><surname>Joosen</surname><given-names>W</given-names></name>
</person-group> (<year>2009</year>) <article-title>A graph based approach to supporting reconfiguration in wireless sensor networks</article-title>. <conf-name>Proceedings of the Workshop on Application of Graph Theory in Wireless Ad hoc Networks and Sensor Networks (GRAPH-HOC 09)</conf-name>, pp. <fpage>326</fpage>–<lpage>331</lpage>.</citation>
</ref>
<ref id="bibr10-0142331212444916">
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Kogekar</surname><given-names>S</given-names></name>
<name><surname>Neema</surname><given-names>S</given-names></name>
<name><surname>Koutsoukos</surname><given-names>X</given-names></name>
</person-group> (<year>2005</year>) <article-title>Dynamic software reconfiguration in sensor networks</article-title>. <source>Proceedings of the Systems Communications</source>, <fpage>413</fpage>–<lpage>420</lpage>.</citation>
</ref>
<ref id="bibr11-0142331212444916">
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Konstantopoulos</surname><given-names>C</given-names></name>
<name><surname>Mpitziopoulos</surname><given-names>A</given-names></name>
<name><surname>Gavalas</surname><given-names>D</given-names></name>
<name><surname>Pantziou</surname><given-names>G</given-names></name>
</person-group> (<year>2010</year>) <article-title>Effective determination of mobile agent itineraries for data aggregation on sensor networks</article-title>. <source>IEEE Transactions on Knowledge and Data Engineering</source> <volume>22</volume>: <fpage>1679</fpage>–<lpage>1693</lpage>.</citation>
</ref>
<ref id="bibr12-0142331212444916">
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Maleki</surname><given-names>S</given-names></name>
<name><surname>Pandharipande</surname><given-names>A</given-names></name>
<name><surname>Leus</surname><given-names>G</given-names></name>
</person-group> (<year>2011</year>) <article-title>Energy-efficient distributed spectrum sensing for cognitive sensor networks</article-title>. <source>IEEE Sensors Journal</source> <volume>11</volume>: <fpage>565</fpage>–<lpage>573</lpage>.</citation>
</ref>
<ref id="bibr13-0142331212444916">
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Ruiz</surname><given-names>LB</given-names></name>
<name><surname>Braga</surname><given-names>TRM</given-names></name>
<name><surname>Silva</surname><given-names>FA</given-names></name>
<name><surname>Assuncao</surname><given-names>HP</given-names></name>
<name><surname>Nogueira</surname><given-names>JMS</given-names></name>
<name><surname>Loureiro</surname><given-names>AAF</given-names></name>
</person-group> (<year>2005</year>) <article-title>On the design of a self-managed wireless sensor network</article-title>. <source>IEEE Communications Magazine</source> <volume>8</volume>: <fpage>95</fpage>–<lpage>102</lpage>.</citation>
</ref>
<ref id="bibr14-0142331212444916">
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Sheu</surname><given-names>RY</given-names></name>
<name><surname>Czajkowski</surname><given-names>M</given-names></name>
<name><surname>Hofmann</surname><given-names>M</given-names></name>
</person-group> (<year>2007</year>) <article-title>Adaptive peer-to-peer agent sensor networks</article-title>. <conf-name>Proceedings of the First International Workshop on Agent Technology for Sensor Networks (ATSN-07)</conf-name>.</citation>
</ref>
<ref id="bibr15-0142331212444916">
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Vigna</surname><given-names>G</given-names></name>
</person-group> (<year>2004</year>) <article-title>Mobile agents: ten reasons for failure</article-title>. <conf-name>Proceedings of the International Conference on Mobile Data Management</conf-name>, pp. <fpage>298</fpage>–<lpage>299</lpage>.</citation>
</ref>
</ref-list>
</back>
</article>