<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD Journal Publishing DTD v2.3 20070202//EN" "journalpublishing.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">JIS</journal-id>
<journal-id journal-id-type="hwp">spjis</journal-id>
<journal-title>Journal of Information Science</journal-title>
<issn pub-type="ppub">0165-5515</issn>
<issn pub-type="epub">1741-6485</issn>
<publisher>
<publisher-name>SAGE Publications</publisher-name>
<publisher-loc>Sage UK: London, England</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1177/0165551512437532</article-id>
<article-id pub-id-type="publisher-id">10.1177_0165551512437532</article-id>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Articles</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>An approach for developing a schemaless XML dataspace profiling system</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" corresp="yes">
<name><surname>Näppilä</surname><given-names>Turkka</given-names></name>
<aff id="aff1-0165551512437532">University of Tampere, Finland</aff>
</contrib>
<contrib contrib-type="author">
<name><surname>Niemi</surname><given-names>Timo</given-names></name>
<aff id="aff2-0165551512437532">University of Tampere, Finland</aff>
</contrib>
</contrib-group>
<author-notes>
<corresp id="corresp1-0165551512437532">Turkka Näppilä, Research Center for Information and Systems (CIS), School of Information Sciences, Kanslerinrinne 1, 33014 University of Tampere, Finland. Email: <email>turkka.nappila@uta.fi</email></corresp>
</author-notes>
<pub-date pub-type="epub-ppub">
<month>6</month>
<year>2012</year>
</pub-date>
<volume>38</volume>
<issue>3</issue>
<fpage>234</fpage>
<lpage>257</lpage>
<permissions>
<copyright-statement>© The Author(s) 2012</copyright-statement>
<copyright-year>2012</copyright-year>
<copyright-holder content-type="sage">Chartered Institute of Library and Information Professionals</copyright-holder>
</permissions>
<abstract>
<p>Dataspace systems have been proposed recently as an alternative to the traditional data integration approach. They offer reduced setup time and costs by allowing cooperation among the data sources based on the knowledge gained gradually through user interaction. A dataspace is a collection of heterogeneous and beforehand unfamiliar but interrelated data sources. In this article, we consider dataspaces composed of XML-based data sources. The XML query and analysis systems designed to satisfy the user’s sophisticated information needs presuppose that they are familiar with the contents, structures and semantics of the underlying data sources. In order to provide this information, we introduce and specify a schemaless XML dataspace profiling system that assists the user in selecting data sources relevant to him/her and in validating their consistency by detecting the potential data conflicts among them. We also demonstrate how our approach affords the possibility of utilizing an advanced XML query system.</p>
</abstract>
<kwd-group>
<kwd>data conflicts</kwd>
<kwd>dataspaces</kwd>
<kwd>dataspace profiling</kwd>
<kwd>formal specification</kwd>
<kwd>XML</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="section1-0165551512437532" sec-type="intro">
<title>1. Introduction</title>
<p>More and more applications require cooperation between autonomous and heterogeneous data sources. Depending on whether the data sources are beforehand well-known and under the control of a single organization or whether they are mostly unfamiliar and controlled by multiple organizations, two kinds of approaches have been proposed to organize this cooperation. Data integration systems have been intended as a solution for the former case. Typically, they provide the user with a global schema (a virtual view) based on which they are able make queries over the available data sources. In data integration systems, all semantic relationships between data sources have been specified precisely in advance. Sub-queries, which are executed in local environments, are automatically generated through the mappings between a global schema and the local schemata. This kind of mechanism has been proposed, among others, for integrating relational data (e.g. [<xref ref-type="bibr" rid="bibr1-0165551512437532">1</xref>]) and OLAP cubes (e.g. [<xref ref-type="bibr" rid="bibr2-0165551512437532">2</xref>]). Another popular technique for enabling better cooperation between beforehand familiar data sources is data translation. In data translation, a data source or its part is customized (e.g. through renaming and restructuring) into a form more compatible with other available data sources. In this approach, the desired target data are constructed from source data based on schema mapping specifications between their schemata. Usually, this requires that both the source and target data are based on the same data model, for example, the relational model (e.g. [<xref ref-type="bibr" rid="bibr3-0165551512437532">3</xref>]) or XML (e.g. [<xref ref-type="bibr" rid="bibr4-0165551512437532">4</xref>]). In addition, in data translation the schema mappings are assumed to induce the corresponding changes at the instance level.</p>
<p>In the latter case, the autonomous and beforehand unfamiliar data sources, which should cooperate, may belong to one or more conceptual domains. In the context of a single conceptual domain, the information needs typically emerge unexpectedly and require comparing and analysing data on organizations, persons, results and so on. On the other hand, some applications, such as criminal investigation and investigative journalism, call for discovering semantic relationships among data sources that belong to disparate conceptual domains. These two situations are combined with the fact that they both necessitate fusing data from data sources that have not originally been intended to cooperate. In these kinds of situations, the user usually has little familiarity with the contents, structures and semantics of the underlying data sources. Thus, one cannot assume that some integration system, in which the semantic relationships among data would have been established, would be readily available. Besides, building such an integration system would be a costly and time-consuming project and hardly appropriate if the information needs are non-permanent or short-term. For this reason, we need a different kind of approach.</p>
<p><italic>Dataspace</italic> systems [<xref ref-type="bibr" rid="bibr5-0165551512437532">5</xref>, <xref ref-type="bibr" rid="bibr6-0165551512437532">6</xref>] have been proposed to address this challenge. A dataspace is a collection of data sources that intend to provide all of the information relevant to a particular user or task, regardless of the format of the underlying data sources or of the systems and interfaces through which they are accessed. Unlike traditional data integration systems, dataspace systems do not require full semantic integration of the available data sources in order to provide useful services [<xref ref-type="bibr" rid="bibr6-0165551512437532">6</xref>]. In fact, the central idea behind the dataspace approach is that the integration between the data sources in a dataspace is tightened in a pay-as-you-go fashion as the user’s understanding about the dataspace increases over time [<xref ref-type="bibr" rid="bibr7-0165551512437532">7</xref><xref ref-type="bibr" rid="bibr8-0165551512437532"/>–<xref ref-type="bibr" rid="bibr9-0165551512437532">9</xref>]. This kind of approach results in reduced setup time and costs, both of which have thus far hindered the widespread adoption of data integration systems [<xref ref-type="bibr" rid="bibr10-0165551512437532">10</xref>]. However, as the dataspace technology is still in its infancy, several major issues remain to be solved, as identified in [<xref ref-type="bibr" rid="bibr6-0165551512437532">6</xref>]. One of the most important of them is to develop mechanisms for exploring the contents, structures and semantics of beforehand unfamiliar, autonomous and heterogeneous data sources. We address this issue in the present article.</p>
<p>While the dataspace approaches in [<xref ref-type="bibr" rid="bibr11-0165551512437532">11</xref><xref ref-type="bibr" rid="bibr12-0165551512437532"/>–<xref ref-type="bibr" rid="bibr13-0165551512437532">13</xref>] operate with a generic triple model, we assume that all available data sources are based on XML (Extensible Markup Language) [<xref ref-type="bibr" rid="bibr14-0165551512437532">14</xref>]. By relying on a single data format, we are able to avoid several problems originating from the diversity of data formats, which has traditionally been one of the main obstacles to large-scale data exchange. XML is a natural choice since, as a platform-independent data format, it is both the leading mark-up language for representing documents and the standard for exchanging data on the Web. For example, the RDF documents [<xref ref-type="bibr" rid="bibr15-0165551512437532">15</xref>] used in the Semantic Web are, in fact, XML documents with a specialized fixed structure. In addition, most business-to-business (B2B) applications are nowadays based on XML with a vocabulary tailored for a specific business domain [<xref ref-type="bibr" rid="bibr16-0165551512437532">16</xref>]. Two types of XML data sources can be distinguished [<xref ref-type="bibr" rid="bibr17-0165551512437532">17</xref>]. Document-centric XML data sources are lightly structured and contain large proportions of text, whereas data-centric XML documents – which are the focus of this article – are typically deeply nested hierarchically and their textual contents are compact. Many other existing data formats can also be converted into XML. For example, all major relational database vendors, such as IBM, Microsoft and Oracle, support the XML-based publishing of relational data in their products [<xref ref-type="bibr" rid="bibr18-0165551512437532">18</xref>]. For these reasons, it is rather obvious that XML greatly promotes the interoperability and integration among data sources [<xref ref-type="bibr" rid="bibr8-0165551512437532">8</xref>]. Because of its central role in today’s data management, we are convinced that it is useful to adopt XML as the core data format in developing dataspace systems.</p>
<p>Much of the user’s interaction with a dataspace system is of an exploratory nature [<xref ref-type="bibr" rid="bibr11-0165551512437532">11</xref>], meaning that, through it, the user tries to find out how suitable the data sources in the dataspace are from the perspective of their information needs. The authors in [<xref ref-type="bibr" rid="bibr13-0165551512437532">13</xref>] call this kind of interaction <italic>dataspace profiling</italic>, analogous to <italic>database profiling</italic>, which has been defined in [<xref ref-type="bibr" rid="bibr19-0165551512437532">19</xref>] as ‘the process of analysing the database to determine its structure and internal relationships’. Through structural profiling, the user gains such knowledge of the underlying dataspace, which they can utilize, among others, in assessing the usefulness of a particular data source or the need to customize the relevant data sources so that they are more suitable to a particular use. When profiling XML data, its special characteristics need to be taken into account. First, owing to its semi-structured nature, the schema-level and instance-level information co-exist in an XML document. Second, the data in an XML document are hierarchical, meaning that the ancestor–descendant relationships between data items at the different levels of the document hierarchy define their interrelationships and serve as the context for attaching semantic interpretation to individual data items. Third, as XML data are self-describing in that the document creator can freely label the data items in their documents, no external schemata need to be provided. These special characteristics of XML data give the starting point for <italic>XML dataspace profiling</italic>.</p>
<p>An XML dataspace is a conglomeration of XML documents collected from autonomous and heterogeneous data sources for a particular task or purpose. The data sources in an XML dataspace may or may not have originally been XML-based, which means that an XML dataspace consists both of native XML data sources and of data sources converted into XML. Due to the nature of XML dataspaces and the special characteristics of XML data, XML dataspace profiling serves two main goals:</p>
<list id="list1-0165551512437532" list-type="order">
<list-item><p>assessing the usefulness of the available XML data sources from the perspective of the user’s information needs based on the content and structure analyses, and</p></list-item>
<list-item><p>validating the consistency of the relevant XML data sources by means of detecting the potential data conflicts among them.</p></list-item>
</list>
<p>The latter goal may lead to the customization of the data sources in order to make them more suitable for further utilization. In this article, we develop an architecture for an XML dataspace profiling system, which comprises mechanisms in terms of which the user is able to gradually increase their understanding of the available XML data sources with which they are not beforehand familiar. In turn, this increased understanding allows the user to utilize advanced query systems (such as XQuery [<xref ref-type="bibr" rid="bibr20-0165551512437532">20</xref>] and RXQL [<xref ref-type="bibr" rid="bibr21-0165551512437532">21</xref>]) to satisfy their information needs. To our best knowledge, this is the first work to consider XML dataspace profiling.</p>
<p>As the authors in [<xref ref-type="bibr" rid="bibr22-0165551512437532">22</xref>], we also see that in the future more and more XML applications will be used alongside relational databases in enterprise information systems. For this reason, the seamless integration between relational databases and XML is required. This, in turn, presupposes that the same principles can be used to represent both kinds of data. Although several approaches propose relational databases for storing and modelling XML data (e.g. [<xref ref-type="bibr" rid="bibr23-0165551512437532">23</xref><xref ref-type="bibr" rid="bibr24-0165551512437532"/>–<xref ref-type="bibr" rid="bibr25-0165551512437532">25</xref>]), this is problematic because of the fundamental differences between XML and relational data. Whereas XML data are hierarchical, semi-structured and ordered, relational data are flat, structured and unordered. Owing to this basic mismatch, it is very hard, if not practically impossible, to map XML data unambiguously to the traditional relational data model [<xref ref-type="bibr" rid="bibr26-0165551512437532">26</xref>]. For this reason, we modified the notion of relation behind the conventional relational databases so that it can also accommodate semi-structured XML data. We call this notion of relation the XML relation, and formally defined it in [<xref ref-type="bibr" rid="bibr27-0165551512437532">27</xref>, <xref ref-type="bibr" rid="bibr28-0165551512437532">28</xref>]. Any textual XML document can be mapped unambiguously to the XML relation representation and vice versa. Since an XML relation consists of three-tuples (triples), we are able to utilize the relational database technology for storing XML data efficiently. In [<xref ref-type="bibr" rid="bibr21-0165551512437532">21</xref>], we introduced the RXQL query language based on XML relations, and discussed in this context how the expressive and storing power of existing relational databases was utilized in its implementation. In the present article, we show that the XML relation representation provides a powerful starting point also for XML dataspace profiling, and therefore we assume that the data sources in the XML dataspace are represented as XML relations (the XML relation representation will be introduced later in Section 3).</p>
<p>In particular, we show how the XML relation representation affords the possibility of specifying an architecture for an XML dataspace profiling system. The architecture contains the mechanisms for the following specific purposes:</p>
<list id="list2-0165551512437532" list-type="order">
<list-item><p>to analyse the information contents of the data sources in an XML dataspace at the schema level and at the instance level;</p></list-item>
<list-item><p>to discover the structural relationships among data items in an XML dataspace;</p></list-item>
<list-item><p>to assist the user in attaching the correct semantic interpretation to the available data item names;</p></list-item>
<list-item><p>to assist the user in detecting potential data conflicts among the data sources in an XML dataspace;</p></list-item>
<list-item><p>based on the outcome of the data conflict detection, to customize the data sources in the XML dataspace to be more suitable for advanced manipulation;</p></list-item>
<list-item><p>to demonstrate how the proposed XML dataspace profiling approach supports the effective utilization of advanced query systems.</p></list-item>
</list>
<p>The remainder of the article is organized as follows. In Section 2, related work is reviewed. Section 3 introduces the sample XML dataspace and notation related to the XML relation representation. Both of these are utilized in the later sections. In Section 4, we present our XML dataspace profiling approach in detail by defining formal tools for assessing the usefulness of the available XML data sources and for validating the consistency of the chosen documents by means of detecting the potential data conflicts among them. Section 5 demonstrates how our XML dataspace profiling approach serves as a prerequisite for effective use of an advanced XML query system. Section 6 contains discussion, and conclusions are given in Section 7.</p>
</sec>
<sec id="section2-0165551512437532">
<title>2. Related work</title>
<p>In the dataspace approach, the desired result is typically achieved through a sequence of interactions with the underlying data sources. Through each of the interactions, the user’s knowledge and understanding of the available data sources increase incrementally based on the outcome of the previous actions. The initial knowledge of unfamiliar data sources is usually gained through information retrieval (IR)-like keyword search [<xref ref-type="bibr" rid="bibr5-0165551512437532">5</xref>]. However, [<xref ref-type="bibr" rid="bibr11-0165551512437532">11</xref>] introduces a system with a search and query interface which, unlike traditional keyword search-based systems, allows the user to take the structural aspects into account also when they are present. They represent the data in the underlying dataspace as resource–property–value triples. The focus in their work is on developing indexing techniques that support flexible querying of dataspaces composed of these triples. However, they do not consider how these triples are produced but take them as given. By contrast, our work focuses on providing the user with such information that enables them to assess the usefulness and consistency of the beforehand unknown data sources in the underlying dataspace without the need to extensively pre-process the data sources.</p>
<p>Also, the approaches in [<xref ref-type="bibr" rid="bibr12-0165551512437532">12</xref>, <xref ref-type="bibr" rid="bibr13-0165551512437532">13</xref>] are based on the triple representation of the data in the underlying dataspace; [<xref ref-type="bibr" rid="bibr12-0165551512437532">12</xref>] introduces a pay-as-you-go data integration technique, <italic>iTrails</italic>, which enriches the semantic integration between what were originally loosely coupled data sources in a dataspace through <italic>trails</italic>. A trail is a piece of information on some specific property of the underlying data sources. Trails can be used, for example, for query expansion. They are added to the system in the course of the user’s actions. However, it is again assumed that an initial set of trails is given in advance, but no attention is paid to how this set is produced in practice. The main focus of the work is on improving the exploitation of trails with respect to gain and relevance. In [<xref ref-type="bibr" rid="bibr13-0165551512437532">13</xref>], the starting point is that the user has no knowledge of the structures and properties of the data sources in the underlying dataspace. Hence, they develop a system, called <italic>Quarry</italic>, which allows the user to browse and query (profile) the dataspace without having to consider how the underlying data are stored and managed. In the context of <italic>Quarry</italic>, the profiling essentially means examining the characteristics of the paths, which are formed of the relationships among the underlying resource–property–value triples. Similarly to the approaches in [<xref ref-type="bibr" rid="bibr11-0165551512437532">11</xref>, <xref ref-type="bibr" rid="bibr12-0165551512437532">12</xref>], <italic>Quarry</italic> also presupposes that the initial set of triples is provided in advance, this time by domain experts. However, in our approach the user does not necessarily need to possess extensive domain knowledge but we provide them with mechanisms to also explore the contents of data sources with which they are not beforehand familiar.</p>
<p>Since XML is based on the semi-structured data model, where the schema-level and instance-level information co-exist in the data, no exact external schema can be attached to the XML data. Although the well-known DTD [<xref ref-type="bibr" rid="bibr14-0165551512437532">14</xref>] or XML Schema [<xref ref-type="bibr" rid="bibr29-0165551512437532">29</xref>] descriptions resemble conventional database schemata, they do not constrain the data as relational schemata do, but typically only list the alternative ways to organize data and the data item names that may occur in valid documents. Furthermore, since DTDs and XML Schemas are an optional feature in the XML standard, most of the real-world XML documents do not contain them at all [<xref ref-type="bibr" rid="bibr30-0165551512437532">30</xref>]. In other words, most XML data sources are schemaless. This is also the starting point in our approach.</p>
<p>Queries into XML data can be specified by XML data manipulation languages with computationally complete expressive power (such as XQuery [<xref ref-type="bibr" rid="bibr20-0165551512437532">20</xref>]) or by specific XML query languages with more limited expressive power (e.g. XML-QL [<xref ref-type="bibr" rid="bibr31-0165551512437532">31</xref>], XML-GL [<xref ref-type="bibr" rid="bibr32-0165551512437532">32</xref>] and RXQL [<xref ref-type="bibr" rid="bibr21-0165551512437532">21</xref>]). However, the effective use of all of these languages requires that the user is at least to some extent familiar with the data item names and their related semantics among the available data sources. When the user operates with unfamiliar XML data sources, they are not able to use the above languages without at first profiling the contents and structures of the available documents. Dataspace profiling was proposed for the first time in [<xref ref-type="bibr" rid="bibr13-0165551512437532">13</xref>]. Unfortunately, they only consider profiling the unfamiliar structural relationships among the available data sources but assume that the users master their contents. By contrast, in this article we present such an XML dataspace profiling approach in terms of which the user is able to acquire knowledge of both contentual and structural aspects of beforehand unfamiliar XML data sources, and which also assists them in the utilization of available XML languages.</p>
<p>The XML query and analysis systems intended to satisfy sophisticated information needs typically presuppose that the data in the available data sources are not conflicting. However, this assumption often does not hold in the context of querying and manipulating autonomous and heterogeneous XML data sources. This means that it is necessary to develop mechanisms both for detecting and for resolving the existing data conflicts. Our work in [<xref ref-type="bibr" rid="bibr28-0165551512437532">28</xref>] was the first to classify the data conflict types possible among XML data. They are characterized as follows:</p>
<list id="list3-0165551512437532" list-type="alpha-lower">
<list-item>
<p><italic>Document-to-document conflicts</italic> are related to cases where the same information content is organized by different XML structures in different XML documents.</p></list-item>
<list-item><p><italic>Attribute-to-element</italic> conflict occurs if the same data item is represented both as an attribute and as an element.</p></list-item>
<list-item><p><italic>Data item-to-data item conflicts</italic> appear if semantically equivalent data items are labelled differently or semantically non-equivalent data items are labelled identically.</p></list-item>
<list-item><p>In <italic>data item-to-value conflict</italic>, the semantically equivalent piece of information is represented both as an (attribute) element name and as an (attribute) element value.</p></list-item>
<list-item><p>In <italic>value-to-value conflict</italic>, semantically equivalent data item values have been represented non-uniformly.<sup><xref ref-type="fn" rid="fn1-0165551512437532">1</xref></sup></p></list-item>
</list>
<p>The data conflict types (b–e) may occur either within a single XML document or between multiple documents. A possible approach to detecting and resolving some of these data conflict types is to combine schema extraction and data translation techniques with each other. In this approach, first a DTD or an XML Schema description is constructed for each data source by applying some XML-based schema extraction tool (e.g. [<xref ref-type="bibr" rid="bibr34-0165551512437532">34</xref>, <xref ref-type="bibr" rid="bibr35-0165551512437532">35</xref>]). After that, data conflicts are removed by some XML-based data translation tools (e.g. [<xref ref-type="bibr" rid="bibr3-0165551512437532">3</xref>, <xref ref-type="bibr" rid="bibr4-0165551512437532">4</xref>]). In principle, the data conflict types (a–c) can be resolved in this way. However, the conflict types (d) and (e) cannot. This is due to the fact that in the data translation approach the renaming and restructuring operations, which are specified through schema mappings, result in the corresponding changes at the instance level. However, this kind of approach does not provide mechanisms for replacing values or pivoting data from the instance level into the schema level and vice versa.</p>
<p>Since data conflicts are common in autonomous and heterogeneous XML data sources, we pay special attention in our XML dataspace profiling approach to assist the user in their detection. In [<xref ref-type="bibr" rid="bibr21-0165551512437532">21</xref>], we introduced the RXQL query language and showed that the data conflict types (a–d) can be resolved in a straightforward manner through it provided that the user is aware of their existence. However, the nature of the data conflict type (e) differs from the other data conflict types in that it covers only the instance level, and its resolving consequently requires modification of the original data sources. Typically, the data conflicts of type (e) need to be resolved during the data cleaning process (e.g. [<xref ref-type="bibr" rid="bibr36-0165551512437532">36</xref>]) in the context of the construction of data warehouses or other data repositories in regular use. In this article, we show that also this data conflict type can be resolved based on the information acquired by XML dataspace profiling.</p>
<p>As recognized in [<xref ref-type="bibr" rid="bibr11-0165551512437532">11</xref>], the effective search over the dataspace requires that all relevant data (e.g. data items, words in text, numeric values and schema components) are indexed. Since our dataspace profiling approach is based on the XML relation representations of the available data sources, we have such an indexing mechanism as built-in. Namely, in the XML relation representation, all data item occurrences and their related values are equipped with a unique structural index, often called Dewey number [<xref ref-type="bibr" rid="bibr37-0165551512437532">37</xref>]. Similar indices have also been used to index hierarchical data structures [<xref ref-type="bibr" rid="bibr38-0165551512437532">38</xref>]. Our indexing mechanism also resembles the ORDPATH indexing of XML data [<xref ref-type="bibr" rid="bibr39-0165551512437532">39</xref>]. However, in ORDPATH a unique index is used to refer to each element/attribute occurrence, including its entire textual content, whereas in the XML relation representation each textual value has been indexed separately. If a value consists of multiple words, then each individual word has its own unique index. Hence, our indexing scheme allows, among others, the straightforward building of inverted indexes to improve searches.</p>
</sec>
<sec id="section3-0165551512437532">
<title>3. Sample XML dataspace and notations</title>
<sec id="section4-0165551512437532">
<title>3.1. Sample XML dataspace</title>
<p>Our sample XML dataspace consists of four documents, as given in <xref ref-type="fig" rid="fig1-0165551512437532">Figure 1(a–d)</xref>. The sample documents contain information about albums of classical music by four different record labels. The documents describe the publisher of the album (label); the album’s serial or catalogue number; its release date and title; the composers (authors) whose works are presented in the album; the titles of the works; the names of the artists (soloists, ensembles and conductors) who perform in the album; and the price of the album.</p>
<fig id="fig1-0165551512437532" position="float">
<label>Figure 1.</label>
<caption><p>The sample XML dataspace.</p></caption>
<graphic xlink:href="10.1177_0165551512437532-fig1.tif"/>
</fig>
<p>The album information for each of the four sample documents is represented using slightly different terminology and document structures. In other words, our sample XML dataspace describes a situation typical among autonomous and heterogeneous data sources, where several data conflict types appear simultaneously. In fact, all data conflict types presented in Section 2 occur among the sample documents. For example, the album information is represented in each document using slightly different structures. This means that the document-to-document conflict occurs between all our documents. Also element-to-element conflict occurs, since, for example, in <italic>doc4.xml</italic> the <italic>title</italic> element occurrences have different intended meanings (in the context of the <italic>album</italic> element occurrence the <italic>title</italic> element occurrence expresses the title of the album, whereas in the context of the <italic>work</italic> element the <italic>title</italic> element occurrences express the name of the work). Further, the names of the composers whose works the album contains are represented in <italic>doc2.xml</italic> as values of <italic>composer</italic> attribute occurrences, while in <italic>doc3.xml</italic> the same information is represented as the value of a <italic>composer</italic> element occurrence. This means that the attribute-to-element conflict occurs between these two documents. Similarly, value-to-attribute/element conflict occurs between <italic>doc1.xml</italic> and the rest of the sample documents, since the name ‘Sibelius’ is represented as an element name in <italic>doc1.xml</italic>, whereas the other documents represent his names as values of the <italic>composer</italic> or <italic>author</italic> element and attribute occurrences. Finally, by looking at, for example, the values of the <italic>composer</italic> element/attribute occurrences throughout the sample XML dataspace, one can easily observe that the name ‘Jean Sibelius’ is spelled differently in their related values. This implies that also the value-to-value conflicts occur among the sample XML documents.</p>
</sec>
<sec id="section5-0165551512437532">
<title>3.2. Notation</title>
<p>Since the XML dataspace profiling approach developed in this article assumes that all the available data sources are represented as XML relations, we next introduce this notation briefly. Formally, an XML relation is a named ternary relation with the schema <italic>D</italic>(<italic>C, T, I</italic>), where <italic>D</italic> stands for the name of an XML document (data source); <italic>C</italic> expresses a data item occurrence (i.e. an element name an attribute name or a value related to them); <italic>T</italic> expresses the type of <italic>C</italic> (possible alternatives are ‘a’, ‘e’ or ‘v’ for an attribute name an element name or a value, respectively); and <italic>I</italic> is an index expressing the exact and unambiguous location of <italic>C</italic> in <italic>D</italic>. For example, the XML relation representation for the root element of the sample document <italic>doc1.xml</italic> in <xref ref-type="fig" rid="fig1-0165551512437532">Figure 1(a)</xref> is the triple (album, ‘e’, 〈1〉). In an XML document, an attribute or element name may have several occurrences, which means that an XML relation may contain triples in which the values of <italic>C</italic> and <italic>T</italic> components are identical but the values of their <italic>I</italic> components differ. In other words, <italic>I</italic> is the key attribute of the XML relation <italic>D</italic>. In [<xref ref-type="bibr" rid="bibr28-0165551512437532">28</xref>], we defined for the XML relation representation a constructor algebra with the closure property. This algebra defines the rules based on which new element and attribute occurrences are created and concatenated to each other in order to construct more complex XML structures. The constructor algebra contains an automatic re-indexing mechanism. Based on the above, it is clear that the XML relation differs considerably from the notion of the relation in relational databases. For example, tuples in conventional relational databases contain only data belonging to the instance level (i.e. the values of the attributes of the relation), whereas the tuples in an XML relation may belong both to the schema level (an attribute/element name as a <italic>C</italic> component) and to the instance level (a value as a <italic>C</italic> component). Besides, the <italic>I</italic> component does not actually belong to either of these levels because it expresses the hierarchical order of the data in <italic>D</italic>. The XML relation representations for the documents in <xref ref-type="fig" rid="fig1-0165551512437532">Figure 1</xref> are given in <xref ref-type="table" rid="table1-0165551512437532">Tables A1</xref>–<xref ref-type="table" rid="table4-0165551512437532">A4</xref> (see <xref ref-type="app" rid="app1-0165551512437532">Appendix</xref>).</p>
<p>Apart from the XML relation representation, we also need to define some additional notations and properties. As stated, the indices in the XML relation representation (i.e. occurrences of the component <italic>I</italic>) are Dewey-style structural indices. In our indexing scheme, the root element of an XML document is always equipped with the index 〈1〉, its first immediate successor with the index 〈1,1〉, the first immediate successor of the former data item with the index 〈1,1,1〉 and so on. Structural indices allow us to effectively access the ancestors and successors of a given data item occurrence. All the indices in an XML relation have the same first index number (1), indicating that they all depend on the very same root element.</p>
<p>Index manipulation plays an important role in the processing of XML relations. We refer to two arbitrary parts, say <italic>part</italic><sub>1</sub> and <italic>part</italic><sub>2</sub> of an index <italic>index</italic> as <italic>index</italic> = 〈<italic>part</italic><sub>1</sub>┴<italic>part</italic><sub>2</sub>〉. Here, <italic>part</italic><sub>1</sub> contains the index numbers related to the first part of <italic>index</italic>, whereas <italic>part</italic><sub>2</sub> is the sub-index consisting of the remaining index numbers. In future, we use either the symbol ξ or a string (e.g. <italic>ind</italic>) to refer to a sub-index consisting of one or more index numbers, whereas a single letter or an integer (e.g. <italic>i</italic> or 1) is used to refer to exactly one index number. Thus, for example, the expression 〈<italic>i</italic>┴ξ〉 applied to the index 〈1,2,3,4〉 means that <italic>i</italic> stands for the index number 1 and ξ is the sub-index 〈2,3,4〉. Likewise, in the context of the above index the expression 〈<italic>ind</italic>┴<italic>j</italic>〉 means that <italic>ind</italic> = 〈1,2,3〉 and <italic>j</italic> = 4. Correspondingly, the expression 〈<italic>i,j</italic>┴ξ〉 would result in <italic>i</italic> = 1, <italic>j</italic> = 2 and ξ = 〈3,4〉. The above expressions can also be used to generate new indices. For example, if <italic>S</italic> is the index set {〈1〉, 〈2〉, 〈3,4〉}, then the set expression {〈1 ┴<italic>ind</italic>〉 | <italic>ind</italic>∈<italic>S</italic>} generates the index set {〈1,1〉, 〈1,2〉, 〈1,3,4〉}. Analogously, if <italic>ind</italic> is the index 〈1,2,3〉, then the expression 〈<italic>ind</italic>┴ 4〉 stands for the index 〈1,2,3,4〉.</p>
<p>If the content of a data item occurrence consists of a string in which the substrings (i.e. individual words and/or number sequences) have been delimited by space characters, then each of these substrings is individually indexed in the XML relation and is represented as a triple with the type ‘v’. However, as in data-centric applications the textual contents of the available data item occurrences are typically compact, it would often be useful to be able to manipulate them as one, undivided string. This kind of value is called <italic>compound value</italic>.</p>
<p>A compound value is constructed by concatenating strings comprised of the textual contents of a data item occurrence. For example, the compound value (“Jean Sibelius: Symphonies Nos. 4-7”, ‘v’ 〈1,5,1〉) in the XML relation representation of the sample document <italic>doc1.xml</italic> (see <xref ref-type="table" rid="table1-0165551512437532">Table A1</xref> in <xref ref-type="app" rid="app1-0165551512437532">Appendix</xref>) has been constructed by concatenating the original triples (Jean, ‘v’, 〈1,5,1〉), (Sibelius:, ‘v’, 〈1,5,2〉), (Symphonies, ‘v’, 〈1,5,3〉), (Nos., ‘v’, 〈1,5,4〉) and (4-7, ‘v’, 〈1,5,5〉). In the definition of the function <italic>compound-value</italic> below, we apply the function <italic>concat</italic> which concatenates two arbitrary strings, <italic>string</italic><sub>1</sub> and <italic>string</italic><sub>2</sub>, as follows: concat(<italic>string</italic><sub>1</sub>, <italic>string</italic><sub>2</sub>) = “<italic>string</italic><sub>1</sub><italic>string</italic><sub>2</sub>” (i.e. the two strings are separated by a space character).</p>
<p>Let us assume that the contents of a data item occurrence with the index <italic>index</italic> consist of separate strings in the XML relation <italic>doc</italic>. Now, the compound value for the contents of this data item occurrence is constructed by applying the function compound-value(<italic>doc</italic>, 〈<italic>index</italic>┴ 1〉), which is formally defined as follows:</p>
<p><disp-formula id="disp-formula1-0165551512437532">
<mml:math display="block" id="math1-0165551512437532">
<mml:mrow>
<mml:mtable align="right" width="80%">
<mml:mtr>
<mml:mtd columnalign="right" columnspan="1">
<mml:mrow>
<mml:mtext>compound-value</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mrow>
<mml:mo>〈</mml:mo>
<mml:mi>index</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo>⊥</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>i</mml:mi>
<mml:mo>〉</mml:mo>
</mml:mrow>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mrow>
<mml:mo>{</mml:mo>
<mml:mtable align="left">
<mml:mtr>
<mml:mtd columnalign="center">
<mml:mrow>
<mml:mtext>concat</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>value</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext>compound-value</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mrow>
<mml:mo>〈</mml:mo>
<mml:mi>index</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo>⊥</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>i</mml:mi>
<mml:mo>+</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>〉</mml:mo>
</mml:mrow>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="center" columnspan="1">
<mml:mrow>
<mml:mspace width="0.25em"/>
<mml:mtext>if</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>value</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext>‘v’</mml:mtext>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mrow>
<mml:mo>〈</mml:mo>
<mml:mi>index</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo>⊥</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>i</mml:mi>
<mml:mo>〉</mml:mo>
</mml:mrow>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo>∧</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>_</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext>‘v’</mml:mtext>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mrow>
<mml:mo>〈</mml:mo>
<mml:mi>index</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo>⊥</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>i</mml:mi>
<mml:mo>+</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>〉</mml:mo>
</mml:mrow>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mi>doc</mml:mi>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="center" columnspan="1">
<mml:mrow>
<mml:mi>value</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="center" columnspan="1">
<mml:mrow>
<mml:mspace width="0.25em"/>
<mml:mtext>if</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>value</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext>‘v’</mml:mtext>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mrow>
<mml:mo>〈</mml:mo>
<mml:mi>index</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo>⊥</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>i</mml:mi>
<mml:mo>〉</mml:mo>
</mml:mrow>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo>∧</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>_</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext>‘v’</mml:mtext>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mrow>
<mml:mo>〈</mml:mo>
<mml:mi>index</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo>⊥</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>i</mml:mi>
<mml:mo>+</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>〉</mml:mo>
</mml:mrow>
<mml:mo stretchy="false">)</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mo>∉</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>doc</mml:mi>
<mml:mo>.</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mrow>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula1-0165551512437532" xlink:href="10.1177_0165551512437532-eq1.tif"/>
</disp-formula></p>
<p>For example, the compound value (“Jean Sibelius: Symphonies Nos. 4-7”, ‘v’, 〈1,5,1〉) for the element occurrence (title, ‘e’, 〈1,5〉) in D1 has been produced by applying the function compound-value(D1, 〈1,5,1〉) if the individual strings in the textual contents of <italic>title</italic> would have been indexed separately. Owing to space considerations, from here on we assume that in the available XML relations the data item contents consisting of multiple space-seperated textual and/or numeric values are represented as compound values.</p>
</sec>
</sec>
<sec id="section6-0165551512437532">
<title>4. XML dataspace profiling system architecture</title>
<p>The two goals for XML dataspace profiling systems stated in Section 1 also constitute the two main components of our XML dataspace profiling system architecture, which is presented in this section. The first main component is composed of mechanisms that assist the user in their assessment of how useful the documents in the underlying XML dataspace are with respect to their information needs. Similarly, the second main component comprises mechanisms assisting the user in validating the consistency of the chosen XML data sources by means of detecting the potential data conflicts in them.</p>
<sec id="section7-0165551512437532">
<title>4.1. Assessing the usefulness of the data sources in the available XML dataspace</title>
<p>The assessment of the usefulness of beforehand unfamiliar data sources in an XML dataspace should be based on the systematic analysis of their contentual and structural aspects. Therefore, an XML dataspace profiling system must provide the user with mechanisms to acquire information on the information contents of the available data sources and the structural relationships of their data items. In the context of XML data, this information is composed of the names of the available data items (content analysis at the schema level), their textual contents (content analysis at the instance level) and their hierarchical relationships (structure analysis). For this reason, the first main component of our XML dataspace profiling system architecture is built on mechanisms for analysing these three aspects. Based on this information the user is able to assess the relevance of the data sources in the underlying XML dataspace from the perspective of their information needs.</p>
<sec id="section8-0165551512437532">
<title>4.1.1. Content analysis</title>
<p><italic>Content analysis at the schema level.</italic> The starting point in assessing the usefulness of a beforehand unfamiliar XML document with respect to the user’s information needs is to review the data item names whose instances occur in it. For example, if the user is interested in documents that contain information about recordings, as in our running example, they can easily reject such documents, which contain data items labelled as <italic>capacity</italic> and <italic>available-seats</italic>, as these are likely to contain information about concert venues rather than recordings. On the other hand, if the data item names in the available documents tend to be relevant, such as <italic>album</italic> and <italic>composer</italic>, the user may be willing to explore them in more detail. XML documents typically contain two kinds of data items. Attributes and elements with textual (string or numeric) contents (i.e. ‘leaf nodes’ in the XML tree visualization) are called <italic>contentual data items</italic>, whereas elements that are used to hierarchically organize other data items (attributes and elements) and do not have textual contents (i.e. ‘internal nodes’ in the XML tree visualization) are called <italic>structural data items.</italic><sup><xref ref-type="fn" rid="fn2-0165551512437532">2</xref></sup></p>
<p>Thus, the first step in XML dataspace profiling is to provide the user with a mechanism to explore the contentual data item names. Since the textual contents in an XML relation are represented by triples with the value ‘v’ in their <italic>T</italic> attribute, the XML relation representation facilitates the straightforward specification of such a mechanism. Namely, the indices (i.e. values of the attribute <italic>I</italic>) in these triples are always of the form 〈<italic>ind</italic>┴ 1〉, when <italic>ind</italic> is the index of the data item name occurrence whose value the triple represents. Thus, the contentual data item names in the XML relation <italic>doc</italic> are produced by selecting the values of the attribute <italic>C</italic> from the triples with the index <italic>ind</italic> as follows:</p>
<p>
<disp-formula id="disp-formula2-0165551512437532">
<label>(1)</label>
<mml:math display="block" id="math2-0165551512437532">
<mml:mrow>
<mml:mtext>contentual-data-item-names</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">{</mml:mo>
<mml:mi>name</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">|</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>name</mml:mi>
<mml:mo>,</mml:mo>
<mml:mi>_</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>ind</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo>:</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>_</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext>‘v’</mml:mtext>
<mml:mo>,</mml:mo>
<mml:mrow>
<mml:mo>〈</mml:mo>
<mml:mi>ind</mml:mi>
<mml:mo>⊥</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>〉</mml:mo>
</mml:mrow>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo stretchy="false">}</mml:mo>
<mml:mo>.</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula2-0165551512437532" xlink:href="10.1177_0165551512437532-eq2.tif"/>
</disp-formula></p>
<p>In above definition – and from this on – we use the character ‘_’ to denote any valid expression. By this notation we are able to keep our definitions compact. For example, in the above definition the character ‘_’ stands for the values ‘a’ and ‘e’. Thus, the result contains both attribute and element names.</p>
<p><italic>Example 1.</italic> In the context of the XML relation representation D1 of the sample document <italic>doc1.xml</italic> the names of its data items that have textual contents are retrieved by applying the function contentual-data-item-names(D1). It produces the set {label, serial, number-of-discs, date, title, work, ensemble, conductor, price}. It is worth noting that, although the sample document contains six <italic>work</italic> element occurrences, the data item name <italic>work</italic> occurs only once in the result. This is because the result of the function <italic>contentual-data-item-names</italic> is a set where duplicates are eliminated.</p>
<p>Formula (1) can be generalized to cover the entire underlying XML dataspace. Let us denote the available XML dataspace by <bold><italic>D</italic></bold>. Now, the expression</p>
<p><disp-formula id="disp-formula3-0165551512437532">
<label>(2)</label>
<mml:math display="block" id="math3-0165551512437532">
<mml:mrow>
<mml:munder>
<mml:mo>⋃</mml:mo>
<mml:mrow>
<mml:mi>doc</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo>∈</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi mathvariant="bold-italic">D</mml:mi>
</mml:mrow>
</mml:munder>
<mml:mtext>contentual-data-item-names</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula3-0165551512437532" xlink:href="10.1177_0165551512437532-eq3.tif"/>
</disp-formula></p>
<p>produces a set composed of the names of such data items that have textual contents in the XML dataspace <bold><italic>D</italic></bold>.</p>
<p>Content analysis at the schema level provides the user with the first insight into the semantics of an XML data source which they are not familiar with. However, how reliably the user is able to interpret the semantics related to the data item names depends on how successfully these names describe their intended meaning. Unfortunately, it is very possible that the data item names do not sufficiently describe their related semantics. In order to be able to more reliably interpret them, the user must acquire more information. For this purpose, we need a mechanism for analysing the information contents also at the instance level.</p>
<p><italic>Content analysis at the instance level.</italic> Often only when the user is familiar with the values related to the specific data item names are they able to attach the correct semantic interpretation to these data items and also to more comprehensively assess the relevance of a particular data source with respect to their information needs. However, the values of a specific data item can implicitly express the domain to which the XML document at hand belongs. For example, in our sample dataspace the values of the <italic>composer</italic> data item occurrences reveal the musical genre of the albums even though this is not explicitly expressed anywhere in the documents. Moreover, when the data item names are abbreviations or acronyms, their correct interpretation requires in many cases that the user is also familiar with their related data values. For example, if the occurrences of the data item name <italic>DoB</italic> are related to values, such as <italic>1770-12-17</italic> and <italic>1865-12-08</italic> and so on, then the user can be quite sure that they express the <italic>date of birth</italic>. It is worth noting that the DTDs or XML Schemas attached to XML data sources typically do not contain information about the exact values related to data item occurrences in valid documents. Therefore, the user is not able to decide solely based on the information provided by them whether particular data sources are useful with respect to their information needs. This is one of the reasons why our dataspace profiling approach considers schemaless XML data sources.</p>
<p>The mechanism producing the values related to the occurrences of a specific data name in a specific data source in the underlying XML dataspace is defined by the function <italic>data-item-values</italic>. In the context of an XML relation <italic>doc</italic>, it produces the names of its contentual data items with their related values as follows:</p>
<p><disp-formula id="disp-formula4-0165551512437532">
<label>(3)</label>
<mml:math display="block" id="math4-0165551512437532">
<mml:mrow>
<mml:mtext>data-item-values</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">{</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>name</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext>values</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>name</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>doc</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">|</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>name</mml:mi>
<mml:mo>∈</mml:mo>
<mml:mtext>contentual-data-item-names</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">}</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula4-0165551512437532" xlink:href="10.1177_0165551512437532-eq4.tif"/>
</disp-formula></p>
<p>where the function <italic>contentual-data-item-names</italic> was defined in Formula (1) and the function <italic>values</italic> is defined as follows:</p>
<p><disp-formula id="disp-formula5-0165551512437532">
<label>(4)</label>
<mml:math display="block" id="math5-0165551512437532">
<mml:mrow>
<mml:mtext>values</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>name</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>doc</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">{</mml:mo>
<mml:mi>value</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">|</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>value</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext>‘v’</mml:mtext>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mrow>
<mml:mo>〈</mml:mo>
<mml:mi>ind</mml:mi>
<mml:mo>⊥</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>〉</mml:mo>
</mml:mrow>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo>:</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>name</mml:mi>
<mml:mo>,</mml:mo>
<mml:mi>_</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>ind</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo stretchy="false">}</mml:mo>
<mml:mo>.</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula5-0165551512437532" xlink:href="10.1177_0165551512437532-eq5.tif"/>
</disp-formula></p>
<p>In the definition of the function <italic>values</italic>, the indexing mechanism of the XML relation representation is utilized in the opposite way as in the definition of the function <italic>contentual-data-item-names</italic>. It is also worth noting that the function <italic>data-item-values</italic> constructs a set of pairs in which the first component is a data item name and the second component is a set containing the values related to its occurrences in <italic>doc</italic>.</p>
<p><italic>Example 2.</italic> Application of the function data-item-values(D1) produces the distinct data item names with their related values in the in the XML relation representation D1 of the sample document <italic>doc1.xml</italic>. In other words, it results in the set {(label, {“Deutsche Grammophon”}), (serial, {“0002 894 577 482 4”}), (number-of-discs, {2}), (date, {“01 Mar. 1999”}), (title, {“Jean Sibelius: Symphonies Nos. 4-7”}), (work, {“Symphony No.4 in A minor, Op.63”, “The Swan of Tuonela, Op.22, No.2”, “Symphony No.5 in E flat, Op.82”, “Symphony No.6 in D minor, Op.104”, “Symphony No.7 in C, Op.105”, “Tapiola, Op.112”}), (ensemble, {“Berliner Philharmoniker”}), (conductor, {“Karajan, Herbert von”}), (price, {$23.98}), }. In the sample document <italic>doc1.xml</italic>, the element <italic>work</italic> is related to six different values, whereas the other data items in the document have just one value. To sum up, the above result expresses to the user that <italic>doc1.xml</italic> contains a recording of music by Jean Sibelius. Based on this information the user can decide whether or not this particular data source is useful with respect to their information needs.</p>
<p>Analogously to Formula (2), the function <italic>data-item-values</italic> can also be generalized to cover the underlying XML dataspace <bold><italic>D</italic></bold>.</p>
</sec>
<sec id="section9-0165551512437532">
<title>4.1.2. Structure analysis</title>
<p>In some cases, even knowing the name of a data item and its related values does not provide sufficient information for the correct interpretation of their intended meaning. For example, in the context of our sample dataspace, let us assume that the user is interested in knowing what kind of data values are related to the <italic>title</italic> data item occurrences in the sample document <italic>doc4.xml</italic>. They are able to do this by applying the function values(title, D4) (see Formula 4), which returns the set {“Beethoven: Piano Concerto No.3 / Sibelius: Symphony No.5”, “Piano Concerto No.3 in C minor”, “Symphony No.5 in E flat major”}. When the user reviews these data values, they may at first seem to be redundant. Therefore, they need a mechanism for determining the cause for this. If the user is not familiar with the sample documents, as it is assumed, they do not know that the <italic>title</italic> data items in <italic>doc4.xml</italic> are used for representing different real-world entities. This simple example shows that the correct semantic interpretation of data item names and their related values requires that they are reviewed in their contexts, that is, together with the other data items in the document hierarchy. Thus, the hierarchical relationships among data items form an important part of the semantic annotation of an XML document. For example, in the above case the immediate predecessors of the <italic>title</italic> elements are labelled <italic>album</italic> and <italic>work</italic>. This means that the <italic>title</italic> element occurrences in <italic>doc4.xml</italic> are used to express both the title of the album and the title of the individual works in the album. In general, it may not be sufficient to track down just the immediate predecessor of a data item, but it may be necessary also to track down their indirect predecessors. Next, we show how the XML relation representation supports the analysis of XML document structures.</p>
<p>The predecessors of a given data item occurrence can be easily tracked down through the indexing mechanism of the XML relation representation. Namely, the index of the immediate predecessor of a given data item occurrence is its index with the last index number removed. For example, the index of the immediate predecessor of the data item occurrence with the index 〈1,1,1〉 is 〈1,1〉. The indices of all (indirect and immediate) predecessors of a data item occurrence with the index <italic>index</italic> are produced by the function predecessors(<italic>index</italic>), which has the following definition:</p>
<p><disp-formula id="disp-formula6-0165551512437532">
<mml:math display="block" id="math6-0165551512437532">
<mml:mrow>
<mml:mtext>predecessors</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>index</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mrow>
<mml:mo>{</mml:mo>
<mml:mtable align="left">
<mml:mtr>
<mml:mtd columnalign="center">
<mml:mrow>
<mml:mo stretchy="false">{</mml:mo>
<mml:mi>ind</mml:mi>
<mml:mo stretchy="false">}</mml:mo>
<mml:mo>∪</mml:mo>
<mml:mo stretchy="false">{</mml:mo>
<mml:mtext>predecessors</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>ind</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">}</mml:mo>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="center" columnspan="1">
<mml:mrow>
<mml:mspace width="0.25em"/>
<mml:mtext>if</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mi>index</mml:mi>
<mml:mo>≠</mml:mo>
<mml:mrow>
<mml:mo>〈</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>〉</mml:mo>
</mml:mrow>
<mml:mspace width="0.25em"/>
<mml:mo>∧</mml:mo>
<mml:mtext>im_predecessor</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>index</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mi>ind</mml:mi>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="center" columnspan="1">
<mml:mrow>
<mml:mo stretchy="false">{</mml:mo>
<mml:mrow>
<mml:mo>〈</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>〉</mml:mo>
</mml:mrow>
<mml:mo stretchy="false">}</mml:mo>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="center" columnspan="1">
<mml:mrow>
<mml:mspace width="0.25em"/>
<mml:mtext>otherwise</mml:mtext>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mrow>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula6-0165551512437532" xlink:href="10.1177_0165551512437532-eq6.tif"/>
</disp-formula></p>
<p>where the auxiliary function <italic>im_predecessor</italic> is defined as follows:</p>
<p><disp-formula id="disp-formula7-0165551512437532">
<label>(5)</label>
<mml:math display="block" id="math7-0165551512437532">
<mml:mrow>
<mml:mtext>im_predecessor</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mrow>
<mml:mo>〈</mml:mo>
<mml:mi>ind</mml:mi>
<mml:mo>⊥</mml:mo>
<mml:mi>i</mml:mi>
<mml:mo>〉</mml:mo>
</mml:mrow>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mi>ind</mml:mi>
<mml:mo>.</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula7-0165551512437532" xlink:href="10.1177_0165551512437532-eq7.tif"/>
</disp-formula></p>
<p>In an XML document, the root element is the ultimate predecessor of any other data item occurrence and thus it itself has no predecessor. It is also worth noting that the predecessors of a data item occurrence can be produced through the index manipulation without the need to access the tuples of an XML relation.</p>
<p><italic>Example 3.</italic> In the XML relation representation D3 of the sample document <italic>doc3.xml</italic> (see <xref ref-type="table" rid="table3-0165551512437532">Table A3</xref> in <xref ref-type="app" rid="app1-0165551512437532">Appendix</xref>), the triple (work, ‘e’, 〈1,1,1,6,2〉) represents an occurrence of a <italic>work</italic> element. The indices of all its predecessors are produced by applying the function predecessors(〈1,1,1,6,2〉), whose evaluation returns the set {〈1,1,1,6〉, 〈1,1,1〉, 〈1,1〉, 〈1〉}. These indices, which refer to the occurrences of the elements <italic>works</italic> (with the index 〈1,1,1,6〉), <italic>details</italic> (〈1,1,1〉), <italic>album</italic> (〈1,1〉) and <italic>albums</italic> (〈1〉), express the path from this specific <italic>work</italic> element occurrence to the document root.</p>
<p>In addition to predecessors, it is often useful to review also a data item occurrence’s successors at the lower levels of the XML document hierarchy. Although a data item occurrence in XML may have exactly one immediate predecessor (except for the root element), it may have multiple immediate successors (which are mutually ‘siblings’ in the XML tree visualization). Next, we define the function <italic>im_successor</italic>, which produces the indices of the immediate successors of a given data item name occurrence (with the index <italic>index</italic>) in the XML relation <italic>doc</italic> as follows:</p>
<p><disp-formula id="disp-formula8-0165551512437532">
<mml:math display="block" id="math8-0165551512437532">
<mml:mrow>
<mml:mtext>im_successor</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>index</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">{</mml:mo>
<mml:mrow>
<mml:mo>〈</mml:mo>
<mml:mi>index</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo>⊥</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>i</mml:mi>
<mml:mo>〉</mml:mo>
</mml:mrow>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">|</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>_</mml:mi>
<mml:mo>,</mml:mo>
<mml:mi>_</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mrow>
<mml:mo>〈</mml:mo>
<mml:mi>index</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo>⊥</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>i</mml:mi>
<mml:mo>〉</mml:mo>
</mml:mrow>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo stretchy="false">}</mml:mo>
<mml:mo>.</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula8-0165551512437532" xlink:href="10.1177_0165551512437532-eq8.tif"/>
</disp-formula></p>
<p>In other words, the indices of the immediate successors of a data item occurrence with the index <italic>index</italic> are formed by selecting from <italic>doc</italic> all those indices which have <italic>index</italic> as their prefix and whose lengths are exactly one index number greater than the length of <italic>index</italic>. It is also worth noting that the indices in the above result set may refer to attribute or element occurrences or to their related values.</p>
<p><italic>Example 4.</italic> In the context of the XML relation representation D3 of <italic>doc3.xml</italic>, the function im_successor(D3,〈1,2〉) produces the set {〈1,2,1〉, 〈1,2,2〉, 〈1,2,3〉, 〈1,2,4〉, 〈1,2,4〉, 〈1,2,6〉, 〈1,2,7〉}, where the indices refer to the occurrences of the data items <italic>price</italic> (〈1,2,1〉), <italic>label</italic> (〈1,2,2〉), <italic>title</italic> (〈1,2,3〉), <italic>author</italic> (〈1,2,4〉), <italic>artists</italic> (〈1,2,5〉), <italic>catalogue-number</italic> (〈1,2,6〉) and <italic>works</italic> (〈1,2,7〉).</p>
<p>All (immediate and indirect) successors of a data item occurrence with the index <italic>index</italic> are produced by the function successors(<italic>index</italic>) as follows:</p>
<p><disp-formula id="disp-formula9-0165551512437532">
<mml:math display="block" id="math9-0165551512437532">
<mml:mrow>
<mml:mtext>successors</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>index</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">{</mml:mo>
<mml:mrow>
<mml:mo>〈</mml:mo>
<mml:mi>index</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo>⊥</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>ξ</mml:mi>
<mml:mo>〉</mml:mo>
</mml:mrow>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">|</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>_</mml:mi>
<mml:mo>,</mml:mo>
<mml:mi>_</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mrow>
<mml:mo>〈</mml:mo>
<mml:mi>index</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo>⊥</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>ξ</mml:mi>
<mml:mo>〉</mml:mo>
</mml:mrow>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo stretchy="false">}</mml:mo>
<mml:mo>.</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula9-0165551512437532" xlink:href="10.1177_0165551512437532-eq9.tif"/>
</disp-formula></p>
<p>In the above formula, the symbol ξ stands for any sub-index consisting of one or more index numbers. In other words, the function <italic>successors</italic> selects from <italic>doc</italic> all those indices whose prefix is <italic>index</italic>. If <italic>index</italic> is associated with a value occurrence (a triple whose <italic>T</italic> attribute has the value ‘v’), then the function yields ϕ, since a value occurrence cannot have its own successors in the document hierachy.</p>
<p><italic>Example 5.</italic> The triple (works, ‘e’, 〈1,2,7〉) in the XML relation representation D3 of <italic>doc3.xml</italic> represents an element name occurrence. The indices of its successors in the document hierarchy are produced by applying the function successors(D3, 〈1,2,7〉). Its evaluation returns the set {〈1,2,7,1〉, 〈1,2,7,1,1〉, 〈1,2,7,1,1,1〉〈1,2,7,2〉, 〈1,2,7,2,1〉, 〈1,2,7,2,1,1〉}, where the indices refer to the occurrences of data item names <italic>work</italic> (〈1,2,7,1〉 and 〈1,2,7,2〉) and <italic>title</italic> (〈1,2,7,1,1〉 and 〈1,2,7,2,1〉), and to their respective values “Symphony No.4 in A minor, Op.63” (〈1,2,7,1,1,1〉) and “Symphony No.5 in E flat, Op.82” (〈1,2,7,2,1,1〉).</p>
<p>As mentioned, structural data items are such data items, which do not have their own textual contents but are used only to organize other data item occurrences hierarchically. Next, we define the function <italic>structural-data-item-names</italic>, which produces the names of structural data items (which are always elements) from an XML relation <italic>doc</italic> as follows:</p>
<p><disp-formula id="disp-formula10-0165551512437532">
<label>(6)</label>
<mml:math display="block" id="math10-0165551512437532">
<mml:mrow>
<mml:mtext>structural-data-item-names</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">{</mml:mo>
<mml:mi>name</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">|</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>name</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext>‘e’</mml:mtext>
<mml:mo>,</mml:mo>
<mml:mi>_</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo>∧</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>name</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo>∉</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext>contentual-data-item-names</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">}</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula10-0165551512437532" xlink:href="10.1177_0165551512437532-eq10.tif"/>
</disp-formula></p>
<p><italic>Example 6.</italic> In the context of the XML relation representation D1 of <italic>doc1.xml</italic>, the application of the function structural-data-item-names(D1) produces the set {album, details, Sibelius, artists}.</p>
<p>All – structural and contentual – data item names occurring in an XML document <italic>doc</italic> are produced by the function <italic>data-item-names</italic>, which is defined as follows:</p>
<p><disp-formula id="disp-formula11-0165551512437532">
<label>(7)</label>
<mml:math display="block" id="math11-0165551512437532">
<mml:mrow>
<mml:mtext>data-item-names</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mtext>contentual-data-item-names</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∪</mml:mo>
<mml:mtext>structural-data-item-names</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula11-0165551512437532" xlink:href="10.1177_0165551512437532-eq11.tif"/>
</disp-formula></p>
<p>when the functions <italic>contentual-data-item-names</italic> and <italic>structural-data-item-names</italic> are as defined in Formulas (1) and (6), respectively. Analogously to Formula (2), the functions <italic>structural</italic>-<italic>data-item-names</italic> and <italic>data-item-names</italic> can also be generalized to cover an XML dataspace <bold><italic>D</italic></bold>.</p>
<p>Through the application of the formal tools presented in this section, the user is able to assess the usefulness of the underlying XML dataspace from the perspective of their information needs. Assessing the usefulness of data sources in an XML dataspace is a stepwise process where, after each step, the user is able to decide whether to proceed to the next step or to halt the process and discard the given data sources as irrelevant. The output of this process is a collection of data sources that are considered to be useful.</p>
</sec>
</sec>
<sec id="section10-0165551512437532">
<title>4.2. Assessing the consistency of the data sources in the available XML dataspace</title>
<p>However, the availability of useful XML data sources does not yet guarantee that they could be utilized as such in advanced query systems and analysis tools. As shown in [<xref ref-type="bibr" rid="bibr28-0165551512437532">28</xref>, <xref ref-type="bibr" rid="bibr21-0165551512437532">21</xref>], the XML documents retrieved from autonomous and heterogeneous data sources typically contain various forms of data conflicts, which must be taken into account in their data-centric processing. Therefore, one of the most critical tasks in XML dataspace profiling is to provide the user with tools for validating the consistency of the data sources that have been considered to be useful in the previous phase of XML dataspace profiling by the means of detecting potential data conflicts among them. In this section, we show how the XML relation representation supports developing mechanisms for this purpose. It is worth noting that these mechanisms do not warrant that an actual data conflict is met but they merely indicate the existence of a <italic>potential</italic> one. The final decision on whether or not a data conflict actually occurs should be left to the user.</p>
<p>As for the assessment of the usefulness of the data sources in the underlying XML dataspace, also the validation of their consistency is a stepwise process. However, in this process each of the steps results in deeper understanding of the documents’ characteristics rather than in deciding on their relevance.</p>
<sec id="section11-0165551512437532">
<title>4.2.1. Detection of document-to-document conflicts</title>
<p>The occurrence of document-to-document conflicts means that disparate XML data sources are not compatible with each other. Two documents are compatible if their schema-level data items and the structural organization among them are identical. However, compatible documents need not contain the same data values or the same number of data item occurrences. Data-centric applications require that the user takes the potential document-to-document conflicts into account in query specification. How this is done in practice depends on the XML query language used.</p>
<p>Next, we define the function <italic>compatible</italic> between two XML relations <italic>doc</italic><sub>1</sub> and <italic>doc</italic><sub>2</sub>. It returns <italic>false</italic> if the document-to-document conflict occurs between them, otherwise it returns <italic>true</italic>. Formally, the compatibility between two XML documents means that their data item names are the same and all occurrences of a specific data item name in them (excluding the root element) depend immediately on a data item of the same type. The function compatible(<italic>doc</italic><sub>1</sub>,<italic>doc</italic><sub>2</sub>) is defined as follows:</p>
<p><disp-formula id="disp-formula12-0165551512437532">
<label>(8)</label>
<mml:math display="block" id="math12-0165551512437532">
<mml:mrow>
<mml:mtext>compatible</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mrow>
<mml:mo>{</mml:mo>
<mml:mtable align="left">
<mml:mtr>
<mml:mtd columnalign="center">
<mml:mrow>
<mml:mi>true</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext>if</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>data-item-names</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mtext>data-item-names</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∧</mml:mo>
<mml:mtext>structure-compatiable</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mi>true</mml:mi>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="center" columnspan="1">
<mml:mrow>
<mml:mi>false</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext>otherwise</mml:mtext>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mrow>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula12-0165551512437532" xlink:href="10.1177_0165551512437532-eq12.tif"/>
</disp-formula></p>
<p>where the function <italic>data-item-names</italic> is as defined in Formula (7) and the function <italic>structure-compatible</italic> is defined as follows:</p>
<p><disp-formula id="disp-formula13-0165551512437532">
<label>(9)</label>
<mml:math display="block" id="math13-0165551512437532">
<mml:mrow>
<mml:mtext>structure-compatible</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mrow>
<mml:mo>{</mml:mo>
<mml:mtable align="left">
<mml:mtr>
<mml:mtd columnalign="center">
<mml:mrow>
<mml:mi>true</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext>if</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:munder>
<mml:mo>⋀</mml:mo>
<mml:mrow>
<mml:mi>name</mml:mi>
<mml:mo>∈</mml:mo>
<mml:mtext>data-item-names</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:munder>
<mml:mtext>same-im-predecessor</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>name</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mi>true</mml:mi>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="center" columnspan="1">
<mml:mrow>
<mml:mi>false</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext>otherwise</mml:mtext>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mrow>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula13-0165551512437532" xlink:href="10.1177_0165551512437532-eq13.tif"/>
</disp-formula></p>
<p>when</p>
<p><disp-formula id="disp-formula14-0165551512437532">
<label>(10)</label>
<mml:math display="block" id="math14-0165551512437532">
<mml:mrow>
<mml:mtext>same-im-predecessor</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>name</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:msub>
<mml:mrow>
<mml:mi>doc</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:msub>
<mml:mrow>
<mml:mi>doc</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mrow>
<mml:mo>{</mml:mo>
<mml:mtable align="left">
<mml:mtr>
<mml:mtd columnalign="center">
<mml:mrow>
<mml:mi>true</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext>if</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mo>∀</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>name</mml:mi>
<mml:mo>,</mml:mo>
<mml:mi>_</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>in</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>d</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>∧</mml:mo>
<mml:mo>∀</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>name</mml:mi>
<mml:mo>,</mml:mo>
<mml:mi>_</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>in</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>d</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>∧</mml:mo>
<mml:mi>in</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>d</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>in</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>d</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>≠</mml:mo>
<mml:mrow>
<mml:mo>〈</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>〉</mml:mo>
</mml:mrow>
<mml:mo>:</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="center" columnspan="1">
<mml:mrow>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>name</mml:mi>
<mml:mtext>’</mml:mtext>
<mml:mo>,</mml:mo>
<mml:mi>_</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>im</mml:mi>
<mml:mi>_</mml:mi>
<mml:mi>predecessor</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>in</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>d</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>∧</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="center" columnspan="1">
<mml:mrow>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>name</mml:mi>
<mml:mtext>’</mml:mtext>
<mml:mo>,</mml:mo>
<mml:mi>_</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>im</mml:mi>
<mml:mi>_</mml:mi>
<mml:mi>predecessor</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>in</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>d</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="center" columnspan="1">
<mml:mrow>
<mml:mi>false</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext>otherwise</mml:mtext>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mrow>
<mml:mspace width="0.25em"/>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula14-0165551512437532" xlink:href="10.1177_0165551512437532-eq14.tif"/>
</disp-formula></p>
<p>and the function <italic>im_predecessor</italic> is as defined in Formula (5).</p>
<p>The function same-im-predecessor(<italic>name, doc</italic><sub>1</sub>, <italic>doc</italic><sub>2</sub>) ensures that the immediate predecessor of each of the occurrences of the data item <italic>name</italic> is the same in both documents. It is also worth noting that, since the data item names in <italic>doc</italic><sub>1</sub> and <italic>doc</italic><sub>2</sub> must be identical, <italic>name</italic> in Formulas (9) and (10) denotes any data item name occurring in both of the documents. Thus, in Formula (9) we could have alternatively expressed <italic>name</italic> ∈ data-item-names(<italic>doc</italic><sub>2</sub>).</p>
<p>Formula (8) is utilized in the definition of the function <italic>search-doc2doc-conflicts</italic>, which returns pairwise all conflicting documents from the XML dataspace <bold><italic>D</italic></bold> as follows:</p>
<p><disp-formula id="disp-formula15-0165551512437532">
<label>(11)</label>
<mml:math display="block" id="math15-0165551512437532">
<mml:mrow>
<mml:mtext>search-doc</mml:mtext>
<mml:mn>2</mml:mn>
<mml:mtext>doc-conflicts</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="bold-italic">D</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mrow>
<mml:mo>{</mml:mo>
<mml:mrow>
<mml:mo>{</mml:mo>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mrow>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>}</mml:mo>
</mml:mrow>
</mml:mrow>
</mml:mrow>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">|</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mo>≠</mml:mo>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mi mathvariant="bold-italic">D</mml:mi>
<mml:mo>:</mml:mo>
<mml:mtext>compatible</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mrow>
<mml:mi>false</mml:mi>
<mml:mo>}</mml:mo>
</mml:mrow>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula15-0165551512437532" xlink:href="10.1177_0165551512437532-eq15.tif"/>
</disp-formula></p>
<p><italic>Example 7.</italic> Let us denote our sample dataspace by <bold><italic>XDS</italic></bold> (= {D1, D2, D3, D4}). Now, evaluation of the function search-doc2doc-conflicts(<bold><italic>XDS</italic></bold>) results in the set {{D1, D2}, {D1, D3}, {D1, D4}, {D2, D3}, {D2, D4}, {D3, D4}}. This result indicates that the document-to-document conflict occurs between any two documents in our sample XML dataspace.</p>
<p>In order to find out the explanation for the occurrences of the potential document-to-document conflicts, the user needs to detect the other data conflicts occurring among the documents in the underlying XML dataspace. However, even if the above function would result in the empty set, indicating no document-to-document conflicts exist among the available documents, this does not mean that the other data conflict types would not possibly occur.</p>
</sec>
<sec id="section12-0165551512437532">
<title>4.2.2. Detection of attribute-to-element conflicts</title>
<p>A potential attribute-to-element (element-to-attribute) conflict occurs if one or more XML documents contain attribute and element occurrences, which are associated with the same name. The potential attribute-to-element conflicts in the XML dataspace <bold><italic>D</italic></bold> can be detected by the function <italic>search-a2e-conflicts</italic> as follows:</p>
<p><disp-formula id="disp-formula16-0165551512437532">
<label>(12)</label>
<mml:math display="block" id="math16-0165551512437532">
<mml:mrow>
<mml:mtext>search-a</mml:mtext>
<mml:mn>2</mml:mn>
<mml:mtext>e-conflicts</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="bold-italic">D</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mrow>
<mml:mo>{</mml:mo>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>name</mml:mi>
<mml:mo>)</mml:mo>
</mml:mrow>
</mml:mrow>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">|</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>∈</mml:mo>
<mml:mi mathvariant="bold-italic">D</mml:mi>
<mml:mo>:</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>name</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext>‘a’</mml:mtext>
<mml:mo>,</mml:mo>
<mml:mi>_</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>∧</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>name</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext>‘e’</mml:mtext>
<mml:mo>,</mml:mo>
<mml:mi>_</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">}</mml:mo>
<mml:mo>.</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula16-0165551512437532" xlink:href="10.1177_0165551512437532-eq16.tif"/>
</disp-formula></p>
<p>In other words, the function analyses whether it is possible to find out from the XML dataspace <bold><italic>D</italic></bold> two such documents <italic>doc</italic><sub>1</sub> and <italic>doc</italic><sub>2</sub> that both contain a data item occurrence with the name <italic>name</italic> so that <italic>name</italic> stands for an attribute name in <italic>doc</italic><sub>1</sub> and for an element name in <italic>doc</italic><sub>2</sub>. Since attribute-to-element conflict may also occur within a single XML document, in the above definition <italic>doc</italic><sub>1</sub> and <italic>doc</italic><sub>2</sub> may refer to the same document.</p>
<p><italic>Example 8.</italic> In our sample XML dataspace, the evaluation of the function search-a2e-conflicts(<bold><italic>XDS</italic></bold>) produces the set {(D2, D1, price), (D2, D3, price), (D2, D3, composer), (D2, D4, price), (D2, D4, composer), (D3, D1, price), (D3, D1, title), (D3, D2, title), (D3, D3, title), (D3, D3, price), (D3, D4, title), (D3, D4, price)}. For example, the triple (D2, D1, title) means that <italic>doc2.xml</italic> contains <italic>price</italic> attribute occurrences, whereas <italic>doc1.xml</italic> contains <italic>price</italic> element occurrences. Similarly, the triple (D3, D3, title) indicates that <italic>doc3.xml</italic> contains both <italic>title</italic> attribute and element occurrences.</p>
<p>It is also worth noting that the attribute and element occurrences with the same name may also be referring to different real-world entities. For example, the result of search-a2e-conflicts(<bold><italic>XDS</italic></bold>) contains the triple (D3, D1, title). If we look at the textual representations of D1 and D3 in <xref ref-type="fig" rid="fig1-0165551512437532">Figures 1(a)</xref> and <xref ref-type="fig" rid="fig1-0165551512437532">1(c)</xref>, we can easily conclude that the <italic>title</italic> element occurrence in <italic>doc1.xml</italic> and the <italic>title</italic> attribute occurrences in <italic>doc3.xml</italic> have different intended meanings. Namely, the <italic>title</italic> element occurrence in <italic>doc1.xml</italic> represents the album title, whereas the <italic>title</italic> attribute occurrences in <italic>doc3.xml</italic> represent work titles.</p>
</sec>
<sec id="section13-0165551512437532">
<title>4.2.3. Detection of data item-to-data item conflicts</title>
<p>Two types of data item-to-data item conflicts exist. In the context of the conflicts of the first type, semantically equivalent data items have been named differently, whereas in the context of the conflicts of the second type semantically non-equivalent data items have been named identically.</p>
<p>The function <italic>values</italic> in Formula (4) can be used directly to detect the potential data item-to-data item conflicts of the first type. For example, if the user is interested in finding out whether the <italic>author</italic> data item in <italic>doc3.xml</italic> and the <italic>composer</italic> data item in <italic>doc4.xml</italic> are used to represent similar real-world entities, they can apply the functions values(author, D3) and values(composer, D4). Their evaluation results in the sets {“Jean Sibelius (1865-1957)”} and {Beethoven, Sibelius}, respectively. By analysing the contents of these sets, the user can easily conclude that in <italic>doc3.xml</italic> the <italic>author</italic> data item represents only composers (not, e.g., writers). In other words, they have detected an occurrence of the data item-to-data item conflict of the first type. In our compact sample XML dataspace, the user could have easily checked this from the documents’ textual representations. However, in the context of large and complex documents this would be very laborious.</p>
<p>In detection of the data item-to-data item conflicts of the second type, the user needs to be provided with a mechanism that produces from the available XML dataspace <bold><italic>D</italic></bold> all pairs of such documents that contain data item occurrences that are named similarly, combined with the name of this common data item and the values related to its occurrences in both documents. For the detection of data item-to-data item conflicts of the second type we define the function <italic>search-d2d2-conflicts</italic> as follows:</p>
<p><disp-formula id="disp-formula17-0165551512437532">
<label>(13)</label>
<mml:math display="block" id="math17-0165551512437532">
<mml:mrow>
<mml:mspace width="0.25em"/>
<mml:mtext>search-d</mml:mtext>
<mml:mn>2</mml:mn>
<mml:mtext>d</mml:mtext>
<mml:mn>2</mml:mn>
<mml:mtext>-conflicts</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="bold-italic">D</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mrow>
<mml:mo>{</mml:mo>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>name</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>)</mml:mo>
</mml:mrow>
</mml:mrow>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">|</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>∈</mml:mo>
<mml:mi mathvariant="bold-italic">D</mml:mi>
<mml:mo>:</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>name</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mtext>data-item-values</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∧</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>name</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mtext>data-item-values</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">}</mml:mo>
<mml:mo>.</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula17-0165551512437532" xlink:href="10.1177_0165551512437532-eq17.tif"/>
</disp-formula></p>
<p>If the result produced by evaluating the function search-d2d2-conflicts(<bold><italic>D</italic></bold>) contains such a tuple (<italic>doc</italic><sub>1</sub>, <italic>doc</italic><sub>2</sub>, <italic>name</italic>, (<italic>V</italic><sub>1</sub>,<italic>V</italic><sub>2</sub>)), where the values in the sets <italic>V</italic><sub>1</sub>and <italic>V</italic><sub>2</sub> are different by nature (this assessment is based on the user’s consideration), then the data item-to-data-item conflict of the second type occurs between documents <italic>doc</italic><sub>1</sub> and <italic>doc</italic><sub>2</sub>. Thus, the user is able to conclude that <italic>name</italic> is used to represent different real-world entities in these two documents. The function <italic>data-item-values</italic> is defined in Formula (3).</p>
<p><italic>Example 9.</italic> In the context of our sample XML dataspace, the result set produced by evaluating the function search-d2d2-conflicts(<bold><italic>XDS</italic></bold>) contains, among others, the tuple (D1, D3, title, ({“Jean Sibelius: Symphonies Nos. 4-7”}, {“Sibelius: Symphony Nos.2 and 5”, “Symphony No.2 in D, Op.43”, “Symphony No.5 in E flat, Op.82”, “Sibelius: Symphonies Nos. 4 &amp; 5”, “Symphony No.4 in A minor, Op.63”})). When the user compares the two value sets, and possibly also consults the textual representations of D1 and D3, they are able to draw the following conclusion: in <italic>doc1.xml</italic> the <italic>title</italic> data item is used to represent only the album title, whereas in <italic>doc3.xml</italic> it is used to represent both the album and work titles. In other words, a data item-to-data item conflict of the second type occurs between <italic>doc1.xml</italic> and <italic>doc3.xml</italic>.</p>
</sec>
<sec id="section14-0165551512437532">
<title>4.2.4. Detection of data item-to-value conflicts</title>
<p>A possible data item-to-value conflict occurs when a data item name and a data item value have identical representations. Data item-to-value conflict may occur either within a single XML document or between multiple documents. In the XML dataspace <bold><italic>D</italic></bold>, the possible data item-to-value conflicts between XML relations <italic>doc</italic><sub>1</sub> and <italic>doc</italic><sub>2</sub> with respect to the data item name/value <italic>name</italic> are detected by the function search-d2v-conflicts(<bold><italic>D</italic></bold>), which is defined as follows:</p>
<p><disp-formula id="disp-formula18-0165551512437532">
<label>(14)</label>
<mml:math display="block" id="math18-0165551512437532">
<mml:mtable>
<mml:mtr>
<mml:mtd>
<mml:mtext>search-d2v-conflicts</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>D</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mo>{</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mi>doc</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mi>doc</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mi>name</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>|</mml:mo>
<mml:msub>
<mml:mi>doc</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mi>doc</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
<mml:mo>∈</mml:mo>
<mml:mi>D</mml:mi>
<mml:mo>∧</mml:mo>
<mml:mi>name</mml:mi>
<mml:mo>∈</mml:mo>
<mml:mtext>data-item-names(</mml:mtext>
<mml:msub>
<mml:mi>doc</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∧</mml:mo>
<mml:mi>name</mml:mi>
<mml:mo>’</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mtext>contentual-date-item-names</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mi>doc</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>:</mml:mo>
<mml:mi>name</mml:mi>
<mml:mo>∈</mml:mo>
<mml:mi>values</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>name</mml:mi>
<mml:mo>’</mml:mo>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mi>doc</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>}</mml:mo>
<mml:mo>.</mml:mo>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:math>
<graphic alternate-form-of="disp-formula18-0165551512437532" xlink:href="10.1177_0165551512437532-eq18.tif"/></disp-formula></p>
<p>In other words, the function <italic>search-d2v-conflicts</italic> returns all such documents (document pairs) in the XML dataspace <bold><italic>D</italic></bold>, where the same piece of information is represented both as a data item name and as a value. The functions <italic>data-item-names, contentual-data-item-names</italic> and <italic>values</italic> are defined in Formulas (7), (1) and (4), respectively.</p>
<p><italic>Example 10.</italic> In our sample XML dataspace, the evaluation of the function search-d2v-conflicts(<bold>XDS</bold>) returns the set {(D1, D4, Sibelius)}. This result is due to the fact that Sibelius appears as an element name occurrence in <italic>doc1.xml</italic> (the tuple (Sibelius, ‘e’, 〈1,6,1〉) in D1) and as a data item value occurrence in <italic>doc4.xml</italic> (the tuple (Sibelius, ‘v’, 〈1,5,2,1,1〉) in D4).</p>
</sec>
<sec id="section15-0165551512437532">
<title>4.2.5. Detection and resolving value-to-value conflicts</title>
<p>In [<xref ref-type="bibr" rid="bibr28-0165551512437532">28</xref>] we developed the mechanisms to resolve the above four data conflict types, and in [<xref ref-type="bibr" rid="bibr21-0165551512437532">21</xref>] we introduced a language for querying and manipulating such heterogeneous XML documents where these conflicts occur. In these works, the background assumption was that the user is aware of the existence of the conflicts occurring in the underlying data. However, in the present article we have formally defined mechanisms that both support the user in their detection and are able to provide him/her with the information, which can be utilized in the query specification. The above four data conflict types can be typically resolved without modifying the original XML documents, whereas in the context of the value-to-value conflicts this is not possible. This is one of the reasons why this conflict type has been omitted in our previous work. However, in this section we show how this data conflict type can also be resolved.</p>
<p>In data-centric applications, the semantically equivalent data item values must be represented uniformly. This is, among others, a prerequisite for valid data grouping and aggregation. Unfortunately, this assumption does not often hold for the XML dataspaces composed of autonomous and heterogeneous data sources. The underlying XML data sources need to be harmonized by resolving the possible value-to-value conflicts among them before sophisticated information needs that involve data grouping and/or aggregation can be satisfied through advanced query and analysis systems. The value-to-value conflicts manifest themselves in two forms. First, semantically equivalent string values may be represented in typographically varying ways (e.g. “Jean Sibelius” has four different typographical representations among the documents in our sample XML dataspace). Second, semantically equivalent numerical values may be represented based on different units of measurement (e.g. in our sample XML dataspace the album prices are represented in USDs, GBPs and EURs). The starting point for the harmonization of these kinds of conflicting values is that the user is supported in their detection.</p>
<p>Detection of conflicting data values is related to the complex problem of <italic>entity matching</italic> [<xref ref-type="bibr" rid="bibr40-0165551512437532">40</xref>].<sup><xref ref-type="fn" rid="fn3-0165551512437532">3</xref></sup> The purpose of entity matching is to search data instances, which refer to the same real-world entity, for example, by identifying the synonymous use of terms. Extensive surveys on general comparison techniques proposed for entity matching are provided in [<xref ref-type="bibr" rid="bibr40-0165551512437532">40</xref><xref ref-type="bibr" rid="bibr41-0165551512437532"/>–<xref ref-type="bibr" rid="bibr42-0165551512437532">42</xref>]. These techniques (e.g. probabilistic, learning, distance-based or rule-based) include some metrics to determine the (e.g. character-based, token-based) similarity between the given values. The performance of individual methods depends heavily on the nature of the underlying data, and in many cases the best results are gained by combining different techniques and metrics. The proposed techniques also assume different degrees of user involvement, but the evaluation of their performance and suitability for the given data set is always based on human expertise. The user must be provided with these kinds of (at least) semi-automated means to detect the conflicting values, since computing them manually would often be too burdensome [<xref ref-type="bibr" rid="bibr43-0165551512437532">43</xref>]. Like the approaches in [<xref ref-type="bibr" rid="bibr8-0165551512437532">8</xref>, <xref ref-type="bibr" rid="bibr9-0165551512437532">9</xref>, <xref ref-type="bibr" rid="bibr11-0165551512437532">11</xref>], also we see that the development of these techniques is beyond the scope of the present article and, as the above works, we assume that a mechanism for determining the similarity between two values is available without considering to the details of its implementation.</p>
<p>In XML documents, it only makes sense to detect the potentially conflicting values in the context of similarly named data items. Namely, if the potential value-to-value conflicts would be detected among all available data item occurrences regardless of their names, the odds are that the results contain numerous matches between values that are, however, not related to semantically equivalent data items. By contrast, when the detection of the potential value-to-value conflicts is limited to only those data item occurrences that have the same name, the number of incorrect matches (i.e. false positives) can be assumed to be considerably smaller. For this reason, the mechanism provided for detecting potential data-item-to-data item conflicts (of the second type) can also be utilized in the detection of value-to-value conflicts.</p>
<p>As defined in Formula (13), the function <italic>search-d2d2-conflicts</italic> produces sets of distinct values related to the occurrences of a specific data item name in two XML documents. Now, let similar (<italic>v</italic><sub>1</sub>,<italic>v</italic><sub>2</sub>) be a generic similarity function, which returns <italic>true</italic> if the two non-identical string values <italic>v</italic><sub>1</sub> and <italic>v</italic><sub>2</sub> are potentially semantically equivalent and otherwise <italic>false</italic>. These two functions are utilized in the definition of the function <italic>search-v2v-conflicts</italic> for detecting the potential value-to-value conflicts among the documents in the XML dataspace <bold><italic>D</italic></bold> as follows:</p>
<p><disp-formula id="disp-formula19-0165551512437532">
<label>(15)</label>
<mml:math display="block" id="math19-0165551512437532">
<mml:mrow>
<mml:mspace width="0.25em"/>
<mml:mtext>search-v</mml:mtext>
<mml:mn>2</mml:mn>
<mml:mtext>v-conflicts</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="bold-italic">D</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mrow>
<mml:mo>{</mml:mo>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>name</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>V</mml:mi>
<mml:mo>)</mml:mo>
</mml:mrow>
</mml:mrow>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">|</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>do</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>name</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mtext>search-d</mml:mtext>
<mml:mn>2</mml:mn>
<mml:mtext>d</mml:mtext>
<mml:mn>2</mml:mn>
<mml:mtext>-conflicts</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="bold-italic">D</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∧</mml:mo>
<mml:mi>V</mml:mi>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">{</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>v</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:msub>
<mml:mrow>
<mml:mi>v</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">|</mml:mo>
<mml:mspace width="0.25em"/>
<mml:msub>
<mml:mrow>
<mml:mi>v</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>∈</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>∧</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>v</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>∈</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>:</mml:mo>
<mml:mtext>similar</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>v</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:msub>
<mml:mrow>
<mml:mi>v</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mi>true</mml:mi>
<mml:mo stretchy="false">}</mml:mo>
<mml:mo stretchy="false">}</mml:mo>
<mml:mo>.</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula19-0165551512437532" xlink:href="10.1177_0165551512437532-eq19.tif"/>
</disp-formula></p>
<p>In other words, the above function produces tuples, which express the pairwise similar values related to the occurrences of <italic>name</italic> in <italic>doc</italic><sub>1</sub> and <italic>doc</italic><sub>2</sub>. Since value-to-value conflicts may occur also within a single document, <italic>doc</italic><sub>1</sub> and <italic>doc</italic><sub>2</sub> may refer to the same document.</p>
<p><italic>Example 11.</italic> In the context of our sample XML dataspace, the result set produced by evaluating the function search-v2v-conflicts(<bold><italic>XDS</italic></bold>) <italic>should</italic> contain, among others, the tuple (D2, D3, composer, {(“Sibelius, Jean”, “Jean Sibelius”)}). Based on this result, the user is able to conclude that the values “Sibelius, Jean” in D2 and “Jean Sibelius” in D3 are semantically equivalent. The above result set should also contain the tuple (D1, D2, price, {($23.98, “EUR 53,00”)}), which indicates that price information in D1 and D2 is expressed using different monetary units. In other words, the above function can also be applied to detect numeric values, which are based on different units of measurement.</p>
<p>It is worth noting that the actual performance of the function <italic>search-v2v-conflicts</italic> depends on the implementation of the function <italic>similar</italic>. For example, our assumption about the behaviour of the function <italic>similar</italic> is rather simplistic. Namely, we assume that the function is capable of identifying only exact matches, whereas the similarity functions typically measure the degree of similarity between the given values. In addition, as stated above the similarity functions are also highly application-specific. For example, there does not exist a string similarity measure that would be universally best [<xref ref-type="bibr" rid="bibr40-0165551512437532">40</xref>]. We leave it for future work to study what kinds of similarity measures are most suitable for detecting value-to-value conflicts among data-centric XML data sources. The alert reader may also have noticed that a similarity function like the one above could also have been used for detecting the potentially conflicting data item names in Formula (13). However, as the detection of the potentially conflicting data values is only meaningful in the context of specific data items, also the detection of the potentially conflicting data item names only makes sense when their related values are considered as well. For example, as shown in Example 9, our sample XML dataspace contains <italic>title</italic> data items which refer to different real-world entity types. This fact could not have been revealed simply by comparing these data item names, but reviewing also the values related to their occurrences is a necessity.</p>
<p>The information provided by the evaluation of the function <italic>search-v2v-conflicts</italic> serves as the starting point for resolving value-to-value conflicts. The value-to-value conflicts are resolved by harmonizing the conflicting values. This means that the non-uniform value representations are replaced with a value specified by the user. For this purpose, we define the function replace-values(<italic>doc, C, V, value</italic>). It modifies an XML document (the argument <italic>doc</italic>) by replacing a set of given values (<italic>V</italic>) that are related to the set of specific data item names (<italic>C</italic>) with the user-specified value (<italic>value</italic>). It is worth noting that the application of <italic>replace-values</italic> does not affect the document structure or data item names. The customization of the XML relation <italic>doc</italic> follows the following principles:</p>
<list id="list4-0165551512437532" list-type="bullet">
<list-item><p>The triples representing data item names remain unaffected in the customized XML relation.</p></list-item>
<list-item><p>The triples representing data item values related to the occurrences of such data items whose names do not appear in <italic>C</italic> remain unaffected.</p></list-item>
<list-item><p>The triples representing data item values related to the occurrences of such data items whose names do appear in <italic>C</italic> but the values themselves do not appear in <italic>V</italic> remain unaffected.</p></list-item>
<list-item><p>In the triples representing data item values related to the occurrences of such data items whose names appear in <italic>C</italic> and the values themselves appear in <italic>V</italic>, the first component of the triple is replaced with the argument <italic>value</italic>.</p></list-item>
</list>
<p>The function <italic>replace-values</italic> is defined as follows (with the individual rows corresponding to each of the above principles):</p>
<p><disp-formula id="disp-formula20-0165551512437532">
<label>(16)</label>
<mml:math display="block" id="math20-0165551512437532">
<mml:mrow>
<mml:mtable align="right" width="80%">
<mml:mtr>
<mml:mtd columnalign="right" columnspan="1">
<mml:mrow>
<mml:mtext>replace-values</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>C</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>V</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>value</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">{</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>t</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>ind</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">|</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>t</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>ind</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo>∧</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>∈</mml:mo>
<mml:mo stretchy="false">{</mml:mo>
<mml:mtext>‘a’</mml:mtext>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext>‘e’</mml:mtext>
<mml:mo stretchy="false">}</mml:mo>
<mml:mo stretchy="false">}</mml:mo>
<mml:mo>∪</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="right" columnspan="1">
<mml:mrow>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">{</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext>‘v’</mml:mtext>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mrow>
<mml:mo>〈</mml:mo>
<mml:mi>ind</mml:mi>
<mml:mo>⊥</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>〉</mml:mo>
</mml:mrow>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">|</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext>‘v’</mml:mtext>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mrow>
<mml:mo>〈</mml:mo>
<mml:mrow>
<mml:mi>in</mml:mi>
</mml:mrow>
<mml:mi>d</mml:mi>
<mml:mo>⊥</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>〉</mml:mo>
</mml:mrow>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo>∧</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mtext>’</mml:mtext>
<mml:mo>,</mml:mo>
<mml:mi>_</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>ind</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo>:</mml:mo>
<mml:mi>n</mml:mi>
<mml:mtext>’</mml:mtext>
<mml:mo>∉</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>C</mml:mi>
<mml:mo stretchy="false">}</mml:mo>
<mml:mo>∪</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="right" columnspan="1">
<mml:mrow>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">{</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext>‘v’</mml:mtext>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mrow>
<mml:mo>〈</mml:mo>
<mml:mi>ind</mml:mi>
<mml:mo>⊥</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>〉</mml:mo>
</mml:mrow>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">|</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext>‘v’</mml:mtext>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mrow>
<mml:mo>〈</mml:mo>
<mml:mrow>
<mml:mi>in</mml:mi>
</mml:mrow>
<mml:mi>d</mml:mi>
<mml:mo>⊥</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>〉</mml:mo>
</mml:mrow>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo>∧</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mtext>’</mml:mtext>
<mml:mo>,</mml:mo>
<mml:mi>_</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>ind</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo>:</mml:mo>
<mml:mi>n</mml:mi>
<mml:mtext>’</mml:mtext>
<mml:mo>∈</mml:mo>
<mml:mi>C</mml:mi>
<mml:mo>∧</mml:mo>
<mml:mi>n</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo>∉</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">}</mml:mo>
<mml:mo>∪</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="right" columnspan="1">
<mml:mrow>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">{</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>value</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext>‘v’</mml:mtext>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mrow>
<mml:mo>〈</mml:mo>
<mml:mi>ind</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo>⊥</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mn>1</mml:mn>
<mml:mo>〉</mml:mo>
</mml:mrow>
<mml:mo stretchy="false">|</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext>‘v’</mml:mtext>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mrow>
<mml:mo>〈</mml:mo>
<mml:mrow>
<mml:mi>ind</mml:mi>
</mml:mrow>
<mml:mspace width="0.25em"/>
<mml:mo>⊥</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mn>1</mml:mn>
<mml:mo>〉</mml:mo>
</mml:mrow>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo>∧</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mtext>’</mml:mtext>
<mml:mo>,</mml:mo>
<mml:mi>_</mml:mi>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>ind</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mi>doc</mml:mi>
<mml:mo>:</mml:mo>
<mml:mi>n</mml:mi>
<mml:mtext>’</mml:mtext>
<mml:mo>∈</mml:mo>
<mml:mi>C</mml:mi>
<mml:mo>∧</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo>∈</mml:mo>
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">}</mml:mo>
<mml:mo>.</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula20-0165551512437532" xlink:href="10.1177_0165551512437532-eq20.tif"/>
</disp-formula></p>
<p><italic>Example 12.</italic> Let us assume that, by analysing the result of the function search-v2v-conflicts(<bold><italic>XSD</italic></bold>), the user has concluded that the values “Jean Sibelius” and “Jean Sibelius (1865-1957)” in <italic>doc3.xml</italic> refer to the same real-world entities (as they are values of the <italic>composer</italic> and <italic>author</italic> elements, respectively). Based on this analysis, they want to replace these varying values with the single value “Sibelius”. This can be done by applying the function replace-values(D3, {composer, author}, {“Jean Sibelius”, “Jean Sibelius (1865-1957)”}, Sibelius). The function transforms the tuples (“Jean Sibelius”, ‘v’, 〈1,1,1,3,1,1〉) and (“Jean Sibelius (1865-1957)”, ‘v’, 〈1,2,4,1〉) into the tuples (Sibelius, ‘v’, 〈1,1,1,3,1,1〉) and (Sibelius, ‘v’, 〈1,2,4,1〉), respectively, while the rest of the tuples in D3 remain unaffected. By customizing the remaining sample documents in a similar fashion, we are able to remove all alternative representations of this value, that is, we resolve the value-to-value conflicts of the first type with respect to the name of the composer Sibelius in our XML dataspace.</p>
<p>The value-to-value conflicts with respect to numeric values, which are represented using different units of measurement, can also be resolved by the function <italic>replace-values</italic>. However, their resolving requires numeric conversion. In other words, a conversion rule must be applied instead of the user-given value as an argument in the function <italic>replace-values</italic>. For example, in the context of our sample XML dataspace the user needs to be provided with a rule, which specifies how the different values of the <italic>price</italic> data item occurrences are converted into the same monetary unit. A more detailed example of this is given in the next section, where we present a summarizing example on how each of the steps in the XML data profiling process based on the architecture described in this section is essential in providing the user with such information on the beforehand unknown data sources that allows them to effectively utilize advanced XML query systems.</p>
</sec>
</sec>
</sec>
<sec id="section16-0165551512437532">
<title>5. XML dataspace profiling in the context of an advanced query system</title>
<p>An XML dataspace profiling system serves two main goals. First, it supports the user in finding out from the available unknown XML data sources those data sources that are useful with respect to their information needs. Second, it increases their understanding about these data sources so that they are able to utilize them in the context of some advanced query system. For example, the effective use of XQuery presupposes that the user masters the contents, structures and semantics of the underlying XML documents. However, the need to manipulate beforehand unknown XML data sources is typically related to satisfying ad hoc information needs. In this case, the underlying data sources are often highly heterogeneous. In other words, many of the data conflict types presented in this article may appear among them. To our best knowledge, RXQL [<xref ref-type="bibr" rid="bibr21-0165551512437532">21</xref>] is so far the only declarative XML query language tailored for manipulating heterogeneous XML documents. In this section, we demonstrate how the increased understanding achieved through the XML dataspace profiling approach introduced in this article enables the effective use of RXQL in order to satisfy the user’s sophisticated information needs.</p>
<p>Let us assume that the user wants to produce <italic>the average prices (in USDs) of the albums containing music composed by Beethoven or Sibelius</italic> based on our sample XML dataspace, with whose contents, structures and semantics they are not beforehand familiar. We further assume that an XML dataspace profiling system built on the formal tools introduced and defined in the previous section is available. Now, according to our XML dataspace profiling approach, the user’s first task is to assess which (if any) of the available XML data sources are useful from the perspective of the above information need. The user can start with analysing the collection at the schema level by applying a tool based on the generalization of the function <italic>data-item-names</italic> (see Formula 7). This produces data item names, such as <italic>album, author, composer, price</italic> and <italic>Sibelius</italic>, which indicate that the available documents might be relevant (they contain information about albums, composers and prices). However, this schema-level analysis is unable to reveal whether the documents also contain music by Beethoven. Thus, the user needs to analyse the collection at the instance level as well. By applying a tool based on the function <italic>data-item-values</italic> (see Formula 3) in our sample XML dataspace, among others, the values “$23.98”, “EUR 53”, “Beethoven, Ludwig van”, Sibelius, Jean”, “Jean Sibelius”, “£6.99”, “EUR 5,99”, “Jean Sibelius (1865 - 1957)”, “Beethoven”, “Sibelius” and “$18.98" are produced. After this, the user can be convinced that the available documents are, indeed, relevant to them. In the above, we have demonstrated how the tools comprising the first main component of our XML dataspace profiling system architecture can be utilized in satisfying the sample information need.</p>
<p>Before the actual RXQL query can be specified, the user must be further assured that the documents of interest are mutually consistent. In other words, the user needs to become aware of all data conflicts that possibly occur among the XML documents selected by the above tools. The tools comprising the second main component of our XML dataspace profiling system architecture support the user in this task. As the results of the schema-level and instance-level analyses already indicated, the selected documents contain several types of inconsistencies. This outcome can be validated by applying tools based on the functions presented in Section 4.2 as follows. First, the application of the tool based on the function <italic>search-doc2doc-conflicts</italic> (see Formula 11) shows that there are no two documents that would be compatible with each other (see Example 7). In other words, several document-to-document conflicts occur among the selected documents. Second, the tool based on the function <italic>search-a2e-conflicts</italic> (see Formula 12) reveals that there exist several attribute-to-element conflicts with respect to <italic>price</italic> and <italic>composer</italic> data items among the sample documents (see Example 8). Third, the tool based on the function <italic>search-d2d2-conflicts</italic> (see Formula 13) reveals, among others, that in <italic>doc3.xml</italic> a data item-to-data item conflict occurs between the data item names <italic>author</italic> and <italic>composer</italic>, because they are used to represent the same real-world entities (i.e. persons that compose music). Fourth, through the tool based on the function <italic>search-d2v-conflicts</italic> (see Formula 14) the user is able to detect the data item-to-value conflict between the data item name <italic>Sibelius</italic> in <italic>doc1xml</italic> and the value <italic>Sibelius</italic> in <italic>doc4.xml</italic> (see Example 10).</p>
<p>The starting point for the effective use of RXQL – or of any other XML query language, for that matter – is that the possible value-to-value conflicts in the underlying XML dataspace are resolved. This requires customization of the data sources. However, as discussed in Section 4.2.5, value-to-value conflicts are more challenging to detect than the other data conflict types. Fortunately, in the case of our compact sample XML dataspace, the instance-level analysis above is enough to reveal that the underlying documents contain two types of value-to-value conflicts: (1) the names of the composers Beethoven and Sibelius have several different typographical representations; and (2) the albums’ prices are represented using different monetary units (USDs, EURs and GBPs). Alternatively, the above information could have been gained by applying the function <italic>search-v2v-conflicts</italic> in Formula (15).</p>
<p>Similarly to Example 12, the user can resolve the first value-to-value conflict by a tool based on the function <italic>replace-values</italic> (see Formula 16), which replaces the varying typographical representations of the composer’ names with the single values “Beethoven” and “Sibelius”. This same function can also be used to harmonize the album prices by applying a simple conversion function with the following exchange rates: 1.00 EUR = 1.38089 USD and 1.00 GBP = 1.57462 USD. After this, the album prices in our sample XML dataspace as expressed in USDs are: 23.98, 72.80, 10.97, 8.23 and 18.98. From here on, we assume that the RXQL query is specified against these customized documents. In the context of our sample query, which is to be specified next, we show how the other data conflict types are resolved by means of RXQL.</p>
<p>The RXQL query satisfying the information need described above is given in <xref ref-type="fig" rid="fig2-0165551512437532">Figure 2</xref>. A detailed description of the syntax of the RXQL query language can be found in [<xref ref-type="bibr" rid="bibr21-0165551512437532">21</xref>], so next we introduce only those features that are needed in our query specification. An RXQL query consists of the mandatory CONSTRUCT and FROM clauses and the optional WHERE and ORDER BY clauses. In the CONSTRUCT clause, the structure and contents of the result document are described. Through nested parentheses, it represents the hierarchical relationships among the data items in the result XML document. An RXQL query produces as a result an XML document containing the data item occurrences based on this description. One of the starting points in the design of RXQL was, in accordance with the arguments in [<xref ref-type="bibr" rid="bibr44-0165551512437532">44</xref>], the avoidance of the use of XML notation in query specification. Thus, in the FROM clause, the user simply expresses which data items from which source documents are extracted, and the meaningfully related data item occurrences are retrieved based on the SPC semantics [<xref ref-type="bibr" rid="bibr45-0165551512437532">45</xref>, <xref ref-type="bibr" rid="bibr28-0165551512437532">28</xref>] used in the query processing. If the CONSTRUCT and FROM clauses contain a common data item name, then its related value that is extracted by the FROM clause is placed as its value in the result document. In the WHERE clause, data selection and aggregation criteria are specified. The ORDER BY clause is used similarly to the corresponding expression in SQL.</p>
<fig id="fig2-0165551512437532" position="float">
<label>Figure 2.</label>
<caption><p>The RXQL query satisfying the sample information need.</p></caption>
<graphic xlink:href="10.1177_0165551512437532-fig2.tif"/>
</fig>
<p>The CONSTRUCT clause of this query expresses that the root element of the result document is labelled as <italic>result</italic> and it contains one or more <italic>album</italic> element occurrences (the ‘+’ sign before the element name), each of which, in turn, contains one <italic>composer</italic> and one <italic>avg-price</italic> element occurrence. The data extraction specifications in the FROM clause are quite straightforward. However, as the tool developed for detecting potential data item-to-value conflicts revealed, in <italic>doc1.xml</italic> a data item occurrence labelled <italic>Sibelius</italic> is used to group the works of the eponymous composer, whereas in the other documents <italic>Sibelius</italic> appears as a value of <italic>composer</italic> and <italic>author</italic> data item occurrences. Therefore, in the first data extraction expression (row 2) “[Sibelius] <bold>INTO</bold> composer” expresses that the data item name <italic>Sibelius</italic> is to be used as the value of a <italic>composer</italic> data item occurrence in the result document. In other words, with this expression the user resolves the data item-to-value conflict in <italic>doc1.xml</italic>. As a whole, the expression in row 2 extracts the values of those <italic>price</italic> data item occurrences that are meaningfully related <italic>Sibelius</italic> data item occurrences in <italic>doc1.xml</italic>. Similarly, the expressions in rows 3, 4 and 5 extract the values of meaningfully related <italic>composer</italic> and <italic>price</italic> data item occurrences in <italic>doc2.xml, doc3.xml</italic> and <italic>doc4.xml</italic>, respectively. The tool for detecting data item-to-data item conflicts revealed that the data item names <italic>author</italic> and <italic>composer</italic> are used to represent the same real-world entities in <italic>doc3.xml</italic>. For this reason, we need the expression “[author, composer] <bold>AS</bold> composer” (in row 4), which indicates that the values of the <italic>author</italic> and <italic>composer</italic> data item occurrences in <italic>doc3.xml</italic> are to be represented as the values of the <italic>composer</italic> element occurrences in the result document.</p>
<p>It is worth noting that, thanks to the SPC semantics utilized in data extraction, in query specification the user can completely ignore the existence of the attribute-to-element and document-to-document conflicts. For example, the tool developed for detecting attribute-to-element conflicts revealed that our sample XML dataspace contains attribute-to-element conflicts with respect to price and composer data items. If we would have specified our sample query in XQuery instead of RXQL, then we would have needed to explicitly specify whether a data item is represented as an element or as an attribute. In RXQL this is not necessary. This is due to the fact that RXQL is at a higher abstraction level and, in it, the user needs only to specify data item names regardless of whether they are represented as attributes or elements in the underlying XML dataspace. Since the SPC semantics automatically extracts the meaningfully related data item occurrences, the user need not pay attention to their actual location in the document hierarchy. In other words, the same data extraction expression is able to cover varyingly structured documents.</p>
<p>The WHERE clause of this query contains both a selection operation and an aggregation operation. In row 6, we have a disjunctive selection operation similar to SQL through which the user expresses that the <italic>composer</italic> element occurrences may only have the values “Beethoven” and “Sibelius” in the result document. (If our sample XML dataspace would also contain music by other composers, this expression would have eliminated them from the result.) The expression in row 7 states that the values of the <italic>avg-price</italic> element occurrences in the result document are produced by calculating the averages (the function AVG) of the values of <italic>price</italic> data item occurrences for each value of <italic>composer</italic> data item occurrences. The final row of the query states that in the result document the <italic>album</italic> element occurrences are ordered in ascending order based on the values of the <italic>composer</italic> element occurrences within them. The result of the query is given in <xref ref-type="fig" rid="fig3-0165551512437532">Figure 3</xref>. In this section, we have demonstrated how the dataspace profiling approach presented in this article supports the satisfaction of sophisticated information needs among heterogeneous and beforehand unfamiliar XML data sources.</p>
<fig id="fig3-0165551512437532" position="float">
<label>Figure 3.</label>
<caption><p>The result of the RXQL query in <xref ref-type="fig" rid="fig2-0165551512437532">Figure 2</xref>.</p></caption>
<graphic xlink:href="10.1177_0165551512437532-fig3.tif"/>
</fig>
</sec>
<sec id="section17-0165551512437532" sec-type="discussion">
<title>6. Discussion</title>
<p>In the previous section, we described a typical use case related to the utilization of an XML dataspace profiling system. Profiling is a prerequisite for the effective utilization of dataspaces, since it is not likely that anyone has intimate familiarity with a dataspace composed of data from autonomous and heterogeneous data sources [<xref ref-type="bibr" rid="bibr13-0165551512437532">13</xref>]. Dataspace profiling is highly dependent on the underlying data model, even though dataspace systems have been generally intended to tolerate data based on multiple data models. For example, the dataspace systems in [<xref ref-type="bibr" rid="bibr12-0165551512437532">12</xref>, <xref ref-type="bibr" rid="bibr13-0165551512437532">13</xref>] store their triples in relational-style tables. The approach in this article is based on XML. This premise is justified by the popularity of the XML format and by the fact that most existing data formats can be converted into XML. To our best knowledge, this is the first work to consider XML dataspace profiling. Moreover, the dataspaces in this article are assumed to be formed based on the users’ ad hoc information needs and thus are likely to have short life expectancy. The subject of short-lived dataspaces has not so far been widely researched [<xref ref-type="bibr" rid="bibr46-0165551512437532">46</xref>].</p>
<p>This article presents an architecture for an XML dataspace profiling system in the form of a set of interconnected formal tools. Concurrently to this work, we are implementing the functionalities of these tools as a part of a prototype dataspace support platform (DSSP) (for the explanation of the term, see [<xref ref-type="bibr" rid="bibr5-0165551512437532">5</xref>, <xref ref-type="bibr" rid="bibr6-0165551512437532">6</xref>]). In addition to basic search capabilities, the XML dataspace profiling module of our DSSP contains a visual interface that supports the user in assessing the usefulness of the available data sources in the underlying XML dataspace from the perspective of their information needs. It represents the contents and structure of an XML document as tree visualization, which is formed by displaying the distinct data item names of a data source and connecting them through arcs describing their hierarchical relationships. This kind of representation allows the user to analyse complex XML documents structurally and at the schema level by simple visual examination. Moreover, the visual interface provides the user with, among other additional features, the opportunity to analyse the data at the instance level in a straightforward manner by reviewing the distinct values related to the individual data item names, and also to detect potential data conflicts between and within the underlying data sources. In our future work, we intend to integrate the expressive power of the RXQL query language and our XML dataspace profiling approach into one powerful system for querying and manipulating highly heterogeneous XML data sources. The XML dataspace profiling module is being implemented in Java, and it utilizes the PostgreSQL implementation of the XML relations already used in [<xref ref-type="bibr" rid="bibr21-0165551512437532">21</xref>].</p>
<p>The approach presented in this article gives rise to two interesting topics for future research. First, various collection statistics can be produced as by-products when the data sources in an XML dataspace are analysed according to the principles described in this article. For example, during the application of the tool based on the function <italic>data-item-names</italic> (Formula 7), it is easy to compute the number of occurrences of individual data item names in the dataspace. With equal ease, the number of the distinct values related to these data item names can be produced while the tool based on the function <italic>data-item-values</italic> (Formula 3) is being applied. These, together with other statistics, can be used, for example, to derive the co-occurrence probabilities between data item names or to form the distributions of their distinct values, which can provide deeper understanding about the underlying dataspace. Our future work will study the possibilities to utilize the various collection statistics in the context of XML dataspace profiling. The outcome of this work will be integrated as a part of the prototype DSSP.</p>
<p>The second topic for future research originates from the fact that the data sources in a dataspace are likely to contain information that can be used to connect their contents semantically to each other. Our XML dataspace profiling approach provides mechanisms in terms of which the user is able to explore the information contents and structural relationships in beforehand unknown XML data sources. This information, in turn, facilitates the discovery of unknown semantic relationships between data in given data sources. Contrary to conventional query formulation, which requires that the user knows the semantic relationships in advance and, based on this knowledge, specifies the navigation among the available data, the goal in the discovery of unknown semantic relationships is to provide the user with navigation paths which make up these relationships. These kinds of paths are generally called semantic associations [<xref ref-type="bibr" rid="bibr47-0165551512437532">47</xref><xref ref-type="bibr" rid="bibr48-0165551512437532"/>–<xref ref-type="bibr" rid="bibr49-0165551512437532">49</xref>]. Formally, a semantic association is a sequence of binary relationships in which each binary relationship expresses a basic semantic relationship between two entities. For example, in our sample XML dataspace we are able to connect two record labels to each other based on the fact that they have released albums containing music composed by the same composer. Semantic associations are often transitive. Namely, if the documents <italic>A</italic> and <italic>B</italic> are semantically connected through a piece of information <italic>i</italic><sub>1</sub> and the documents <italic>B</italic> and <italic>C</italic> are similarly connected through a piece of information <italic>i</italic><sub>2</sub>, then the documents <italic>A</italic> and <italic>C</italic> are transitively connected to each other. The chains of semantic associations can be arbitrarily long. In [<xref ref-type="bibr" rid="bibr48-0165551512437532">48</xref>, <xref ref-type="bibr" rid="bibr49-0165551512437532">49</xref>], we introduced a query language capable of constructing semantic associations based on the underlying basic relationships. In our future work, we aim to study how these basic associations can be extracted through XML dataspace profiling.</p>
</sec>
<sec id="section18-0165551512437532" sec-type="conclusions">
<title>7. Conclusions</title>
<p>The purpose of dataspace systems is to offer an easy-to-set-up and cost-effective way to organize the cooperation between unfamiliar, autonomous and heterogeneous data sources. This article has introduced a dataspace profiling approach which provides the user with such information that enables the utilization of these kinds of data sources in satisfying their sophisticated information needs. We have presented and specified an architecture for an XML dataspace profiling system, which serves two goals. First, it assists the user in selecting from the data sources in the underlying XML dataspace those data sources that are useful from the perspective of their information needs. Second, it assists them in validating the consistency of the selected data sources by means of detecting the potential data conflicts. Resolving some of the data conflicts – which is a typical precondition for effective querying – requires the customization of the original XML data sources. We have also contributed a solution for this task. Our XML dataspace profiling system approach comprises a set of tools that were formally defined based on the relational representation of XML documents. Further, we have demonstrated through a practical example that the information produced by XML dataspace profiling is a necessary prerequisite for the effective utilization of beforehand unfamiliar, autonomous and heterogeneous data sources when using an advanced XML query system.</p>
</sec>
</body>
<back>
<app-group>
<app id="app1-0165551512437532">
<title>Appendix</title>
<table-wrap id="table1-0165551512437532" position="float">
<label>Table A1.</label>
<caption><p>The XML relation D1 for <italic>doc1.xml</italic></p></caption>
<graphic alternate-form-of="table1-0165551512437532" xlink:href="10.1177_0165551512437532-table1.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="left"/>
<col align="left"/>
</colgroup>
<thead>
<tr>
<th align="left">Data item</th>
<th align="left">Type</th>
<th align="left">Index</th>
</tr>
</thead>
<tbody>
<tr>
<td>album</td>
<td>‘e’</td>
<td>〈1〉</td>
</tr>
<tr>
<td>label</td>
<td>‘e’</td>
<td>〈1,1〉</td>
</tr>
<tr>
<td>“Deutsche Grammophon”</td>
<td>‘v’</td>
<td>〈1,1,1〉</td>
</tr>
<tr>
<td>serial</td>
<td>‘e’</td>
<td>〈1,2〉</td>
</tr>
<tr>
<td>“0002 894 577 482 4”</td>
<td>‘v’</td>
<td>〈1,2,1〉</td>
</tr>
<tr>
<td>number-of-discs</td>
<td>‘e’</td>
<td>〈1,3〉</td>
</tr>
<tr>
<td>2</td>
<td>‘v’</td>
<td>〈1,3,1〉</td>
</tr>
<tr>
<td>date</td>
<td>‘e’</td>
<td>〈1,4〉</td>
</tr>
<tr>
<td>“01 Mar. 1999”</td>
<td>‘v’</td>
<td>〈1,4,1〉</td>
</tr>
<tr>
<td>title</td>
<td>‘e’</td>
<td>〈1,5〉</td>
</tr>
<tr>
<td>“Jean Sibelius: Symphonies Nos. 4-7”</td>
<td>‘v’</td>
<td>〈1,5,1〉</td>
</tr>
<tr>
<td>details</td>
<td>‘e’</td>
<td>〈1,6〉</td>
</tr>
<tr>
<td>Sibelius</td>
<td>‘e’</td>
<td>〈1,6,1〉</td>
</tr>
<tr>
<td>work</td>
<td>‘e’</td>
<td>〈1,6,1,1〉</td>
</tr>
<tr>
<td>“Symphony No.4 in A minor, Op.63”</td>
<td>‘v’</td>
<td>〈1,6,1,1,1〉</td>
</tr>
<tr>
<td>work</td>
<td>‘e’</td>
<td>〈1,6,1,2〉</td>
</tr>
<tr>
<td>“The Swan of Tuonela, Op.22, No.2”</td>
<td>‘v’</td>
<td>〈1,6,1,2,1〉</td>
</tr>
<tr>
<td>work</td>
<td>‘e’</td>
<td>〈1,6,1,3〉</td>
</tr>
<tr>
<td>“Symphony No.5 in E flat, Op.82”</td>
<td>‘v’</td>
<td>〈1,6,1,3,1〉</td>
</tr>
<tr>
<td>work</td>
<td>‘e’</td>
<td>〈1,6,1,4〉</td>
</tr>
<tr>
<td>“Symphony No.6 in D minor, Op.104”</td>
<td>‘v’</td>
<td>〈1,6,1,4,1〉</td>
</tr>
<tr>
<td>work</td>
<td>‘e’</td>
<td>〈1,6,1,5〉</td>
</tr>
<tr>
<td>“Symphony No.7 in C, Op.105”</td>
<td>‘v’</td>
<td>〈1,6,1,5,1〉</td>
</tr>
<tr>
<td>work</td>
<td>‘e’</td>
<td>〈1,6,1,6〉</td>
</tr>
<tr>
<td>“Tapiola, Op.112”</td>
<td>‘v’</td>
<td>〈1,6,1,6,1〉</td>
</tr>
<tr>
<td>artists</td>
<td>‘e’</td>
<td>〈1,6,2〉</td>
</tr>
<tr>
<td>ensemble</td>
<td>‘e’</td>
<td>〈1,6,2,1〉</td>
</tr>
<tr>
<td>“Berliner Philharmoniker”</td>
<td>‘v’</td>
<td>〈1,6,2,1,1〉</td>
</tr>
<tr>
<td>conductor</td>
<td>‘e’</td>
<td>〈1,6,2,2〉</td>
</tr>
<tr>
<td>“Karajan, Herbert von”</td>
<td>‘v’</td>
<td>〈1,6,2,2,1〉</td>
</tr>
<tr>
<td>price</td>
<td>‘e’</td>
<td>〈1,7〉</td>
</tr>
<tr>
<td>$23.98</td>
<td>‘v’</td>
<td>〈1,7,1〉</td>
</tr>
<tr>
<td>additional-information</td>
<td>‘e’</td>
<td>〈1,8〉</td>
</tr>
</tbody>
</table>
</table-wrap>
<table-wrap id="table2-0165551512437532" position="float">
<label>Table A2.</label>
<caption><p>The XML relation D2 for <italic>doc2.xml</italic></p></caption>
<graphic alternate-form-of="table2-0165551512437532" xlink:href="10.1177_0165551512437532-table2.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="left"/>
<col align="left"/>
</colgroup>
<thead>
<tr>
<th align="left">Data item</th>
<th align="left">Type</th>
<th align="left">Index</th>
</tr>
</thead>
<tbody>
<tr>
<td>album</td>
<td>‘e’</td>
<td>〈1〉</td>
</tr>
<tr>
<td>price</td>
<td>‘a’</td>
<td>〈1,1〉</td>
</tr>
<tr>
<td>“EUR 53”</td>
<td>‘v’</td>
<td>〈1,1,1〉</td>
</tr>
<tr>
<td>label</td>
<td>‘e’</td>
<td>〈1,2〉</td>
</tr>
<tr>
<td>Philips</td>
<td>‘v’</td>
<td>〈1,2,1〉</td>
</tr>
<tr>
<td>serial</td>
<td>‘e’</td>
<td>〈1,3〉</td>
</tr>
<tr>
<td>“000289 464 6822 7”</td>
<td>‘v’</td>
<td>〈1,3,1〉</td>
</tr>
<tr>
<td>date</td>
<td>‘e’</td>
<td>〈1,4〉</td>
</tr>
<tr>
<td>“01 April 2001”</td>
<td>‘v’</td>
<td>〈1,4,1〉</td>
</tr>
<tr>
<td>title</td>
<td>‘e’</td>
<td>〈1,5〉</td>
</tr>
<tr>
<td>“Beethoven: Symphony No.5 / Sibelius: Symphony No.2”</td>
<td>‘v’</td>
<td>〈1,5,1〉</td>
</tr>
<tr>
<td>details</td>
<td>‘e’</td>
<td>〈1,6〉</td>
</tr>
<tr>
<td>work</td>
<td>‘e’</td>
<td>〈1,6,1〉</td>
</tr>
<tr>
<td>composer</td>
<td>‘a’</td>
<td>〈1,6,1,1〉</td>
</tr>
<tr>
<td>“Beethoven, Ludwig van”</td>
<td>‘v’</td>
<td>〈1,6,1,1,1〉</td>
</tr>
<tr>
<td>“Symphony No.5 in C minor, Op.67”</td>
<td>‘v’</td>
<td>〈1,6,1,2〉</td>
</tr>
<tr>
<td>work</td>
<td>‘e’</td>
<td>〈1,6,2〉</td>
</tr>
<tr>
<td>composer</td>
<td>‘a’</td>
<td>〈1,6,2,1〉</td>
</tr>
<tr>
<td>“Sibelius, Jean”</td>
<td>‘v’</td>
<td>〈1,6,2,1,1〉</td>
</tr>
<tr>
<td>“Symphony No.2 in D, Op.43”</td>
<td>‘v’</td>
<td>〈1,6,2,2〉</td>
</tr>
<tr>
<td>artists</td>
<td>‘e’</td>
<td>〈1,6,3〉</td>
</tr>
<tr>
<td>ensemble</td>
<td>‘e’</td>
<td>〈1,6,3,1〉</td>
</tr>
<tr>
<td>“Royal Concertgebouw Orchestra”</td>
<td>‘v’</td>
<td>〈1,6,3,1,1〉</td>
</tr>
<tr>
<td>conductor</td>
<td>‘e’</td>
<td>〈1,6,3,2〉</td>
</tr>
<tr>
<td>“George Szell”</td>
<td>‘v’</td>
<td>〈1,6,3,2,1〉</td>
</tr>
</tbody>
</table>
</table-wrap>
<table-wrap id="table3-0165551512437532" position="float">
<label>Table A3.</label>
<caption><p>The XML relation D3 for <italic>doc3.xml</italic></p></caption>
<graphic alternate-form-of="table3-0165551512437532" xlink:href="10.1177_0165551512437532-table3.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="left"/>
<col align="left"/>
</colgroup>
<thead>
<tr>
<th align="left">Data item</th>
<th align="left">Type</th>
<th align="left">Index</th>
</tr>
</thead>
<tbody>
<tr>
<td>albums</td>
<td>‘e’</td>
<td>〈1〉</td>
</tr>
<tr>
<td>album</td>
<td>‘e’</td>
<td>〈1,1〉</td>
</tr>
<tr>
<td>details</td>
<td>‘e’</td>
<td>〈1,1,1〉</td>
</tr>
<tr>
<td>label</td>
<td>‘e’</td>
<td>〈1,1,1,1〉</td>
</tr>
<tr>
<td>“EMI Classics”</td>
<td>‘v’</td>
<td>〈1,1,1,1,1〉</td>
</tr>
<tr>
<td>title</td>
<td>‘e’</td>
<td>〈1,1,1,2〉</td>
</tr>
<tr>
<td>“Sibelius: Symphony Nos. 2 and 5”</td>
<td>‘v’</td>
<td>〈1,1,1,2,1〉</td>
</tr>
<tr>
<td>composers</td>
<td>‘e’</td>
<td>〈1,1,1,3〉</td>
</tr>
<tr>
<td>composer</td>
<td>‘e’</td>
<td>〈1,1,1,3,1〉</td>
</tr>
<tr>
<td>“Jean Sibelius”</td>
<td>‘v’</td>
<td>〈1,1,1,3,1,1〉</td>
</tr>
<tr>
<td>artists</td>
<td>‘e’</td>
<td>〈1,1,1,4〉</td>
</tr>
<tr>
<td>ensemble</td>
<td>‘e’</td>
<td>〈1,1,1,4,1〉</td>
</tr>
<tr>
<td>“Philharmonia Orchestra”</td>
<td>‘v’</td>
<td>〈1,1,1,4,1,1〉</td>
</tr>
<tr>
<td>conductor</td>
<td>‘e’</td>
<td>〈1,1,1,4,2〉</td>
</tr>
<tr>
<td>“Herbert von Karajan”</td>
<td>‘v’</td>
<td>〈1,1,1,4,2,1〉</td>
</tr>
<tr>
<td>catalogue-number</td>
<td>‘e’</td>
<td>〈1,1,1,5〉</td>
</tr>
<tr>
<td>0724347688225</td>
<td>‘v’</td>
<td>〈1,1,1,5,1〉</td>
</tr>
<tr>
<td>works</td>
<td>‘e’</td>
<td>〈1,1,1,6〉</td>
</tr>
<tr>
<td>work</td>
<td>‘e’</td>
<td>〈1,1,1,6,1〉</td>
</tr>
<tr>
<td>title</td>
<td>‘a’</td>
<td>〈1,1,1,6,1,1〉</td>
</tr>
<tr>
<td>“Symphony No.2 in D, Op.43”</td>
<td>‘v’</td>
<td>〈1,1,1,6,1,1,1〉</td>
</tr>
<tr>
<td>work</td>
<td>‘e’</td>
<td>〈1,1,1,6,2〉</td>
</tr>
<tr>
<td>title</td>
<td>‘a’</td>
<td>〈1,1,1,6,2,1〉</td>
</tr>
<tr>
<td>“Symphony No.5 in E flat, Op.82”</td>
<td>‘v’</td>
<td>〈1,1,1,6,2,1,1〉</td>
</tr>
<tr>
<td>price</td>
<td>‘a’</td>
<td>〈1,1,2〉</td>
</tr>
<tr>
<td>£6.99</td>
<td>‘v’</td>
<td>〈1,1,2,1〉</td>
</tr>
<tr>
<td>album</td>
<td>‘e’</td>
<td>〈1,2〉</td>
</tr>
<tr>
<td>price</td>
<td>‘a’</td>
<td>〈1,2,1〉</td>
</tr>
<tr>
<td>“EUR 5,99”</td>
<td>‘v’</td>
<td>〈1,2,1,1〉</td>
</tr>
<tr>
<td>label</td>
<td>‘e’</td>
<td>〈1,2,2〉</td>
</tr>
<tr>
<td>“EMI Classics”</td>
<td>‘v’</td>
<td>〈1,2,2,1〉</td>
</tr>
<tr>
<td>title</td>
<td>‘e’</td>
<td>〈1,2,3〉</td>
</tr>
<tr>
<td>“Sibelius: Symphonies Nos. 4 &amp; 5”</td>
<td>‘v’</td>
<td>〈1,2,3,1〉</td>
</tr>
<tr>
<td>author</td>
<td>‘e’</td>
<td>〈1,2,4〉</td>
</tr>
<tr>
<td>“Jean Sibelius (1865 – 1957)”</td>
<td>‘v’</td>
<td>〈1,2,4,1〉</td>
</tr>
<tr>
<td>artists</td>
<td>‘e’</td>
<td>〈1,2,5〉</td>
</tr>
<tr>
<td>conductor</td>
<td>‘e’</td>
<td>〈1,2,5,1〉</td>
</tr>
<tr>
<td>“Herbert von Karajan (1908 -1989)”</td>
<td>‘v’</td>
<td>〈1,2,5,1,1〉</td>
</tr>
<tr>
<td>ensemble</td>
<td>‘e’</td>
<td>〈1,2,5,2〉</td>
</tr>
<tr>
<td>“Berlin Philharmonic Orchestra”</td>
<td>‘v’</td>
<td>〈1,2,5,2,1〉</td>
</tr>
<tr>
<td>catalogue-number</td>
<td>‘e’</td>
<td>〈1,2,6〉</td>
</tr>
<tr>
<td>5099952187223</td>
<td>‘v’</td>
<td>〈1,2,6,1〉</td>
</tr>
<tr>
<td>works</td>
<td>‘e’</td>
<td>〈1,2,7〉</td>
</tr>
<tr>
<td>work</td>
<td>‘e’</td>
<td>〈1,2,7,1〉</td>
</tr>
<tr>
<td>title</td>
<td>‘e’</td>
<td>〈1,2,7,1,1〉</td>
</tr>
<tr>
<td>“Symphony No.4 in A minor, Op.63”</td>
<td>‘v’</td>
<td>〈1,2,7,1,1,1〉</td>
</tr>
<tr>
<td>work</td>
<td>‘e’</td>
<td>〈1,2,7,2〉</td>
</tr>
<tr>
<td>title</td>
<td>‘e’</td>
<td>〈1,2,7,2,1〉</td>
</tr>
<tr>
<td>“Symphony No.5 in E flat, Op.82”</td>
<td>‘v’</td>
<td>〈1,2,7,2,1,1〉</td>
</tr>
</tbody>
</table>
</table-wrap>
<table-wrap id="table4-0165551512437532" position="float">
<label>Table A4.</label>
<caption><p>The XML relation D4 for <italic>doc4.xml</italic></p></caption>
<graphic alternate-form-of="table4-0165551512437532" xlink:href="10.1177_0165551512437532-table4.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="left"/>
<col align="left"/>
</colgroup>
<thead>
<tr>
<th align="left">Data item</th>
<th align="left">Type</th>
<th align="left">Index</th>
</tr>
</thead>
<tbody>
<tr>
<td>album</td>
<td>‘e’</td>
<td>〈1〉</td>
</tr>
<tr>
<td>label</td>
<td>‘e’</td>
<td>〈1,1〉</td>
</tr>
<tr>
<td>“Sony Classical”</td>
<td>‘v’</td>
<td>〈1,1,1〉</td>
</tr>
<tr>
<td>title</td>
<td>‘e’</td>
<td>〈1,2〉</td>
</tr>
<tr>
<td>“Beethoven: Piano Concerto No.3 / Sibelius: Symphony No.5”</td>
<td>‘v’</td>
<td>〈1,2,1〉</td>
</tr>
<tr>
<td>serial</td>
<td>‘e’</td>
<td>〈1,3〉</td>
</tr>
<tr>
<td>88697287822</td>
<td>‘v’</td>
<td>〈1,3,1〉</td>
</tr>
<tr>
<td>release-date</td>
<td>‘e’</td>
<td>〈1,4〉</td>
</tr>
<tr>
<td>“11 April 2008”</td>
<td>‘v’</td>
<td>〈1,4,1〉</td>
</tr>
<tr>
<td>works</td>
<td>‘e’</td>
<td>〈1,5〉</td>
</tr>
<tr>
<td>work</td>
<td>‘e’</td>
<td>〈1,5,1〉</td>
</tr>
<tr>
<td>composer</td>
<td>‘e’</td>
<td>〈1,5,1,1〉</td>
</tr>
<tr>
<td>Beethoven</td>
<td>‘v’</td>
<td>〈1,5,1,1,1〉</td>
</tr>
<tr>
<td>title</td>
<td>‘e’</td>
<td>〈1,5,1,2〉</td>
</tr>
<tr>
<td>“Piano Concerto No.3 in C minor”</td>
<td>‘v’</td>
<td>〈1,5,1,2,1〉</td>
</tr>
<tr>
<td>artists</td>
<td>‘e’</td>
<td>〈1,5,1,3〉</td>
</tr>
<tr>
<td>soloist</td>
<td>‘e’</td>
<td>〈1,5,1,3,1〉</td>
</tr>
<tr>
<td>“Glenn Gould”</td>
<td>‘v’</td>
<td>〈1,5,1,3,1,1〉</td>
</tr>
<tr>
<td>ensemble</td>
<td>‘e’</td>
<td>〈1,5,1,3,2〉</td>
</tr>
<tr>
<td>BPO</td>
<td>‘v’</td>
<td>〈1,5,1,3,2,1〉</td>
</tr>
<tr>
<td>conductor</td>
<td>‘e’</td>
<td>〈1,5,1,3,3〉</td>
</tr>
<tr>
<td>“Herbert von Karajan”</td>
<td>‘v’</td>
<td>〈1,5,1,3,3,1〉</td>
</tr>
<tr>
<td>work</td>
<td>‘e’</td>
<td>〈1,5,2〉</td>
</tr>
<tr>
<td>composer</td>
<td>‘e’</td>
<td>〈1,5,2,1〉</td>
</tr>
<tr>
<td>Sibelius</td>
<td>‘v’</td>
<td>〈1,5,2,1,1〉</td>
</tr>
<tr>
<td>title</td>
<td>‘e’</td>
<td>〈1,5,2,2〉</td>
</tr>
<tr>
<td>“Symphony No.5 in E flat major”</td>
<td>‘v’</td>
<td>〈1,5,2,2,1〉</td>
</tr>
<tr>
<td>ensemble</td>
<td>‘e’</td>
<td>〈1,5,2,3〉</td>
</tr>
<tr>
<td>BPO</td>
<td>‘v’</td>
<td>〈1,5,2,3,1〉</td>
</tr>
<tr>
<td>conductor</td>
<td>‘e’</td>
<td>〈1,5,2,4〉</td>
</tr>
<tr>
<td>“Herbert von Karajan”</td>
<td>‘v’</td>
<td>〈1,5,2,4,1〉</td>
</tr>
<tr>
<td>price</td>
<td>‘e’</td>
<td>〈1,6〉</td>
</tr>
<tr>
<td>$18.98</td>
<td>‘v’</td>
<td>〈1,6,1〉</td>
</tr>
</tbody>
</table>
</table-wrap>
</app>
</app-group>
<ack>
<p>This work was supported by the Tampere Doctoral Programme in Information Science and Engineering (TISE) and the Academy of Finland (under the project no. 140315).</p>
</ack>
<notes>
<fn-group>
<fn fn-type="other" id="fn1-0165551512437532">
<label>1</label>
<p>Another type of value-to-value conflict occurs when semantically non-equivalent data item values are represented identically. This is more widely known as the problem of homonymy. For example, [<xref ref-type="bibr" rid="bibr33-0165551512437532">33</xref>] reviews and devises techniques for detecting homonymies. The removal of homonymous values is hard (e.g. if ‘Paris, France’ and ‘Paris, New York’ are referred to the single term ‘Paris’, their replacing requires manual appraisal of all relevant records), this is why the study of their detection and removal are left for future work.</p></fn>
<fn fn-type="other" id="fn2-0165551512437532">
<label>2</label>
<p>In addition, an XML document may also have elements with mixed contents that consist of both other data items and textual values. This is characteristic to document-centric XML documents where element labels are used mainly to annotate entities in the text. However, in data-centric documents, which are the focus in this article, elements are more often used either to group information or to represent compact values. For this reason, in our XML dataspace profiling approach the manipulation of elements with mixed contents are omitted.</p></fn>
<fn fn-type="other" id="fn3-0165551512437532">
<label>3</label>
<p>In literature, the problem of entity matching is also known as duplicate identification, record linkage, entity resolution, reference reconciliation [<xref ref-type="bibr" rid="bibr40-0165551512437532">40</xref>], instance identification, name matching, duplicate record detection [<xref ref-type="bibr" rid="bibr41-0165551512437532">41</xref>] and data instance matching [<xref ref-type="bibr" rid="bibr42-0165551512437532">42</xref>]. The name disambiguation problem [<xref ref-type="bibr" rid="bibr33-0165551512437532">33</xref>] is its special case.</p></fn>
</fn-group>
</notes>
<ref-list>
<title>References</title>
<ref id="bibr1-0165551512437532">
<label>[1]</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Breitbart</surname><given-names>Y</given-names></name>
<name><surname>Olson</surname><given-names>PH</given-names></name>
<name><surname>Thompson</surname><given-names>GR</given-names></name>
</person-group>. <article-title>Database integration in distributed heterogeneous database systems</article-title>. In: <conf-name>Proceedings of the second international conference on data engineering</conf-name>. <conf-loc>Washington, DC: IEEE Computer Society</conf-loc>, <year>1986</year>, pp. <fpage>301</fpage>–<lpage>310</lpage>.</citation>
</ref>
<ref id="bibr2-0165551512437532">
<label>[2]</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Bruckner</surname><given-names>RM</given-names></name>
<name><surname>Ling</surname><given-names>TW</given-names></name>
<name><surname>Mangisengi</surname><given-names>O</given-names></name>
<name><surname>Tjoa</surname><given-names>AM</given-names></name>
</person-group>. <article-title>A framework for a multidimensional OLAP model using topic maps</article-title>. In: <person-group person-group-type="editor">
<name><surname>Ling</surname><given-names>TW</given-names></name>
<etal/>
</person-group>. (eds) <source>Proceedings of the 3rd international conference on web information systems engineering</source>. <publisher-loc>Washington, DC</publisher-loc>: <publisher-name>IEEE Computer Society</publisher-name>, <year>2002</year>, pp. <fpage>109</fpage>–<lpage>118</lpage>.</citation>
</ref>
<ref id="bibr3-0165551512437532">
<label>[3]</label>
<citation citation-type="book">
<person-group person-group-type="editor">
<name><surname>Kolaitis</surname><given-names>PK</given-names></name>
</person-group>. <article-title>Schema mappings, data exchange, and metadata management</article-title>. In: <person-group person-group-type="editor">
<name><surname>Li</surname><given-names>C</given-names></name>
</person-group> (ed.) <source>Proceedings of the 24th ACM SIGACT-SIGMOD-SIGART symposium on principles of database systems</source>. <publisher-loc>New York</publisher-loc>: <publisher-name>ACM Press</publisher-name>, <year>2005</year>, pp. <fpage>61</fpage>–<lpage>75</lpage>.</citation>
</ref>
<ref id="bibr4-0165551512437532">
<label>[4]</label>
<citation citation-type="book">
<person-group person-group-type="editor">
<name><surname>Arenas</surname><given-names>M</given-names></name>
<name><surname>Libkin</surname><given-names>L</given-names></name>
</person-group>. <article-title>XML data exchange: consistency and query answering</article-title>. In: <person-group person-group-type="editor">
<name><surname>Li</surname><given-names>C</given-names></name>
</person-group> (ed.) <source>Proceedings of the 24th ACM SIGACT-SIGMOD-SIGART symposium on principles of database systems</source>. <publisher-loc>New York</publisher-loc>: <publisher-name>ACM Press</publisher-name>, <year>2005</year>, pp. <fpage>13</fpage>–<lpage>24</lpage>.</citation>
</ref>
<ref id="bibr5-0165551512437532">
<label>[5]</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Franklin</surname><given-names>M</given-names></name>
<name><surname>Halevy</surname><given-names>A</given-names></name>
<name><surname>Maier</surname><given-names>D</given-names></name>
</person-group>. <article-title>From databases to dataspaces</article-title>. <source>SIGMOD Record</source> <year>2005</year>; <volume>34</volume>(<issue>4</issue>): <fpage>27</fpage>–<lpage>31</lpage>.</citation>
</ref>
<ref id="bibr6-0165551512437532">
<label>[6]</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Halevy</surname><given-names>A</given-names></name>
<name><surname>Franklin</surname><given-names>M</given-names></name>
<name><surname>Maier</surname><given-names>D</given-names></name>
</person-group>. <article-title>Principles of dataspace systems</article-title>. In: <person-group person-group-type="editor">
<name><surname>Vansummeren</surname><given-names>S</given-names></name>
</person-group> (ed.) <source>Proceedings of the 25th ACM SIGACT-SIGMOD-SIGART symposium on principles of database systems</source>. <publisher-loc>New York</publisher-loc>: <publisher-name>ACM Press</publisher-name>, <year>2006</year>, pp. <fpage>1</fpage>–<lpage>9</lpage>.</citation>
</ref>
<ref id="bibr7-0165551512437532">
<label>[7]</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Madhavan</surname><given-names>J</given-names></name>
<name><surname>Jeffery</surname><given-names>SR</given-names></name>
<name><surname>Cohen</surname><given-names>S</given-names></name>
<name><surname>Dong</surname><given-names>X</given-names></name>
<name><surname>Ko</surname><given-names>D</given-names></name>
<name><surname>Yu</surname><given-names>C</given-names></name>
<name><surname>Halevy</surname><given-names>A</given-names></name>
</person-group>. <article-title>Web-scale data integration: you can only afford to pay as you go</article-title>. In: <conf-name>Proceedings of the 3rd biennial conference on innovative data systems research</conf-name> <volume>2007</volume>: <fpage>342</fpage>–<lpage>350</lpage>.</citation>
</ref>
<ref id="bibr8-0165551512437532">
<label>[8]</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Jeffery</surname><given-names>SR</given-names></name>
<name><surname>Franklin</surname><given-names>MJ</given-names></name>
<name><surname>Halevy</surname><given-names>A</given-names></name>
</person-group>. <article-title>Pay-as-you-go user feedback for dataspace systems</article-title>. In: <person-group person-group-type="editor">
<name><surname>Wang</surname><given-names>JT-L</given-names></name>
</person-group> (ed.) <source>Proceedings of the ACM SIGMOD international conference on management of data</source>. <publisher-loc>New York</publisher-loc>: <publisher-name>ACM Press</publisher-name>, <year>2008</year>, pp. <fpage>847</fpage>–<lpage>860</lpage>.</citation>
</ref>
<ref id="bibr9-0165551512437532">
<label>[9]</label>
<citation citation-type="book">
<person-group person-group-type="editor">
<name><surname>Sarma</surname><given-names>AD</given-names></name>
<name><surname>Dong</surname><given-names>X</given-names></name>
<name><surname>Halevy</surname><given-names>A</given-names></name>
</person-group>. <article-title>Bootstrapping pay-as-you-go data integration systems</article-title>. In: <person-group person-group-type="editor">
<name><surname>Wang</surname><given-names>JT-L</given-names></name>
</person-group> (ed.) <source>Proceedings of the ACM SIGMOD international conference on management of data</source>. <publisher-loc>New York</publisher-loc>: <publisher-name>ACM Press</publisher-name>, <year>2008</year>, pp. <fpage>861</fpage>–<lpage>874</lpage>.</citation>
</ref>
<ref id="bibr10-0165551512437532">
<label>[10]</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Belhajjame</surname><given-names>K</given-names></name>
<name><surname>Paton</surname><given-names>NW</given-names></name>
<name><surname>Embury</surname><given-names>SM</given-names></name>
<name><surname>Fernandes</surname><given-names>AAA</given-names></name>
<name><surname>Hedeler</surname><given-names>C</given-names></name>
</person-group>. <article-title>Feedback-based annotation, selection and refinement of schema mappings for dataspaces</article-title>. In: <person-group person-group-type="editor">
<name><surname>Manolescu</surname><given-names>I</given-names></name>
<etal/>
</person-group>. (eds) <source>Proceedings of the 13th international conference on extending database technology, AICPS 426</source>. <publisher-loc>New York</publisher-loc>: <publisher-name>ACM Press</publisher-name>, <year>2010</year>, pp. <fpage>573</fpage>–<lpage>584</lpage>.</citation>
</ref>
<ref id="bibr11-0165551512437532">
<label>[11]</label>
<citation citation-type="book">
<person-group person-group-type="editor">
<name><surname>Dong</surname><given-names>X</given-names></name>
<name><surname>Havely</surname><given-names>A</given-names></name>
</person-group>. <article-title>Indexing dataspaces</article-title>. In: <person-group person-group-type="editor">
<name><surname>Chan</surname><given-names>CY</given-names></name>
<etal/>
</person-group>. (eds), <source>Proceedings of the ACM SIGMOD international conference on management of data</source>. <publisher-loc>New York</publisher-loc>: <publisher-name>ACM Press</publisher-name>, <year>2007</year>, pp. <fpage>43</fpage>–<lpage>54</lpage>.</citation>
</ref>
<ref id="bibr12-0165551512437532">
<label>[12]</label>
<citation citation-type="book">
<person-group person-group-type="editor">
<name><surname>Vaz Salles</surname><given-names>MA</given-names></name>
<name><surname>Dittrich</surname><given-names>J-P</given-names></name>
<name><surname>Karakashian</surname><given-names>SK</given-names></name>
<name><surname>Girard</surname><given-names>OR</given-names></name>
<name><surname>Blunschi</surname><given-names>L</given-names></name>
</person-group>. <article-title>iTrails. Pay-as-you-go information integration in dataspaces</article-title>. In: <person-group person-group-type="editor">
<name><surname>Koch</surname><given-names>C</given-names></name>
<etal/>
</person-group>. (eds) <source>Proceedings of the 33rd international conference on very large data bases</source>. <publisher-loc>New York</publisher-loc>: <publisher-name>ACM Press</publisher-name>, <year>2007</year>, pp. <fpage>663</fpage>–<lpage>674</lpage>.</citation>
</ref>
<ref id="bibr13-0165551512437532">
<label>[13]</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Howe</surname><given-names>B</given-names></name>
<name><surname>Maier</surname><given-names>D</given-names></name>
<name><surname>Rayner</surname><given-names>N</given-names></name>
<name><surname>Rucker</surname><given-names>J</given-names></name>
</person-group>. <article-title>Quarrying dataspaces: schemaless profiling of unfamiliar information sources</article-title>. In: <source>Proceedings of the 24th international conference on data engineering workshops</source>. <publisher-loc>Washington, DC</publisher-loc>: <publisher-name>IEEE Computer Society</publisher-name>, <year>2008</year>, pp. <fpage>270</fpage>–<lpage>277</lpage>.</citation>
</ref>
<ref id="bibr14-0165551512437532">
<label>[14]</label>
<citation citation-type="web">
<collab>Extensible Markup Language (XML) 1.0</collab>, <comment><ext-link ext-link-type="uri" xlink:href="http://www.w3.org/TR/REC-xml">http://www.w3.org/TR/REC-xml</ext-link></comment> (<year>2008</year>, <access-date>accessed December 2011</access-date>).</citation>
</ref>
<ref id="bibr15-0165551512437532">
<label>[15]</label>
<citation citation-type="web">
<collab>Resource Description Framework (RDF)</collab>, <comment><ext-link ext-link-type="uri" xlink:href="http://www.w3.org/RDF/">http://www.w3.org/RDF/</ext-link></comment> (<year>2004</year>, <access-date>accessed December 2011</access-date>).</citation>
</ref>
<ref id="bibr16-0165551512437532">
<label>[16]</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Lampathaki</surname><given-names>F</given-names></name>
<name><surname>Mouzakitis</surname><given-names>S</given-names></name>
<name><surname>Gionis</surname><given-names>G</given-names></name>
<name><surname>Charalabidis</surname><given-names>Y</given-names></name>
<name><surname>Askounis</surname><given-names>D</given-names></name>
</person-group>. <article-title>Business to business interoperability: a current review of XML data integration standards</article-title>. <source>Computer Standards and Interfaces</source> <year>2009</year>; <volume>31</volume>(<issue>6</issue>): <fpage>1045</fpage>–<lpage>1055</lpage>.</citation>
</ref>
<ref id="bibr17-0165551512437532">
<label>[17]</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Fuhr</surname><given-names>N</given-names></name>
<name><surname>Großjohann</surname><given-names>K</given-names></name>
</person-group>. <article-title>XIRQL: an XML query language based on information retrieval concepts</article-title>. <source>ACM Transactions on Information Systems</source> <year>2004</year>; <volume>22</volume>(<issue>2</issue>): <fpage>313</fpage>–<lpage>356</lpage>.</citation>
</ref>
<ref id="bibr18-0165551512437532">
<label>[18]</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Rys</surname><given-names>M</given-names></name>
<name><surname>Chamberlin</surname><given-names>D</given-names></name>
<name><surname>Florescu</surname><given-names>D</given-names></name>
</person-group>. <article-title>XML and relational database systems: the inside story</article-title>. In <person-group person-group-type="editor">
<name><surname>Özcan</surname><given-names>F</given-names></name>
</person-group> (ed.) <source>Proceedings of the ACM SIGMOD international conference on management of data</source>. <publisher-loc>New York</publisher-loc>: <publisher-name>ACM Press</publisher-name>, <year>2005</year>, pp. <fpage>945</fpage>–<lpage>947</lpage>.</citation>
</ref>
<ref id="bibr19-0165551512437532">
<label>[19]</label>
<citation citation-type="web">
<person-group person-group-type="author">
<name><surname>Marshall</surname><given-names>B</given-names></name>
</person-group>, <source>Data quality and data profiling: a glossary of terms</source>, <comment><ext-link ext-link-type="uri" xlink:href="http://www.agt.net/public/bmarshal/dataqual.htm">http://www.agt.net/public/bmarshal/dataqual.htm</ext-link></comment> (<year>2006</year>, <access-date>accessed December 2011</access-date>).</citation>
</ref>
<ref id="bibr20-0165551512437532">
<label>[20]</label>
<citation citation-type="web">
<source>XQuery 1.0: an XML query language</source>. <edition>2nd ed.</edition> <comment><ext-link ext-link-type="uri" xlink:href="http://www.w3.org/TR/xquery">http://www.w3.org/TR/xquery</ext-link></comment> (<year>2010</year>, <access-date>accessed August 2011</access-date>).</citation>
</ref>
<ref id="bibr21-0165551512437532">
<label>[21]</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Näppilä</surname><given-names>T</given-names></name>
<name><surname>Moilanen</surname><given-names>K</given-names></name>
<name><surname>Niemi</surname><given-names>T</given-names></name>
</person-group>. <article-title>A query language for selecting, harmonizing, and aggregating heterogeneous XML data</article-title>. <source>International Journal of Web Information Systems</source> <year>2011</year>; <volume>7</volume>(<issue>1</issue>): <fpage>62</fpage>–<lpage>99</lpage>.</citation>
</ref>
<ref id="bibr22-0165551512437532">
<label>[22]</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Niemi</surname><given-names>T</given-names></name>
<name><surname>Junkkari</surname><given-names>M</given-names></name>
<name><surname>Järvelin</surname><given-names>K</given-names></name>
</person-group>. <article-title>Concept-based query language approach to enterprise information systems</article-title>. <source>Enterprise Information Systems</source> <year>2011</year>; <volume>6</volume>: <fpage>1</fpage>–<lpage>41</lpage> (<access-date>accessed December 2011</access-date>).</citation>
</ref>
<ref id="bibr23-0165551512437532">
<label>[23]</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Florescu</surname><given-names>D</given-names></name>
<name><surname>Kossmann</surname><given-names>D</given-names></name>
</person-group>. <article-title>Storing and querying XML data using an RDBMS</article-title>. <source>IEEE Data Engineering Bulletin</source> <year>1999</year>; <volume>22</volume>(<issue>3</issue>): <fpage>27</fpage>–<lpage>34</lpage>.</citation>
</ref>
<ref id="bibr24-0165551512437532">
<label>[24]</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Shanmugasundaram</surname><given-names>J</given-names></name>
<name><surname>Tufte</surname><given-names>K</given-names></name>
<name><surname>Zhang</surname><given-names>C</given-names></name>
<name><surname>He</surname><given-names>G</given-names></name>
<name><surname>DeWitt</surname><given-names>DJ</given-names></name>
<name><surname>Naughton</surname><given-names>JF</given-names></name>
</person-group>. <article-title>Relational databases for querying XML documents: limitations and opportunities</article-title>. In: <person-group person-group-type="editor">
<name><surname>Atkinson</surname><given-names>MP</given-names></name>
<etal/>
</person-group>.(eds) <source>Proceedings of 25th international conference on very large data bases</source>. <publisher-loc>San Francisco</publisher-loc>: <publisher-name>Morgan Kaufman</publisher-name>, <year>1999</year>, pp. <fpage>302</fpage>–<lpage>314</lpage>.</citation>
</ref>
<ref id="bibr25-0165551512437532">
<label>[25]</label>
<citation citation-type="book">
<person-group person-group-type="editor">
<name><surname>Halverson</surname><given-names>A</given-names></name>
<name><surname>Josifovski</surname><given-names>V</given-names></name>
<name><surname>Lohman</surname><given-names>G</given-names></name>
<name><surname>Pirahesh</surname><given-names>H</given-names></name>
<name><surname>Mörchel</surname><given-names>M</given-names></name>
</person-group>. <article-title>ROX: relational over XML</article-title>. In: <person-group person-group-type="editor">
<name><surname>Nascimento</surname><given-names>MA</given-names></name>
<etal/>
</person-group>. (eds) <source>Proceedings of 30th international conference on very large data bases</source>. <publisher-loc>San Francisco</publisher-loc>: <publisher-name>Morgan Kaufman</publisher-name>, <year>2004</year>, pp. <fpage>264</fpage>–<lpage>275</lpage>.</citation>
</ref>
<ref id="bibr26-0165551512437532">
<label>[26]</label>
<citation citation-type="book">
<person-group person-group-type="editor">
<name><surname>Pal</surname><given-names>S</given-names></name>
<name><surname>Cseri</surname><given-names>I</given-names></name>
<name><surname>Schaller</surname><given-names>G</given-names></name>
<name><surname>Seeliger</surname><given-names>O</given-names></name>
<name><surname>Giakoumakis</surname><given-names>L</given-names></name>
<name><surname>Zolotov</surname><given-names>VV</given-names></name>
</person-group>. <article-title>Indexing XML data stored in a relational database</article-title>. In: <person-group person-group-type="editor">
<name><surname>Nascimento</surname><given-names>MA</given-names></name>
<etal/>
</person-group>. (eds) <source>Proceedings of 30th international conference on very large data bases</source>. <publisher-loc>San Francisco</publisher-loc>: <publisher-name>Morgan Kaufman</publisher-name>, <year>2004</year>, pp. <fpage>1134</fpage>–<lpage>1145</lpage>.</citation>
</ref>
<ref id="bibr27-0165551512437532">
<label>[27]</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Niemi</surname><given-names>T</given-names></name>
<name><surname>Järvelin</surname><given-names>K</given-names></name>
</person-group>. <source>Another look at XML</source>. <comment>Technical report A-2006-1</comment>, <publisher-name>University of Tampere, Department of Computer Sciences</publisher-name>, <publisher-loc>Tampere, Finland</publisher-loc>, <year>2006</year>.</citation>
</ref>
<ref id="bibr28-0165551512437532">
<label>[28]</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Niemi</surname><given-names>T</given-names></name>
<name><surname>Näppilä</surname><given-names>T</given-names></name>
<name><surname>Järvelin</surname><given-names>K</given-names></name>
</person-group>. <article-title>A relational data harmonization approach to XML</article-title>. <source>Journal of Information Science</source> <year>2009</year>; <volume>35</volume>(<issue>5</issue>): <fpage>571</fpage>–<lpage>601</lpage>.</citation>
</ref>
<ref id="bibr29-0165551512437532">
<label>[29]</label>
<citation citation-type="web">
<collab>XML Schema</collab>, <comment><ext-link ext-link-type="uri" xlink:href="http://www.w3.org/TR/xmlschema-0">http://www.w3.org/TR/xmlschema-0</ext-link></comment> (<year>2004</year>, <access-date>accessed December 2011</access-date>).</citation>
</ref>
<ref id="bibr30-0165551512437532">
<label>[30]</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Tagarelli</surname><given-names>A</given-names></name>
<name><surname>Greco</surname><given-names>S</given-names></name>
</person-group>. <article-title>Semantic clustering of XML documents</article-title>. <source>ACM Transactions on Information Systems</source> <year>2010</year>; <volume>28</volume>(<issue>1</issue>): <comment>Article</comment> <fpage>3</fpage>.</citation>
</ref>
<ref id="bibr31-0165551512437532">
<label>[31]</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Deutsch</surname><given-names>A</given-names></name>
<name><surname>Fernandez</surname><given-names>M</given-names></name>
<name><surname>Florescu</surname><given-names>D</given-names></name>
<name><surname>Levy</surname><given-names>A</given-names></name>
<name><surname>Suciu</surname><given-names>D</given-names></name>
</person-group>. <article-title>A query language for XML</article-title>. <source>Computer Networks</source> <year>1999</year>; <volume>31</volume>(<issue>11–16</issue>): <fpage>1155</fpage>–<lpage>1169</lpage>.</citation>
</ref>
<ref id="bibr32-0165551512437532">
<label>[32]</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Ceri</surname><given-names>S</given-names></name>
<name><surname>Comai</surname><given-names>S</given-names></name>
<name><surname>Fraternali</surname><given-names>P</given-names></name>
<name><surname>Paraboschi</surname><given-names>S</given-names></name>
<name><surname>Tanca</surname><given-names>L</given-names></name>
<name><surname>Damiani</surname><given-names>E</given-names></name>
</person-group>. <article-title>XML-GL: a graphical language for querying and restructuring XML documents</article-title>. <source>Computer Networks</source> <year>1999</year>; <volume>31</volume>(<issue>11–16</issue>): <fpage>1171</fpage>–<lpage>1187</lpage>.</citation>
</ref>
<ref id="bibr33-0165551512437532">
<label>[33]</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>On</surname><given-names>B-W</given-names></name>
<name><surname>Lee</surname><given-names>I</given-names></name>
<name><surname>Lee</surname><given-names>D</given-names></name>
</person-group>. <article-title>Scalable clustering methods for the name disambiguation problem</article-title>. <source>Knowledge and Information Systems</source> <year>2011</year>; <volume>6</volume>: <fpage>1</fpage>–<lpage>23</lpage>.</citation>
</ref>
<ref id="bibr34-0165551512437532">
<label>[34]</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Min</surname><given-names>J-K</given-names></name>
<name><surname>Ahn</surname><given-names>J-Y</given-names></name>
<name><surname>Chung</surname><given-names>C-W</given-names></name>
</person-group>. <article-title>Efficient extraction of schemas for XML documents</article-title>. <source>Information Processing Letters</source> <year>2003</year>; <volume>85</volume>(<issue>1</issue>): <fpage>7</fpage>–<lpage>12</lpage>.</citation>
</ref>
<ref id="bibr35-0165551512437532">
<label>[35]</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Hegewald</surname><given-names>J</given-names></name>
<name><surname>Naumann</surname><given-names>F</given-names></name>
<name><surname>Weiss</surname><given-names>M</given-names></name>
</person-group>. <article-title>XStruct: efficient schema extraction from multiple and large XML documents</article-title>. In: <source>Proceedings of the 22th international conference on data engineering workshops</source>. <publisher-loc>Washington, DC</publisher-loc>: <publisher-name>IEEE Computer Society</publisher-name>, <year>2006</year>, pp.<fpage>1</fpage>–<lpage>10</lpage>.</citation>
</ref>
<ref id="bibr36-0165551512437532">
<label>[36]</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Rusu</surname><given-names>LI</given-names></name>
<name><surname>Rahayu</surname><given-names>JW</given-names></name>
<name><surname>Taniar</surname><given-names>D</given-names></name>
</person-group>. <article-title>On building XML data warehouses</article-title>. In: <source>Proceedings of the 5th international conference in intelligent data engineering and automated learning</source>. <comment>LNCS 3177</comment>. <publisher-loc>Berlin Heidelberg</publisher-loc>: <publisher-name>Springer Verlag</publisher-name>, <year>2004</year>, pp. <fpage>293</fpage>–<lpage>299</lpage>.</citation>
</ref>
<ref id="bibr37-0165551512437532">
<label>[37]</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Xu</surname><given-names>Y</given-names></name>
<name><surname>Papakonstantinou</surname><given-names>Y</given-names></name>
</person-group>. <article-title>Efficient keyword search for smallest LCAs in XML databases</article-title>. In: <person-group person-group-type="editor">
<name><surname>Li</surname><given-names>C</given-names></name>
</person-group> (ed.) <source>Proceedings of the 24th ACM SIGACT-SIGMOD-SIGART symposium on principles of database systems</source>. <publisher-loc>New York</publisher-loc>: <publisher-name>ACM Press</publisher-name>, <year>2005</year>, pp. <fpage>527</fpage>–<lpage>538</lpage>.</citation>
</ref>
<ref id="bibr38-0165551512437532">
<label>[38]</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Niemi</surname><given-names>T</given-names></name>
</person-group>. <article-title>A seven-tuple representation for hierarchical data structures</article-title>. <source>Information Systems</source> <year>1983</year>; <volume>8</volume>(<issue>3</issue>): <fpage>151</fpage>–<lpage>157</lpage>.</citation>
</ref>
<ref id="bibr39-0165551512437532">
<label>[39]</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>O’Neil</surname><given-names>P</given-names></name>
<name><surname>O’Neil</surname><given-names>E</given-names></name>
<name><surname>Pal</surname><given-names>S</given-names></name>
<name><surname>Cseri</surname><given-names>I</given-names></name>
<name><surname>Schaller</surname><given-names>G</given-names></name>
<name><surname>Westbury</surname><given-names>N</given-names></name>
</person-group>. <article-title>ORDPATHs: insert-friendly XML node labels</article-title>. In: <source>Proceedings of the ACM SIGMOD international conference on management of data</source>. <publisher-loc>New York</publisher-loc>: <publisher-name>ACM Press</publisher-name>, <year>2004</year>, pp. <fpage>903</fpage>–<lpage>908</lpage>.</citation>
</ref>
<ref id="bibr40-0165551512437532">
<label>[40]</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Köpcke</surname><given-names>H</given-names></name>
<name><surname>Rahm</surname><given-names>E</given-names></name>
</person-group>. <article-title>Frameworks for entity matching: a comparison</article-title>. <source>Data &amp; Knowledge Engineering</source> <year>2010</year>; <volume>69</volume>(<issue>2</issue>): <fpage>197</fpage>–<lpage>210</lpage>.</citation>
</ref>
<ref id="bibr41-0165551512437532">
<label>[41]</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Elmagarmid</surname><given-names>AK</given-names></name>
<name><surname>Ipeirotis</surname><given-names>PG</given-names></name>
<name><surname>Verykios</surname><given-names>VS</given-names></name>
</person-group>. <article-title>Duplicate record detection: a survey</article-title>. <source>IEEE Transactions on Knowledge and Data Engineering</source> <year>2007</year>; <volume>19</volume>(<issue>1</issue>): <fpage>1</fpage>–<lpage>16</lpage>.</citation>
</ref>
<ref id="bibr42-0165551512437532">
<label>[42]</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Dorneles</surname><given-names>CF</given-names></name>
<name><surname>Gonçalves</surname><given-names>R</given-names></name>
<name><surname>dos Santos Mello</surname><given-names>R</given-names></name>
</person-group>. <article-title>Approximate data instance matching: a survey</article-title>. <source>Knowledge and Information Systems</source> <year>2011</year>; <volume>27</volume>(<issue>1</issue>): <fpage>1</fpage>–<lpage>21</lpage>.</citation>
</ref>
<ref id="bibr43-0165551512437532">
<label>[43]</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Cafarella</surname><given-names>MJ</given-names></name>
<name><surname>Halevy</surname><given-names>A</given-names></name>
<name><surname>Madhavan</surname><given-names>J</given-names></name>
</person-group>. <article-title>Structured data on the Web</article-title>. <source>Communications of the ACM</source> <year>2011</year>; <volume>54</volume>(<issue>2</issue>): <fpage>72</fpage>–<lpage>79</lpage>.</citation>
</ref>
<ref id="bibr44-0165551512437532">
<label>[44]</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Erwig</surname><given-names>M</given-names></name>
</person-group>. <article-title>Xing: a visual XML query language</article-title>. <source>Journal of Visual Languages and Computing</source> <year>2003</year>; <volume>14</volume>(<issue>1</issue>): <fpage>5</fpage>–<lpage>45</lpage>.</citation>
</ref>
<ref id="bibr45-0165551512437532">
<label>[45]</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Näppilä</surname><given-names>T</given-names></name>
<name><surname>Järvelin</surname><given-names>K</given-names></name>
<name><surname>Niemi</surname><given-names>T</given-names></name>
</person-group>. <article-title>A tool for data cube construction from structurally heterogeneous XML documents</article-title>. <source>Journal of the American Society for Information Science and Technology</source> <year>2008</year>; <volume>59</volume>(<issue>3</issue>): <fpage>435</fpage>–<lpage>449</lpage>.</citation>
</ref>
<ref id="bibr46-0165551512437532">
<label>[46]</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Hedeler</surname><given-names>C</given-names></name>
<name><surname>Belhajjame</surname><given-names>K</given-names></name>
<name><surname>Fernandes</surname><given-names>AAA</given-names></name>
<name><surname>Embury</surname><given-names>SM</given-names></name>
<name><surname>Paton</surname><given-names>NW</given-names></name>
</person-group>. <article-title>Dimensions of dataspaces</article-title>. In <person-group person-group-type="editor">
<name><surname>Sexton</surname><given-names>AP</given-names></name>
</person-group> (ed.) <source>Dataspace: the final frontier, 26th British national conference on databases</source>, <comment>LNCS 5588</comment>. <publisher-loc>Berlin</publisher-loc>: <publisher-name>Springer Verlag</publisher-name>, <year>2009</year>, pp. <fpage>55</fpage>–<lpage>66</lpage>.</citation>
</ref>
<ref id="bibr47-0165551512437532">
<label>[47]</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Sheth</surname><given-names>A</given-names></name>
<name><surname>Aleman-Meza</surname><given-names>B</given-names></name>
<name><surname>Arpinar</surname><given-names>IB</given-names></name>
<name><surname>Bertram</surname><given-names>C</given-names></name>
<name><surname>Warke</surname><given-names>Y</given-names></name>
<name><surname>Ramakrishnan</surname><given-names>C</given-names></name>
<etal/>
</person-group>. <article-title>Semantic association identification and knowledge discovery for national security applications</article-title>. <source>Journal of Database Management</source> <year>2005</year>; <volume>16</volume>(<issue>1</issue>): <fpage>33</fpage>–<lpage>53</lpage>.</citation>
</ref>
<ref id="bibr48-0165551512437532">
<label>[48]</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Niemi</surname><given-names>T</given-names></name>
<name><surname>Jämsen</surname><given-names>J</given-names></name>
</person-group>. <article-title>A query language for discovering semantic associations, Part I: approach and formal definition of query primitives</article-title>. <source>Journal of the American Society for Information Science and Technology</source> <year>2007</year>; <volume>58</volume>(<issue>11</issue>): <fpage>1559</fpage>–<lpage>1568</lpage>.</citation>
</ref>
<ref id="bibr49-0165551512437532">
<label>[49]</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Niemi</surname><given-names>T</given-names></name>
<name><surname>Jämsen</surname><given-names>J</given-names></name>
</person-group>. <article-title>A query language for discovering semantic associations, Part II: sample queries and query evaluation</article-title>. <source>Journal of the American Society for Information Science and Technology</source> <year>2007</year>; <volume>58</volume>(<issue>11</issue>): <fpage>1686</fpage>–<lpage>1700</lpage>.</citation>
</ref>
</ref-list>
</back>
</article>