<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD Journal Publishing DTD v2.3 20070202//EN" "journalpublishing.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">DMS</journal-id>
<journal-id journal-id-type="hwp">spdms</journal-id>
<journal-title>The Journal of Defense Modeling and Simulation: Applications, Methodology, Technology</journal-title>
<issn pub-type="ppub">1548-5129</issn>
<issn pub-type="epub">1557-380X</issn>
<publisher>
<publisher-name>SAGE Publications</publisher-name>
<publisher-loc>Sage UK: London, England</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1177/1548512910395641</article-id>
<article-id pub-id-type="publisher-id">10.1177_1548512910395641</article-id>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Articles</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>CADAC: Multi-use Architecture for Constructive Aerospace Simulations</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" corresp="yes">
<name><surname>Zipfel</surname><given-names>Peter H</given-names></name>
</contrib>
<aff id="aff1-1548512910395641">U.S. Air Force Research Laboratory, Eglin AFB, FL, USA</aff>
</contrib-group>
<author-notes>
<corresp id="corresp1-1548512910395641">Peter H Zipfel, U.S. Air Force Research Laboratory, Eglin AFB, 73 Country Club Road, Shalimar, FL 32579, USA Email: <email>mastech.zipfel@cox.net</email></corresp>
</author-notes>
<pub-date pub-type="epub-ppub">
<month>4</month>
<year>2012</year>
</pub-date>
<volume>9</volume>
<issue>2</issue>
<issue-title>Special Issue: Resuability, Interoperability and Composability in Air Warfare Simulations</issue-title>
<fpage>129</fpage>
<lpage>145</lpage>
<permissions>
<copyright-statement>© 2012 The Society for Modeling and Simulation International</copyright-statement>
<copyright-year>2012</copyright-year>
<copyright-holder content-type="society">The Society for Modeling and Simulation International</copyright-holder>
</permissions>
<abstract>
<p>In today’s network-centric world, aerospace vehicles interact with many objects. They navigate by overhead satellites, synchronize their flight paths with other vehicles, swarm over hostile territory and attack multiple targets. Studying these engagements with high-fidelity constructive simulations has become an important task of modeling and simulation (M&amp;S). The simulation framework Computer Aided Design of Aerospace Concepts (CADAC) has its roots in FORTRAN code that dates back to the 1960s and was used by industry and the U.S. Air Force to simulate aerospace vehicles in all flight environments. To adapt CADAC to the new environment, a complete rewrite was carried out in C++, taking advantage of object-oriented programming techniques. The architecture of CADAC++ is based on the hierarchical structure of inherited classes. The vehicles (aircraft, missiles, satellites or ground targets), inherit the six-degree-of-freedom (6-DoF) equations of motion from the classes ‘Flat6’ or ‘Round6’, conveying either the flat or elliptical Earth model. In turn, these classes inherit the communication structure from the base class ‘Cadac’. The components of the vehicle, e.g., aerodynamics, propulsion and autopilot, are represented by modules, which are member functions of the vehicle class. Communication among the modules occurs by protected module-variable arrays. Every instantiated vehicle object is encapsulated with its methods and data. To communicate between vehicles, data packets are loaded onto a global data bus for recall by other vehicles. Input occurs by ASCII file and output is compatible with CADAC Studio, a plotting and data processing package. CADAC++ is chiefly an engineering tool for refining the components of the primary vehicle and exploring its performance as it interacts (possibly repeatedly instantiated) with the multi-object environment. Its modular structure enables reuse of component models across simulations. In the 10 years of development, CADAC++ based constructive simulations have been built for many types of aerospace vehicles and integrated with mission-level simulations.</p>
</abstract>
<kwd-group>
<kwd>aircraft and missile simulations</kwd>
<kwd>engagement simulations</kwd>
<kwd>high fidelity modeling</kwd>
<kwd>constructive simulations</kwd>
<kwd>C++ programming language</kwd>
<kwd>six degrees of freedom</kwd>
<kwd>CADAC</kwd>
<kwd>CADAC studio</kwd>
<kwd>three-stage booster</kwd>
<kwd>dual role missile</kwd>
<kwd>self defense missile</kwd>
<kwd>hypersonic cruise missile</kwd>
<kwd>multi-object programming</kwd>
<kwd>run-time polymorphism</kwd>
<kwd>classes</kwd>
<kwd>communication bus.</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="section1-1548512910395641" sec-type="intro">
<title>1. Introduction</title>
<p>High-fidelity, six-degree-of-freedom (6-DoF) simulations play an important part in the development of weapon systems. These so-called constructive simulations are used in technology trade studies, preliminary design, hardware-in-the-loop evaluation, flight testing and training.<sup><xref ref-type="bibr" rid="bibr1-1548512910395641">1</xref></sup></p>
<p>The first all-digital, constructive simulations were created by the National Aeronautics and Space Administration (NASA), U.S. Department of Defense (DoD) and industry. In 1966 Litton Industries developed the architecture for a missile simulation in FORTRAN IV that had all of the features of a full 6-DoF simulation. It was the source of many derivatives by Hughes Aircraft, North American Aviation and Aerospace Corporation. Noteworthy is the U.S. Army ENDOSIM simulation.<sup><xref ref-type="fn" rid="fn1-1548512910395641">a</xref></sup> The U.S. Air Force also adopted it to its own needs and named the simulation Computer Aided Design of Aerospace Concepts (CADAC).</p>
<p><fn fn-type="other" id="fn1-1548512910395641">
<p>AMTEC Corporation. <italic>Endo-atmospheric Non-nuclear Kill Simulation</italic>. Report No. TR 1147. Huntsville, AL: U.S. Army Strategic Defense Command, August 1989 (restricted distribution).</p>
</fn></p>
<p>CADAC, since its inception in 1978, has morphed through many stages of improvements, but has remained faithful to its FORTRAN language. But in today’s network-centric world, aerospace vehicles interact with many objects: they navigate by overhead satellites, synchronize their flight paths with other vehicles, swarm over hostile territory and attack multiple targets. Studying this connectivity has become an important aspect of high-fidelity simulations. FORTRAN, lacking the power of object-oriented programming, has therefore been replaced by C++. A new architecture, called CADAC++, was created to enable the conceptualization of aerospace vehicles.</p>
<p>Other organizations followed the same trend and converted from FORTRAN to C++, or started entirely new frameworks in C++. Best known is JSBSim,<sup><xref ref-type="bibr" rid="bibr2-1548512910395641">2</xref></sup> an open-source aircraft simulation that is also the basis of the Flight Gear Simulator.<sup><xref ref-type="bibr" rid="bibr3-1548512910395641">3</xref></sup> The U.S. Army created an entirely new framework called CMD C++ Model Developer.<sup><xref ref-type="bibr" rid="bibr4-1548512910395641">4</xref></sup> At its core is a kernel that supports any kind of modeling described by time-phased differential equations. Its distribution is unrestricted. Another U.S. Army organization, MSIC (Missile and Space Intelligence Center) contracted with Dynetics for the MSIC++ Generic Simulation,<sup><xref ref-type="fn" rid="fn2-1548512910395641">b</xref></sup> which is a multi-purpose missile simulation environment, but not generally available to the public.</p>
<p><fn fn-type="other" id="fn2-1548512910395641">
<p>Dynetics. MSIC++ <italic>Generic Simulation Documentation</italic>. Report No.: MSIC C.M. Control Number COV0. Dynetics, 18 April 1995 (restricted distribution).</p>
</fn></p>
<p>CADAC is a joint development by the U.S. Air Force and the University of Florida. Its framework architecture and some of the academic simulations are publicly available. The original FORTRAN version and the plotting and analysis programs, CADAC Studio, can be downloaded from the American Institute of Aeronautics and Astronautics (AIAA).<sup><xref ref-type="bibr" rid="bibr5-1548512910395641">5</xref></sup> The C++ simulations are available as a three-part Self-Study Series, based on lectures at the University of Florida.<sup><xref ref-type="bibr" rid="bibr6-1548512910395641">6</xref>-<xref ref-type="bibr" rid="bibr8-1548512910395641">8</xref></sup> CADAC Studio also supports these C++ simulations.</p>
<p>CADAC++, in its 10-year history, has been used as a simulation test bed for missiles, aircraft, unmanned aerial vehicles (UAVs) and spacecraft. Its modular structure enables reuse of subsystem models and its well defined interfaces allow integration into higher level simulations, like FLAMES<sup>®</sup>-based mission models.<sup><xref ref-type="bibr" rid="bibr9-1548512910395641">9</xref></sup></p>
<p>This paper summarizes the process that led from requirements definition to architecture development and full-up constructive simulation. Some examples are presented that highlight the features of CADAC++.</p>
</sec>
<sec id="section2-1548512910395641">
<title>2. Requirements</title>
<p>CADAC++ is an engineering tool aiding in the development of aerospace vehicles. Although it focuses on the main vehicle – missile, aircraft, spacecraft – it also portrays the interactions with outside elements, such as satellites, targets and sister vehicles. The main vehicle is modeled with greatest fidelity, while the secondary objects have simpler representations.</p>
<p>The synthesis and conceptualization process places distinct requirements on the simulation architecture. To support the design engineer in evaluating the aerodynamics, propulsion, guidance and control components, CADAC++ should mirror the same modular structure and closely control the interfaces between them. It should encapsulate each vehicle object for multiple instantiation and provide global communication between them. Input and output must be flexible and compatible with CADAC Studio, a post-processing and analysis tool. More specific requirements follow.</p>
<sec id="section3-1548512910395641">
<title>2.1 Face to the User</title>
<p>Users like to focus on the evaluation of the main vehicle without being burdened by the details of the simulation’s execution. They want control of the input/output and the vehicle modules that define the subsystems.</p>
<p>There should be only one input file that controls the simulation. It displays the run title, an option line for directing the output, the calling sequence of the modules, the sizing of the integration step and the initializing of the vehicle parameters. The integration step size should be variable. The aerodynamics and propulsion tables should be kept separate for safekeeping rather than being part of the source code. Their file names, given in the input file, would load the data decks into memory prior to execution. Multiple instantiation of the vehicle objects should be accomplished by simply duplicating the vehicle input data and changing selected variables as necessary.</p>
<p>The output control should be simple yes/no choices. An option line would provide output to the screen of the primary and secondary vehicles, together with the event messages that indicate their changing flight status. There should also be an option to archive the screen output to a file. Plot files as well as statistical data files would be written for individual vehicles and merged together for multi-vehicle displays. These output files should be compatible with the existing CADAC Studio for two- and three-dimensional plotting and statistical analysis.</p>
<p>The components of the vehicles should be mirrored by modules that model their features. Strict control of the interfaces will make the modules interchangeable amongst simulations. The modules should define these interface variables, execute integration of state variables and enable table look-up. Any vehicle changes that the user wants to make should be confined to these modules.</p>
</sec>
<sec id="section4-1548512910395641">
<title>2.2 Multiple Encapsulated Vehicle Object</title>
<p>Each aerospace vehicle (be it missile, aircraft or spacecraft) should be built up from a hierarchy of classes, starting with the base class Cadac, followed by the equations of motion, and completed by the vehicle itself. Each vehicle is a C++ object with its data (aerodynamics and propulsion) and methods (modules) encapsulated. Run-time polymorphism should be used to sequence through the vehicle objects during execution.</p>
</sec>
<sec id="section5-1548512910395641">
<title>2.3 Modularity of Vehicle Components</title>
<p>The modules, representing the vehicle components, should be public member functions of the vehicle classes. Their interfaces, the module-variables, would be stored in protected data arrays that are available to all modules of the vehicle object. During execution, the modules should define all module variables, make initializations, integrate state variables and conduct post-run calculations.</p>
</sec>
<sec id="section6-1548512910395641">
<title>2.4 Event Scheduling</title>
<p>Just as aerospace vehicles transition though flight phases, the simulation should be able to sequence through such events. These events should be controlled by the input file without any code changes in the modules. Relational operators such as &lt;, =, &gt; would be applied to the module-variables and trigger the events.</p>
</sec>
<sec id="section7-1548512910395641">
<title>2.5 Global Communication Bus</title>
<p>Because vehicle objects are encapsulated into classes, a global communication bus should enable the transfer of data. Each vehicle should be able to publish and subscribe to any of the module-variables.</p>
</sec>
<sec id="section8-1548512910395641">
<title>2.6 Table Look-up</title>
<p>Table utilities should provide for one, two and three independent variable look-up. Tables must be stored in separate files and modifications easily accomplished. Simple syntax should make the table look-up easy to program in the modules.</p>
</sec>
<sec id="section9-1548512910395641">
<title>2.7 Monte Carlo Capability</title>
<p>To automate the evaluation of random processes, a Monte Carlo methodology should be implemented. Distributions like uniform, Gaussian, Rayleigh, exponential and Markov should be identified in the input file by keywords. Stochastic output data must be written to files compatible with CADAC Studio for post-processing.</p>
</sec>
<sec id="section10-1548512910395641">
<title>2.8 Matrix Utility Operations</title>
<p>The full power of C++ should be applied to matrix operations. Matrix utilities should be tailored to the specific needs of flight simulations and not burdened by C++ container classes. Efficient pointer arithmetic will speed up the execution and allow unlimited stringing of matrix operations.</p>
</sec>
<sec id="section11-1548512910395641">
<title>2.9 Documentation and Error Checking</title>
<p>The module-variables, being the key interfaces between the modules, should be fully documented. The definitions provided in the modules should be collected in a single output file. The module-variables in the input file should also be documented with the same definitions.</p>
<p>Error checking should identify module-variables that have not been assigned the correct names or locations in the input file or the modules. Incompatible matrix operations should be flagged, as well as problems with opening of file streams. A variable should be displayed on the console that indicates the computational precision of the attitude calculations.</p>
</sec>
</sec>
<sec id="section12-1548512910395641">
<title>3. Architecture</title>
<p>These requirements can be satisfied with object oriented programming in C++. Hierarchical class structures, encapsulation of data and methods, run-time polymorphism, overloading of functions and operators, are all features used in CADAC++ to build a simulation environment suitable for flight vehicle synthesis.</p>
<p>CADAC++ programming follows the International Standard for C++ defined by the American National Standards Institute/International Organization for Standardization (ANSI/ISO) Committee in 1998 and implemented by most compilers like Microsoft Visual C++. Thus, portability is assured and low-cost operation is made possible.</p>
<p>Each requirement is now addressed separately, with particular focus on the classes that structure the features of CADAC++</p>
<array>
<tbody>
<tr>
<td>CLASS</td>
<td>DESCRIPTION</td>
</tr>
<tr>
<td>Cadac,…</td>
<td>Hierarchical class structure of vehicles</td>
</tr>
<tr>
<td>Vehicle</td>
<td>Hosting a pointer array of type Cadac</td>
</tr>
<tr>
<td>Module</td>
<td>Storing module information</td>
</tr>
<tr>
<td>Variable</td>
<td>Declaring module-variables</td>
</tr>
<tr>
<td>Event</td>
<td>Storing event information</td>
</tr>
<tr>
<td>Packet</td>
<td>Declaring data packets for global communication bus</td>
</tr>
<tr>
<td>Datadeck</td>
<td>Hosting a pointer array of type Table</td>
</tr>
<tr>
<td>Table</td>
<td>Storing tabular data</td>
</tr>
<tr>
<td>Markov</td>
<td>Storing Markov data</td>
</tr>
<tr>
<td>Matrix</td>
<td>Storing matrix operations</td>
</tr>
<tr>
<td>Document</td>
<td>Storing module-variable definitions</td>
</tr>
</tbody>
</array>
<graphic id="img1-1548512910395641" position="anchor" xlink:href="10.1177_1548512910395641-img1.tif"/>
<sec id="section13-1548512910395641">
<title>3.1 Face to the User</title>
<p>The user friendly requirements are met with an architecture that enables easy use and modification of the simulations. The input file has all the features that control the execution: title, option line, module call, timing control and vehicle initialization.</p>
<p>The option line provides nine possible outputs. During run-time, <monospace>y_scrn</monospace>, <monospace>y_event</monospace> and <monospace>y_comscrn</monospace> write data to the console; <monospace>y_tabout</monospace>, <monospace>y_plot</monospace>, <monospace>y_merge</monospace>, <monospace>y_doc</monospace>, <monospace>y_traj</monospace> and <monospace>y_stat</monospace> write the output to ASCII files for later processing by CADAC Studio. An important feature is the control that the user has over the loading and execution sequence of the modules. For sophisticated simulations, the calling sequence may become very important. Each of the timing events can be controlled separately in order not to overload the output devices. With the keyword <monospace>VEHICLES</monospace> begins the loading of the vehicle objects. Only a fraction of the first object <monospace>MISSILE6</monospace> is shown, though there are five vehicles to be loaded. By simply replicating <monospace>MISSILE6</monospace> or other objects and incrementing the integer after <monospace>VEHICLES</monospace>, new objects are loaded. Note how the file names that contain the tables are identified by the keywords <monospace>AERO_DECK</monospace> and <monospace>PROP_DECK</monospace>.</p>
<p>The user who wants to modify a vehicle component has only to deal with the corresponding module. The module contains all code and interfaces that define the components, carries out the table look-up and integrates the state variables. Re-use of modules for other simulations is facilitated by the strict control and detailed documentation of the interfaces.</p>
<p>As an example, let us look at the much abbreviated ‘newton’ module.</p>
<graphic id="img2-1548512910395641" position="anchor" xlink:href="10.1177_1548512910395641-img2.tif"/>
<p>The module consists of three parts: the definition of module variables, the initialization and the integration. In <monospace>def_newton()</monospace> the creation of capitalized <monospace>Matrix</monospace> variables, lower case <monospace>real</monospace> and <monospace>integer</monospace> variables is shown. Any new module-variable will be added here. Conversion of trajectory parameter from the input file to more suitable variables occurs in <monospace>init_newton()</monospace>. The integration takes place in newton(…) with a call to the function <monospace>integrate(…)</monospace>. This part shows the three sections of the code: creating or localizing variables, executing code and loading module-variables to the array <monospace>flat6[]</monospace>.</p>
<p>More detail of the modules is provided below under the heading Modularity of Vehicle Components.</p>
</sec>
<sec id="section14-1548512910395641">
<title>3.2 Multiple Encapsulated Vehicle Object</title>
<p>The rewriting of CADAC was motivated by the unique feature of C++ allowing encapsulation of vehicle objects. Encapsulation means binding together data and functions while restricting their access. The aerodynamic and propulsion data are bound together with the table look-up functions and many other functions that support the missile and aircraft objects. In turn, these objects are created from a hierarchical class structure derived from the common <italic>abstract</italic> base class <monospace>Cadac</monospace>.</p>
<p>This hierarchical class structure in CADAC depends on the particular simulation. For instance, the CADAC 6-DoF aircraft simulation consists of a single branch <monospace>Cadac ← Flat6 ← Plane</monospace>, where Flat6 models the equations of motion over the flat Earth, and <monospace>Plane</monospace> models the components of an airplane. The more elaborate CADAC missile engagement simulation has multiple branches. Its main branch represents the high-fidelity 6-DoF missile model <monospace>Cadac ← Flat6 ← Missile</monospace>. The supporting vehicle branches <monospace>Cadac ← Flat3 ← Target</monospace> and <monospace>Cadac ← Flat3 ←</monospace> Recce are the 3-DoF target and reconnaissance aircraft. As another example, the 3-DoF CADAC cruise missile simulations over the round rotating Earth has the three branches: <monospace>Cadac ← Round3 ← Cruise</monospace>, <monospace>Cadac ← Round3 ← Target</monospace> and <monospace>Cadac ← Round3 ← Satellite</monospace>.</p>
<p>The vehicle objects, declared by their respective classes, are created during run-time by the polymorphism capability of C++. Polymorphism (many forms, one interface) uses inheritance and virtual functions to build one vehicle-list of all vehicle objects, be they 6-DoF missiles, 3-DoF targets and recce aircrafts or satellites. At execution, this vehicle- list is cycled through at each integration step in order to compute the respective vehicle parameters.</p>
<p>The class <bold>Vehicle</bold> facilitates the run-time polymorphism. It has a private member <monospace>**vehicle_ptr</monospace>, which is a pointer to an array of pointers of the class <monospace>Cadac</monospace> that contains the pointers to all the vehicles objects. It also declares the offset operator <monospace>Cadac *operator[](int slot)</monospace> that returns the pointer to the vehicle object located at the offset slot in the vehicle-list.</p>
<p>In <monospace>main()</monospace>, the object <monospace>Vehicle <bold>vehicle_list</bold>(num_vehicles)</monospace> is created, initialized and its constructor allocates memory for the array of pointers</p>
<p><disp-quote>
<p><monospace>vehicle_ptr=new Cadac *[num_ vehicles];</monospace></p>
</disp-quote></p>
<p>Then the global function <monospace>Cadac *<bold>set_obj_type</bold>(…)</monospace> interrogates the input file <monospace>input.asc</monospace> to identify the vehicle types by keywords such as MISSILE6, TARGET3, RECCE3, etc. It allocates memory to the vehicle objects <monospace>Missile</monospace>, <monospace>Target</monospace>, <monospace>Recce</monospace>, etc. and returns pointers of base class <monospace>Cadac</monospace>. These pointers are stored in the <monospace>vehicle_ptr[]</monospace> array by the <monospace>Vehicle</monospace> member function</p>
<p><disp-quote>
<p><monospace>vehicle_list.add<bold>_vehicle</bold> (*vehicle_type)</monospace>;</p>
</disp-quote></p>
<p>Now the <monospace>Vehicle</monospace> object <monospace>vehicle_list</monospace> is ready to be addressed by its offset operator <monospace>[]</monospace>. For instance, the vehicle specific data are read from <monospace>input.asc by</monospace></p>
<p><disp-quote>
<p><monospace>vehicle_list[i]-&gt;vehicle<bold>_ data</bold>(input)</monospace>;</p>
</disp-quote></p>
<p>where <monospace>i</monospace> is the <monospace>(i+1)</monospace>th vehicle object in the sequence established in input.asc. Here is the explanation of the logic flow. The offset operator <monospace>[]</monospace> takes <monospace>i</monospace> and returns the <monospace>vehicle_ptr[i]</monospace> of the <monospace>(i+1)</monospace>th vehicle. Although the <monospace>vehicle_ptr</monospace> array is of the base class <monospace>Cadac</monospace>, the compiler has knowledge of the individual pointer being of the derived class <monospace>Missile</monospace>, <monospace>Target</monospace> or <monospace>Recce</monospace>. Such is the marvel of run-time polymorphism! Another important example is the call of a vehicle module, say the aerodynamic module</p>
<p><disp-quote>
<p><monospace>vehicle_list[i]-&gt;aerodynamics()</monospace>;</p>
</disp-quote></p>
<p>If the <monospace>(i+1)</monospace>th vehicle is the MISSILE6, a pointer of type Missile is furnished that is used to call the member function <monospace>aerodynamics()</monospace> of the derived class <monospace>Missile</monospace>. On the other hand, if the vehicle is the TARGET3, the pointer is of type <monospace>Target</monospace> and points to the <monospace>Target</monospace> member function <monospace>aerodynamics()</monospace>.</p>
<p>Through run-time polymorphism any number of different vehicles can be called using the common pointer array of type <monospace>Cadac</monospace>. These calls are executed during initialization and at every integration step. A limitation of this architecture is that all vehicle objects have to be instantiated at the beginning of the run.</p>
</sec>
<sec id="section15-1548512910395641">
<title>3.3 Modularity of Vehicle Components</title>
<p>A key feature of CADAC is its modularity, which reflects the component structure of an aerospace vehicle. Just as the hardware is divided into subsystems (such as propulsion, autopilot, guidance and control) CADAC simulations are broken into propulsion module, autopilot module, etc. This is extended to include non-hardware modules like aerodynamics, Newton’s and Euler’s equations of motion and environmental modules. This one-for-one correspondence ensures clean interfaces between the modules.</p>
<p>Each module is a pure virtual member function of the abstract base class <monospace>Cadac</monospace> and is overridden in the derived class, be it <monospace>Flat6</monospace>, <monospace>Flat3</monospace>, <monospace>Missile</monospace>, <monospace>Target</monospace>, <monospace>Recce</monospace> or others. If the derived class does not use a module, the module will return empty.</p>
<p>The calling sequence of the modules is controlled by their sequential listing in the input file <monospace>input.asc</monospace>. Each module may consist of four parts: the definition part (identified by <monospace>def</monospace>), the initialization part <monospace>(init)</monospace>, the execution part <monospace>(exec)</monospace> and the last call <monospace>(term)</monospace>. All are called only once, with the exception of <monospace>exec</monospace> which is called during every integration step.</p>
<p>The structure <bold>Module</bold> declares the name and the four parts of the module. Reading from <monospace>input.asc</monospace>, the modules are loaded into the <monospace>module_list</monospace> by the global function</p>
<p><disp-quote>
<p><monospace><bold>order_modules</bold>(input,num_ modules,module_list)</monospace>;</p>
</disp-quote></p>
<p>At creation of the vehicle object, at module initialization and at each integration cycle the <monospace>module_list</monospace> is interrogated for the module names. For example, the definition of the aerodynamic module occurs in the vehicle’s <bold>constructor</bold></p>
<p><disp-quote>
<p><monospace>if((module_list[j].name==”aerodynamics”)&amp;&amp;(module_list[j].definition==”def”))</monospace>;</p>
<p><monospace>def_aerodynamics()</monospace>;</p>
</disp-quote></p>
<p>Then the initialization of the module takes place in <monospace><bold>main()</bold></monospace></p>
<p><disp-quote>
<p><monospace>if((module_list[j].name==”aerodynamics”)&amp;&amp;(module_list[j].initialization==”init”))</monospace></p>
<p><monospace>vehicle_list[i]-&gt;init_aerodynamics()</monospace>;</p>
</disp-quote></p>
<p>where <monospace>vehicle_list[i]</monospace> is the pointer to the vehicle object. During integration, the module is called inside the <monospace><bold>execute</bold>(…)</monospace> function which is called directly from <monospace>main()</monospace></p>
<p><disp-quote>
<p><monospace>if(module_list[j]. name==”aerodynamics”)</monospace></p>
<p><monospace>vehicle_list[i]-&gt;aerodynamics()</monospace>;</p>
</disp-quote></p>
<p>Currently, the terminal calls are not needed.</p>
<p>Data are transferred between modules by <bold>module-variables</bold> and stored in arrays of type Variable. Each derived object from the base class Cadac has an array with its own name, such as <monospace>flat6[]</monospace>, <monospace>missile[]</monospace>, <monospace>target[]</monospace>, etc. They are protected members of Cadac. The arrays are sized by global constants <monospace>NFLAT6</monospace>, <monospace>NMISSILE</monospace>, <monospace>NTARGET</monospace>, etc. and each module is assigned a block of indices in its respective arrays.</p>
<p>The class <monospace><bold>Variable</bold></monospace> declares the module-variable object. Its private members store the label, the initial value, the type of variable (<monospace>int</monospace>, <monospace>double</monospace>, 3 x 1 vector, 3 x 3 matrix), the definition and units, the module where the value is calculated, its role (input data, state variable to be integrated, diagnostic, output to other modules and data saved for the next integration cycle), the output direction (screen, plot file, communication bus) and two error codes. The public methods of <monospace>Variable</monospace> contain a four times overloaded function <monospace>init(…)</monospace> for integer, double, vector and matrix variables which are used for the variable definitions in the definition part of the module, e.g.</p>
<p><disp-quote>
<p><monospace>missile[110].<bold>init</bold>(“ca”,0,”Axial force coefficient”,”aerodynamics”, ”out”,”plot”)</monospace>;</p></disp-quote></p>
<p>Other public methods of Variable govern the reading and loading of the module-variables inside a module. To make the module-variables local variables, the member functions <monospace>integer()</monospace>, <monospace>real()</monospace>, <monospace>vec()</monospace> and <monospace>mat()</monospace> are used. For instance,</p>
<p><disp-quote>
<p><monospace>int mfreeze_newt=flat6[247].integer()</monospace>;</p>
<p><monospace>double grav=flat6[55].real()</monospace>;</p>
<p><monospace>Matrix TBL=flat6[120].mat()</monospace>;</p>
<p><monospace>Matrix FAPB=flat6[200].vec()</monospace>;</p>
</disp-quote></p>
<p>By convention, scalar variables are named with all lower-case letters, while upper-case letters designate matrices. Only 3 x 1 vectors and 3 x 3 matrices are permitted as module-variables.</p>
<p>The loading of the local module-variables into the protected arrays uses the member functions <monospace>gets(…)</monospace>, <monospace>gets_vec(…)</monospace> and <monospace>gets_mat(…)</monospace> where <monospace>gets(…)</monospace> is overloaded and serves both int and double types. For instance,</p>
<p><disp-quote>
<p><monospace>flat6[247].gets(mfreeze_newt)</monospace>;</p>
<p><monospace>flat6[248].gets(dvbef)</monospace>;</p>
<p><monospace>flat6[230].gets_vec(FSPB)</monospace>;</p>
<p><monospace>flat6[120].gets_mat(TBL)</monospace>;</p>
</disp-quote></p>
<p>Module-variables provide the sole data transfer between the modules of a vehicle object. For documentation they are recorded in sequential order in <monospace>doc.asc</monospace> with their definitions and other relevant information. Between their label and array location, there is a unique one-to-one relationship. Any deviation from that rule is flagged in <monospace>doc.asc</monospace>.</p>
</sec>
<sec id="section16-1548512910395641">
<title>3.4 Event Scheduling</title>
<p>As aerospace vehicles fly their trajectories, they may sequence through several events towards their destinations. Just think of rockets staging, airplanes taking off, cruising and landing and missiles passing through midcourse and terminal phases towards the intercept. Events in CADAC++ are interruptions of the trajectory for the purpose of reading new values of module-variables. They can only be scheduled for the main vehicle object. The maximum number of events is determined by the global integer <monospace>NEVENT</monospace>, while the number of new module-variables in each event is limited by the global integer <monospace>NVAR</monospace>.</p>
<p>An event is defined in the input file <monospace>input.asc</monospace> by the event block starting and ending with the keywords <monospace>IF … ENDIF</monospace>. Appended to <monospace>IF</monospace> is the event criterion. It consists of the watch variable (any module-variable except of type Matrix) and a relational operator followed by a numerical value. For instance,</p>
<p><disp-quote>
<p><monospace>IF dbt &lt; 8000</monospace></p>
<p><monospace>mseek 12 //’int’ =x2:Enable, =x3:Acquisition, =x4:Lock module seeker</monospace></p>
<p><monospace>ENDIF</monospace></p>
</disp-quote></p>
<p>means, if the range to the target is less than 8000 m, the seeker is enabled. The supported relational operators are <monospace>&lt;</monospace>, <monospace>=</monospace>, <monospace>&gt;</monospace>.</p>
<p>The <monospace><bold>Event</bold></monospace> class supports the creation of Event type objects. The pointer of each event is stored in the <monospace><bold>event_ptr_list</bold>[NEVENT]</monospace>, which is a protected member of the vehicle class. The private members of the Event class store information about the event, such as watch variable, relational operator, threshold value and new module-variables. The public methods are ‘set’ and ‘get’ functions for the data. To expedite execution, the new module-variables are not stored by their name, but by their offset index in the module-variable array. Therefore, rather than cycling through all the module-variables, the new module-variables are directly picked out by their offset indices. These index lists are also part of the private data members of <monospace>Event</monospace>.</p>
<p>Event data are read in <monospace>main()</monospace> from <monospace>input.asc</monospace> by the vehicle member function</p>
<p><disp-quote>
<p><monospace>vehicle_list[i]-&gt;<bold>vehicle_data</bold>(input)</monospace>;</p>
</disp-quote></p>
<p>for each vehicle object and they are ’set‘ into <monospace>Event</monospace> objects, whose pointers are stored in the <monospace>event_ptr_ list</monospace>.</p>
<p>In the function <monospace>execute(…)</monospace>, the watch variables are monitored at every integration interval by the vehicle member function <monospace><bold>event(…)</bold></monospace>. If the criterion of an event is satisfied, the new values for the module-variables are loaded and a message is written to the console to announce the event.</p>
<p>Event scheduling provides great flexibility to shaping the trajectory of an aerospace vehicle. However, as a design matures and the switching logic becomes well defined, the events can be scheduled in the module itself and any event scheduling in the <monospace>input.asc</monospace> file may be completely eliminated at the inconvenience of having to recompile the module if changes are made.</p>
</sec>
<sec id="section17-1548512910395641">
<title>3.5 Global Communication Bus</title>
<p>Encapsulation by classes isolates vehicle objects from each other. However, this feature of C++ prevents direct communication between the vehicles. For instance, the missile object needs to know the coordinates of the target object in order for its seeker to track it. How can the missile get access to the protected target data?</p>
<p>In CADAC++ the global communication bus, called <monospace><bold>combus</bold></monospace>, provides this interface. Selected module-variables are stored in combus so that other vehicles can download them. To identify this process we use the terms ‘<bold>publish</bold>’ and ‘<bold>subscribe</bold>’.</p>
<p>Every vehicle prepares a data set of module-variables and publishes it to <monospace>combus</monospace>. These module-variables are identified by the keyword ‘<monospace>com</monospace>’ in their definition; for instance vmach is added to the data set by</p>
<p><disp-quote>
<p><monospace>flat6[56].init(“vmach”,0,”Mach number”,”environment”,”out”, ”scrn,plot,<bold>com</bold>”)</monospace>;</p>
</disp-quote></p>
<p>Any vehicle can subscribe to the data set of any other vehicle. Utility methods enable the process.</p>
<p>The enabling global class is <monospace><bold>Packet</bold></monospace>. One of its private data member stores the vehicle ID, the status of the vehicle (alive, hit, dead), the number of module-variables in the data set and a pointer to the array of module-variables of type <monospace>Variable</monospace>. Each vehicle object contributes one packet to the communication array <monospace>combus</monospace> of type <monospace>Packet</monospace>. The slot # is the same as that of the vehicle in the <monospace>vehicle_list</monospace>.</p>
<p>Under the <monospace>main()</monospace> scope, the pointer to the communication array is created <monospace>(Packet *combus)</monospace> and dynamic memory is allocated <monospace>(combus=new Packet [num_vehicles])</monospace>, where the array is dimensioned by the number of vehicle objects. In the vehicle constructor, the vehicle member function <monospace>com_index_arrays()</monospace> is called, which collects the offset indices of the module-variables into integer arrays. Still under the <monospace>main()</monospace> scope, <monospace>combus</monospace> is initialized with the packet of each vehicle i</p>
<p><disp-quote>
<p><monospace>combus[i]=vehicle_list[i] -&gt;loading_packet_init(…)</monospace>;</p>
</disp-quote></p>
<p>Then, in function <monospace>execute(…)</monospace>, at every integration step, the values of the module-variables are updated</p>
<p><disp-quote>
<p><monospace>combus[i]=vehicle_list[i]-&gt;loading_packet(…)</monospace>;</p>
</disp-quote></p>
<p>Each packet has a data set of module variables stored in the array pointed to by Variable <monospace>*data</monospace>. The storage sequence in the data set is determined by the order the module-variables are read. The module sequence is defined in the input file <monospace>input.asc</monospace>. This sequence is important for the subscription process.</p>
<p>The subscription of module-variables occurs in the modules. For instance, the seeker in order to track the target has to subscribe to the target position and velocity. First, the target ID is built from the string ’t‘ and the tail number of the target. Then <monospace>combus</monospace> is searched for this packet and the data set is downloaded</p>
<p><disp-quote>
<p><monospace>data_t=combus[i].get_data()</monospace>;</p>
</disp-quote></p>
<p>Knowing that the target position and velocity vectors are at offset 1 and 2, they can be subscribed</p>
<p><disp-quote>
<p><monospace>Matrix STEL=data_t[1].vec()</monospace>;</p>
<p><monospace>Matrix VTEL=data_t[2].vec()</monospace>;</p>
</disp-quote></p>
<p>Now <monospace>STEL</monospace> and <monospace>VTEL</monospace> of the target object are local variables of the missile object and can be used by the seeker.</p>
<p>The number of module-variables in the data set is unrestricted. If you are unsure of the storage sequence, you can find it by selecting <monospace>y_comscrn</monospace> and counting the labels. However, be aware that the three components of vectors count as one label only.</p>
</sec>
<sec id="section18-1548512910395641">
<title>3.6 Table Look-up</title>
<p>Interpolating aerodynamic and propulsion tables is an important task in any aerospace simulation. Aerodynamic coefficients are usually given as functions of incidence angles and Mach number. Sometimes they are also expressed as functions of altitude and control surface deflections. Propulsion data are tailored to the type of propulsion system. For rocket motors, simple thrust tables may suffice. Turbojet and ramjet engines depend on throttle, Mach number and sometimes on incidence angles.</p>
<p>The more variables are used to describe the system, the greater the complexity of the table. Seldom is the dimension higher than three due to run-time considerations. CADAC++ supports table look-up schemes up to third dimension and interpolates linearly between the discrete table entries. It keeps the so-called ‘data decks’ as separate files so they can be properly protected as the need may arise.</p>
<p>The handling of the tables is accomplished by two classes, <monospace>Datadeck</monospace> and <monospace>Table</monospace>. The class <monospace><bold>Datadeck</bold></monospace> has a private member <monospace>**table_ptr</monospace>, which is a pointer to an array of pointers of the class <monospace>Table</monospace> that contains the pointers to all of the tables of a data deck. Under the ‘main vehicle’ scope, inside the ‘protected’ access specifier, the objects <monospace>Datadeck aerotable</monospace> and <monospace>Datadeck proptable</monospace> are declared along with the table pointer <monospace>Table *table</monospace>. At execution, two distinct phases take place: loading the tables and extracting the interpolated value.</p>
<p>The loading of the tables starts when the file <monospace>input.asc</monospace> is read by the function</p>
<p><disp-quote>
<p><monospace>void <bold>input_data</bold>(fstream &amp;input)</monospace>;</p>
</disp-quote></p>
<p>and the keywords <monospace>AERO_DECK</monospace> and <monospace>PROP_DECK</monospace> are encountered with their trailing file names. Then the calls</p>
<p><disp-quote>
<p><monospace>read_tables(file_name,aerotable) <bold>and</bold> read_tables(file_name,proptable)</monospace>;</p>
</disp-quote></p>
<p>execute the code of the function</p>
<p><disp-quote>
<p><monospace>void <bold>read_tables</bold>(char *file_name, Datadeck &amp;datatable)</monospace>;</p>
</disp-quote></p>
<p>which picks up one of the <monospace>file_name</monospace> and returns by reference the object <monospace>datatable</monospace> of type <monospace>Datadeck</monospace>. Internally, <monospace>read_tables(…)</monospace>opens the data file and allocates dynamic memory first to the array of Table pointers (pointed to by <monospace>**table_ptr</monospace> which is a private member of the object <monospace>Datadeck aerotable</monospace>) then to the <monospace>Table</monospace> object (pointed to by <monospace>table</monospace>) and its data arrays. Now the numerical values are read into the data arrays for each table and <monospace>read_tables(…)</monospace>returns void. Both functions <monospace>input_data(…)</monospace>and <monospace>read_tables(…)</monospace> operate within the scope of the ‘main vehicle’ object.</p>
<p>The extraction of the interpolated value occurs in the modules. The <monospace>Datadeck</monospace> objects <monospace>aerotable</monospace> or <monospace>proptable</monospace>, declared under the ‘main vehicle’ object, give access to the public <monospace>Datadeck</monospace> member function</p>
<p><disp-quote>
<p><monospace>double <bold>look_up</bold>(string name, double value1,…)</monospace>;</p>
</disp-quote></p>
<p>which is overloaded three times for one, two and three independent variables. A typical example, taken from an ‘aerodynamic’ module of a two-dimensional table look-up, is</p>
<p><disp-quote>
<p><monospace>double cm=aerotable.look_up(“cm_vs_elev_alpha”,delex,alphax)</monospace>;</p>
</disp-quote></p>
<p>It returns the interpolated value. This call to <monospace>look_up(…)</monospace> initiates two other calls to member functions of Datadeck. First, in <monospace><bold>find_index</bold>(…)</monospace>, a binary search locates the indices of the independent variables just below the table entries. Then <monospace><bold>interpolate</bold>(…)</monospace> linearly interpolates between the next higher discrete value and passes the interpolated value back up to the <monospace>look_up(…)</monospace> function for return.</p>
<p>Additions and deletions of tables in the AERO_DECK or PROP_DECK are automatically adjusted during the loading of the tables. If a simulation requires data tables of a different type (e.g., antenna pattern) one has to do four things: (1) create an ASCII file with the data tables, (2) identify the file name by a keyword <monospace>ANT_DECK antenna_data.asc</monospace> in the <monospace>input.asc</monospace> file, (3) declare an additional Datadeck object in the ‘main vehicle’ class <monospace>antennatable</monospace> and (4) replicate in the function <monospace>input_data(…)</monospace>.</p>
</sec>
<sec id="section19-1548512910395641">
<title>3.7 Monte Carlo Capability</title>
<p>High fidelity simulations use random variables to model noise, disturbances and uncertain phenomena. If we make a single run, it represents only one realization of the total population of random variables. To do a complete stochastic analysis, many repetitive runs have to be executed, each drawing a different value from a distribution. This process can be automated and is referred to as the Monte Carlo capability of a simulation.</p>
<p>Randomized variables may be needed at initialization (e.g., seeker bias) or during the execution of the simulation (e.g., seeker noise). CADAC++ supports both. They are identified in the input file <monospace>input.asc</monospace> by the capitalized keywords that designate their distributions <monospace>UNI</monospace>, <monospace>GAUSS</monospace>, <monospace>RAYL</monospace>, <monospace>EXP</monospace> and <monospace>MARKOV</monospace>. The first four are used for initialization only. MARKOV models a Markov process with Gaussian distribution and first-order time correlation. It has to be called every integration cycle.</p>
<p>To initiate a Monte Carlo run, the keyword <monospace>MONTE</monospace> with two arguments is inserted right before the <monospace>OPTION</monospace> line in <monospace>input.asc</monospace>. The first argument is the run repetition number and the second is the random number seed. If the repetition number is set to zero, one run is executed using the mean values of the distributions.</p>
<p>The stochastic variables, identified in <monospace>input.asc</monospace>, are read by the vehicle object function</p>
<p><disp-quote>
<p><monospace><bold>vehicle_data</bold>(fstream &amp;input,int nmonte)</monospace>;</p>
</disp-quote></p>
<p>If there are initialization variables, a value is drawn from their respective distribution and held constant until it is re-initialized for the next trajectory. Module-variables identified by <monospace>MARKOV</monospace> are initialized with their Gaussian distribution and stored in the <monospace>markov_list</monospace>, which is of type Markov and sized by the global integer <monospace>NMARKOV</monospace>. If <monospace>nmonte=0</monospace>, the mean values are selected.</p>
<p>The class <monospace><bold>Markov</bold></monospace> handles the storage of the Markov data. It declares as private members the sigma and time correlation values of the Markov process and the index of the module-variable of its array. The <monospace>Markov markov_list</monospace> is a protected member of the Cadac hierarchy. Therefore, each main vehicle object has its own list of Markov variables with its own random draws.</p>
<p>At every integration step, for each vehicle, the Markov noise function is called in function <monospace>execute(…)</monospace></p>
<p><disp-quote>
<p><monospace>vehicle_list[i]-&gt;<bold>markov_noise</bold>(sim_time,int_step,nmonte)</monospace>;</p>
</disp-quote></p>
<p>This function downloads the Markov data from the <monospace>markov_list</monospace> and calls the utility function <monospace><bold>markov</bold>(…)</monospace> to refresh the value.</p>
<p>Because Markov noise is a first order correlation process, the current value depends on the previous value. Therefore, there is a provision in the <monospace>Markov</monospace> class to save the current value for the next cycle.</p>
<p>Stochastic analysis is an important aspect of the performance evaluation of any aerospace vehicle. CADAC++ support stochastic initialization for all vehicles, but reserves the Markov process for only the main vehicle. For post-run analysis, the stochastic data of the main vehicle are written to <monospace>stat</monospace> files by exercising the OPTION <monospace><bold>y_stat</bold></monospace>.</p>
</sec>
<sec id="section20-1548512910395641">
<title>3.8 Matrix Utility Operations</title>
<p>Modern programming uses matrix operations wherever possible to condense code and eliminate errors caused by coordinating equations. CADAC++ has a rich set of matrix operations which are public members of the class <monospace><bold>Matrix</bold></monospace>. This class is tailored to the special needs of flight dynamics. Generality has been sacrificed for efficiency. Rather than using template classes and particularly the vector container class of the STL, the CADAC++ matrix operations are restricted to variables of type <monospace>double</monospace>.</p>
<p>The class <monospace><bold>Matrix</bold></monospace> declares a private pointer to the matrix array double <monospace><bold>*pbody</bold></monospace> together with the array dimensions. There are 55 matrix operations declared in the public access area. They are divided into 34 functions and 21 overloaded operators.</p>
<p>In the following examples, capitalized variables are arrays, lower-case names are either functions or scalars.</p>
<p><disp-quote>
<p><monospace>Matrix AAPNB=TBLC*WOELC.skew_sym()*UTBLC*gnav_mid_pn*dvtbc</monospace>;</p>
</disp-quote></p>
<p>This example calculates the (3 x 1) acceleration vector <monospace>AAPNB</monospace> from the LOS rates <monospace>WOELC</monospace>.</p>
<p>The next example calculates the 8 x 8 gain matrix of the filter:</p>
<p><disp-quote>
<p><monospace>Matrix GK=PMAT*~HH*INV. inverse()</monospace>;</p>
</disp-quote></p>
<p>And, finally, the 3 x 1 accelerometer vector error is determined by</p>
<p><monospace>Matrix EAB=ESCALA.diamat_ vec()+EMISA.skew_sym()</monospace>;</p>
<p>Note the limitless possibilities of stringing together matrix operations.</p>
<p>Matrix variables are created by specifying their name and dimensions, e.g., <monospace>Matrix MAT(3,6)</monospace>. The constructor allocates dynamic memory to the <monospace>Matrix</monospace> pointer <monospace>*pbody</monospace> and zeros all elements. The operations themselves use pbody and perform pointer arithmetic to accomplish the various matrix manipulations. Those operations that re-create a matrix <monospace>return</monospace> <monospace><bold>*this</bold></monospace>; i.e. they return the re-calculated object that was originally created and initialized, e.g.</p>
<p><disp-quote>
<p><monospace>Matrix UNIT(3,3)</monospace>;</p>
<p><monospace>UNIT.identity()</monospace>;</p>
</disp-quote></p>
<p>The matrix utilities have a full suite of overloaded operators. The assignment operator requires a <monospace><bold>copy constructor</bold></monospace> to provide for a deep copy of the object to assure that the new object has its own memory allocated and that it is recoverable when the object is destroyed.</p>
<p>The offset operator <monospace><bold>[]</bold></monospace> is also overloaded to access the elements of a <monospace>Matrix</monospace> array. However, this works only for one-dimensional arrays because two-dimensional arrays require more than one offset operator. For those instances, the Matrix functions <monospace>assign_loc(. .)</monospace> and <monospace>get_loc(…)</monospace> must be used.</p>
</sec>
<sec id="section21-1548512910395641">
<title>3.9 Documentation and Error Checking</title>
<p>Self-documentation is an essential part of any simulation. Of primary interest are the variables that are used for input/output as interfaces between modules and those of particular interest for diagnostics. All are referred to as <monospace><bold>module-variables</bold></monospace>. The description of a module-variable occurs only once in the ‘def_module’ function. This description is used to document the input file <monospace>input.asc</monospace> and to create a list of all module-variables in the output file <monospace>doc.asc</monospace>. The documentation of <monospace>input.asc</monospace> is automatic, while the file <monospace>doc.asc</monospace> is only created if the <monospace>OPTION y_doc</monospace> is selected.</p>
<p>CADAC error checking focuses in particular on the correct formatting of the <monospace>input.asc</monospace> file and the enforcement of the one-to-one correspondence rule, ’One module-variable name for one array location‘. Other checks assure that matrix operations are performed on compatible matrices and that file streams open correctly.</p>
<p>The class <monospace><bold>Document</bold></monospace> is used to make the module-variable descriptions available. Its private data are essentially a subset of the class <monospace>Variable</monospace>. They store name, type, definition and module of each module-variable. Under the <monospace>main()</monospace> scope (during initialization), arrays of type <monospace>Document</monospace> are built for each vehicle object, followed by the function call <monospace>document()</monospace></p>
<p><disp-quote>
<p><monospace>vehicle_list[i]-&gt;<bold>document</bold> (fdoc,title,doc_missile6)</monospace>;</p>
</disp-quote></p>
<p>This function, under the vehicle object scope, writes to <monospace>doc.asc</monospace> formatted information of each module-variable and identifies the empty slots in the module-variable arrays. Under the same scope, <monospace>input.asc</monospace> is documented if <monospace>OPTION y_doc</monospace> is set</p>
<p><disp-quote>
<p><monospace><bold>document_input</bold>(doc_missile6, doc_target3,doc_recce3)</monospace>;</p>
</disp-quote></p>
<p>This function operates under the global scope. It uses the arrays of type <monospace>Document</monospace> to extract the module-variable descriptions and appends them after the numerical value of the variable. If it cannot find a matching name it prints out an error message.</p>
<p>To flag violations of the one-on-one correspondence rule, both <monospace>Document</monospace> and <monospace>Variable</monospace> classes cooperate. In the <monospace>Variable</monospace> class the private <monospace>char error[2]</monospace> holds the error codes (* or A).</p>
<p>During initialization, as the <monospace><bold>init</bold>(…)</monospace> functions of the modules are called, a check is made whether that slot is empty and can receive a new variable. If not, the error code ‘<monospace>*</monospace>’ is set. As <monospace>document (…)</monospace> writes the output file <monospace>doc.asc</monospace>, the module-variable array is checked for duplicate names. The error code ‘A’ is set if this occurs. Both codes are inserted in the first column of the <monospace>doc.asc</monospace> file and a warning message is sent to the console.</p>
<p>A good description of a particular simulation is produced if the modules, the <monospace>input.asc</monospace> and the <monospace>doc.asc</monospace> files are combined in a document. It should enable someone else, who is familiar with the CADAC++ architecture, to pick up, run and understand the simulation.</p>
</sec>
</sec>
<sec id="section22-1548512910395641">
<title>4. Constructive Simulations</title>
<p>Constructive simulations have become the engineer’s major integration tool. With their realistic portrayal of the physical interactions between aerodynamics, propulsion, guidance and control they support concept studies, hardware integration tasks, flight testing and training. Specifically they enable the following:</p>
<list id="list1-1548512910395641" list-type="bullet">
<list-item><p><italic>Developing performance requirements</italic>. A variety of concepts are simulated to match up technologies with requirements and to define preliminary performance specifications.</p></list-item>
<list-item><p><italic>Performing technology trade studies</italic>. Various subsystem are modeled and analyzed as they interact with other subsystems to determine the specifications that best meet the performance requirements.</p></list-item>
<list-item><p><italic>Guiding and validating designs</italic>. Sensitivity studies are conducted to determine the optimal design parameters; models of subcomponents are tested as they interact with other parts of the system; overall performance is established.</p></list-item>
<list-item><p><italic>Test support</italic>. Test trajectories and footprints are pre-calculated and test results are correlated with simulations.</p></list-item>
<list-item><p><italic>Reduction in test cost</italic>. A simulation, validated by flight test, is used to investigate other points in the flight envelope.</p></list-item>
<list-item><p><italic>Investigating inaccessible environments</italic>. Simulations are the most cost effective way to check out vehicles that fly through the Martian atmosphere or land on Venus.</p></list-item>
<list-item><p><italic>Pilot and operator training</italic>. Thousands of flight simulators help train military and civilian pilots.</p></list-item>
<list-item><p><italic>Practicing dangerous procedures</italic>. System failures, abort procedures, and extreme flight conditions can be explored safely on simulators.</p></list-item>
<list-item><p><italic>Gaining insight into flight dynamics</italic>. Dynamic variables can be traced through the simulation and limiting constraints can be identified.</p></list-item>
<list-item><p><italic>Integration of components</italic>. Understanding how subsystems interact to form a functioning vehicle.</p></list-item>
</list>
<p>CADAC, during its long history, has supported all of these tasks. It has been used to develop missile performance requirements, to conduct technology trades (airframe, propulsion, seeker, guidance and control), and to support flight test planning and data analysis. Air-to-air missile concepts have been integrated into air combat domes and into mission-level simulation frameworks like FLAMES<sup>®</sup>.</p>
<p>Not all CADAC simulations are at the 6-DoF fidelity, though high-fidelity modeling is required for delivery accuracy, hardware-in-the-loop and flight testing. However, during weapon conceptualization, lower fidelity 5-DoF or 3-DoF models often suffice or are mandated by the lack of detailed component data. These simpler simulations drop one or three of the attitude degrees of freedom. Most of the recent CADAC simulations are of 6-DoF fidelity, but some UAV, air-to-air and air-to-ground missiles are modeled at 5-DoF. All these simulations have the same CADAC++ framework. The distinction is reflected in the vehicle class structure and the associated modules.</p>
<p>For efficient use of constructive simulations, versatile plotting options and stochastic data processing must be available. CADAC Studio satisfies that need. Its history is as distinguished as that of the CADAC simulations. Originally developed for mainframes, then for VAXes and finally for PCs, it provides for interactive plotting, automated launch envelope and footprint generation and post-processing of Monte Carlo runs.</p>
<p>The plotting options consist of two dimensional traces and three dimensional trajectories either in a Cartesian grid or in longitude, latitude, altitude over the globe. A strip-chart capability plots up to 12 traces against time.</p>
<p>The SWEEP program of CADAC Studio automates the generation of footprints for air-to-ground missile and launch envelopes for air-to-air missiles. A single CADAC submittal will spawn trajectory runs against a target grid. Plotting options then generate carpet plots of selected parameters.</p>
<p>Monte Carlo runs draw from a variety of stochastic distributions for insertion of numerical values into uncertain parameters such as aerodynamic uncertainties, INS errors, seeker errors and wind gusts. CADAC Studio analyzes the output and generates CEPs, bivariate ellipses and mean values in the target or intercept planes with plots that also display the scatter points. Even the SWEEP program can be executed in the Monte Carlo mode to generate CEPs throughout the envelope or footprint.</p>
<p>CADAC and CADAC Studio provide a complete environment for constructive simulations. They have been used for bombs, missiles, UAVs, aircraft and spacecraft. Some recently developed simulations are summarized next.</p>
</sec>
<sec id="section23-1548512910395641">
<title>5. Multi-use Examples</title>
<p>During the course of the CADAC++ development many simulations were built on the same framework. The modular architecture lends itself to multi-use applications. For example the environmental module is suitable for all simulations. The 6-DoF equations of motion over the WGS 84<sup><xref ref-type="bibr" rid="bibr10-1548512910395641">10</xref></sup> or flat Earth apply to all corresponding simulations (Newton and Euler modules are the same). Seeker, INS, guidance and control laws can be shared where appropriate. With the strict enforcement of the interfaces between modules, the integration of an existing module into a new simulation is simplified.</p>
<p><xref ref-type="table" rid="table1-1548512910395641">Table 1</xref> summarizes the currently active CADAC++ simulations. They cover the breadth of aerospace vehicles. Among the 13 simulations are two 5-DoF models, six over the flat Earth, and five over the elliptical WGS84 Earth. Most have Monte Carlo capability and use the U.S. Standard Atmosphere 1976;<sup><xref ref-type="bibr" rid="bibr11-1548512910395641">11</xref></sup> some can implement a test atmosphere with winds aloft as well as Dryden-type turbulence.<sup><xref ref-type="bibr" rid="bibr12-1548512910395641">12</xref></sup> The simulations are also distinguished by the type of vehicle objects they model. Some have just one object, while others have two or three. The first object is always the vehicle of primary interest. It determines the degree-of-freedom classification. It can morph into different configurations as indicated by the ‘+’ sign. The semicolon separates the objects. Each vehicle object can be instantiated multiple times making possible the engagement of many-on-many. Two simulations have been integrated into the mission-level FLAMES<sup>®</sup> framework: Long Range Strike Missile and Self Defense Missile.</p>
<table-wrap id="table1-1548512910395641" position="float">
<label>Table 1.</label>
<caption><p>CADAC++ Active Simulations</p></caption>
<graphic alternate-form-of="table1-1548512910395641" xlink:href="10.1177_1548512910395641-table1.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="left"/>
<col align="char" char="."/>
<col align="left"/>
<col align="left"/>
</colgroup>
<thead>
<tr>
<th align="left">TYPE</th>
<th align="left">VEHICLE OBJECTS</th>
<th align="left">DoF</th>
<th align="left">EARTH</th>
<th align="left">FEATURES</th>
</tr>
</thead>
<tbody>
<tr>
<td><bold>Cruise Missile</bold></td>
<td>Missile; Target; Satellite</td>
<td>5</td>
<td>Spherical</td>
<td>Remote Targeting</td>
</tr>
<tr>
<td><bold>Fighter Aircraft</bold></td>
<td>Aircraft</td>
<td>6</td>
<td>Flat</td>
<td>Generic F16</td>
</tr>
<tr>
<td><bold>Air-to-Ground Missile</bold></td>
<td>Missile; Aircraft; Target</td>
<td>6</td>
<td>Flat</td>
<td>Weather Deck, MC</td>
</tr>
<tr>
<td><bold>Air-to-Air Missile</bold></td>
<td>Missile; Target Aircraft</td>
<td>6</td>
<td>Flat</td>
<td>MC</td>
</tr>
<tr>
<td><bold>National Aerospace Plane</bold></td>
<td>Plane + Transfer Vehicle + Interceptor; Tracking Station; Satellite</td>
<td>6</td>
<td>WGS84</td>
<td>Generic X30,Weather Deck, MC</td>
</tr>
<tr>
<td><bold>Generic Defense Missile</bold></td>
<td>Defensive Missile; Aircraft; Offensive Missile</td>
<td>6</td>
<td>Flat</td>
<td>MC</td>
</tr>
<tr>
<td><bold>Three Stage Booster</bold></td>
<td>Rocket with Three Stages</td>
<td>6</td>
<td>WGS84</td>
<td>Insertion Guidance, Weather Deck, MC</td>
</tr>
<tr>
<td><bold>Long Range Strike Missile</bold></td>
<td>Missile; Target</td>
<td>5</td>
<td>Spherical</td>
<td>Hypersonic, FLAMES<sup>®</sup></td>
</tr>
<tr>
<td><bold>Dual Role Missile</bold></td>
<td>Missile; Target; Recce Aircraft</td>
<td>6</td>
<td>Flat</td>
<td>Two Pulse Rocket, Integral Rocket Ramjet, MC</td>
</tr>
<tr>
<td><bold>Global Strike</bold></td>
<td>Booster + Waverider + Munition; Satellite; Target</td>
<td>6</td>
<td>WGS84</td>
<td>Wave Rider, MC</td>
</tr>
<tr>
<td><bold>Self Defense Missile</bold></td>
<td>Defensive Missile; Aircraft; Offensive Missile</td>
<td>6</td>
<td>Flat</td>
<td>Real time, MC, FLAMES<sup>®</sup></td>
</tr>
<tr>
<td><bold>Small Smart Bomb</bold></td>
<td>Bomb; Satellite; Target</td>
<td>6</td>
<td>WGS84</td>
<td>Weather Deck, MC</td>
</tr>
<tr>
<td><bold>Hypersonic Cruise Missile</bold></td>
<td>Missile; Satellite; Target</td>
<td>6</td>
<td>WGS84</td>
<td>Scramjet, Weather Deck, MC</td>
</tr>
</tbody>
</table>
<table-wrap-foot>
<fn id="table-fn1-1548512910395641">
<p>MC=Monte Carlo capable</p>
</fn>
</table-wrap-foot>
</table-wrap>
<p>Two simulations are presented as examples. The Three Stage Booster simulation represents a model of a rocket that can place a payload into low Earth orbit using the WGS84 equations of motions. The Generic Defense Missile simulation (which models three objects) represents a blue missile launched from a blue aircraft against an incoming red missile using the flat Earth equations of motions.</p>
<sec id="section24-1548512910395641">
<title>5.1 Three Stage Booster Simulation</title>
<p>This is a typical solid rocket delivery booster. It is controlled by thrust vector control (TVC) and reaction control system (RCS) but has no aerodynamic control fins. The autopilot uses accelerometer and rate gyro feedback from the inertial measurement unit (IMU) to steer the missile. During the first stage, a pitch program is executed while maintaining small incidence angles in the high dynamic pressure region. Stages two and three are under ascent guidance to meet the terminal insertion conditions. This guidance law implements linear tangent guidance for minimum fuel consumption.<sup><xref ref-type="bibr" rid="bibr13-1548512910395641">13</xref>,<xref ref-type="bibr" rid="bibr14-1548512910395641">14</xref></sup> The onboard inertial navigation system (INS), updated by the global precision system (GPS) and a star tracker, provides the navigation states of the booster.</p>
<p>The class hierarchy of this simulation has only one branch, Cadac ← Round6 ← Hyper. ‘Round6’ models the 6-DoF equations of motion over the WGS84 Earth and ‘Hyper’ contains all the subsystems of the booster coded in modules (see <xref ref-type="fig" rid="fig1-1548512910395641">Figure 1</xref>). The protected arrays of the classes are labeled <monospace>round6[]</monospace> and <monospace>hyper[]</monospace> and the assigned locations are indicated in the brackets.</p>
<fig id="fig1-1548512910395641" position="float">
<label>Figure 1.</label>
<caption><p>Modular architecture of the three stage booster simulation.</p></caption>
<graphic xlink:href="10.1177_1548512910395641-fig1.tif"/>
</fig>
<p>A typical trajectory is launched and places a payload at the suborbital conditions of 110 km altitude, 1.5° flight path angle and 6600 m/s inertial speed. <xref ref-type="fig" rid="fig2-1548512910395641">Figure 2</xref> was generated with the CADAC Studio Globe program.</p>
<fig id="fig2-1548512910395641" position="float">
<label>Figure 2.</label>
<caption><p>Ascent of the three stage booster and suborbital insertion.</p></caption>
<graphic xlink:href="10.1177_1548512910395641-fig2.tif"/>
</fig>
<p>To evaluate the performance of the booster the engineer requires the traces of many trajectory parameters. Some of them are plotted with CADAC Studio 2Dim and displayed in <xref ref-type="fig" rid="fig3-1548512910395641">Figure 3</xref>.</p>
<fig id="fig3-1548512910395641" position="float">
<label>Figure 3.</label>
<caption><p>Trajectory parameters of the three stage booster ascent.</p></caption>
<graphic xlink:href="10.1177_1548512910395641-fig3.tif"/>
</fig>
<p>Note the dynamic pressure peak at 30 seconds into flight. The incidence angles are small during the peak to keep the structural loads within limits. Afterwards, the angle of attack increases dramatically to alter the flight path towards the insertion point.</p>
<p>This simulation makes use of the Round6 class common to all 6-DoF simulations over the WGS84 Earth. It uses the INS, GPS and star-track modules from other simulations. Only the aerodynamics(), propulsion(), guidance() and control() modules are specific to this application.</p>
</sec>
<sec id="section25-1548512910395641">
<title>5.2 Generic Defense Missile Simulation</title>
<p>This simulation highlights the multiple instantiation of three vehicle objects. An aircraft launches a missile (blue) to intercept an attacking missile (red). The blue missile receives target updates during midcourse until its seeker locks onto the red missile for terminal homing.</p>
<p>The class structure has three branches. For the main missile object Cadac ← Flat6 ← Missile, for the red missile Cadac ← Flat3 ← Target, and for the aircraft Cadac ← Flat3 ← Aircraft. The modules are shown in <xref ref-type="fig" rid="fig4-1548512910395641">Figure 4</xref>. Inside each object data flows through the protected arrays while across objects the data is provided by the communication bus ‘combus’ packets. Note that three levels of modeling fidelity are combined. The major focus of the analysis is on the blue missile. It is modeled in 6-DoF while the red missile is in 5-DoF and the aircraft in 3-DoF (though both, red missile and blue aircraft use the 3-DoF equations of motion).</p>
<fig id="fig4-1548512910395641" position="float">
<label>Figure 4.</label>
<caption><p>Modular architecture of the Generic Defense Missile simulation.</p></caption>
<graphic xlink:href="10.1177_1548512910395641-fig4.tif"/>
</fig>
<p>The multiple instantiation of the vehicle objects is demonstrated in <xref ref-type="fig" rid="fig5-1548512910395641">Figure 5</xref>. The aircraft launches two defensive missiles against two incoming threat missiles. The graph was drawn by the 3Dim plotting program of CADAC Studio.</p>
<fig id="fig5-1548512910395641" position="float">
<label>Figure 5.</label>
<caption><p>Two defensive missiles against two offensive missiles fly-out.</p></caption>
<graphic xlink:href="10.1177_1548512910395641-fig5.tif"/>
</fig>
<p>As an example of a typical Monte Carlo result, <xref ref-type="fig" rid="fig6-1548512910395641">Figure 6</xref> shows the impact points of the blue missile on the red missile intercept plane created by 100 MC runs. The generation of this graph is fully automated in CADAC Studio. The CEP and the bivariate ellipse are shown. It reveals a significant bias in the system due to guidance and control lags and limiters.</p>
<fig id="fig6-1548512910395641" position="float">
<label>Figure 6.</label>
<caption><p>Impact of blue missile on red missile intercept plane.</p></caption>
<graphic xlink:href="10.1177_1548512910395641-fig6.tif"/>
</fig>
<p>The Generic Defense Missile simulation makes use of the common class Flat6 with its 6-DoF equations of motion over the flat Earth. Several modules of the blue missile are shared with other simulations. These include modules such as rcs(), tvc(), actuator(), ins() and sensor(). The modules aerodynamics(), propulsion(), guidance() and control() are specific to the Generic Defense Missile.</p>
<p>These are just two examples of the family of CADAC++ simulations shown in <xref ref-type="table" rid="table1-1548512910395641">Table 1</xref>. Other simulations also demonstrate the commonality made possible by the class structure and modularity of the CADAC++ architecture.</p>
</sec>
</sec>
<sec id="section26-1548512910395641">
<title>6 Summary</title>
<p>The conversion of CADAC from FORTRAN to C++ is essentially complete. During the ten years since the switch has been made, several simulations were updated and new models created. CADAC Studio also experienced modifications to make it compatible with the C++ output. The new code has been applied to various US Air Force projects and found to be invaluable for concept explorations, technology assessments and mission-level studies.</p>
</sec>
</body>
<back>
<ref-list>
<title>References</title>
<ref id="bibr1-1548512910395641">
<label>1.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Zipfel</surname><given-names>PH</given-names></name>
</person-group>. <article-title>Modeling and Simulation of Aerospace Vehicle Dynamics</article-title>. <edition>2nd ed.</edition> <article-title>American Institute of Aeronautics and Astronautics</article-title>, <year>2007</year>.</citation>
</ref>
<ref id="bibr2-1548512910395641">
<label>2.</label>
<citation citation-type="web">
<person-group person-group-type="author">
<name><surname>Berndt</surname><given-names>JS</given-names></name>
</person-group>. <article-title>JSBSim</article-title>, <comment><ext-link ext-link-type="uri" xlink:href="http://www.jsbsim.org">www.jsbsim.org</ext-link></comment>. <access-date>Last accessed: 19 Jan 2011</access-date>.</citation>
</ref>
<ref id="bibr3-1548512910395641">
<label>3.</label>
<citation citation-type="web">
<collab>Flightgear Version 2.0.0</collab>, <comment><ext-link ext-link-type="uri" xlink:href="http://www.flightgear.org">http://www.flightgear.org</ext-link></comment> (<day>25</day> <month>February</month> <year>2010</year>). <access-date>Last accessed: 19 Jan 2011</access-date>.</citation>
</ref>
<ref id="bibr4-1548512910395641">
<label>4.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Hester</surname><given-names>J</given-names></name>
</person-group>. <article-title>CMD C++ Modeling Developer</article-title>. <publisher-loc>Redstone Arsenal, AL</publisher-loc>: <publisher-name>U.S. Army Research, Development and Engineering Command</publisher-name>; <email>jeffrey.hester@us.army.mil</email>,</citation>
</ref>
<ref id="bibr5-1548512910395641">
<label>5.</label>
<citation citation-type="web">
<person-group person-group-type="author">
<name><surname>Zipfel</surname><given-names>PH</given-names></name>
</person-group>. <article-title>CADAC4</article-title>, <comment><ext-link ext-link-type="uri" xlink:href="http://www.AIAA.org/content.cfm?pageid=403&amp;ID=1592">http://www.AIAA.org/content.cfm?pageid=403&amp;ID=1592</ext-link></comment>. <access-date>Last accessed: 19 Jan 2011</access-date>.</citation>
</ref>
<ref id="bibr6-1548512910395641">
<label>6.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Zipfel</surname><given-names>PH</given-names></name>
</person-group>. <source>Building Aerospace Simulations in C++</source>. <edition>2nd ed.</edition> <comment>AIAA, 2008 (CD-ROM)</comment>.</citation>
</ref>
<ref id="bibr7-1548512910395641">
<label>7.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Zipfel</surname><given-names>PH</given-names></name>
</person-group>. <source>Fundamentals of Six Degrees of Freedom Aerospace Simulations in FORTRAN and C++</source>. <comment>AIAA, 2004 (CD-ROM)</comment>.</citation>
</ref>
<ref id="bibr8-1548512910395641">
<label>8.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Zipfel</surname><given-names>PH</given-names></name>
</person-group>. <source>Advanced Six Degrees of Freedom Aerospace Simulation and Analysis</source>. <comment>AIAA, 2005 (CD-ROM)</comment>.</citation>
</ref>
<ref id="bibr9-1548512910395641">
<label>9.</label>
<citation citation-type="web">
<collab>Ternion Corporation</collab>. <article-title>FLAMES Flexible Analysis, Modeling, and Exercise System</article-title>, <comment><ext-link ext-link-type="uri" xlink:href="http://www.ternion.com">http://www.ternion.com</ext-link></comment>. <access-date>Last accessed: 19 Jan 2011</access-date>.</citation>
</ref>
<ref id="bibr10-1548512910395641">
<label>10.</label>
<citation citation-type="book">
<collab>NIMA</collab>. <source>Department of Defense World Geodetic System 1984</source>. <comment>Report No.: TR 8350.2 4</comment>.<publisher-loc>Bethesda, MD</publisher-loc>: <publisher-name>NIMA</publisher-name>, <month>July</month> <year>1997</year>.</citation>
</ref>
<ref id="bibr11-1548512910395641">
<label>11.</label>
<citation citation-type="journal">
<collab>NOAA</collab>. <source>U.S. Standard Atmosphere 1976</source>. <comment>Report No.: S/T 76-1562. U.S</comment>. <article-title>Government Printing Office</article-title>, <year>1976</year>.</citation>
</ref>
<ref id="bibr12-1548512910395641">
<label>12.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Dryden</surname><given-names>HL</given-names></name>
</person-group>. <article-title>A review of the statistical theory of turbulence</article-title>. <source>Q Appl Math</source><year>1943</year>; <volume>1</volume>: <fpage>7</fpage>-<lpage>42</lpage>.</citation>
</ref>
<ref id="bibr13-1548512910395641">
<label>13.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Bryson</surname><given-names>HO</given-names></name>
</person-group>. <source>Applied Optimal Control</source>. <publisher-name>Hemisphere Publishing Co.</publisher-name>, <year>1975</year>.</citation>
</ref>
<ref id="bibr14-1548512910395641">
<label>14.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Jaggers</surname><given-names>RF</given-names></name>
</person-group>. <source>Multi-Stage Linear Tangent Guidance as Baseline for the Space Shuttle Vehicle</source>. <comment>Technical Report MSC-07458 (Internal Note MSC-EG-72-39)</comment>.</citation>
</ref>
</ref-list>
</back>
</article>