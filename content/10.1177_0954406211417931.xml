<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD Journal Publishing DTD v2.3 20070202//EN" "journalpublishing.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">PIC</journal-id>
<journal-id journal-id-type="hwp">sppic</journal-id>
<journal-title>Proceedings of the Institution of Mechanical Engineers, Part C: Journal of Mechanical Engineering Science</journal-title>
<issn pub-type="ppub">0954-4062</issn>
<issn pub-type="epub">2041-2983</issn>
<publisher>
<publisher-name>SAGE Publications</publisher-name>
<publisher-loc>Sage UK: London, England</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1177/0954406211417931</article-id>
<article-id pub-id-type="publisher-id">10.1177_0954406211417931</article-id>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Design and Manufacture</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>Formal syntax and semantics of basic function blocks in IEC 61499</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" corresp="yes">
<name><surname>Tu</surname> <given-names>Y</given-names></name>
<xref ref-type="aff" rid="aff1-0954406211417931">1</xref>
<xref ref-type="aff" rid="aff2-0954406211417931">2</xref>
<xref ref-type="corresp" rid="corresp1-0954406211417931">*</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Li</surname> <given-names>D</given-names></name>
<xref ref-type="aff" rid="aff1-0954406211417931">1</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Li</surname> <given-names>S</given-names></name>
<xref ref-type="aff" rid="aff1-0954406211417931">1</xref>
</contrib>
</contrib-group>
<aff id="aff1-0954406211417931"><label>1</label>School of Mechanical and Automotive Engineering, South China University of Technology, Guangzhou, People’s Republic of China</aff>
<aff id="aff2-0954406211417931"><label>2</label>Faculty of Applied Mathematics, Guangdong University of Technology, Guangzhou, People’s Republic of China</aff>
<author-notes>
<corresp id="corresp1-0954406211417931"><label>*</label>School of Mechanical and Automotive Engineering, South China University of Technology, Guangzhou, Guangdong Province, People’s Republic of China. email: <email>taylor_tu@126.com</email></corresp>
</author-notes>
<pub-date pub-type="epub-ppub">
<month>4</month>
<year>2012</year>
</pub-date>
<volume>226</volume>
<issue>4</issue>
<fpage>1025</fpage>
<lpage>1035</lpage>
<history>
<date date-type="received"><day>27</day><month>1</month><year>2011</year></date>
<date date-type="accepted"><day>4</day><month>7</month><year>2011</year></date>
</history>
<permissions>
<copyright-statement>© Authors 2011</copyright-statement>
<copyright-year>2011</copyright-year>
<copyright-holder content-type="society">Institution of Mechanical Engineers</copyright-holder>
</permissions>
<abstract>
<p>The use IEC 61499 (International Electrotechnical Commission, IEC) as a modelling language for distributed industrial process measurement control systems lacks formal syntax and explicit semantics and can hardly ensure reliability and validity of systems. As the basic modelling elements in IEC 61499, syntax and semantics of basic function block (BFB) are specified informally and ambiguously. Hence, the formal syntax and explicit semantics of BFB are advanced to achieve the behavioural consistency and correct results, in this article. The formal syntax is defined by mathematical set theory and the explicit semantics are composed of two kinds of semantics: denotational and execution semantics. The denotational semantics explain the meaning of language with an extended Mealy finite-state machines for the formal verification in a formal way. The execution semantics provide execution rule and algorithm scheduling in the execution process and involve an input machine and the main part, in which input machine masters the matching relation of event and data input variables and the main part offers execution orders and algorithm computation. Besides, the execution semantics of BFB are exemplified with two events and algorithms as the execution order t<sub>1</sub>–t<sub>20</sub>, and a flowchart of BFB behaviours is given as an overview of the processing steps for implementation or code generation.</p>
</abstract>
<kwd-group>
<kwd>IEC 61499</kwd>
<kwd>basic function blocks</kwd>
<kwd>formal syntax</kwd>
<kwd>denotational semantics</kwd>
<kwd>execution semantics</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="sec1-0954406211417931"><title>1 INTRODUCTION</title>
<p>IEC 61131 (International Electrotechnical Commission, IEC) PLC (programmable logic controller) standard [<bold><xref ref-type="bibr" rid="bibr1-0954406211417931">1</xref></bold>] is used as a standard to organize, design, and execute program logic within control devices in industrial manufacturing systems; it has been extended into a new standard IEC 61499 for distributed systems [<bold><xref ref-type="bibr" rid="bibr2-0954406211417931">2</xref></bold>, <bold><xref ref-type="bibr" rid="bibr3-0954406211417931">3</xref></bold>]. Owing to more distributed control requirements, IEC 61499 has been approved as a portable, reusable, and modular development standard of system modelling for distributed industrial process measurement control systems (IPMCS) by the IEC since 2005 [<bold><xref ref-type="bibr" rid="bibr2-0954406211417931">2</xref></bold>]. In particular, IEC 61499 has been regarded not only as an architecture model based on function blocks (FBs) executed in different real-time environments, but also as a modelling language including syntax and semantics to describe the structure and behaviour of distributed control systems.</p>
<p>As a modelling language, IEC 61499 defines the syntax of three kinds of FBs literally, i.e. basic FB (BFB), composite FB (CFB) and service interface FB (SIFB). A BFB is the basic modelling element in IEC 61499 and its type is composed of interface, execution control chart (ECC), and algorithms described in <xref ref-type="fig" rid="fig2-0954406211417931">Fig. 2</xref> [<bold><xref ref-type="bibr" rid="bibr2-0954406211417931">2</xref></bold>]. A concrete case PID_CALC is illustrated in <xref ref-type="fig" rid="fig1-0954406211417931">Fig. 1</xref>. The left of <xref ref-type="fig" rid="fig1-0954406211417931">Fig. 1(a)</xref> shows the interfaces of PID_CALC, including event inputs/outputs and data inputs/outputs. The black line between event and data inputs/outputs specifies the <italic>WITH</italic> qualifier, which means that input or output variables shall besampled upon the occurrence of an event at the associated event input or event output, respectively. <xref ref-type="fig" rid="fig1-0954406211417931">Fig. 1(b)</xref> displays the ECC consisting of states, transitions, and actions which specify the sequencing of algorithm invocation for such an FB.
<fig id="fig1-0954406211417931" position="float"><label>Fig. 1</label><caption><p>BFB PID_CALC example: (a) external interfaces; (b) ECC</p></caption><graphic xlink:href="10.1177_0954406211417931-fig1.tif"/></fig></p>
<p>The example is illustrative and the details of the specification are not normative. The PID_CALC can be regarded as a functional component with states that can be triggered to perform a certain execution and its behaviour can be described by ECC. Frankly, only the semantics of BFB in IEC 61499 have been referred, while others have been neglected because of the complexity and diversity of their structure and behaviour [<bold><xref ref-type="bibr" rid="bibr4-0954406211417931">4</xref></bold>–<bold><xref ref-type="bibr" rid="bibr6-0954406211417931">6</xref></bold>].</p>
<p>Even for BFB, the older version of IEC 61499 brought some issues about its semantics, e.g. event input clearance rule, the order of transition evaluation, the time for event output issued, etc. A few researches are devoted to revising them with some assumptions or postulates for the execution of BFB. For example, Vyatkin [<bold><xref ref-type="bibr" rid="bibr7-0954406211417931">7</xref></bold>] at University of Auckland offered some postulates about BFB as follows.</p>
<list list-type="order">
<list-item><p>An FB can be in one of the states ‘active’, ‘idle’, or ‘pre-empted’. An activation can occur only as a consequence of event at an event input of the block.</p></list-item>
<list-item><p>A single run of a BFB cannot be preempted by another FB. It can only be preempted by resource in order to process event inputs.</p></list-item>
<list-item><p>A single run of a BFB is instantaneous or ‘relatively’ short.</p></list-item>
<list-item><p>Event input of a BFB clears after single ECC transition, regardless of if this event was used in the evaluation or not.</p></list-item>
<list-item><p>Event outputs are issued immediately after the corresponding action is completed.</p></list-item>
<list-item><p>If a BFB emits several event outputs in one state of ECC, they are emitted sequentially.</p></list-item>
</list>
<p>Meanwhile, Zoitl [<bold><xref ref-type="bibr" rid="bibr8-0954406211417931">8</xref></bold>] of Vienna University of Technology generalized some assumptions about the execution of BFB as follows.</p>
<list list-type="order">
<list-item><p>There is only one event active during the single run (no concurrent events). After the first transition clears, the event occurrence clears too. An event input can be used at most once, but it may possibly clear unused.</p></list-item>
<list-item><p>During a single run of a BFB, several states may be executed. After changing the state of the ECC for the first time, the event input is cleared. Only transitions that purely consist of guard condition are then able to clear.</p></list-item>
</list>
<p>These assumptions or postulates about BFB guarantee the semantics of BFB unambiguous and facilitate the implementation of application based on FBs independent of the different run-time environments.</p>
<p>Besides, other results about BFB have also been discussed. Vyatkin and co-workers [<bold><xref ref-type="bibr" rid="bibr4-0954406211417931">4</xref></bold>, <bold><xref ref-type="bibr" rid="bibr5-0954406211417931">5</xref></bold>, <bold><xref ref-type="bibr" rid="bibr7-0954406211417931">7</xref></bold>, <bold><xref ref-type="bibr" rid="bibr9-0954406211417931">9</xref></bold>–<bold><xref ref-type="bibr" rid="bibr11-0954406211417931">11</xref></bold>] adopted a formal modelling approach for verification of IEC 61499 FBs using net condition/event systems (NCES). They illustrated an integral real BFB EC by an NCES model through the connection with five state machines. This approach focused on the exchange of place and transition to describe the event flow and state transition. Zoitl [<bold><xref ref-type="bibr" rid="bibr8-0954406211417931">8</xref></bold>, <bold><xref ref-type="bibr" rid="bibr12-0954406211417931">12</xref></bold>–<bold><xref ref-type="bibr" rid="bibr14-0954406211417931">14</xref></bold>] considered the time property of one algorithm in BFB and offered a flowchart of BFB execution process and BFB-oriented benchmark.</p>
<p>On the other hand, the use of formal methods is increasing in critical system development, where emergent system properties such as safety, reliability, and security are very important. Critical systems where formal methods have been applied successfully include an air traffic control information system [<bold><xref ref-type="bibr" rid="bibr15-0954406211417931">15</xref></bold>], railway signalling systems [<bold><xref ref-type="bibr" rid="bibr16-0954406211417931">16</xref></bold>], spacecraft systems [<bold><xref ref-type="bibr" rid="bibr17-0954406211417931">17</xref></bold>], etc. Actually, formal methods rely on mathematical representations of systems including formal specification, specification analysis and proof, transformational development, and program verification.</p>
<p>As the first part of the formal methods, the use of formal specification can eliminate ambiguity and thus reduce the chance of errors being introduced during system development. Moreover, formal specification languages are mathematics-based languages whose purpose is to aid the construction of systems [<bold><xref ref-type="bibr" rid="bibr18-0954406211417931">18</xref></bold>]. Formal specification languages are composed of formal syntax and semantics to describe the composition, architecture, and behaviour of systems. There are two fundamental languages in formal specification languages: one is an algebra-based language which describes systems in terms of operations and their relationships, such as Larch and OBJ and the other is a model-based language where a model of system is built by mathematical constructs such as sets and sequences and the system operations are defined by how they modify the system state, such as Z, VDM, CSP, and Petri Nets. The formal specification of systems is based on these formal languages and provides support for the later formal verification to guarantee the correctness of system design.</p>
<p>Considering the advantages of formal methods during the system development, formal methods for specification, analysis, and verification of the FB-based system can be used. As the smallest granular functional unit in IEC 61499, the syntax and semantics of BFB can be also described by a formal specification language not only to involve the aforementioned assumptions and postulates of BFB, but also to provide an automatic model checker technique for formal verification. Unfortunately, few articles are concerned about the formal specification of BFB.</p>
<p>In this article, formal syntax and semantics of BFB are advanced to provide a precise, formal specification for BFB in order to facilitate more complicated formal modelling of the FB-based application. Formal syntax of BFB defines a variety of elements of BFB helpful for the modelling of CFB, applications, and systems. On the other hand, the semantics of BFB can be described in two ways, denotational semantics and execution semantics, associated with the syntax. Denotational semantics interpret the meanings of language by mathematical notions, formulas, or theorems in a formal way useful for formal verification of BFB behaviours. Execution semantics define how and when the various elements of a language should produce a behaviour and offer a set of guidelines for execution. Execution semantics of BFB are exemplified as t<sub>1</sub>–t<sub>20</sub> with an example with two events and two algorithms, and a flowchart of BFB behaviours is illustrated the execution orders and constraints to facilitate implementation or code-generation.</p>
<p>The remainder of the article is as follows: <xref ref-type="sec" rid="sec2-0954406211417931">Section 2</xref> introduces a formal syntax of BFB. Following this, the denotational semantics of BFB are given in <xref ref-type="sec" rid="sec5-0954406211417931">Section 3</xref>. Successively, execution semantics of BFB are provided with an example and a flowchart in <xref ref-type="sec" rid="sec10-0954406211417931">Section 4</xref>. Finally, <xref ref-type="sec" rid="sec16-0954406211417931">Section 5</xref> summarizes the main topics addressed in the article and presents future works in this direction.</p>
</sec>
<sec id="sec2-0954406211417931"><title>2 FORMAL SYNTAX OF BFB</title>
<sec id="sec3-0954406211417931"><title>2.1 Basic FB type</title>
<p>In IEC 61499, an FB is a functional unit of software comprising an individual, named copy of the data structure specified by FB type, which persists from one invocation of the FB to the next. There are three kinds of standard FB types: BFB, CFB, and SIFB. BFB type cannot be decomposed into other FB types and may utilize an ECC to control the execution of its algorithms [<bold><xref ref-type="bibr" rid="bibr2-0954406211417931">2</xref></bold>].</p>
<p>The BFB type consists of a head and body, as illustrated in <xref ref-type="fig" rid="fig2-0954406211417931">Fig. 2</xref>. The head is responsible for controling the dynamics by accepting event inputs and issuing event outputs, which is composed of event interface and an ECC. The body masters the functionality according to algorithms by sampling data inputs and updating data outputs, which is made up of algorithms and input, output, and internal variables with the initial values. In terms of the BFB type declaration and the instance definition, the formal syntax of BFB can be defined as follows [<bold><xref ref-type="bibr" rid="bibr2-0954406211417931">2</xref></bold>].
<fig id="fig2-0954406211417931" position="float"><label>Fig. 2</label><caption><p>BFB type</p></caption><graphic xlink:href="10.1177_0954406211417931-fig2.tif"/></fig>
<fig id="fig3-0954406211417931" position="float"><label>Fig. 3</label><caption><p>BFB execution model (single event and algorithm)</p></caption><graphic xlink:href="10.1177_0954406211417931-fig3.tif"/></fig></p>
<p>Definition 1 (BFB type): A BFB type, <italic>BType</italic>, is a four-tuple defined as
<disp-formula id="disp-formula1-0954406211417931"><graphic xlink:href="10.1177_0954406211417931-eq1.tif"/></disp-formula>
where <italic>Inf</italic> is a BType interface, <italic>ECC</italic> an EC chart,<italic>L</italic> a set of internal variables, and <italic>Alg</italic> a set of algorithms.</p>
<p>The interface of BFB type involves the event interface and data input/output variables. Besides, a <italic>WITH</italic> function should be introduced to specify an association among input or output variables and an event at the associated event input or output, respectively.</p>
<p>Definition 2 (Interface): An interface <italic>Inf</italic> of <italic>BType</italic> is a six-tuple defined as
<disp-formula id="disp-formula2-0954406211417931"><graphic xlink:href="10.1177_0954406211417931-eq2.tif"/></disp-formula>
where <italic>EI</italic> = {<italic>ei</italic><sub>1</sub>, <italic>e</italic><italic>i</italic><sub>2</sub>, …, <italic>e</italic><italic>i<sub>n</sub></italic>} is a set of event inputs and <italic>n</italic> the number of <italic>EI</italic>; <italic>EO</italic> = {<italic>eo</italic><sub>1</sub>, <italic>eo</italic><sub>2</sub>, …, <italic>eo<sub>m</sub></italic>} a set of event outputs m and is the number of <italic>EO</italic>; <italic>DI</italic> = {<italic>di</italic><sub>1</sub>, <italic>di</italic><sub>2</sub>, … <italic>di<sub>p</sub></italic>} a set of input variables and <italic>p</italic> the number of <italic>DI</italic>, where <italic>di<sub>j</sub></italic> = (<italic>in<sub>j</sub></italic>, <italic>iυ<sub>j</sub></italic>), <italic>j</italic> = 1, ... , <italic>p</italic> in which <italic>in<sub>j</sub></italic> and <italic>iυ<sub>j</sub></italic> are the name and value of the <italic>j</italic>th input variable, respectively, and <italic>iυ<sub>j</sub></italic> has its initial value as <italic>i</italic><italic>υ</italic><sub><italic>j</italic></sub>; <italic>DO</italic> = {<italic>do</italic><sub>1</sub>, <italic>do</italic><sub>2</sub>, ... , <italic>do<sub>q</sub></italic>} a set of output variables and <italic>q</italic> the number of <italic>DO</italic>, where <italic>do<sub>j</sub></italic> = (<italic>on<sub>j</sub></italic>, <italic>oυ<sub>j</sub></italic>), <italic>j</italic> = 1, ... , <italic>q</italic> in which <italic>on<sub>j</sub></italic> and <italic>oυ<sub>j</sub></italic> are the name and value of the <italic>j</italic>th output variable, respectively, and <italic>oυ<sub>j</sub></italic> has its initial value as <italic>oυ</italic><sub><italic>j</italic>o</sub>; <italic>WI</italic> = {<italic>wi</italic><sub>1</sub>, <italic>wi</italic><sub>2</sub>, ... <italic>wi<sub>u</sub></italic>} a set of input <italic>WITH</italic> functions and <italic>u</italic> the number of <italic>WI</italic>, where <italic>wi<sub>j</sub></italic> = <italic>ei<sub>j</sub></italic> × <italic>DI</italic>*, <italic>j</italic> = 1, ... , <italic>u</italic> in which <italic>ei<sub>j</sub></italic> is the <italic>j</italic>th event input and <inline-formula id="ilm1-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math1-0954406211417931"><mml:mrow><mml:mtext>DI</mml:mtext><mml:mo>*</mml:mo><mml:mo>⊆</mml:mo><mml:mi>DI</mml:mi></mml:mrow></mml:math></inline-formula> a set of all possible input variables associated with the <italic>j</italic>th event input; and <italic>WO</italic> = {<italic>wo</italic><sub>1</sub>, <italic>wo</italic><sub>2</sub>, ... , <italic>wo<sub>v</sub></italic>} a set of output <italic>WITH</italic> functions and <italic>υ</italic> the number of <italic>WO</italic>, where <inline-formula id="ilm2-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math2-0954406211417931"><mml:mrow><mml:mi>w</mml:mi><mml:msub><mml:mrow><mml:mi>o</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>o</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mi>DO</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>,</mml:mo><mml:mi>υ</mml:mi></mml:mrow></mml:math></inline-formula> in which <italic>eo<sub>j</sub></italic> is the <italic>j</italic>th event output and <inline-formula id="ilm3-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math3-0954406211417931"><mml:mrow><mml:msup><mml:mrow><mml:mi>DO</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msup><mml:mo>⊆</mml:mo><mml:mi>DO</mml:mi></mml:mrow></mml:math></inline-formula> a set of all possible output variables associated with the <italic>j</italic>th event output.</p>
<p>In addition, the data types of <italic>di<sub>j</sub></italic> and <italic>do<sub>j</sub></italic> aforementioned in the Definition 2 can be any of ARRAY, BOOL, BYTE, COLOR, INT, REAL, STRING, TIME, WORD, MATRIX, etc.</p>
<p>Definition 3 (<italic>WITH</italic> function): A <italic>WITH</italic> function of <italic>BType</italic> is defined as
<disp-formula id="disp-formula3-0954406211417931"><graphic xlink:href="10.1177_0954406211417931-eq3.tif"/></disp-formula>
where <italic>e</italic> is an event input/output, <italic>d</italic> input/output variables, 2<italic><sup>d</sup></italic> a power set of input/output variables, and × is a cross-product denoting a pair relation among elements.</p>
<p>An ECC is used for algorithm EC and is composed of EC states, EC transitions, and EC actions shown in <xref ref-type="fig" rid="fig1-0954406211417931">Fig. 1 (b)</xref>.</p>
<p>Definition 4 (ECC): An <italic>ECC</italic> of <italic>BType</italic> is a three-tuple defined as
<disp-formula id="disp-formula4-0954406211417931"><graphic xlink:href="10.1177_0954406211417931-eq4.tif"/></disp-formula>
where <italic>ES</italic> = {<italic>es</italic><sub>1</sub>, <italic>es</italic><sub>2</sub>, ... ,<italic>es<sub>r</sub></italic>} is a set of EC states and <italic>r</italic> the number of <italic>ES</italic>, where <inline-formula id="ilm4-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math4-0954406211417931"><mml:mrow><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>jk</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, <italic>j</italic> = 1, ... , <italic>r</italic> is the <italic>j</italic>th EC state composed of the state name <italic>s<sub>j</sub></italic> and <italic>k</italic> EC actions in the <italic>j</italic>th state in which each action <italic>ea<sub>ji</sub></italic> ∈ <inline-formula id="ilm5-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math5-0954406211417931"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>Alg</mml:mi><mml:mo>×</mml:mo><mml:mi>EO</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>∪</mml:mo><mml:mi>Alg</mml:mi><mml:mo>∪</mml:mo><mml:mi>EO</mml:mi></mml:mrow></mml:math></inline-formula>, <italic>i</italic> = 1, ... , <italic>k</italic> and <inline-formula id="ilm6-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math6-0954406211417931"><mml:mrow><mml:mi>E</mml:mi><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>⊆</mml:mo><mml:mi>ES</mml:mi></mml:mrow></mml:math></inline-formula> a set of ECC initial state and <italic>ET</italic> = <inline-formula id="ilm7-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math7-0954406211417931"><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math></inline-formula> a set of EC transitions and <italic>l</italic> the number of <italic>ET</italic>, where <italic>et<sub>j</sub></italic> = (<italic>es<sub>j</sub></italic>, <italic>ec<sub>j</sub></italic>, <italic>es'<sub>j</sub></italic>), <italic>j</italic> = 1, ... , <italic>l</italic> in which <italic>es<sub>j</sub></italic> ∈ <italic>ES</italic> and <inline-formula id="ilm9-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math9-0954406211417931"><mml:mrow><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mo>'</mml:mo><mml:msub><mml:mi/><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mi>ES</mml:mi></mml:mrow></mml:math></inline-formula> are the source and destination EC state in the <italic>j</italic>th EC transition, respectively, and <inline-formula id="ilm10-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math10-0954406211417931"><mml:mrow><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mi>EI</mml:mi><mml:mo>∪</mml:mo><mml:mi>G</mml:mi></mml:mrow></mml:math></inline-formula> is the <italic>j</italic>th EC transition condition from the <italic>es<sub>j</sub></italic> to the <inline-formula id="ilm11-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math11-0954406211417931"><mml:mrow><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mo>'</mml:mo><mml:msub><mml:mi/><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, which is composed of <italic>EI</italic> or a set of guard predicates <inline-formula id="ilm12-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math12-0954406211417931"><mml:mrow><mml:mi>G</mml:mi><mml:mo>:</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>DI</mml:mi></mml:mrow></mml:msup><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>DO</mml:mi></mml:mrow></mml:msup><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:msup><mml:mo>→</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mi>true</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula> <italic>false</italic>} which each is a Boolean function on input, output or internal variables.</p>
<p>Owing to the input and output variables defined in Definition 2, the internal variables should be defined as follows.</p>
<p>Definition 5 (Internal variable set): An internal variable set <italic>L</italic> of <italic>BType</italic> is defined as
<disp-formula id="disp-formula5-0954406211417931"><graphic xlink:href="10.1177_0954406211417931-eq5.tif"/></disp-formula>
where <italic>s</italic> is the number of <italic>L</italic>, and each variable <italic>l<sub>j</sub></italic> = <inline-formula id="ilm13-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math13-0954406211417931"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>l</mml:mi><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:msub><mml:mrow><mml:mi>υ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> in which <italic>ln<sub>j</sub></italic> and <italic>lυ<sub>j</sub></italic> are the name and value of the <italic>j</italic>th internal variable, respectively, and <italic>lυ<sub>j</sub></italic> has its initial value as <inline-formula id="ilm14-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math14-0954406211417931"><mml:mrow><mml:mi>l</mml:mi><mml:msub><mml:mrow><mml:mi>υ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mtext>o</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. Similarly, the data type of <italic>l<sub>j</sub></italic> can be one of ARRAY, BOOL, BYTE, COLOR, INT, REAL, STRING, TIME, WORD, MATRIX, etc.</p>
<p>Algorithms deal with the functionality with data variables computation, which can be written in any kind of language defined in IEC 61131-3, Java, C++, etc., executed in the resource and applied to the different control domains.</p>
<p>Definition 6 (Algorithm): An algorithm set <italic>Alg</italic> of <italic>BType</italic> is defined as
<disp-formula id="disp-formula6-0954406211417931"><graphic xlink:href="10.1177_0954406211417931-eq6.tif"/></disp-formula>
where <inline-formula id="ilm15-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math15-0954406211417931"><mml:mrow><mml:mi>a</mml:mi><mml:mi>lg</mml:mi><mml:msub><mml:mi/><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>:</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>DI</mml:mi></mml:mrow></mml:msup><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>DO</mml:mi></mml:mrow></mml:msup><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:msup><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>DO</mml:mi></mml:mrow></mml:msup><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, <italic>j</italic> =1, ..., <italic>t</italic> is the <italic>j</italic>th algorithm function which updates the values of internal and output variables in terms of the values of input, output, and internal variables and <italic>t</italic> the number of <italic>Alg</italic>.</p>
</sec>
<sec id="sec4-0954406211417931"><title>2.2 Basic FB</title>
<p>BFB type defines the various composition elements of a BFB. When applying with BFB to compose more complicated blocks or applications, BFB shall be embedded in a more complicated architecture and it comprises its name and type. The formal definition of BFB is given as follows.</p>
<p>Definition 7 (BFB): A BFB of <italic>BType</italic> is a two-tuple defined as
<disp-formula id="disp-formula7-0954406211417931"><graphic xlink:href="10.1177_0954406211417931-eq7.tif"/></disp-formula>
where <italic>Name</italic> is the name of <italic>BFB</italic> and <italic>BType</italic> the BFB type in aforementioned definitions.</p>
<p>With the formal definition of BFB, more complicated structure of FBs can be constructed by BFB explicitly, i.e. subapplication and CFB, to form the hierarchical heterogeneous architecture of an application. Of course, the relevant contents about BFB are discussed in the article and the others will be studied in future.</p>
</sec>
</sec>
<sec id="sec5-0954406211417931"><title>3. DENOTATIONAL SEMANTICS OF BFB</title>
<p>Syntax of a language can offer composition elements and parameters in a literal, graphic, or formal way, without interpreting how to compose these elements to form an application. Fortunately, semantics of a language can make up the deficiency of syntax and add detailed information about composition, configuration and execution of components.</p>
<sec id="sec6-0954406211417931"><title>3.1 Aim for two kinds of semantics of BFB</title>
<p>Two kinds of semantics are introduced in this article: one is denotational semantics, concerning about applying mathematical objects which present how systems behave with the abstract symbols, expressions, or theorems; the other is execution semantics, focusing on the exact execution path and scheduling mechanism during the execution process. The similarity of the two semantics is the description of behaviours of components or systems. The difference is that denotational semantics provide the formal execution models to specify the behaviours in order to facilitate formal verification about functional and non-functionalrequirements of systems, while the execution semantics use the execution order and a flowchart to specify EC and algorithm computation explicitly in favour of implementation or code generation after the formal verification is approved for system modelling. These two kinds of semantics are necessary for system modelling, design, and development.</p>
<p>Currently, the formal execution models are mainly divided into three ways: one is state-based models, i.e. finite-state machines (FSM) and statechart on states and transitions in the execution process; another is process-based models, i.e. Kahn process network, dataflow, and process calculi (CSP, CCS) which represent computation as a set of concurrent processes; the third one is the mixture of state-based models and process-based models, called heterogeneous models which contain the state transitions and dataflow process [<bold><xref ref-type="bibr" rid="bibr19-0954406211417931">19</xref></bold>].</p>
<p>In BFB, there are state-based models and process-based models simultaneously involved, that is to say, ECC in BFB can be expressed by state-based models and algorithms computation can be summarized by process-based models. Hence, how to combine them into a unified model to describe the denotational semantics of BFB?</p>
</sec>
<sec id="sec7-0954406211417931"><title>3.2 Extended Mealy FSM</title>
<p>Considering the combination of ECC and algorithms simultaneously in BFB, EMFSM is presented as an extended Mealy FSM on guard formulas and action functions associated with the transitions in FSM. Each state in EMFSM is a pair of location and variables, in which the location may represent the label of state and the variables contain input, output, and internal variables. The transitions are triggered by event inputs and evaluated by guard predicates to decide whether they occur. Each transition is enabled if and only if the guard predicate is <italic>true</italic> and when a transition occurs, updating actions of a set of variables that happen simultaneously. The formal definition of EMFSM is given as follows.</p>
<p>Definition 8 (EMFSM): An <italic>EMFSM</italic> is a seven-tuple defined as
<disp-formula id="disp-formula8-0954406211417931"><graphic xlink:href="10.1177_0954406211417931-eq8.tif"/></disp-formula>
where <italic>Q</italic> × <italic>V</italic> is a finite set of extended states, <italic>Q</italic> a set of location, and <inline-formula id="ilm16-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math16-0954406211417931"><mml:mrow><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>×</mml:mo><mml:mo>·</mml:mo><mml:mo>·</mml:mo><mml:mo>·</mml:mo><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> an <italic>n</italic>-tuple set of variables including input, output, and internal variables; <italic>Σ</italic> a non-empty finite set of event inputs; <italic>Γ</italic> a finite set of event outputs including the empty set ∅; <inline-formula id="ilm18-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math18-0954406211417931"><mml:mrow><mml:mi>G</mml:mi><mml:mo>:</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:msup><mml:mo>→</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math></inline-formula> a set of guard predicates over <italic>V</italic>; <inline-formula id="ilm19-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math19-0954406211417931"><mml:mrow><mml:mi>A</mml:mi><mml:mo>=</mml:mo><mml:mi>Φ</mml:mi><mml:mo>∪</mml:mo><mml:mi>ψ</mml:mi><mml:mo>:</mml:mo><mml:mi>Q</mml:mi><mml:mo>×</mml:mo><mml:mi>V</mml:mi><mml:mo>×</mml:mo><mml:mi>Σ</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:msup><mml:mo>×</mml:mo><mml:mi>Γ</mml:mi></mml:mrow></mml:math></inline-formula> a finite set of action functions composed of a finite set of event output function <inline-formula id="ilm20-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math20-0954406211417931"><mml:mrow><mml:mi>Φ</mml:mi><mml:mo>:</mml:mo><mml:mi>Q</mml:mi><mml:mo>×</mml:mo><mml:mi>Σ</mml:mi><mml:mo>→</mml:mo><mml:mi>Γ</mml:mi></mml:mrow></mml:math></inline-formula> and a set of variables updating function <inline-formula id="ilm21-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math21-0954406211417931"><mml:mrow><mml:mi>Ψ</mml:mi><mml:mo>:</mml:mo><mml:mi>Q</mml:mi><mml:mo>×</mml:mo><mml:mi>V</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>; <inline-formula id="ilm22-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math22-0954406211417931"><mml:mrow><mml:mi>δ</mml:mi><mml:mo>⊆</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>×</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:mi>Σ</mml:mi><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> <italic>Γ</italic> × <italic>G</italic> × <italic>A</italic> × (<italic>Q</italic> × <italic>V</italic>) a state-transition relation; and (<italic>q</italic><sub>0</sub>, <italic>υ</italic><sub>0</sub>) is the initial state, where <inline-formula id="ilm23-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math23-0954406211417931"><mml:mrow><mml:msub><mml:mrow><mml:mi>υ</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msubsup><mml:mrow><mml:mi>υ</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn> </mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>υ</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn> </mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup><mml:mo>)</mml:mo></mml:mrow><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula> is the initial values of variables and <italic>q</italic><sub>0</sub> the initial location.</p>
<p>Obviously, the definitions of <italic>G</italic> and <italic>A</italic> are dependent on <italic>V</italic>. The guards <italic>G</italic> are predicates over the variables to either 1 (<italic>true</italic>) or 0 (<italic>false</italic>). Action function <italic>a</italic> ∈ <italic>A</italic> is composed of the variables updating function and the output function. The variables updating function <italic>ψ</italic> ∈ <italic>Ψ</italic> computes the values of variable in the current state, written as <inline-formula id="ilm24-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math24-0954406211417931"><mml:mrow><mml:mi>ψ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>υ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>ψ</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>υ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>ψ</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>υ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Theoutput function <italic>φ</italic> ∈ <italic>Φ</italic> exports the event outputsaccording to the state and event inputs, written as <inline-formula id="ilm25-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math25-0954406211417931"><mml:mrow><mml:mi>ψ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>σ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>γ</mml:mi></mml:mrow></mml:math></inline-formula>. There is an implicit action written as <italic>Ξ</italic> which updates variables to the current value. If <italic>Ψ<sub>k</sub></italic> = <italic>Ξ</italic>, it means that <italic>a<sup>k</sup></italic> is a do not care updating action of the variable <italic>υ<sup>k</sup></italic>. In addition, if no event output is generated, written as <italic>φ</italic>(<italic>p</italic>,<italic>σ</italic>) = <italic>ɛ</italic>, the EMFSM is known as a transition system.</p>
<p>The transition relation is usually written as (<italic>q, u</italic>) = ((<italic>p,υ</italic>), <italic>σ</italic>,<italic>γ</italic>, <italic>g, a</italic>), where (<italic>p, υ</italic>), (<italic>q, u</italic>) ∈ <italic>Q</italic> × <italic>V</italic>, <italic>g</italic> ∈ <italic>G</italic>, <italic>a</italic> ∈ <italic>A</italic>. If <italic>g</italic> is absent, it means that <italic>g</italic> always evaluates to <italic>true</italic> and the transition can happen when <italic>σ</italic> occurs. If <italic>a</italic> is absent, it means that no variable is updated and no event output is issued during the transition.</p>
</sec>
<sec id="sec8-0954406211417931"><title>3.3 Explicit transition relation</title>
<p>Owing to the effect of <italic>g</italic> and <italic>σ</italic>, the transition relation may possibly be not unique which results in the non-deterministic EMFSM. To overcome the ambiguity, an explicit transition relation can be defined as follows.</p>
<p>Definition 9 (Explicit transition relation): Let<inline-formula id="ilm26-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math26-0954406211417931"><mml:mrow><mml:mi>EMFSM</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>×</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>Σ</mml:mi><mml:mo>,</mml:mo><mml:mi>Γ</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>δ</mml:mi><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>υ</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be an EMFSM. The explicit transition relation of <italic>EMFSM</italic> is defined as</p>
<disp-formula id="disp-formula9-0954406211417931"><graphic xlink:href="10.1177_0954406211417931-eq9.tif"/></disp-formula>
<p>The explicit transition relation <italic>δ<sub>d</sub></italic> satisfies the following two properties:</p>
<list list-type="alpha-lower">
<list-item><p>reflexive
<disp-formula id="disp-formula10-0954406211417931"><graphic xlink:href="10.1177_0954406211417931-eq10.tif"/></disp-formula>
where <italic>ε</italic> is an empty event input;</p></list-item>
<list-item><p>transitive:
<disp-formula id="disp-formula11-0954406211417931"><graphic xlink:href="10.1177_0954406211417931-eq11.tif"/></disp-formula>
</p></list-item>
</list>
</sec>
<sec id="sec9-0954406211417931"><title>3.4 Deterministic EMFSM and verification</title>
<p>To achieve the further unambiguous execution semantics and deterministic behaviours of BFB, EMFSM uses the explicit transition relation satisfying the reflexive and transitive properties. Besides, the strong condition of explicit transition relation is needed to ensure that the synchronized product of two deterministic EMFSMs is also deterministic. With the well-defined explicit transition relation, the definition of deterministic EMFSM can be obtained as follows.</p>
<p>Definition 10 (Deterministic EMFSM): An <inline-formula id="ilm27-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math27-0954406211417931"><mml:mrow><mml:mi>EMFSM</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>×</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>Σ</mml:mi><mml:mo>,</mml:mo><mml:mi>Γ</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>υ</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is deterministic if <inline-formula id="ilm28-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math28-0954406211417931"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>υ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>σ</mml:mi><mml:mo>,</mml:mo><mml:mtext>γ</mml:mtext><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and (<italic>q</italic>', <italic>u</italic>') = <inline-formula id="ilm29-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math29-0954406211417931"><mml:mrow><mml:msub><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>υ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>σ</mml:mi><mml:mo>,</mml:mo><mml:mi>γ</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> imply (<italic>q, u</italic>)=(<italic>q', u</italic>').</p>
<p>For the formal verification of BFB behaviours, deterministic EMFSM can be transformed into two ordinary MFSMs: one is the location MFSM which has the same structure as the EMFSM; the other is the variable MFSM which models the updating of the variables. The two MFSMs share the relabelled event set and can be used with the temporal logic in model checker tool (e.g. SPIN, etc.) for the formal verification.</p>
</sec>
</sec>
<sec id="sec10-0954406211417931"><title>4 EXECUTION SEMANTICS OF BFB</title>
<p>The denotational semantics provide a model of computation with the EMFSM to facilitate the formal verification of BFB behaviours, while one requires the execution semantics to obtain an implementation or generate code automatically. In this section, execution semantics are proposed to define how and when the various elements of BFB will produce the behaviours and offer a set of guidelines for the execution rule of BFB [<bold><xref ref-type="bibr" rid="bibr14-0954406211417931">14</xref></bold>, <bold><xref ref-type="bibr" rid="bibr20-0954406211417931">20</xref></bold>].</p>
<sec id="sec11-0954406211417931"><title>4.1 BFB execution model with single event and algorithm</title>
<p>IEC 61499 offers an execution order of BFB with a single event and algorithm as t<sub>1</sub>–t<sub>8</sub> shown in <xref ref-type="fig" rid="fig3-0954406211417931">Fig. 3</xref> [<bold><xref ref-type="bibr" rid="bibr2-0954406211417931">2</xref></bold>]. At first, the data inputs are ready (t<sub>1</sub>), and then the event input triggers the evaluation of ECC (t<sub>2</sub>). If an algorithm is to be executed, the underlying scheduling function is notified (t<sub>3</sub>) and when there is time, it is granted execution time (t<sub>4</sub>). After the algorithm finishes its execution (t<sub>5</sub>–t<sub>6</sub>), ECC is notified (t<sub>7</sub>) and appropriate event outputs may be issued (t<sub>8</sub>). However, when multiple events or algorithms are involved in BFB, the execution model t<sub>1</sub>–t<sub>8</sub> is not adequate and a more complicated execution model is needed as the execution semantics of BFB [<bold><xref ref-type="bibr" rid="bibr2-0954406211417931">2</xref></bold>, <bold><xref ref-type="bibr" rid="bibr12-0954406211417931">12</xref></bold>].</p>
</sec>
<sec id="sec12-0954406211417931"><title>4.2 BFB execution model with multiple events and algorithms</title>
<p>If multiple events or algorithms exist in one BFB, event queue ordering and algorithm scheduling should be studied. An example is illustrated with two event inputs <italic>ei</italic><sub>1</sub> at INIT and <italic>ei</italic><sub>2</sub> at EX, two input variables <italic>di</italic><sub>1</sub> at DI1 and <italic>di</italic><sub>2</sub> at DI2, two algorithms <italic>Init_Alg</italic> and <italic>Main_Alg</italic>, two event outputs <italic>eo</italic><sub>1</sub> at INITO and <italic>eo</italic><sub>2</sub> at EXO, and two output variables <italic>do</italic><sub>1</sub> at DO1 and <italic>do</italic><sub>2</sub> at DO2 in <xref ref-type="fig" rid="fig4-0954406211417931">Fig. 4</xref>. In this case, BFB is composed of two parts: an input machine which is constructed to indicate the association of the event input and inputs variables, and the main part which consists of ECC and algorithms for algorithms execution. In the whole process, the resource will provide enough memory for variable storage and computation.
<fig id="fig4-0954406211417931" position="float"><label>Fig. 4</label><caption><p>BFB execution model (multiple events and algorithms)</p></caption><graphic xlink:href="10.1177_0954406211417931-fig4.tif"/></fig></p>
<sec id="sec13-0954406211417931"><title>4.2.1 Input machine of BFB</title>
<p>At first, event input and data input variables are imported as input pairs into the input machine. There are two states and four transitions in the input machine, where each transition occurs with the guard condition and its actions accordingly. The initial state is state <italic>false</italic> and the exact behaviour defined in the input machine is presented in <xref ref-type="table" rid="table1-0954406211417931">Table 1</xref>. To define the guard condition, the characteristic function <inline-formula id="ilm30-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math30-0954406211417931"><mml:mrow><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:mi>with</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>ei</mml:mi><mml:mo>,</mml:mo><mml:mi>di</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of a set of input pairs is given.
<table-wrap id="table1-0954406211417931" position="float"><label>Table 1</label><caption><p>States and transitions of input machine</p></caption>
<graphic alternate-form-of="table1-0954406211417931" xlink:href="10.1177_0954406211417931-table1.tif"/>
<table frame="hsides"><thead align="left">
<tr><th/>
<th/>
<th align="left">Condition</th>
<th align="left">Action</th></tr></thead>
<tbody align="left">
<tr>
<td>State</td>
<td><italic>False</italic></td>
<td>Event inputs associate with input variables unsuccessfully</td>
<td>—</td></tr>
<tr>
<td/>
<td><italic>True</italic></td>
<td>Event inputs associate with input variables successfully</td>
<td>—</td></tr>
<tr>
<td>Transition</td>
<td><italic>c</italic><sub>0</sub>/<italic>ε</italic></td>
<td><italic>c</italic><sub>0</sub>: event inputs or input variables are sent into BFB</td>
<td>None</td></tr>
<tr>
<td/>
<td><italic>c</italic><sub>1</sub>/<italic>a</italic><sub>1</sub></td>
<td><inline-formula id="ilm31-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math31-0954406211417931"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:mi>with</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>ei</mml:mi><mml:mo>,</mml:mo><mml:mi>di</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula></td>
<td><italic>a</italic><sub>1</sub>: <italic>WITH(ei,di)</italic> is sent into BFB</td></tr>
<tr>
<td/>
<td><italic>c</italic><sub>2</sub>/<italic>a</italic><sub>2</sub></td>
<td><inline-formula id="ilm32-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math32-0954406211417931"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:mi>with</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>ei</mml:mi><mml:mo>,</mml:mo><mml:mi>di</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula></td>
<td><italic>a</italic><sub>2</sub>: waiting for the former <italic>WITH(ei,di)</italic> execution in the main part completed</td></tr>
<tr>
<td/>
<td><italic>c</italic><sub>3</sub>/<italic>ε</italic></td>
<td><italic>c</italic><sub>3</sub>: event inputs or input variables are sent into BFB</td>
<td>none</td></tr>
</tbody>
</table>
</table-wrap>
<disp-formula id="disp-formula12-0954406211417931"><graphic xlink:href="10.1177_0954406211417931-eq12.tif"/></disp-formula>
where <italic>WITH(ei,di)</italic> is the input <italic>WITH</italic> function defined in Definition 3. For instance, there are four input pairs of event inputs and data input variables in <xref ref-type="fig" rid="fig4-0954406211417931">Fig. 4</xref>, such as (<italic>ei</italic><sub>1</sub>, <italic>di</italic><sub>1</sub>), (<italic>ei</italic><sub>1</sub>, <italic>di</italic><sub>2</sub>), (<italic>ei</italic><sub>2</sub>, <italic>di</italic><sub>1</sub>), and (<italic>ei</italic><sub>2</sub>, <italic>di</italic><sub>2</sub>), while <italic>WITH(ei,di)</italic> are just the input pairs (<italic>ei</italic><sub>1</sub>, <italic>di</italic><sub>1</sub>) and (<italic>ei</italic><sub>2</sub>, <italic>di</italic><sub>2</sub>).</p>
<p>From <xref ref-type="table" rid="table1-0954406211417931">Table 1</xref>, when the transition <italic>c</italic><sub>1</sub>/<italic>a</italic><sub>1</sub> from state <italic>false</italic> to <italic>true</italic> occurs, the input machine will issue <italic>WITH(ei,di)</italic> to the main part of BFB. If the execution of the former <italic>WITH(ei,di)</italic> in the main part has not been completed, the transition <italic>c</italic><sub>2</sub>/<italic>a</italic><sub>2</sub> does not occur and the state of the input machine is still in state <italic>true</italic> even if another new input pair is ready in the input machine. Hence, the input machine takes care of the event queue ordering and association with input variables to ensure which transition will occur in the main part of BFB later when multiple event inputs occur at the same time. With the input machine, the loss of event inputs will disappear. For each execution of the input machine, the output from it is the <italic>WITH(ei,di)</italic> to be sent into the main part for the EC and algorithm computation.</p>
</sec>
<sec id="sec14-0954406211417931"><title>4.2.2 Main part of BFB</title>
<p>In the main part, the execution of algorithms is invoked by the EC part of BFB in response to the output from the input machine of BFB. The invocation sends a request to scheduling function of the associated resource to schedule the execution of an algorithm. Upon completion of the algorithm, the EC generates zero or more event outputs as appropriate. The order of events and algorithm execution for the case in which two events and two algorithms is depicted in <xref ref-type="fig" rid="fig4-0954406211417931">Fig. 4</xref>. The relevant times are defined as follows [<bold><xref ref-type="bibr" rid="bibr2-0954406211417931">2</xref></bold>, <bold><xref ref-type="bibr" rid="bibr14-0954406211417931">14</xref></bold>].</p>
<list list-type="simple">
<list-item><p>t<sub>1</sub> the values of input variables <italic>di</italic><sub>1</sub> and <italic>di</italic><sub>2</sub> are made available</p></list-item>
<list-item><p>t<sub>2</sub> the event input <italic>ei</italic><sub>1</sub> and <italic>ei</italic><sub>2</sub> is sent to BFB</p></list-item>
<list-item><p>t<sub>3</sub> the input pair <inline-formula id="ilm33-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math33-0954406211417931"><mml:mrow><mml:mi>WITH</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> from the input machine enters the main part of BFB. The <italic>ei</italic><sub>1</sub> is sent to ECC for EC, and the corresponding <italic>di</italic><sub>1</sub> are sent into algorithm for computation at the same time</p></list-item>
<list-item><p>t<sub>4</sub> with the <italic>ei</italic><sub>1</sub> arrival, the transition from state <italic>Idle</italic> to <italic>Init</italic> occurs</p></list-item>
<list-item><p>t<sub>5</sub> in state <italic>Init</italic>, ECC calls resource scheduling function to schedule algorithm <italic>Init_Alg</italic></p></list-item>
<list-item><p>t<sub>6</sub> algorithm <italic>Init_Alg</italic> execution begins</p></list-item>
<list-item><p>t<sub>7</sub> algorithm <italic>Init_Alg</italic> completes establishment of values for <italic>do</italic><sub>1</sub> at DO1 associated with the <italic>eo</italic><sub>1</sub> by the <italic>WITH</italic> qualifier</p></list-item>
<list-item><p>t<sub>8</sub> the resource scheduling function is notified that algorithm <italic>Init_Alg</italic> execution has ended</p></list-item>
<list-item><p>t<sub>9</sub> the scheduling function invokes ECC</p></list-item>
<list-item><p>t<sub>10</sub> ECC issues an event output variable <italic>eo</italic><sub>1</sub> at INITO</p></list-item>
<list-item><p>t<sub>11</sub> transition from state <italic>Init</italic> to <italic>Idle</italic> occurs</p></list-item>
<list-item><p>t<sub>12</sub> the input pair <italic>WITH(ei</italic><sub>2</sub>,<italic>di</italic><sub>2</sub>) from the input machine enters the main part. The <italic>ei</italic><sub>2</sub> is sent into ECC, and the corresponding <italic>di</italic><sub>2</sub> is sent into algorithm at the same time.</p></list-item>
<list-item><p>t<sub>13</sub> with the <italic>ei</italic><sub>2</sub> arrival, the transition from state <italic>Idle</italic> to <italic>Main</italic> occurs</p></list-item>
<list-item><p>t<sub>14</sub> in state <italic>Main</italic>, ECC calls resource scheduling function to schedule algorithm <italic>Main_Alg</italic></p></list-item>
<list-item><p>t<sub>15</sub> algorithm <italic>Main_Alg</italic> execution begins</p></list-item>
<list-item><p>t<sub>16</sub> algorithm <italic>Main_Alg</italic> completes establishment of values for <italic>do</italic><sub>2</sub> at DO2 associated with the <italic>eo</italic><sub>2</sub> by the <italic>WITH</italic> qualifier</p></list-item>
<list-item><p>t<sub>17</sub> resource scheduling function is notified that algorithm <italic>Main_Alg</italic> execution has ended</p></list-item>
<list-item><p>t<sub>18</sub> scheduling function invokes ECC</p></list-item>
<list-item><p>t<sub>19</sub> ECC issues an event output <italic>eo</italic><sub>2</sub> at EXO</p></list-item>
<list-item><p>t<sub>20</sub> transition from state <italic>Main</italic> to <italic>Idle</italic> occurs</p></list-item>
</list>
<p>In fact, t<sub>1</sub>–t<sub>20</sub> is the execution semantics of BFB and depicts event trigger mechanism, execution order, and algorithm computation in <xref ref-type="fig" rid="fig4-0954406211417931">Fig. 4</xref>. As shown in <xref ref-type="fig" rid="fig5-0954406211417931">Fig. 5</xref>, the significant timing delays in this case, which are of interest in application design, are given as follows [<bold><xref ref-type="bibr" rid="bibr2-0954406211417931">2</xref></bold>].
<fig id="fig5-0954406211417931" position="float"><label>Fig. 5</label><caption><p>BFB execution timing</p></caption><graphic xlink:href="10.1177_0954406211417931-fig5.tif"/></fig></p>
<list list-type="simple">
<list-item><p>T<sub>init_setup</sub>=t<sub>3</sub>–t<sub>1</sub> (time from the input machine for <inline-formula id="ilm34-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math34-0954406211417931"><mml:mrow><mml:mi>WITH</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>)</p></list-item>
<list-item><p>T<sub>init_start</sub> = t<sub>6</sub>–t<sub>3</sub> (time from <italic>ei</italic><sub>1</sub> to beginning of algorithm <italic>Init_alg</italic> execution)</p></list-item>
<list-item><p>T<sub>init_alg</sub> = t<sub>8</sub>–t<sub>6</sub> (algorithm <italic>Init_alg</italic> execution time)</p></list-item>
<list-item><p>T<sub>init_end</sub> = t<sub>11</sub>–t<sub>8</sub> (time from end of algorithm <italic>Init_alg</italic> execution to <italic>eo</italic><sub>1</sub>)</p></list-item>
<list-item><p>T<sub>main_setup</sub> = t<sub>12</sub>–t<sub>11</sub> (time from the input machine for <inline-formula id="ilm35-0954406211417931"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math35-0954406211417931"><mml:mrow><mml:mi>WITH</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>)</p></list-item>
<list-item><p>T<sub>main_start</sub> = t<sub>15</sub>–t<sub>12</sub> (time from <italic>ei</italic><sub>2</sub> to beginning of algorithm <italic>Main_alg</italic> execution)</p></list-item>
<list-item><p>T<sub>main_alg</sub> = t<sub>17</sub>–t<sub>15</sub> (algorithm <italic>Main_alg</italic> execution time)</p></list-item>
<list-item><p>T<sub>main_end</sub> = t<sub>20</sub>–t<sub>17</sub> (time from end of algorithm <italic>Init_alg</italic> execution to <italic>eo</italic><sub>2</sub>)</p></list-item>
</list>
<p>In particular, when an input pair enters the main part, no other input pairs will be sent into the main part until the former input pair completes its execution and ECC returns to state <italic>Idle</italic>, simplified as ‘no input-arrival once execution’. Each event input can only be used at most once and will be cleared if unused. If no transition occurs and no input pair is sent into the main part, the execution of BFB will be finished.</p>
<p>Although the example in <xref ref-type="fig" rid="fig4-0954406211417931">Fig. 4</xref> is about two events and algorithms, it still offers a method of execution semantics for more complicated BFB.</p>
</sec>
<sec id="sec15-0954406211417931"><title>4.2.3 A flowchart of BFB behaviours</title>
<p>A flowchart of BFB behaviours which gives an overview of the processing steps that occur during the execution of a BFB in detail is shown in <xref ref-type="fig" rid="fig6-0954406211417931">Fig. 6</xref>. It can offer a guideline for implementation or code generation [<bold><xref ref-type="bibr" rid="bibr14-0954406211417931">14</xref></bold>].
<fig id="fig6-0954406211417931" position="float"><label>Fig. 6</label><caption><p>A flowchart of BFB behaviours</p></caption><graphic xlink:href="10.1177_0954406211417931-fig6.tif"/></fig></p>
</sec>
</sec>
</sec>
<sec id="sec16-0954406211417931"><title>5 CONCLUSIONS</title>
<p>IEC 61499 as a modelling language for distributed IPMCS offers literal syntax and ambiguous semantics for FBs. As the basic modelling element, the literal syntax and bit semantics of BFB are specified in the standard, while not enough, e.g. event input clearance rule, the order of transition evaluation and the time for event output issued, etc. Hence, some assumptions and postulates about BFB semantics are involved in the semantics of BFB. However, they are specified in a literal or graphic language and lack a formal specification language to obtain the precise, formal, and mathematical definitions useful for the formal verification, implementation, and code generation automatically. With this aim, the formal syntax and explicit semantics of BFB are advanced, which are helpful to attain reliability and validity of systems, in this article.</p>
<p>Formal syntax of BFB is used by mathematical set theory to define a variety of elements of BFB, which facilitate composing and modelling the bigger granular FBs such as CFB, subapplication, and application. Meanwhile, the semantics of BFB are described in two ways: one is denotational semantics interpreting the meaning of language with mathematical objects in a formal way and the other execution semantics specifying how and when the various elements of a BFB to produce behaviours in the execution process. In denotational semantics, anEMFSM is advanced to involve state-based and process-based models simultaneously to express the state transitions and algorithm scheduling for formal verification about functional and non-functional properties. In the execution semantics, an input machine and main part of BFB are constructed to specify the execution order of BFB, in which the input machine charges with the association of events and input variables and the main part masters the EC and algorithm computation. A case of two events and algorithms is illustrated to describe the execution order as t<sub>1</sub>–t<sub>20</sub> and a flowchart of BFB behaviours is also given in detail. With the execution semantics, implementation or code generation after the formal verification can be made for system design.</p>
<p>Future works may focus on two aspects: one is the decomposition algorithm of EMFSM into two ordinary MFSMs to complete the formal verification of BFB behaviours and the other to provide the execution semantics for the bigger granular FBs in order to obtain the explicit semantics of systems and facilitate the possible implementation finally.</p>
</sec>
</body>
<back>
<sec id="sec17-0954406211417931"><title>FUNDING</title>
<p>This study was supported by Chinese NSFC (grant nos. 50875090 and 50905063) and 863 Plan of China (grant no. 2009AA04Z111).</p>
</sec>
<ref-list>
<title>REFERENCES</title>
<ref id="bibr1-0954406211417931"><label>1</label><citation citation-type="other"><comment>IEC. International standard IEC 61131-3: programming controllers, edition 2, Geneva, 2003</comment></citation></ref>
<ref id="bibr2-0954406211417931"><label>2</label><citation citation-type="other"><comment>IEC. International standard IEC 61499-1 function blocks-Part 1: architecture, edition 1, Geneva, 2005</comment></citation></ref>
<ref id="bibr3-0954406211417931"><label>3</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Gerber</surname><given-names>C. h.</given-names></name><name><surname>Hanisch</surname><given-names>H.-M.</given-names></name><name><surname>Ebbinghaus</surname><given-names>S.</given-names></name></person-group> <article-title>From IEC 61131 to IEC 61499 for distributed systems: A case study</article-title>. <source>EURASIP J. Embedded Syst.</source>, <year>2008</year>, <volume>Vol. 2008</volume>, <fpage>1</fpage>–<lpage>8</lpage>.</citation></ref>
<ref id="bibr4-0954406211417931"><label>4</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Vyatkin</surname><given-names>V.</given-names></name></person-group> <article-title>The IEC 61499 standard and its semantics</article-title>. <source>IEEE Ind. Electron. Mag.</source>, <year>2009</year>, <volume>4</volume>(<issue>3</issue>), <fpage>40</fpage>–<lpage>48</lpage>.</citation></ref>
<ref id="bibr5-0954406211417931"><label>5</label><citation citation-type="other"><comment>Vyatkin, V. Execution semantic of function blocks based on the model of net condition/event systems. In <italic>Proceedings of 4th IEEE International Conference on Industrial Informatics</italic>, Singapore, 16–18 August 2006, pp. 874–879</comment></citation></ref>
<ref id="bibr6-0954406211417931"><label>6</label><citation citation-type="book"><person-group person-group-type="author"><name><surname>Thramboulidis</surname><given-names>K.</given-names></name><name><surname>Doukas</surname><given-names>G.</given-names></name></person-group> <article-title>IEC 61499 execution model semantics</article-title>. In <source>Innovative Algorithms and Techniques in Automation, Industrial Electronics and Telecommunications</source> (Eds <person-group person-group-type="editor"><name><surname>Sobh</surname><given-names>T.</given-names></name><name><surname>Elleithy</surname><given-names>K.</given-names></name><name><surname>Mahmood</surname><given-names>A.</given-names></name><name><surname>Karim</surname><given-names>M.</given-names></name></person-group>), <year>2007</year>, pp. <fpage>223</fpage>–<lpage>228</lpage> (<publisher-name>Springer, Dordrecht</publisher-name>, <publisher-loc>the Netherlands</publisher-loc>).</citation></ref>
<ref id="bibr7-0954406211417931"><label>7</label><citation citation-type="other"><comment>Vyatkin, V., Dubinin, V., Veber, C., and Ferrarini, L. Alternatives for execution semantics of IEC 61499. In <italic>IEEE International Conference on Industrial Information (INDIN'2007)</italic>, Vienna, Austria, 24–26 July 2007, pp. 1151–1156</comment></citation></ref>
<ref id="bibr8-0954406211417931"><label>8</label><citation citation-type="other"><comment>Sünder, C., Zoitl, A., Christensen, H., Colla, M., and Strasser, T. Execution models for the IEC 61499 elements composite function block and subapplication. In <italic>IEEE International Conference on Industrial Information (INDIN'2007)</italic>, Vienna, Austria, 24–26 July 2007, pp. 1169–1175</comment></citation></ref>
<ref id="bibr9-0954406211417931"><label>9</label><citation citation-type="book"><person-group person-group-type="author"><name><surname>Vyatkin</surname><given-names>V.</given-names></name></person-group> <source>IEC 61499 function blocks for embedded and distributed control systems design</source>, <year>2007</year>, (<publisher-name>ISA</publisher-name>, <publisher-loc>North Carolina</publisher-loc>).</citation></ref>
<ref id="bibr10-0954406211417931"><label>10</label><citation citation-type="book"><person-group person-group-type="author"><name><surname>Dubinin</surname><given-names>V.</given-names></name><name><surname>Vyatkin</surname><given-names>V.</given-names></name></person-group> <article-title>On definition of a formal model for IEC 61499 function blocks</article-title>. <source>EURASIP J. Embedded Syst.</source>, <year>2008</year>, <volume>Vol. 2008</volume>, <fpage>1</fpage>–<lpage>10</lpage>.</citation></ref>
<ref id="bibr11-0954406211417931"><label>11</label><citation citation-type="other"><comment>Dubinin, V., Vyatkin, V., and Hanisch, H.-M. Modeling and verification of IEC 61499 applications using Prolog. In <italic>Proceedings of the 11th IEEE International Conference on Emerging Technologies and Factory Automation</italic>, Prague, 20–22 September 2006, pp. 774–781</comment></citation></ref>
<ref id="bibr12-0954406211417931"><label>12</label><citation citation-type="other"><comment>Sünder, C., Zoitl, A., Christensen, J. H., Vyatkin, V., Brennan, R. W., Valentini, A., Ferrarini, L., Strasser, T., Martinez-Lastra, J. L., and Auinger, F. Usability and interoperability of IEC 61499 based distributed automation systems. In <italic>Proceedings of the 4th IEEE International Conference on Industrial Informatics</italic>, Singapore, 16–18 August 2006, pp. 31–37</comment></citation></ref>
<ref id="bibr13-0954406211417931"><label>13</label><citation citation-type="other"><comment>Sünder, C., Zoitl, A., Rofner, H., Strasser, T., and Brunnenkreef, J. Benchmarking of IEC 61499 runtime environments. In <italic>Proceedings of the 12th IEEE International Conference on Emerging Technologies and Factory Automation</italic>, Patras, Greece, 25–28 September 2007, pp. 25–28</comment></citation></ref>
<ref id="bibr14-0954406211417931"><label>14</label><citation citation-type="book"><person-group person-group-type="author"><name><surname>Zoitl</surname><given-names>A.</given-names></name></person-group> <source>Real-time execution for IEC 61499</source>, <year>2008</year>, (<publisher-name>ISA</publisher-name>, <publisher-loc>North Carolina</publisher-loc>).</citation></ref>
<ref id="bibr15-0954406211417931"><label>15</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Hall</surname><given-names>A.</given-names></name></person-group> <article-title>Using formal methods to develop an ATC information system</article-title>. <source>IEEE Softw.</source>, <year>1996</year>, <volume>13</volume>(<issue>2</issue>), <fpage>66</fpage>–<lpage>76</lpage>.</citation></ref>
<ref id="bibr16-0954406211417931"><label>16</label><citation citation-type="other"><comment>Dehbonei, B. and Mejia, F. Formal development of safety-critical software systems in railway signaling. In <italic>Applications of formal methods</italic> (Eds M. Hinchey and J. P. Bowen), 1995, ch. 10 (Prentice-Hall, London)</comment></citation></ref>
<ref id="bibr17-0954406211417931"><label>17</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Easterbrook</surname><given-names>S.</given-names></name><name><surname>Lutz</surname><given-names>R.</given-names></name><name><surname>Covington</surname><given-names>R.</given-names></name><name><surname>Kelly</surname><given-names>J.</given-names></name><name><surname>Ampo</surname><given-names>Y.</given-names></name><name><surname>Hamilton</surname><given-names>D.</given-names></name><name><surname>IV&amp;V Fac</surname></name><name><surname>Fairmont</surname><given-names>W. V.</given-names></name></person-group> <article-title>Experience using lightweight formal methods for requirements modeling</article-title>. <source>IEEE Trans. Softw. Eng.</source>, <year>1998</year>, <volume>24</volume>(<issue>1</issue>), <fpage>4</fpage>–<lpage>14</lpage>.</citation></ref>
<ref id="bibr18-0954406211417931"><label>18</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Hierons</surname><given-names>R. M.</given-names></name><name><surname>Bogdanov</surname><given-names>K.</given-names></name><name><surname>Bowen</surname><given-names>J. P.</given-names></name><name><surname>Cleaveland</surname><given-names>R.</given-names></name><name><surname>Derrick</surname><given-names>J.</given-names></name><name><surname>Dick</surname><given-names>J.</given-names></name><name><surname>Gheorghe</surname><given-names>M.</given-names></name><name><surname>Harman</surname><given-names>M.</given-names></name><name><surname>Kapoor</surname><given-names>K.</given-names></name><name><surname>Krause</surname><given-names>P.</given-names></name><name><surname>Lüttgen</surname><given-names>G.</given-names></name><name><surname>Simons</surname><given-names>A. J. H.</given-names></name><name><surname>Vilkomir</surname><given-names>S.</given-names></name><name><surname>Woodward</surname><given-names>M. R.</given-names></name><name><surname>Zedan</surname><given-names>H.</given-names></name></person-group> <article-title>Using formal Specifications to support testing</article-title>. <source>ACM Comput. Surv.</source>, <year>2009</year>, <volume>41</volume>(<issue>2</issue>), <fpage>1</fpage>–<lpage>76</lpage>.</citation></ref>
<ref id="bibr19-0954406211417931"><label>19</label><citation citation-type="other"><comment>Yuqing, T., Di, L., and Fang, L. A formal framework for component-based embedded systems. In <italic>Proceedings of 2010 IEEE/ASME International Conference on Advanced Intelligent Mechatronics</italic>, Montreal, Canada, 6–9 July 2010</comment></citation></ref>
<ref id="bibr20-0954406211417931"><label>20</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Cengic</surname><given-names>G.</given-names></name><name><surname>Akesson</surname><given-names>K.</given-names></name></person-group> <article-title>On formal analysis of IEC 61499 applications, Part B: Execution semantics</article-title>. <source>IEEE Trans. Ind. Inf.</source>, <year>2010</year>, <volume>6</volume>(<issue>2</issue>), <fpage>145</fpage>–<lpage>154</lpage>.</citation></ref>
</ref-list>
<ref-list>
<title>BIBLIOGRAPHY</title>
<ref id="bibr21-0954406211417931"><citation citation-type="other"><comment>Cengic, G. and Akesson, K. Definition of the execution model used in the Fuber IEC 61499 runtime environment. In <italic>Proceedings of the 6th IEEE International Conference on Industrial Informatics</italic>, Daejeon, Korea, 13–16 July 2008, pp. 301–306</comment></citation></ref>
<ref id="bibr22-0954406211417931"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Cengic</surname><given-names>G.</given-names></name><name><surname>Akesson</surname><given-names>K.</given-names></name></person-group> <article-title>On formal analysis of IEC 61499 applications, Part A: Modeling</article-title>. <source>IEEE Trans. Ind. Inf.</source>, <year>2010</year>, <volume>6</volume>(<issue>2</issue>), <fpage>136</fpage><lpage>144</lpage>.</citation></ref>
<ref id="bibr23-0954406211417931"><citation citation-type="other"><comment>Cengic, G., Ljungkrantz, O., and Akesson, K. Formal modeling of function block applications running in IEC 61499 execution runtime. In <italic>Proceedings of the 11th IEEE International Conference on Emerging Technologies and Factory Automation</italic>, Prague, 20–22 September 2006, pp. 612–7</comment></citation></ref>
<ref id="bibr24-0954406211417931"><citation citation-type="web"><person-group person-group-type="author"><name><surname>Christensen</surname><given-names>J. H.</given-names></name></person-group> <article-title>Function block development kit</article-title>. <source>FBDK</source>, <comment>available from <ext-link ext-link-type="uri" xlink:href="http://www.Holobloc.com">http://www.Holobloc.com</ext-link></comment>.</citation></ref>
<ref id="bibr25-0954406211417931"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Chryssolouris</surname><given-names>G.</given-names></name></person-group> <article-title>Sensors in laser machining</article-title>. <source>CIRP Ann.</source>, <year>1994</year>, <volume>43</volume>(<issue>2</issue>), <fpage>513</fpage><lpage>519</lpage>.</citation></ref>
<ref id="bibr26-0954406211417931"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Chryssolouris</surname><given-names>G.</given-names></name><name><surname>Domroese</surname><given-names>M.</given-names></name><name><surname>Beaulieu</surname><given-names>P.</given-names></name></person-group> <article-title>Sensor synthesis for control of manufacturing processes</article-title>. <source>J. Eng. Ind., ASME.</source>, <year>1992</year>, <volume>114</volume>, <fpage>158</fpage><lpage>174</lpage>.</citation></ref>
<ref id="bibr27-0954406211417931"><citation citation-type="other"><comment>Hirsch, M., Gerber, Ch., Vyatkin, V., and Hanisch, H.-M. Design and implementation of heterogeneous distributed controllers according to the IEC 61499 standard - a case study. In <italic>IEEE International Conference on Industrial Informatics (INDIN´2007)</italic>, Vienna, Austria, 24–26 July 2007, pp. 829–834</comment></citation></ref>
<ref id="bibr28-0954406211417931"><citation citation-type="other"><comment>Ivanova-Vasileva, I., Gerber, Ch., and Hanisch, H.-M. Transformation of IEC 61499 control systems to formal models. In <italic>International Conference on Automatics and Informatics (CAI´07)</italic>, Sofia, Bulgaria, 3–6 October 2007, pp. V-5-V-10</comment></citation></ref>
<ref id="bibr29-0954406211417931"><citation citation-type="other"><comment>Missal, D., Hirsch, M., and Hanisch, H.-M. Hierarchical distributed controllers-design and verification. In <italic>IEEE International Conference on Emerging Technologies and Factory Automation (ETFA'2007)</italic>, Patras, Greece, 25–28 September 2007, pp. 657–664</comment></citation></ref>
</ref-list>
</back>
</article>