<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD Journal Publishing DTD v2.3 20070202//EN" "journalpublishing.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">PIC</journal-id>
<journal-id journal-id-type="hwp">sppic</journal-id>
<journal-title>Proceedings of the Institution of Mechanical Engineers, Part C: Journal of Mechanical Engineering Science</journal-title>
<issn pub-type="ppub">0954-4062</issn>
<issn pub-type="epub">2041-2983</issn>
<publisher>
<publisher-name>SAGE Publications</publisher-name>
<publisher-loc>Sage UK: London, England</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1177/0954406211425440</article-id>
<article-id pub-id-type="publisher-id">10.1177_0954406211425440</article-id>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Mechanisms and Machines</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>A unified formula of fault-tolerant algorithms considering joint velocity jump for redundant robots</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<name><surname>Zhao</surname><given-names>J</given-names></name>
</contrib>
<contrib contrib-type="author" corresp="yes">
<name><surname>Xie</surname><given-names>B</given-names></name>
<xref ref-type="corresp" rid="corresp1-0954406211425440">*</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Liu</surname><given-names>Y</given-names></name>
</contrib>
</contrib-group>
<aff id="aff1-0954406211425440">The College of Mechanical Engineering &amp; Applied Electronics Technology, Beijing University of Technology, Beijing, People’s Republic of China</aff>
<author-notes>
<corresp id="corresp1-0954406211425440"><label>*</label>The College of Mechanical Engineering &amp; Applied Electronics Technology, Beijing University of Technology, Beijing 100124, People’s Republic of China. email: <email>xiebiyunyun@gmail.com</email></corresp>
</author-notes>
<pub-date pub-type="epub-ppub">
<month>6</month>
<year>2012</year>
</pub-date>
<volume>226</volume>
<issue>6</issue>
<fpage>1663</fpage>
<lpage>1671</lpage>
<history>
<date date-type="received"><day>29</day><month>3</month><year>2011</year></date>
<date date-type="accepted"><day>13</day><month>9</month><year>2011</year></date>
</history>
<permissions>
<copyright-statement>© Authors 2011</copyright-statement>
<copyright-year>2011</copyright-year>
<copyright-holder content-type="society">Institution of Mechanical Engineers</copyright-holder>
</permissions>
<abstract>
<p>Based on the previous research studies, the analytical formula of the optimal joint velocity with minimum jump for robots with multi-degrees of redundancy is derived. This new algorithm considers the motion planning of healthy and reduced robots at the same time to achieve an overall better performance of fault tolerance. Simulation examples are implemented with a planar 4 R robot and a 5 R spatial robot. In the end, the issues of reducing the joint velocity jump and thereby improving the motion stability for both single-degree and multi-degree redundant robots in fault-tolerant operations are completely solved.</p>
</abstract>
<kwd-group>
<kwd>redundant robot</kwd>
<kwd>motion planning</kwd>
<kwd>fault tolerance</kwd>
<kwd>joint velocity jump</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="sec1-0954406211425440" sec-type="intro"><title>1 INTRODUCTION</title>
<p>This article is the continuation of the previous research studies [<bold><xref ref-type="bibr" rid="bibr1-0954406211425440">1</xref></bold>–<bold><xref ref-type="bibr" rid="bibr3-0954406211425440">3</xref></bold>] on the fault-tolerant algorithm with minimum joint velocity jump (JVJ) for redundant robots. In this article, only the redundant robots with revolute joints and the position of the end-effector are considered.</p>
<p>Redundant robots can be divided into two categories: single- and multi-degree redundant robots. When any joint of a robot fails and is locked, the robot will degrade to a new robot with different structural parameters, which is called ‘reduced robot’. One of the differences between single- and multi-degree redundant robots is that the reduced robot of the former one is non-redundant, while the latter one is still redundant. Proper utilization of the multi-degree kinematical redundancy can provide manipulators with greater dexterity not only before joint failures but also after them.</p>
<p>Many indices have been proposed to evaluate the performance of reduced robots [<bold><xref ref-type="bibr" rid="bibr4-0954406211425440">4</xref></bold>–<bold><xref ref-type="bibr" rid="bibr10-0954406211425440">10</xref></bold>]. Besides those, JVJ at the instant of locking a failed joint is another critical issue that should be studied. To exactly continue the desired task, the healthy robot (the robot before failure) will be replaced by the reduced robot at the moment of joint failure. Inevitably, there are jumps of velocity and torques in the surviving joints, which will further affect the accuracy of the end-effector’s movement to continue its trajectory [<bold><xref ref-type="bibr" rid="bibr3-0954406211425440">3</xref></bold>] (©2008 IEEE). Many research studies and experiments have been done to demonstrate the relation between the JVJs and the performances of the robot [<bold><xref ref-type="bibr" rid="bibr1-0954406211425440">1</xref></bold>, <bold><xref ref-type="bibr" rid="bibr11-0954406211425440">11</xref></bold>–<bold><xref ref-type="bibr" rid="bibr13-0954406211425440">13</xref></bold>]. A fault-tolerant algorithm with minimum JVJ was proposed, and an analytical formula of the optimal joint velocity with minimum JVJ was derived to optimize the joint movement of the redundant robot [<bold><xref ref-type="bibr" rid="bibr1-0954406211425440">1</xref></bold>].</p>
<p>The aim of this study is to eliminate or, at least, reduce JVJ at the moment of locked-joint failure. This involves motion planning in two different phases. The first is before the moment of failure: the motion planning of the healthy robot. The second is after the moment of failure: the motion planning of the reduced robot. At the same time, as mentioned above, this issue can also be divided into two different categories based on the degree of redundancy: thecase of single-redundancy and that of multi-redundancy. For the case of single-redundancy, since the reduced robot is a non-redundant one, only the ‘before-failure phase’, which is the motion of the healthy robot, needs to be planned. For the case of multi-redundancy, both the before- and the after-phases need to be planned, because the reduced robot is also a redundant one. In another word, the motion planning needs to consider the healthy and reduced robots at the same time.</p>
<p>In the work of Zhao and Fang [<bold><xref ref-type="bibr" rid="bibr2-0954406211425440">2</xref></bold>], although the case of multi-degree redundancy was dealt with, only the ‘after-failure phase’ (reduced robot) is discussed. The main result obtained is ‘the projection of the least-norm velocity vector for the remaining joints of a manipulator onto the null space of the reduced manipulator is mathematically proved to be a zero vector’.</p>
<p>In the work of Zhao and Li [<bold><xref ref-type="bibr" rid="bibr1-0954406211425440">1</xref></bold>], the case of single-degree redundancy was mainly discussed. The derived motion planning method can only be applied to the ‘before-failure phase’ (healthy robot).</p>
<p>In this article, this work is extended to a more general case. An analytical formula is derived for themotion planning of both the healthy robot (before-failure phase) and the reduced robot (after-failure phase). Its universal form enables it to be suitable for both single- and multi-redundant robots.</p>
<p>There are also many research studies devoted to the topic of failure detection and dynamic fault tolerance. A control framework, consisting of servo, interface, and supervisor layers, is constructed to detect failure [<bold><xref ref-type="bibr" rid="bibr14-0954406211425440">14</xref></bold>]. A new non-linear analytical redundancy framework is proposed to improve the performance in fault detection [<bold><xref ref-type="bibr" rid="bibr15-0954406211425440">15</xref></bold>]. In this article, the issue of fault detection is not considered. It is assumed that any joint failure can be properly predicted, so that the failed joint can be actively locked.</p></sec>
<sec id="sec2-0954406211425440"><title>2 DEFINITION OF JVJ</title>
<p>For the sake of coherence of representation, the definition of JVJ in references [<bold><xref ref-type="bibr" rid="bibr1-0954406211425440">1</xref></bold>, <bold><xref ref-type="bibr" rid="bibr2-0954406211425440">2</xref></bold>] is repeated here.</p>
<p>It is assumed that a redundant robot has <italic>n</italic> degrees of freedom (DOFs) and <italic>m</italic> absolute parameters of theend-effector, and <italic>n</italic> is greater than <italic>m</italic>. When one of the robot’s joints fails and is locked, the robot will change into a reduced robot and the velocity of surviving joints will also be redistributed due to the failed and locked joints. In this way, the difference of joint velocity between the healthy and the reduced robots may be observed. The difference is defined as JVJ and formulated as follows [<bold><xref ref-type="bibr" rid="bibr1-0954406211425440">1</xref></bold>]
<disp-formula id="disp-formula1-0954406211425440"><label>(1)</label><graphic xlink:href="10.1177_0954406211425440-eq1.tif"/></disp-formula>
where <inline-formula id="ilm10954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math1-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is the JVJ of joint <italic>j</italic> when joint <italic>i</italic> fails, <inline-formula id="ilm20954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math2-0954406211425440"><mml:mrow><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> the joint velocity of joint <italic>j</italic> before failure, and <inline-formula id="ilm30954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math3-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> the joint velocity of joint <italic>j</italic> when joint <italic>i</italic> fails.</p>
<p>Subscript ‘<italic>j</italic>’ ranges from 1 to <italic>n</italic>, which represents all joints; superscript ‘<italic>i</italic>’ denotes the failed joints. When <italic>j</italic>=<italic>i</italic>, get <inline-formula id="ilm50954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math5-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, since the failed joint is locked, i.e. <inline-formula id="ilm60954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math6-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. It is obvious that the JVJ depends on not only the joint velocity of the healthy robot but also that of the reduced robot. The smaller <inline-formula id="ilm70954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math7-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is, the smaller the JVJ is, and namely, locking of the failed joint has smaller influence on the kinematical and dynamical properties of a robot [<bold><xref ref-type="bibr" rid="bibr1-0954406211425440">1</xref></bold>]. Minimizing <inline-formula id="ilm80954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math8-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> will enable the robot to mitigate the vibration and jerk that result from excessive JVJ, and further improve the operational accuracy at the instant of failures.</p>
<p>In the case of redundant robots with one degree redundancy, the reduced robots are non-redundant ones, so that <inline-formula id="ilm90954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math9-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is uniquely determined by the reduced Jacobian matrix, which is given by the original Jacobian matrix <bold>J</bold> with its <italic>i</italic>th column removed. Thus, the reduced Jacobian matrix can be expressed as <inline-formula id="ilm100954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math10-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mi>J</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi> </mml:mi><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, and <inline-formula id="ilm110954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math11-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> can be calculated by
<disp-formula id="disp-formula2-0954406211425440"><label>(2)</label><graphic xlink:href="10.1177_0954406211425440-eq2.tif"/></disp-formula>
where <inline-formula id="ilm120954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math12-0954406211425440"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">X</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mtext mathvariant="bold">R</mml:mtext></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>×</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> is the velocity vector of the end-effector and <inline-formula id="ilm130954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math13-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:msub><mml:mi/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mtext mathvariant="bold">J</mml:mtext></mml:mrow><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mtext mathvariant="bold">R</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mtext mathvariant="bold">n</mml:mtext><mml:mo mathvariant="bold">-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo mathvariant="bold">×</mml:mo><mml:mtext mathvariant="bold">m</mml:mtext></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> the inverse of the reduced Jacobian <inline-formula id="ilm140954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math14-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:msub><mml:mi/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msup><mml:mtext mathvariant="bold">J</mml:mtext></mml:mrow></mml:math></inline-formula>. To minimize <inline-formula id="ilm150954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math15-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, only <inline-formula id="ilm160954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math16-0954406211425440"><mml:mrow><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> in equation (<xref ref-type="disp-formula" rid="disp-formula1-0954406211425440">1</xref>) needs to be optimized [<bold><xref ref-type="bibr" rid="bibr3-0954406211425440">3</xref></bold>] (©2008 IEEE).</p>
<p>However, in the case of redundant robots with multi-degree redundancy, the reduced robot is still a redundant one, and <inline-formula id="ilm170954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math17-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> cannot be uniquely determined by the reduced Jacobian <inline-formula id="ilm180954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math18-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:msub><mml:mi/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msup><mml:mtext mathvariant="bold">J</mml:mtext></mml:mrow></mml:math></inline-formula>. Hence, for multi-degree redundancy, both <inline-formula id="ilm190954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math19-0954406211425440"><mml:mrow><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="ilm200954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math20-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> in equation (<xref ref-type="disp-formula" rid="disp-formula1-0954406211425440">1</xref>) need to be optimized.</p></sec>
<sec id="sec3-0954406211425440"><title>3 ANALYTICAL FORMULAS OF THE JOINT VELOCITY AND RELATED PROBLEMS</title>
<sec id="sec4-0954406211425440"><title>3.1 Expression of the formula for single-redundant robot</title>
<p>equation (<xref ref-type="disp-formula" rid="disp-formula1-0954406211425440">1</xref>) indicates that the JVJ depends on the difference of joint velocity between the healthy and reduced robots. For the redundant robot with one redundancy, when any joint of the robot fails and is locked, the joint velocities of the reduced robot are uniquely determined by the desired trajectory of theend-effector. For this reason, one can optimize the joint velocities of the healthy robot through the joint self-motion to make them get close to that of the reduced robot as much as possible. This optimal motion planning has already been clearly stated in previous research studies [<bold><xref ref-type="bibr" rid="bibr1-0954406211425440">1</xref></bold>]. Here, only the result of the formula for the single-redundant robot is given as
<disp-formula id="disp-formula3-0954406211425440"><label>(3)</label><graphic xlink:href="10.1177_0954406211425440-eq3.tif"/></disp-formula>
where <inline-formula id="ilm210954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math21-0954406211425440"><mml:mrow><mml:msup><mml:mrow><mml:mtext mathvariant="bold">J</mml:mtext></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mtext mathvariant="bold">J</mml:mtext></mml:mrow><mml:mrow><mml:mtext>T</mml:mtext></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mtext mathvariant="bold">JJ</mml:mtext></mml:mrow><mml:mrow><mml:mtext>T</mml:mtext></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>∈</mml:mo><mml:mtext mathvariant="bold">R</mml:mtext><mml:msup><mml:mrow/><mml:mrow><mml:mi>n</mml:mi><mml:mo>×</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> is the Moore–Penrose generalized inverse of <bold>J</bold>,  <bold>I</bold> <inline-formula id="ilm240954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math24-0954406211425440"><mml:mrow><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mtext mathvariant="bold">R</mml:mtext></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>×</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> the identity matrix, ‘<italic>n</italic>’ the number of possible failed joints, and <inline-formula id="ilm250954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math25-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mo mathvariant="bold">θ</mml:mo></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mo>'</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mrow><mml:mtext>T</mml:mtext></mml:mrow></mml:msup><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>×</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> the extended joint velocity vector of the reduced robot, whose non-zero components can be calculated by equation (<xref ref-type="disp-formula" rid="disp-formula2-0954406211425440">2</xref>) [<bold><xref ref-type="bibr" rid="bibr3-0954406211425440">3</xref></bold>] (©2008 IEEE).</p></sec>
<sec id="sec5-0954406211425440"><title>3.2 Derivation of the formula for multi-redundant robot</title>
<p>For multi-redundant robot, the joint velocities of both the healthy and reduced robots cannot be uniquely determined. Hence, to minimize the JVJ, one must optimize the joint velocities of both the healthy andreduced robots at the same time, through their joint self-motions separately, to make them get close to each other as much as possible. This optimal motion planning can be stated as: On condition that end-effector’s motion is satisfied, optimize the joint velocities of both the healthy and the reduced redundant robots at the same time to minimize the square sum of the JVJ. Assuming that all redundant joints of the robot have the same possibility to fail, the optimal motion planning can be formulated as
<disp-formula id="disp-formula4-0954406211425440"><label>(4)</label><graphic xlink:href="10.1177_0954406211425440-eq4.tif"/></disp-formula>
subject to
<disp-formula id="disp-formula5-0954406211425440"><label>(5)</label><graphic xlink:href="10.1177_0954406211425440-eq5.tif"/></disp-formula>
where <inline-formula id="ilm260954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math26-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mover><mml:mrow><mml:mo mathvariant="bold">θ</mml:mo></mml:mrow><mml:mi>·</mml:mi></mml:mover><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mrow><mml:mtext>T</mml:mtext></mml:mrow></mml:msup><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mtext mathvariant="bold">R</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> is the joint velocity of the reduced robot when joint <italic>i</italic> is locked (note the difference between <inline-formula id="ilm270954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math27-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mover><mml:mrow><mml:mo mathvariant="bold">θ</mml:mo></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow></mml:math></inline-formula> and <inline-formula id="ilm280954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math28-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mo mathvariant="bold">θ</mml:mo></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mo>'</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>). In addition, <inline-formula id="ilm290954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math29-0954406211425440"><mml:mrow><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mo mathvariant="bold">θ</mml:mo></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mo>*</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mrow><mml:mtext>T</mml:mtext></mml:mrow></mml:msup><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mtext mathvariant="bold">R</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> is the reduction form of the joint velocity vector of the healthy robot by simply removing the element <inline-formula id="ilm300954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math30-0954406211425440"><mml:mrow><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
<p>This is a constraint optimization problem. The analytical solution of this problem should be obtained. The well-known Lagrange multipliers method is often used to solve this problem. Introducing column vectors of the (currently unknown) Lagrange multipliers <bold>η</bold> and <inline-formula id="ilm320954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math32-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo mathvariant="bold">η</mml:mo></mml:mrow></mml:math></inline-formula> which constitute a new objective function, one can change the constrained optimization into an unconstrained one
<disp-formula id="disp-formula6-0954406211425440"><label>(6)</label><graphic xlink:href="10.1177_0954406211425440-eq6.tif"/></disp-formula>
</p>
<p>To minimize the functional <inline-formula id="ilm330954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math33-0954406211425440"><mml:mrow><mml:msup><mml:mrow><mml:mi>Z</mml:mi></mml:mrow><mml:mrow><mml:mo>'</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, its partial derivatives are set to zero with respect to these parameter vectors <bold>η</bold>, <inline-formula id="ilm350954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math35-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo mathvariant="bold">η</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula id="ilm360954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math36-0954406211425440"><mml:mrow><mml:mover><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow></mml:math></inline-formula>, and <inline-formula id="ilm370954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math37-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mover><mml:mrow><mml:mo mathvariant="bold">θ</mml:mo></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow></mml:math></inline-formula>
<disp-formula id="disp-formula7-0954406211425440"><label>(7)</label><graphic xlink:href="10.1177_0954406211425440-eq7.tif"/></disp-formula>
<disp-formula id="disp-formula8-0954406211425440"><label>(8)</label><graphic xlink:href="10.1177_0954406211425440-eq8.tif"/></disp-formula>
<disp-formula id="disp-formula9-0954406211425440"><label>(9)</label><graphic xlink:href="10.1177_0954406211425440-eq9.tif"/></disp-formula>
<disp-formula id="disp-formula10-0954406211425440"><label>(10)</label><graphic xlink:href="10.1177_0954406211425440-eq10.tif"/></disp-formula>
</p>
<p>First, equations (<xref ref-type="disp-formula" rid="disp-formula7-0954406211425440">7</xref>) and (<xref ref-type="disp-formula" rid="disp-formula9-0954406211425440">9</xref>) are solved to get the optimized joint velocity of the healthy redundant robot <inline-formula id="ilm380954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math38-0954406211425440"><mml:mrow><mml:mover><mml:mrow><mml:mo mathvariant="bold">θ</mml:mo></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow></mml:math></inline-formula>.</p>
<p>Arranging equation (<xref ref-type="disp-formula" rid="disp-formula7-0954406211425440">7</xref>) into gives
<disp-formula id="disp-formula11-0954406211425440"><label>(11)</label><graphic xlink:href="10.1177_0954406211425440-eq11.tif"/></disp-formula>
</p>
<p>Substituting <inline-formula id="ilm390954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math39-0954406211425440"><mml:mrow><mml:mover><mml:mrow><mml:mo mathvariant="bold">θ</mml:mo></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow></mml:math></inline-formula> into equation (<xref ref-type="disp-formula" rid="disp-formula9-0954406211425440">9</xref>) and solving for <bold>η</bold> lead to
<disp-formula id="disp-formula12-0954406211425440"><label>(12)</label><graphic xlink:href="10.1177_0954406211425440-eq12.tif"/></disp-formula>
</p>
<p>Substituting <bold>η</bold> back to equation (<xref ref-type="disp-formula" rid="disp-formula7-0954406211425440">7</xref>) and solving for<inline-formula id="ilm420954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math42-0954406211425440"><mml:mrow><mml:mover><mml:mrow><mml:mo mathvariant="bold">θ</mml:mo></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow></mml:math></inline-formula>, one can obtain the general analytical formula of the optimized joint velocity of the healthy redundant robot
<disp-formula id="disp-formula13-0954406211425440"><label>(13)</label><graphic xlink:href="10.1177_0954406211425440-eq13.tif"/></disp-formula>
where <inline-formula id="ilm430954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math43-0954406211425440"><mml:mrow><mml:msup><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">J</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>J</mml:mi></mml:mrow><mml:mrow><mml:mtext>T</mml:mtext></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>JJ</mml:mi></mml:mrow><mml:mrow><mml:mtext>T</mml:mtext></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>∈</mml:mo><mml:mtext mathvariant="bold">R</mml:mtext><mml:msup><mml:mrow/><mml:mrow><mml:mi>n</mml:mi><mml:mo>×</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> is the Moore–Penrose generalized inverse of <bold>J</bold>, <bold>l</bold><inline-formula id="ilm460954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math46-0954406211425440"><mml:mrow><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mtext mathvariant="bold">R</mml:mtext></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>×</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> is the identity matrix, and ‘<italic>n</italic>’ the number of possible failed joints.</p>
<p>Then, solving equations (<xref ref-type="disp-formula" rid="disp-formula8-0954406211425440">8</xref>) and (<xref ref-type="disp-formula" rid="disp-formula10-0954406211425440">10</xref>) to get the optimized joint velocity of the reduced (still redundant) robot <inline-formula id="ilm470954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math47-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mover><mml:mrow><mml:mo mathvariant="bold">θ</mml:mo></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow></mml:math></inline-formula></p>
<p>Calculating and arranging equation (<xref ref-type="disp-formula" rid="disp-formula8-0954406211425440">8</xref>) into
<disp-formula id="disp-formula14-0954406211425440"><label>(14)</label><graphic xlink:href="10.1177_0954406211425440-eq14.tif"/></disp-formula>
</p>
<p>Substituting <inline-formula id="ilm480954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math48-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mover><mml:mrow><mml:mo mathvariant="bold">θ</mml:mo></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow></mml:math></inline-formula> into equation (<xref ref-type="disp-formula" rid="disp-formula10-0954406211425440">10</xref>) and solving for <inline-formula id="ilm490954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math49-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo mathvariant="bold">η</mml:mo></mml:mrow></mml:math></inline-formula> lead to
<disp-formula id="disp-formula15-0954406211425440"><label>(15)</label><graphic xlink:href="10.1177_0954406211425440-eq15.tif"/></disp-formula>
</p>
<p>Substituting <inline-formula id="ilm500954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math50-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo mathvariant="bold">η</mml:mo></mml:mrow></mml:math></inline-formula> back to equation (<xref ref-type="disp-formula" rid="disp-formula8-0954406211425440">8</xref>) and solving for <inline-formula id="ilm510954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math51-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mover><mml:mrow><mml:mo mathvariant="bold">θ</mml:mo></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow></mml:math></inline-formula>, one can obtain the general analytical formula of the optimized joint velocity of the reduced (still redundant) robot
<disp-formula id="disp-formula16-0954406211425440"><label>(16)</label><graphic xlink:href="10.1177_0954406211425440-eq16.tif"/></disp-formula>
where <inline-formula id="ilm520954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math52-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mtext mathvariant="bold">J</mml:mtext></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mtext mathvariant="bold">J</mml:mtext></mml:mrow><mml:mrow><mml:mtext>T</mml:mtext></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mtext mathvariant="bold">J</mml:mtext><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mtext mathvariant="bold">J</mml:mtext></mml:mrow><mml:mrow><mml:mtext>T</mml:mtext></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>∈</mml:mo><mml:mtext mathvariant="bold">R</mml:mtext><mml:msup><mml:mrow/><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> is the Moore–Penrose generalized inverse of reduced <inline-formula id="ilm530954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math53-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mtext mathvariant="bold">J</mml:mtext></mml:mrow></mml:math></inline-formula>, <bold>l</bold><inline-formula id="ilm550954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math55-0954406211425440"><mml:mrow><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mtext mathvariant="bold">R</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> the identity matrix, and ‘<italic>n</italic>’ the number of possible failed joints.</p>
<p>Now, the analytical formulas of the joint velocity of both the healthy and reduced robots are obtained
<disp-formula id="disp-formula17-0954406211425440"><label>(17)</label><graphic xlink:href="10.1177_0954406211425440-eq17.tif"/></disp-formula>
</p>
<p>The formulas given above are (<italic>n</italic> + 1) linear equations with (<italic>n</italic> + 1) variables: <inline-formula id="ilm560954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math56-0954406211425440"><mml:mrow><mml:mover><mml:mrow><mml:mo mathvariant="bold">θ</mml:mo></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow></mml:math></inline-formula> and <inline-formula id="ilm570954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math57-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mover><mml:mrow><mml:mo mathvariant="bold">θ</mml:mo></mml:mrow><mml:mi>·</mml:mi></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. This system is solvable but quite complicated due to the non-same order of the matrices. To make the solution more clear and easy to be understood, a 4 R redundant planar robot is used as an example to illustrate the solving process.</p>
<p>Assuming that a redundant robot with 4 joints is used to implement a planar task, which only requires 2 DOF, equation (<xref ref-type="disp-formula" rid="disp-formula17-0954406211425440">17</xref>) can be written as follows
<disp-formula id="disp-formula18-0954406211425440"><label>(18)</label><graphic xlink:href="10.1177_0954406211425440-eq18.tif"/></disp-formula>
</p>
<p>Some transform operators are defined as follows
<disp-formula id="disp-formula32-0954406211425440"><graphic xlink:href="10.1177_0954406211425440-eq32.tif"/></disp-formula>
</p>
<p><inline-formula id="ilm580954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math58-0954406211425440"><mml:mrow><mml:msub><mml:mrow><mml:mtext mathvariant="bold">I</mml:mtext></mml:mrow><mml:mrow><mml:mi>ii</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is a square matrix in which element (<italic>i</italic>, <italic>i</italic>) is 1 and other elements are 0. For example
<disp-formula id="disp-formula33-0954406211425440"><graphic xlink:href="10.1177_0954406211425440-eq33.tif"/></disp-formula>
</p>
<p>First, the transformation of the second equation in equation (<xref ref-type="disp-formula" rid="disp-formula18-0954406211425440">18</xref>) is conducted to increase the order of the matrices. The nature of this transformation is adding an identical equation <inline-formula id="ilm590954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math59-0954406211425440"><mml:mrow><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mo mathvariant="bold">θ</mml:mo></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mo mathvariant="bold">θ</mml:mo></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> to the original equations. The detailed process is as follows</p>
<p>Multiplying <inline-formula id="ilm600954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math60-0954406211425440"><mml:mrow><mml:msub><mml:mrow><mml:mtext mathvariant="bold">I</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> on both sides of the equation
<disp-formula id="disp-formula19-0954406211425440"><label>(19)</label><graphic xlink:href="10.1177_0954406211425440-eq19.tif"/></disp-formula>
</p>
<p>Adding <inline-formula id="ilm610954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math61-0954406211425440"><mml:mrow><mml:msub><mml:mrow><mml:mtext mathvariant="bold">I</mml:mtext></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub><mml:mover><mml:mrow><mml:mo mathvariant="bold">θ</mml:mo></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow></mml:math></inline-formula> on both sides of the former equation
<disp-formula id="disp-formula20-0954406211425440"><label>(20)</label><graphic xlink:href="10.1177_0954406211425440-eq20.tif"/></disp-formula>
</p>
<p>Substituting <inline-formula id="ilm620954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math62-0954406211425440"><mml:mrow><mml:mover><mml:mrow><mml:mo mathvariant="bold">θ</mml:mo></mml:mrow><mml:mi>·</mml:mi></mml:mover><mml:msup><mml:mrow/><mml:mrow><mml:mo>*</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">I</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn> </mml:mrow><mml:mrow><mml:mtext>T</mml:mtext></mml:mrow></mml:msubsup><mml:mover><mml:mrow><mml:mo mathvariant="bold">θ</mml:mo></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow></mml:math></inline-formula> into the former equation
<disp-formula id="disp-formula21-0954406211425440"><label>(21)</label><graphic xlink:href="10.1177_0954406211425440-eq21.tif"/></disp-formula>
</p>
<p>Arranging this equation, one arrives at
<disp-formula id="disp-formula22-0954406211425440"><label>(22)</label><graphic xlink:href="10.1177_0954406211425440-eq22.tif"/></disp-formula>
</p>
<p>Through similar transformations, the third to fifth equations in equation (<xref ref-type="disp-formula" rid="disp-formula18-0954406211425440">18</xref>) can also be transformed which leads to
<disp-formula id="disp-formula23-0954406211425440"><label>(23)</label><graphic xlink:href="10.1177_0954406211425440-eq23.tif"/></disp-formula>
<disp-formula id="disp-formula24-0954406211425440"><label>(24)</label><graphic xlink:href="10.1177_0954406211425440-eq24.tif"/></disp-formula>
<disp-formula id="disp-formula25-0954406211425440"><label>(25)</label><graphic xlink:href="10.1177_0954406211425440-eq25.tif"/></disp-formula>
</p>
<p>Adding transformed equations (<xref ref-type="disp-formula" rid="disp-formula22-0954406211425440">22</xref>) to (<xref ref-type="disp-formula" rid="disp-formula25-0954406211425440">25</xref>) together and rearranging the result, leads to
<disp-formula id="disp-formula26-0954406211425440"><label>(26)</label><graphic xlink:href="10.1177_0954406211425440-eq26.tif"/></disp-formula>
</p>
<p>Substituting equation (<xref ref-type="disp-formula" rid="disp-formula26-0954406211425440">26</xref>) into the first equation in equation (<xref ref-type="disp-formula" rid="disp-formula18-0954406211425440">18</xref>), one arrives at
<disp-formula id="disp-formula27-0954406211425440"><label>(27)</label><graphic xlink:href="10.1177_0954406211425440-eq27.tif"/></disp-formula>
where
<disp-formula id="disp-formula28-0954406211425440"><label>(28)</label><graphic xlink:href="10.1177_0954406211425440-eq28.tif"/></disp-formula>
<disp-formula id="disp-formula29-0954406211425440"><label>(29)</label><graphic xlink:href="10.1177_0954406211425440-eq29.tif"/></disp-formula>
</p>
<p>The final result of the general analytical formula of the joint velocity that can minimize the JVJ of the redundant robot is given as follows
<disp-formula id="disp-formula30-0954406211425440"><label>(30)</label><graphic xlink:href="10.1177_0954406211425440-eq30.tif"/></disp-formula>
</p>
<p>Substituting equation (<xref ref-type="disp-formula" rid="disp-formula30-0954406211425440">30</xref>) into the second equation in equation (<xref ref-type="disp-formula" rid="disp-formula17-0954406211425440">17</xref>), one can get the optimized joint velocity of the reduced robot <inline-formula id="ilm630954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math63-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mover><mml:mrow><mml:mo mathvariant="bold">θ</mml:mo></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow></mml:math></inline-formula>.</p>
<p>For any <italic>n</italic>-joint redundant robot with multi-degree redundancy, through the similar derivation as given above, the same form of result can be obtained just as the formula is illustrated in equation (<xref ref-type="disp-formula" rid="disp-formula30-0954406211425440">30</xref>).</p></sec>
<sec id="sec6-0954406211425440"><title>3.3 Comparison between the two formulas</title>
<p>The analytical formula of optimized joint velocity for single-redundant robots is shown in equation (<xref ref-type="disp-formula" rid="disp-formula3-0954406211425440">3</xref>). The analytical formula for multiple-redundant robots is showed in equation (<xref ref-type="disp-formula" rid="disp-formula17-0954406211425440">17</xref>). The first formula in equation (<xref ref-type="disp-formula" rid="disp-formula17-0954406211425440">17</xref>) is the expression of optimized joint velocity for a healthy robot. The second formula in equation (<xref ref-type="disp-formula" rid="disp-formula17-0954406211425440">17</xref>) is the expression of optimized joint velocity for a reduced robot. The formations of all these formulas are similar because they are derived through same criteria.</p>
<p>The only difference between equation (<xref ref-type="disp-formula" rid="disp-formula3-0954406211425440">3</xref>) and the first equation in equation (<xref ref-type="disp-formula" rid="disp-formula17-0954406211425440">17</xref>) is that the coefficient in equation (<xref ref-type="disp-formula" rid="disp-formula3-0954406211425440">3</xref>) is 1/<italic>n</italic>, but in equation (<xref ref-type="disp-formula" rid="disp-formula17-0954406211425440">17</xref>), it is <inline-formula id="ilm650954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math65-0954406211425440"><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The reason is given below. The objective function for a single-redundant robot described in previous research studies [<bold><xref ref-type="bibr" rid="bibr1-0954406211425440">1</xref></bold>] is
<disp-formula id="disp-formula31-0954406211425440"><label>(31)</label><graphic xlink:href="10.1177_0954406211425440-eq31.tif"/></disp-formula>
</p>
<p>Compared with the objective function for multiple-redundant robots adopted in this article, as showed in equation (<xref ref-type="disp-formula" rid="disp-formula4-0954406211425440">4</xref>), <inline-formula id="ilm660954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math66-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mo mathvariant="bold">θ</mml:mo></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mo>'</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> is replaced by <inline-formula id="ilm670954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math67-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mover><mml:mrow><mml:mo mathvariant="bold">θ</mml:mo></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow></mml:math></inline-formula> and <inline-formula id="ilm680954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math68-0954406211425440"><mml:mrow><mml:mover><mml:mrow><mml:mo mathvariant="bold">θ</mml:mo></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow></mml:math></inline-formula> is replaced by <inline-formula id="ilm690954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math69-0954406211425440"><mml:mrow><mml:mover><mml:mrow><mml:mo mathvariant="bold">θ</mml:mo></mml:mrow><mml:mi>·</mml:mi></mml:mover><mml:msup><mml:mrow/><mml:mrow><mml:mo>*</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>. These changes mean that JVJs of the locked joint are not included in the calculation of the total JVJ, which is more reasonable due to the reason that there is no need to consider the situation of the failed joint in the post-failure operation. This modification results in the change of coefficient in the final formulas, where 1/<italic>n</italic> is replaced by <inline-formula id="ilm710954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math71-0954406211425440"><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
<p>Both equations (<xref ref-type="disp-formula" rid="disp-formula3-0954406211425440">3</xref>) and (<xref ref-type="disp-formula" rid="disp-formula17-0954406211425440">17</xref>) show that the optimal joint velocity with minimum JVJ can be written in thestandard pattern of the gradient projection algorithm [<bold><xref ref-type="bibr" rid="bibr16-0954406211425440">16</xref></bold>].</p>
<p>For both single- and multi-redundant robots, these formulas of optimized joint velocity are conducted under the assumption that all joints will possibly fail and the possibilities are equal.</p>
<p>For robots with single-degree of redundancy, <inline-formula id="ilm720954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math72-0954406211425440"><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn> </mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mo mathvariant="bold">θ</mml:mo></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mo>'</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> can be uniquely determined through equation (<xref ref-type="disp-formula" rid="disp-formula2-0954406211425440">2</xref>), and then the optimal joint velocity of the healthy robot can be conducted through equation (<xref ref-type="disp-formula" rid="disp-formula3-0954406211425440">3</xref>). For robots with multi-degrees of redundancy, the optimal joint velocity of the healthy robot <inline-formula id="ilm730954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math73-0954406211425440"><mml:mrow><mml:mover><mml:mrow><mml:mo mathvariant="bold">θ</mml:mo></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow></mml:math></inline-formula> is first obtained through equation (<xref ref-type="disp-formula" rid="disp-formula18-0954406211425440">18</xref>), and when a specific joint <italic>i</italic> is locked, its extended form <inline-formula id="ilm740954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math74-0954406211425440"><mml:mrow><mml:mover><mml:mrow><mml:mo mathvariant="bold">θ</mml:mo></mml:mrow><mml:mi>·</mml:mi></mml:mover><mml:msup><mml:mrow/><mml:mrow><mml:mo>*</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> is being substituted into the second equation in equation (<xref ref-type="disp-formula" rid="disp-formula17-0954406211425440">17</xref>) to obtain the optimal joint velocity of the reduced robot <inline-formula id="ilm750954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math75-0954406211425440"><mml:mrow><mml:msup><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mover><mml:mrow><mml:mo mathvariant="bold">θ</mml:mo></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow></mml:math></inline-formula>.</p></sec></sec>
<sec id="sec7-0954406211425440"><title>4 SIMULATION EXAMPLES</title>
<p>The least norm velocity algorithm (LNVA) can operate a robot with the minimum joint velocity in the square sum sense, which may have a smaller JVJ when joint failure occurs [<bold><xref ref-type="bibr" rid="bibr3-0954406211425440">3</xref></bold>] (©2008 IEEE). Comparisons between it and the new method are made in this section. Some experimental results concerning error metric are also presented here.</p>
<sec id="sec8-0954406211425440"><title>4.1 Planar 4 R robot</title>
<p><xref ref-type="fig" rid="fig1-0954406211425440">Figure 1</xref> shows a planar 4 R robot. For positional tasks, it is a redundant robot with two degrees of redundancy. The two algorithms, the minimum JVJ algorithm (JVJA) and LNVA, are implemented, respectively, to make the robot finish a planar circle trajectory. After the simulation, the comparisons of these algorithms on JVJ index will be made. The simulation conditions are given below. The four links of the robot are identical and each is 0.5 m long. Assume the velocity of its end-effector <inline-formula id="ilm760954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math76-0954406211425440"><mml:mrow><mml:mover><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mo>-</mml:mo><mml:mn>0</mml:mn><mml:mo>.</mml:mo><mml:mn>5</mml:mn><mml:mi>π</mml:mi><mml:mi>sin</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>.</mml:mo><mml:mn>5</mml:mn><mml:mi>π</mml:mi><mml:mi>cos</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:msup><mml:mi/><mml:mrow><mml:mtext>T</mml:mtext></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>m/s, simulation time <italic>t</italic> = 1.0 s, and calculation time d<italic>t</italic> = 0.01 s.
<fig id="fig1-0954406211425440" position="float"><label>Fig. 1</label><caption><p>A planar 4 R robot</p></caption><graphic xlink:href="10.1177_0954406211425440-fig1.tif"/></fig></p>
<p><xref ref-type="fig" rid="fig2-0954406211425440">Figure 2</xref> compares the simulation results of the two different algorithms for estimating the square sum of JVJ of all joints at each moment. It is worth noting that the failure possibilities of all joints are considered in this case. It is clear that the JVJ varies with time. At a different configuration, there will be different JVJ. For the whole time range, the minimum JVJA outperforms the LNVA with a lower JVJ value. In addition, also because both the two algorithms belong to a local solution, at some moments, the minimum JVJA could be equal or less effective than LNVA.
<fig id="fig2-0954406211425440" position="float"><label>Fig. 2</label><caption><p>Square sum of JVJs of all joints</p></caption><graphic xlink:href="10.1177_0954406211425440-fig2.tif"/></fig></p>
<p>Next, the fault operations with locking joint 1 at different moments are implemented respectively, and the results are shown in <xref ref-type="fig" rid="fig3-0954406211425440">Figs 3</xref> and <xref ref-type="fig" rid="fig4-0954406211425440">4</xref>. (Note that JVJ is not a square value here.) The maximum JVJ in JVJA is less than 1 rad/s. The maximum JVJ in LNVA is around 2 rad/s. Nearly, 50 per cent of JVJ has been reduced by JVJA, which proves its superiority to LNVA.
<fig id="fig3-0954406211425440" position="float"><label>Fig. 3</label><caption><p>JVJ of other joints when locking of joint 1 takes place for JVJA</p></caption><graphic xlink:href="10.1177_0954406211425440-fig3.tif"/></fig>
<fig id="fig4-0954406211425440" position="float"><label>Fig. 4</label><caption><p>JVJ of other joints when locking of joint 1 takes place for LNVA</p></caption><graphic xlink:href="10.1177_0954406211425440-fig4.tif"/></fig></p>
<p>As mentioned in <xref ref-type="sec" rid="sec6-0954406211425440">Section 3.3</xref>, the minimum JVJA is proposed with the consideration that all joints are possible to fail and the possibilities are equal. Hence, the planning of joint velocity by this algorithm is aimed to reduce the sum of JVJs for all possible joint failures. For example, if a robot is working for a very long period of time, during which it may have many times of joint failures, this algorithm can ensure that the sum of all the JVJs during those failures is minimum compared with other algorithms. Or in another case, where a large number of robots are operating for a short period time and they all can possibly have failures in different joints, this algorithm can also prove to be superior to others. In a word, JVJ is the optimal one because no matter which joint is locked, it can ensure the minimum JVJ in a general probability sense. However, in this case of simulation, a single robot operating for a short time range is assumed, and only joint 1 will possibly fail. If one chooses another joint to be locked, for a specified joint at a specified moment, the JVJ of the new algorithm may not always be significantly better than the one of LNVAs; at some extreme time, it may be even worse.</p>
<p>Finally, two simulations with different algorithms are conducted by locking joint 1 at <italic>t</italic> = 0.5 s during the robots’ operation. The trajectories of all the joint velocities are shown in <xref ref-type="fig" rid="fig5-0954406211425440">Figs 5</xref> and <xref ref-type="fig" rid="fig6-0954406211425440">6</xref>. It is clear that for both the algorithms, there are obvious JVJs at<italic>t</italic> = 0.5 s, and the JVJs of all joints in JVJA are lessthan the ones in LNVA. The values of JVJ at <italic>t</italic> = 0.5 s shown in <xref ref-type="fig" rid="fig5-0954406211425440">Figs 5</xref> and <xref ref-type="fig" rid="fig6-0954406211425440">6</xref> are also consistent with the results shown in <xref ref-type="fig" rid="fig3-0954406211425440">Figs 3</xref> and <xref ref-type="fig" rid="fig4-0954406211425440">4</xref>.
<fig id="fig5-0954406211425440" position="float"><label>Fig. 5</label><caption><p>Joint velocity for JVJA when locking of joint 1 takes place at <italic>t</italic> = 0.5 s</p></caption><graphic xlink:href="10.1177_0954406211425440-fig5.tif"/></fig>
<fig id="fig6-0954406211425440" position="float"><label>Fig. 6</label><caption><p>Joint velocity for LNVA when locking of joint 1 takes place at <italic>t</italic> = 0.5 s</p></caption><graphic xlink:href="10.1177_0954406211425440-fig6.tif"/></fig></p></sec>
<sec id="sec9-0954406211425440"><title>4.2 Spatial 5 R robot</title>
<p>To further demonstrate the difference between the two algorithms, a 5 R spatial robot, with higher non-linear properties compared with planar robots, is employed to implement simulations. <xref ref-type="fig" rid="fig7-0954406211425440">Figure 7</xref> shows a spatial 5 R robot. For spatial positional tasks, it is a redundant robot with two degrees of redundancy. The minimum JVJA and LNVA are implemented, respectively, to make the robot finish a spatial circle trajectory.
<fig id="fig7-0954406211425440" position="float"><label>Fig. 7</label><caption><p>A spatial 5 R robot</p></caption><graphic xlink:href="10.1177_0954406211425440-fig7.tif"/></fig></p>
<p>The simulation conditions are given as follows. The five links of the robot are identical and each is 0.5 m long. It is assumed that the velocity of its end-effector is <inline-formula id="ilm770954406211425440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math77-0954406211425440"><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">X</mml:mtext></mml:mrow><mml:mi>·</mml:mi></mml:mover><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mo>-</mml:mo><mml:mi>π</mml:mi><mml:mi>sin</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>π</mml:mi><mml:mi>cos</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:msup><mml:mi/><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>m/s, simulation time <italic>t</italic> = 1.0 s, and calculation time d<italic>t</italic> = 0.01 s. <xref ref-type="fig" rid="fig8-0954406211425440">Figure 8</xref> compares the simulation results of the two different algorithms for estimating the square sum of JVJs of all joints at each moment. The failure possibilities of all joints are considered in this case. For the all time ranges, the minimum JVJA outperforms LNVA since it has a lower JVJ value, which is consistent with the result shown in <xref ref-type="fig" rid="fig2-0954406211425440">Fig. 2</xref>. At some configurations, these two algorithms are quite close on theJVJ index. This phenomenon, as the one shown in <xref ref-type="fig" rid="fig2-0954406211425440">Fig. 2</xref>, is due to the local property of these two algorithms.
<fig id="fig8-0954406211425440" position="float"><label>Fig. 8</label><caption><p>Square sum of JVJs of all joints</p></caption><graphic xlink:href="10.1177_0954406211425440-fig8.tif"/></fig></p>
<p>Next, the fault operations with locking joint 1 at different moments are implemented, and the results are shown in <xref ref-type="fig" rid="fig9-0954406211425440">Figs 9</xref> and <xref ref-type="fig" rid="fig10-0954406211425440">10</xref>. (Note that JVJ is not a square value here.) At specific moments during the robot’s operation, after joint 1 locked, the other survival joints experience JVJ. Their JVJs in the minimum JVJA are less than their corresponding ones in LNVA. It has to be admitted that the difference between them is not very significant, and the reason has been explained in <xref ref-type="sec" rid="sec8-0954406211425440">Section 4.1</xref>.
<fig id="fig9-0954406211425440" position="float"><label>Fig. 9</label><caption><p>JVJ of other joints when locking of joint 1 takes place for JVJA</p></caption><graphic xlink:href="10.1177_0954406211425440-fig9.tif"/></fig>
<fig id="fig10-0954406211425440" position="float"><label>Fig. 10</label><caption><p>JVJ of other joints when locking of joint 1 takes place for LDVA</p></caption><graphic xlink:href="10.1177_0954406211425440-fig10.tif"/></fig>
</p></sec>
<sec id="sec10-0954406211425440"><title>4.2 Experimental results on path errors</title>
<p>The discussion on JVJ given in this article concerns its purely kinematical effects. More exploration on dynamic level may reveal the intrinsic relationship between JVJ and the path error. In paper [<bold><xref ref-type="bibr" rid="bibr13-0954406211425440">13</xref></bold>], an experimental study on the path error of a redundant robot in fault-tolerant operations for locked-joint failure is conducted. Here, a typical result is shown to demonstrate the error metric of path error caused by the JVJ.</p>
<p>A Power-Cube planar 3 R robot with link lengths 0.29, 0.32, and 0.23 m is tracking a circle with the speed</p>
<p>
<disp-formula id="disp-formula34-0954406211425440"><graphic xlink:href="10.1177_0954406211425440-eq34.tif"/></disp-formula>
</p>
<p>Using LNDA, it is observed that locking of joint 3 takes place at <italic>t</italic> = 3 s. The path error in the least norm form is shown in <xref ref-type="fig" rid="fig11-0954406211425440">Fig. 11</xref>. The joint velocity profile is shown in <xref ref-type="fig" rid="fig12-0954406211425440">Fig. 12</xref>.
<fig id="fig11-0954406211425440" position="float"><label>Fig. 11</label><caption><p>Path error when locking of joint 3 takes place at <italic>t</italic> = 3 s</p></caption><graphic xlink:href="10.1177_0954406211425440-fig11.tif"/></fig>
<fig id="fig12-0954406211425440" position="float"><label>Fig. 12</label><caption><p>Joint velocity when locking of joint 3 takes place at <italic>t</italic> = 3 s</p></caption><graphic xlink:href="10.1177_0954406211425440-fig12.tif"/></fig></p>
<p>At the instant of joint locking, a large JVJ causes an increased path error and subsequently affects the accuracy of the remaining task. More discussion can be found in paper [<bold><xref ref-type="bibr" rid="bibr13-0954406211425440">13</xref></bold>].</p></sec></sec>
<sec id="sec11-0954406211425440"><title>5 SUMMARY AND CONCLUSIONS</title>
<p>In the previous research studies, the algorithm of the optimal joint velocity with minimum jump for robots with single degree of redundancy is developed. In this article, the analytical formula of the optimal joint velocity with minimum jump for robots with multi-degree of redundancy is derived and an algorithm proposed. Through the comparison between these two research studies, one can see that their formulas have unified forms and both of them are superior to the least-norm algorithm on the performance of reducing JVJ. In the end, the issues of reducing JVJ and thereby improving the motion stability for both single- and multi-degree redundant robots in fault-tolerant operations are completely solved.</p>
<p>The JVJ problem of redundant robots including dynamic considerations will be focused in our future work.</p></sec>
</body>
<back>
<ack><title>ACKNOWLEDGEMENT</title>
<p>This project is supported by National Natural Science Foundation of China (NO.51075005). Portions have been reprinted, with permission, from Institute of Electrical and Electronics Engineers. © 2008 IEEE.</p></ack>
<ref-list>
<title>REFERENCES</title>
<ref id="bibr1-0954406211425440"><label>1</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Zhao</surname><given-names>J.</given-names></name><name><surname>Li</surname><given-names>Q.</given-names></name></person-group> <article-title>On the joint velocity jump for redundant robots in the presence of locked-joint failures</article-title>. <source>J. Mech. Des.</source>, <year>2008</year>, <volume>130</volume>, <fpage>102305</fpage>–<lpage>1–102305-7</lpage>.</citation></ref>
<ref id="bibr2-0954406211425440"><label>2</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Zhao</surname><given-names>J.</given-names></name><name><surname>Fang</surname><given-names>C.</given-names></name></person-group> <article-title>On the joint velocity jump during fault tolerant operations for manipulators with multiple degrees of redundancy</article-title>. <source>Mech. Mach. Theory</source>, <year>2009</year>, <volume>44</volume>, <fpage>1201</fpage>–<lpage>1210</lpage>.</citation></ref>
<ref id="bibr3-0954406211425440"><label>3</label><citation citation-type="other"><comment><bold>Zhao, J.</bold> and <bold>Li, Q.</bold> (Eds) An analytical algorithm with minimum joint velocity jump for redundant robots in the presence of locked-joint failures. In Proceedings of the IEEE International Conference on <italic>Robotics and automation the half-day workshop on: towards autonomous agriculture of tomorrow</italic>, Pasadena, California, 19–23 May 2008, pp. 1987–1992 (Institute of Electrical and Electronics Engineers, Piscataway, New Jersey)</comment>.</citation></ref>
<ref id="bibr4-0954406211425440"><label>4</label><citation citation-type="other"><comment><bold>Caldwell, C.</bold> and <bold>Roberts, R. G.</bold> (Eds) Fault-tolerant kinematically redundant robots. In Proceedings of the Thirty-Fourth Southeastern Symposium on <italic>System theory</italic>, Huntsville, Alabama, 18–19 March 2002, pp. 381–385 (Institute of Electrical and Electronics Engineers, Piscataway, New Jersey)</comment>.</citation></ref>
<ref id="bibr5-0954406211425440"><label>5</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Goel</surname><given-names>M.</given-names></name><name><surname>Maciejewski</surname><given-names>A. A.</given-names></name><name><surname>Balakrishnan</surname><given-names>V.</given-names></name></person-group> <article-title>Analyzing unidentified locked-joint failures in kinematically redundant manipulators</article-title>. <source>J. Robot. Syst.</source>, <year>2005</year>, <volume>22</volume>, <fpage>15</fpage>–<lpage>29</lpage>.</citation></ref>
<ref id="bibr6-0954406211425440"><label>6</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Lewis</surname><given-names>C. L.</given-names></name><name><surname>Maciejewski</surname><given-names>A. A.</given-names></name></person-group> <article-title>Fault tolerant operation of kinematically redundant manipulators for locked joint failures</article-title>. <source>IEEE Trans. Robot. Autom.</source>, <year>1997</year>, <volume>13</volume>, <fpage>622</fpage>–<lpage>629</lpage>.</citation></ref>
<ref id="bibr7-0954406211425440"><label>7</label><citation citation-type="other"><comment><bold>Maciejewski, A. A.</bold> (Ed.) Fault tolerant properties ofkinematically redundant manipulators. In Proceedings of the IEEE International Conference on <italic>Robotics and automation</italic> (Cat No. 90CH2876-1), Cincinnati, Ohio, 13–18 May 1990, vol. 1, pp. 638–642 (Institute of Electrical and Electronics Engineers Computer Society Press, Los Alamitos, California)</comment>.</citation></ref>
<ref id="bibr8-0954406211425440"><label>8</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Roberts</surname><given-names>R. G.</given-names></name><name><surname>Maciejewski</surname><given-names>A. A.</given-names></name></person-group> <article-title>A local measure of fault tolerance for kinematically redundant manipulators</article-title>. <source>IEEE Trans. Robot. Autom.</source>, <year>1996</year>, <volume>12</volume>, <fpage>543</fpage>–<lpage>552</lpage>.</citation></ref>
<ref id="bibr9-0954406211425440"><label>9</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Saglia</surname><given-names>J. A.</given-names></name><name><surname>Dai</surname><given-names>J. S.</given-names></name><name><surname>Caldwell</surname><given-names>D. G.</given-names></name></person-group> <article-title>Geometry and kinematic analysis of a redundantly actuated parallel mechanism that eliminates singularities and improves dexterity</article-title>. <source>J. Mech. Des.</source>, <year>2008</year>, <volume>130</volume>, <fpage>124501.1</fpage>–<lpage>124501.5</lpage>.</citation></ref>
<ref id="bibr10-0954406211425440"><label>10</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Zhao</surname><given-names>J.</given-names></name><name><surname>Jing</surname><given-names>H.</given-names></name><name><surname>Zhang</surname><given-names>L.</given-names></name></person-group> <article-title>Fault tolerant motion planning for two coordinating manipulators</article-title>. <source><italic>Chin. J. Mech. Eng</italic>.</source>, <year>2004</year>, <volume>40</volume>, <fpage>172</fpage>–<lpage>176</lpage>.</citation></ref>
<ref id="bibr11-0954406211425440"><label>11</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Groom</surname><given-names>K. N.</given-names></name><name><surname>Maciejewski</surname><given-names>A. A.</given-names></name><name><surname>Balakrishnan</surname><given-names>V.</given-names></name></person-group> <article-title>Real-time failure-tolerant control of kinematically redundant manipulators</article-title>. <source>IEEE Trans. Robot. Autom.</source>, <year>1999</year>, <volume>15</volume>, <fpage>1109</fpage>–<lpage>1115</lpage>.</citation></ref>
<ref id="bibr12-0954406211425440"><label>12</label><citation citation-type="other"><comment><bold>Tinos, R., Terra, M. H.,</bold> and <bold>Bergerman M.</bold> (Eds) Fault tolerance in cooperative manipulators. In Proceedings of the IEEE International Conference on <italic>Robotics and automation</italic>, Washington, DC, 11–15 May 2002, vol. 1, pp. 470–475 (Institute of Electrical and Electronics Engineers, Piscataway, New Jersey)</comment>.</citation></ref>
<ref id="bibr13-0954406211425440"><label>13</label><citation citation-type="other"><comment><bold>Zhao, J., Liu, Y.,</bold> and <bold>Jin, Y.</bold> (Eds) On path errors of redundant robots in fault tolerant operations for locked joint failures. In Proceedings of the 14th International Conference on <italic>Advanced robotics (ICAR 2009)</italic>, Munich, Germany, 22–26 June 2009, pp. 1–6 (Institute of Electrical and Electronics Engineers, Piscataway, New Jersey)</comment>.</citation></ref>
<ref id="bibr14-0954406211425440"><label>14</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Visinsky</surname><given-names>M. L.</given-names></name><name><surname>Cavallaro</surname><given-names>J. R.</given-names></name><name><surname>Walker</surname><given-names>I. D.</given-names></name></person-group> <article-title>Dynamic fault tolerance framework for remote robots</article-title>. <source>IEEE Trans. Robot. Autom.</source>, <year>1995</year>, <volume>11</volume>, <fpage>477</fpage>–<lpage>490</lpage>.</citation></ref>
<ref id="bibr15-0954406211425440"><label>15</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Leuschen</surname><given-names>M. L.</given-names></name><name><surname>Walker</surname><given-names>I. D.</given-names></name><name><surname>Cavallaro</surname><given-names>J. R.</given-names></name></person-group> <article-title>Fault residual generation via nonlinear analytical redundancy</article-title>. <source>IEEE Trans. Control Syst. Technol.</source>, <year>2005</year>, <volume>13</volume>, <fpage>452</fpage>–<lpage>458</lpage>.</citation></ref>
<ref id="bibr16-0954406211425440"><label>16</label><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Liegeois</surname><given-names>A.</given-names></name></person-group> <article-title>Automatic supervisory control of the configuration and behavior of multibody mechanisms</article-title>. <source>IEEE Trans. Syst. Man Cybern.</source>, <year>1977</year>, <volume>SMC-7</volume>, <fpage>868</fpage>–<lpage>871</lpage>.</citation></ref>
</ref-list>
</back>
</article>