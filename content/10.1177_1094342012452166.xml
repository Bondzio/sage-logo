<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD Journal Publishing DTD v2.3 20070202//EN" "journalpublishing.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">HPC</journal-id>
<journal-id journal-id-type="hwp">sphpc</journal-id>
<journal-title>The International Journal of High Performance Computing Applications</journal-title>
<issn pub-type="ppub">1094-3420</issn>
<issn pub-type="epub">1741-2846</issn>
<publisher>
<publisher-name>SAGE Publications</publisher-name>
<publisher-loc>Sage UK: London, England</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1177/1094342012452166</article-id>
<article-id pub-id-type="publisher-id">10.1177_1094342012452166</article-id>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Regular Articles</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>GPU-based approaches for real-time sound source localization using the SRP-PHAT algorithm</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" corresp="yes">
<name>
<surname>Minotto</surname>
<given-names>Vicente Peruffo</given-names>
</name>
<xref ref-type="aff" rid="aff1-1094342012452166">1</xref>
<xref ref-type="corresp" rid="corresp1-1094342012452166"/>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Jung</surname>
<given-names>Claudio Rosito</given-names>
</name>
<xref ref-type="aff" rid="aff1-1094342012452166">1</xref>
</contrib>
<contrib contrib-type="author">
<name>
<surname>da Silveira</surname>
<given-names>Luiz Gonzaga</given-names>
<suffix>Jr</suffix>
</name>
<xref ref-type="aff" rid="aff2-1094342012452166">2</xref>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Lee</surname>
<given-names>Bowon</given-names>
</name>
<xref ref-type="aff" rid="aff3-1094342012452166">3</xref>
</contrib>
<bio>
<title>Author biographies</title>
<p>
<italic>Vicente Peruffo Minotto</italic> received the B.S. degree in Computer Engineering from Universidade do Vale do Rio dos Sinos (Unisinos), Brazil, in 2011. He is currently a Master’s student at Universidade Federal do Rio Grande do Sul (UFRGS) under the advisement of Professor Caudio R Jung. He expects to receive his Applied Computing M.S. degree in 2013. His research interests include microphone array signal processing, human–computer interaction, multimodal signal processing, and high-performance computing with GPUs. His main ongoing research topic is related to real-time human–computer interaction using multimodal signal processing, which he intends to continue pursuing in a future Ph.D. course.</p>
<p>
<italic>Claudio Rosito Jung</italic> received the B.S. and M.S. degrees in Applied Mathematics, and the Ph.D. degree in Computer Sciences, from Universidade Federal do Rio Grande do Sul (UFRGS), Brazil, in 1993, 1995 and 2002, respectively. He is currently an Assistant Professor at UFRGS in the Computer Science Department. His research interests include image denoising and enhancement, image segmentation, medical imaging, multiscale image analysis, intelligent vehicles, object tracking, multimedia applications, human motion analysis and stereo/multiview matching.</p>
<p>
<italic>Luiz Gonzaga da Silveira Jr</italic> is an Assistant Professor at the Applied Computing Graduate Program (PIPCA). He researches at Universidade do Vale do Rio dos Sinos (Unisinos), São Leopoldo, Brazil. He received his B.S. degree in Electrical Engineering from Federal University of Paraiba (UFPb), Brazil, in 1992. He obtained his M.S. and Ph.D. degrees in Electrical Engineering/Computer Engineering from the State University of Campinas (UNICAMP), Brazil, in 1996 and 2005, respectively. His research interests include computational visualization, image-based rendering and modeling, graphics architectures and GPU programming. He is a member of the IEEE, IEEE Computer Society, ACM, ACM/Siggraph and Brazilian Computer Society (SBC). He is also the cofounder of the startup companies V3D and Ficta, focused on computational visualization and mobile technologies, respectively.</p>
<p>
<italic>Bowon Lee</italic> received the B.S. degree in Electrical Engineering from Seoul National University, Seoul, Korea in 2000, and the M.S. and Ph.D. degrees in Electrical and Computer Engineering from the University of Illinois at Urbana-Champaign in 2003 and 2006, respectively. He is currently a senior research scientist in the Mobile and Immersive Experience Lab at Hewlett- Packard Laboratories in Palo Alto, California. His research interests include statistical signal processing on audio and speech, microphone array signal processing, acoustic event detection and localization, and multimodal signal processing. He received two top 10% awards from the IEEE Workshop on Multimedia Signal Processing in 2009. He has served as the technical program committee of the IEEE International Conference on Multimedia and Expo from 2010 to 2012, the IEEE Workshop on Applications of Signal Processing to Audio and Acoustics in 2011, and the IEEE Digital Signal Processing and Signal Processing Education Workshop in 2011. He is a senior member of the IEEE and a member of the Audio Engineering Society. He grew up in Seoul, South Korea and served for the Republic of Korea Army from 1995 to 1998 and retired as a sergeant.</p>
</bio>
</contrib-group>
<aff id="aff1-1094342012452166">
<label>1</label>Instituto de Informática, Universidade Federal do Rio Grande do Sul, RS, Brazil</aff>
<aff id="aff2-1094342012452166">
<label>2</label>Applied Computing Graduate Program (PIPCA), Universidade do Vale do Rio dos Sinos, RS, Brazil</aff>
<aff id="aff3-1094342012452166">
<label>3</label>Mobile and Immersive Experience Lab, Hewlett-Packard Laboratories, Palo Alto, CA, USA </aff>
<author-notes>
<corresp id="corresp1-1094342012452166">Vicente Peruffo Minotto, Universidade Federal do Rio Grande do Sul, Av. Bento Gonçalvez 9500, Porto Alegre, 91501-970, Brazil. Email: <email>vpminotto@inf.ufrgs.br</email>
</corresp>
</author-notes>
<pub-date pub-type="epub-ppub">
<month>8</month>
<year>2013</year>
</pub-date>
<volume>27</volume>
<issue>3</issue>
<issue-title>Special Issue section on CCDSC 2012 Workshop</issue-title>
<fpage>291</fpage>
<lpage>306</lpage>
<permissions>
<copyright-statement>© The Author(s) 2012</copyright-statement>
<copyright-year>2012</copyright-year>
<copyright-holder content-type="sage">SAGE Publications</copyright-holder>
</permissions>
<abstract>
<p>The aim of most microphone array applications is to localize sound sources in a noisy and reverberant environment. For that purpose, many different sound source localization (SSL) algorithms have been proposed, where the SRP-PHAT (steered response power using the phase transform) has been known as one of the state-of-the-art methods. Its original formulation allows two different practical implementations, one that is computed in the frequency domain (FDSP) and another in the time domain (TDSP), which can be enhanced by interpolation. However, the main problem of this algorithm is its high computational cost due to intensive grid scan in search for the sound source. Considering the power of graphics processing units (GPUs) for working with massively parallelizable compute-intensive algorithms, we present two highly scalable GPU-based versions of the SRP-PHAT, one for each formulation, and also an implementation of the cubic splines interpolation in the GPU. These approaches exploit the parallel aspects of the SRP-PHAT, allowing real-time execution for large search grids. Comparing our GPU approaches against traditional multithreaded CPU approaches, results show a speed up of <inline-formula id="inline-formula1-1094342012452166">
<mml:math id="mml-inline1-1094342012452166">
<mml:mn>275</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula> for the FDSP, and <inline-formula id="inline-formula2-1094342012452166">
<mml:math id="mml-inline2-1094342012452166">
<mml:mn>70</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula> for the TDSP with interpolation, when comparing high-end GPUs with high-end CPUs.</p>
</abstract>
<kwd-group>
<kwd>GPGPU</kwd>
<kwd>CUDA</kwd>
<kwd>SRP-PHAT</kwd>
<kwd>audio processing</kwd>
<kwd>cubic splines interpolation</kwd>
<kwd>high performance</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="section1-1094342012452166">
<title>1. Introduction</title>
<p>Sound source localization (SSL) is an important topic in microphone array signal processing applications, such as beamforming for speech capture in teleconferencing (<xref ref-type="bibr" rid="bibr2-1094342012452166">Brandstein and Ward, 2001</xref>), distant speech recognition (<xref ref-type="bibr" rid="bibr30-1094342012452166">Wöelfel and McDonough, 2009</xref>), or human–computer interaction (<xref ref-type="bibr" rid="bibr6-1094342012452166">Dey et al., 2011</xref>), most of which require real-time processing of the signals. With two microphones, we can find the time difference of arrival (TDOA) using the generalized cross-correlation (GCC) method, which typically involves a frequency weighting function (<xref ref-type="bibr" rid="bibr14-1094342012452166">Knapp and Carter, 1976</xref>). Given a single TDOA estimate determined by two microphone signals, we can then find a hyperboloid in a three-dimensional space of points that share the same TDOA.</p>
<p>For systems with more than two microphones, we can find the source location from a set of TDOAs from different microphone pairs by finding the optimal intersection of the hyperboloids using the maximum-likelihood (<xref ref-type="bibr" rid="bibr1-1094342012452166">Brandstein et al., 1995</xref>) or least-squares (<xref ref-type="bibr" rid="bibr3-1094342012452166">Brandstein et al., 1997</xref>) criteria. These methods rely on the assumption that the individual TDOA estimates are accurate enough to determine the sound source location. Unfortunately, in typical acoustic environments with reverberation, background noise, and interfering sound sources, TDOA estimates can become unreliable making the TDOA-based SSL methods inaccurate (<xref ref-type="bibr" rid="bibr2-1094342012452166">Brandstein and Ward, 2001</xref>).</p>
<p>Alternatively, we can use the <italic>steered response power</italic> (SRP) method (<xref ref-type="bibr" rid="bibr24-1094342012452166">Omologo et al., 1997</xref>; <xref ref-type="bibr" rid="bibr7-1094342012452166">DiBiase, 2000</xref>) as an extension of the GCC method to multiple microphones. The main idea of the SRP is to steer the microphone array to all possible candidate source locations to find the one with the maximum power, typically using some frequency weighting. In particular, the SRP method with the PHAT frequency weighting (SRP-PHAT) has been popular for its robustness against background noise and reverberation (<xref ref-type="bibr" rid="bibr7-1094342012452166">DiBiase, 2000</xref>; <xref ref-type="bibr" rid="bibr2-1094342012452166">Brandstein and Ward, 2001</xref>; <xref ref-type="bibr" rid="bibr9-1094342012452166">Do et al., 2007</xref>). The SRP-PHAT can be computed either in the time domain (<xref ref-type="bibr" rid="bibr24-1094342012452166">Omologo et al., 1997</xref>; <xref ref-type="bibr" rid="bibr7-1094342012452166">DiBiase, 2000</xref>) (TDSP) or in the frequency domain (<xref ref-type="bibr" rid="bibr31-1094342012452166">Zhang et al., 2007</xref>) (FDSP).</p>
<p>The SRP-based methods belong to the category of the search space-based methods such as maximum-likelihood approaches (<xref ref-type="bibr" rid="bibr31-1094342012452166">Zhang et al., 2007</xref>; <xref ref-type="bibr" rid="bibr16-1094342012452166">Lee et al., 2008</xref>) and wideband MUSIC algorithm (<xref ref-type="bibr" rid="bibr29-1094342012452166">Tung et al., 1999</xref>). In general, search space-based techniques have a computational complexity proportional to the number of microphones in the array, and mainly the number of candidate source locations in the discretized search space, making them almost impracticable for real-time speech processing applications.</p>
<p>Solutions to this problem have been proposed by some authors. <xref ref-type="bibr" rid="bibr15-1094342012452166">Lee and Kalker (2010</xref>) showed that by using Intel’s Integrated Performance Primitives (IPP, a multi-threaded library) to couple common operations of the FDSP together, one can reduce the CPU usage from 39.2% to 14.4%. Alternatively, <xref ref-type="bibr" rid="bibr8-1094342012452166">Do and Silverman (2007</xref>) proposed an iterative hierarchical method called coarse-to-fine region contraction (CFRC) to reduce the effective number of candidate locations for the SRP-PHAT. Their approach may achieve a runtime reduction up to three orders of magnitude for low signal-to-noise ratio (SNR) scenario, but the speedup decreases as the SNR increases. Furthermore, the sound source is assumed to be stationary. In our previous work (<xref ref-type="bibr" rid="bibr5-1094342012452166">da Silveira et al., 2010</xref>) we proposed a GPU implementation of the FDSP which exploited a level of parallelism of the algorithm.</p>
<p>Using GPUs for audio signal processing has been a growing practice since the advent of general-purpose programmable devices. As an example, many works have been devoted to the one-dimensional discrete Fourier transform (DFT) (<xref ref-type="bibr" rid="bibr11-1094342012452166">Govindara et al., 2008</xref>; <xref ref-type="bibr" rid="bibr20-1094342012452166">NVIDIA Corporation, 2011b</xref>), audio synthesis and finite impulse response (FIR) filtering (<xref ref-type="bibr" rid="bibr25-1094342012452166">Savioja et al., 2011</xref>), and audio rendering (<xref ref-type="bibr" rid="bibr28-1094342012452166">Tsingos, 2009</xref>). In this paper we present two approaches for SSL by computing the SRP-PHAT using CUDA (<xref ref-type="bibr" rid="bibr21-1094342012452166">NVIDIA Corporation, 2011c</xref>): the TDSP with interpolation (TDISP) and the FDSP, which is an improved version of the work in <xref ref-type="bibr" rid="bibr5-1094342012452166">da Silveira et al. (2010</xref>). When comparing our GPU-based approaches with CPU-based multithreaded implementations using OpenMP, the FDSP shows a speed-up of <inline-formula id="inline-formula3-1094342012452166">
<mml:math id="mml-inline3-1094342012452166">
<mml:mn>275</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>, and the TDISP shows a speed-up of <inline-formula id="inline-formula4-1094342012452166">
<mml:math id="mml-inline4-1094342012452166">
<mml:mn>70</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>. In addition, our implementations also provide the advantage of leaving the CPU available for any other kind of processes, and the advantage of achieving the speed-ups without modifying the algorithms formulations, which could allow further speed improvements using methods for search space reduction (<xref ref-type="bibr" rid="bibr8-1094342012452166">Do and Silverman, 2007</xref>).</p>
<p>The remainder of this paper is organized as follows. Section 2 reviews the mathematical foundations of the SRP-PHAT algorithm and the interpolation that can be applied to the time domain version. A theoretical analysis of the computational cost of both versions is presented in Section 3. Section 4 describes the main concepts of programming GPUs using NVIDIA’s CUDA model. In Section 5 we present our approach for computing the SRP-PHATs using the GPU. Finally, Section 6 shows the experimental evaluation that demonstrates the efficiency of our GPU algorithms and Section 7 draws some conclusions about the presented work.</p>
</sec>
<sec id="section2-1094342012452166">
<title>2. Sound source localization</title>
<p>For an array of <inline-formula id="inline-formula5-1094342012452166">
<mml:math id="mml-inline5-1094342012452166">
<mml:mi>M</mml:mi>
</mml:math>
</inline-formula> microphones, the signal <inline-formula id="inline-formula6-1094342012452166">
<mml:math id="mml-inline6-1094342012452166">
<mml:msub>
<mml:mi>x</mml:mi>
<mml:mi>m</mml:mi>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula> captured at the <inline-formula id="inline-formula7-1094342012452166">
<mml:math id="mml-inline7-1094342012452166">
<mml:mi>m</mml:mi>
</mml:math>
</inline-formula>th microphone can be modeled as<disp-formula id="disp-formula1-1094342012452166">
<label>1</label>
<mml:math id="mml-disp1-1094342012452166">
<mml:msub>
<mml:mi>x</mml:mi>
<mml:mi>m</mml:mi>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">=</mml:mo>
<mml:msub>
<mml:mi mathvariant="italic">α</mml:mi>
<mml:mi>m</mml:mi>
</mml:msub>
<mml:mi>s</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:msubsup>
<mml:mi>t</mml:mi>
<mml:mi>m</mml:mi>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:msubsup>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">+</mml:mo>
<mml:msub>
<mml:mi>u</mml:mi>
<mml:mi>m</mml:mi>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">,</mml:mo>
</mml:math>
<graphic alternate-form-of="disp-formula1-1094342012452166" xlink:href="10.1177_1094342012452166-eq1.tif"/>
</disp-formula>
</p>
<p>where <inline-formula id="inline-formula8-1094342012452166">
<mml:math id="mml-inline8-1094342012452166">
<mml:mi>s</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula> is the source signal, <inline-formula id="inline-formula9-1094342012452166">
<mml:math id="mml-inline9-1094342012452166">
<mml:msub>
<mml:mi>u</mml:mi>
<mml:mi>m</mml:mi>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula> represents the combination of reverberation, interferences, and background noise, and <inline-formula id="inline-formula10-1094342012452166">
<mml:math id="mml-inline10-1094342012452166">
<mml:msub>
<mml:mi mathvariant="italic">α</mml:mi>
<mml:mi>m</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> and <inline-formula id="inline-formula11-1094342012452166">
<mml:math id="mml-inline11-1094342012452166">
<mml:msubsup>
<mml:mi>t</mml:mi>
<mml:mi>m</mml:mi>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:msubsup>
</mml:math>
</inline-formula> respectively denote the propagation attenuation and delay of the signal <inline-formula id="inline-formula12-1094342012452166">
<mml:math id="mml-inline12-1094342012452166">
<mml:mi>s</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula> from a source location <inline-formula id="inline-formula13-1094342012452166">
<mml:math id="mml-inline13-1094342012452166">
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:math>
</inline-formula> to the <inline-formula id="inline-formula14-1094342012452166">
<mml:math id="mml-inline14-1094342012452166">
<mml:mi>m</mml:mi>
</mml:math>
</inline-formula>th microphone. Equivalently, <xref ref-type="disp-formula" rid="disp-formula1-1094342012452166">Equation (1)</xref> can be represented in the frequency domain as<disp-formula id="disp-formula2-1094342012452166">
<label>2</label>
<mml:math id="mml-disp2-1094342012452166">
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>m</mml:mi>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">=</mml:mo>
<mml:msub>
<mml:mi mathvariant="italic">α</mml:mi>
<mml:mi>m</mml:mi>
</mml:msub>
<mml:mi>S</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:msup>
<mml:mi>e</mml:mi>
<mml:mrow>
<mml:mo stretchy="false">−</mml:mo>
<mml:mi>j</mml:mi>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:msubsup>
<mml:mi mathvariant="italic">τ</mml:mi>
<mml:mi>m</mml:mi>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:msup>
<mml:mo stretchy="false">+</mml:mo>
<mml:msub>
<mml:mi>U</mml:mi>
<mml:mi>m</mml:mi>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">,</mml:mo>
</mml:math>
<graphic alternate-form-of="disp-formula2-1094342012452166" xlink:href="10.1177_1094342012452166-eq2.tif"/>
</disp-formula>
</p>
<p>where <inline-formula id="inline-formula15-1094342012452166">
<mml:math id="mml-inline15-1094342012452166">
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>2</mml:mn>
<mml:mi mathvariant="italic">π</mml:mi>
<mml:mi>f</mml:mi>
<mml:mi>T</mml:mi>
</mml:math>
</inline-formula> is the normalized frequency in radians corresponding to the frequency in <inline-formula id="inline-formula16-1094342012452166">
<mml:math id="mml-inline16-1094342012452166">
<mml:mi>f</mml:mi>
</mml:math>
</inline-formula> Hz of the continuous-time signal <inline-formula id="inline-formula17-1094342012452166">
<mml:math id="mml-inline17-1094342012452166">
<mml:msub>
<mml:mi>x</mml:mi>
<mml:mi>m</mml:mi>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula> that is sampled with the sampling period of <inline-formula id="inline-formula18-1094342012452166">
<mml:math id="mml-inline18-1094342012452166">
<mml:mi>T</mml:mi>
</mml:math>
</inline-formula> seconds, i.e. <inline-formula id="inline-formula19-1094342012452166">
<mml:math id="mml-inline19-1094342012452166">
<mml:msub>
<mml:mi>x</mml:mi>
<mml:mi>m</mml:mi>
</mml:msub>
<mml:mo stretchy="false">[</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">]</mml:mo>
<mml:mo stretchy="false">=</mml:mo>
<mml:msub>
<mml:mi>x</mml:mi>
<mml:mi>m</mml:mi>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mi>T</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula> and <inline-formula id="inline-formula20-1094342012452166">
<mml:math id="mml-inline20-1094342012452166">
<mml:msubsup>
<mml:mi mathvariant="italic">τ</mml:mi>
<mml:mi>m</mml:mi>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:msubsup>
<mml:mo stretchy="false">=</mml:mo>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msubsup>
<mml:mi>t</mml:mi>
<mml:mi>m</mml:mi>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
<mml:mi>T</mml:mi>
</mml:mfrac>
</mml:mrow>
</mml:math>
</inline-formula>. We assume that the signal is sampled above the Nyquist rate, i.e. <inline-formula id="inline-formula21-1094342012452166">
<mml:math id="mml-inline21-1094342012452166">
<mml:mi>T</mml:mi>
<mml:mo stretchy="false">&lt;</mml:mo>
<mml:mrow>
<mml:mfrac>
<mml:mn>1</mml:mn>
<mml:mrow>
<mml:mn>2</mml:mn>
<mml:msub>
<mml:mi>f</mml:mi>
<mml:mrow>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="normal">m</mml:mi>
<mml:mi mathvariant="normal">a</mml:mi>
<mml:mi mathvariant="normal">x</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:math>
</inline-formula> where <inline-formula id="inline-formula22-1094342012452166">
<mml:math id="mml-inline22-1094342012452166">
<mml:msub>
<mml:mi>f</mml:mi>
<mml:mrow>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="normal">m</mml:mi>
<mml:mi mathvariant="normal">a</mml:mi>
<mml:mi mathvariant="normal">x</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula> is the maximum frequency of the signal.</p>
<p>Given a vector of Fourier transforms of observed signals, <inline-formula id="inline-formula23-1094342012452166">
<mml:math id="mml-inline23-1094342012452166">
<mml:mo fence="false" stretchy="false">{</mml:mo>
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">,</mml:mo>
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">,</mml:mo>
<mml:mo stretchy="false">…</mml:mo>
<mml:mo stretchy="false">,</mml:mo>
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>M</mml:mi>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo fence="false" stretchy="false">}</mml:mo>
</mml:math>
</inline-formula>, SSL therefore may be seen as the problem of finding a source location <inline-formula id="inline-formula24-1094342012452166">
<mml:math id="mml-inline24-1094342012452166">
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:math>
</inline-formula> that satisfies some optimality criteria such as maximum-likelihood (<xref ref-type="bibr" rid="bibr31-1094342012452166">Zhang et al., 2007</xref>; <xref ref-type="bibr" rid="bibr15-1094342012452166">Lee and Kalker, 2010</xref>) or maximum power of the filter-and-sum beamformer such as the SRP-PHAT method (<xref ref-type="bibr" rid="bibr7-1094342012452166">DiBiase, 2000</xref>).</p>
<p>Next we present the two different versions of the SRP-PHAT that, although being mathematically equivalent, differ in practice. Section 2.1 presents the frequency-domain version adapted by <xref ref-type="bibr" rid="bibr31-1094342012452166">Zhang et al. (2007</xref>). Section 2.2 shows the time domain version, which was first introduced as the global coherence field (GCF) by <xref ref-type="bibr" rid="bibr24-1094342012452166">Omologo et al. (1997</xref>).</p>
<sec id="section3-1094342012452166">
<title>2.1. Frequency domain SRP-PHAT</title>
<p>The SRP-PHAT method finds a source location by comparing the output powers of PHAT-weighted filter-and-sum beamformers of different potential sound source locations in a search region. In the frequency domain (<xref ref-type="bibr" rid="bibr7-1094342012452166">DiBiase, 2000</xref>), the SRP-PHAT of a point <inline-formula id="inline-formula25-1094342012452166">
<mml:math id="mml-inline25-1094342012452166">
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:math>
</inline-formula> in space is defined as<disp-formula id="disp-formula3-1094342012452166">
<label>3</label>
<mml:math id="mml-disp3-1094342012452166">
<mml:mi>P</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">=</mml:mo>
<mml:mrow>
<mml:munderover>
<mml:mo movablelimits="false" stretchy="false">∑</mml:mo>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mi>M</mml:mi>
</mml:munderover>
</mml:mrow>
<mml:mrow>
<mml:munderover>
<mml:mo movablelimits="false" stretchy="false">∑</mml:mo>
<mml:mrow>
<mml:mi>l</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mi>M</mml:mi>
</mml:munderover>
</mml:mrow>
<mml:mrow>
<mml:msubsup>
<mml:mo stretchy="false">∫</mml:mo>
<mml:mn>0</mml:mn>
<mml:mrow>
<mml:mn>2</mml:mn>
<mml:mi mathvariant="italic">π</mml:mi>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>m</mml:mi>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:msubsup>
<mml:mi>X</mml:mi>
<mml:mi>l</mml:mi>
<mml:mo stretchy="false">∗</mml:mo>
</mml:msubsup>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mrow>
<mml:mo>|</mml:mo>
</mml:mrow>
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>m</mml:mi>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:msubsup>
<mml:mi>X</mml:mi>
<mml:mi>l</mml:mi>
<mml:mo stretchy="false">∗</mml:mo>
</mml:msubsup>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mrow>
<mml:mo>|</mml:mo>
</mml:mrow>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
<mml:msup>
<mml:mi>e</mml:mi>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:msubsup>
<mml:mi mathvariant="italic">τ</mml:mi>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:msup>
<mml:mrow>
</mml:mrow>
<mml:mi>d</mml:mi>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
</mml:math>
<graphic alternate-form-of="disp-formula3-1094342012452166" xlink:href="10.1177_1094342012452166-eq3.tif"/>
</disp-formula>
</p>
<p>where <inline-formula id="inline-formula26-1094342012452166">
<mml:math id="mml-inline26-1094342012452166">
<mml:msubsup>
<mml:mi mathvariant="italic">τ</mml:mi>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:msubsup>
<mml:mo stretchy="false">=</mml:mo>
<mml:msubsup>
<mml:mi mathvariant="italic">τ</mml:mi>
<mml:mi>m</mml:mi>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:msubsup>
<mml:mo stretchy="false">−</mml:mo>
<mml:msubsup>
<mml:mi mathvariant="italic">τ</mml:mi>
<mml:mi>l</mml:mi>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:msubsup>
</mml:math>
</inline-formula> is the term representing the TDOA between microphones <inline-formula id="inline-formula27-1094342012452166">
<mml:math id="mml-inline27-1094342012452166">
<mml:mi>m</mml:mi>
</mml:math>
</inline-formula> and <inline-formula id="inline-formula28-1094342012452166">
<mml:math id="mml-inline28-1094342012452166">
<mml:mi>l</mml:mi>
</mml:math>
</inline-formula> and point <inline-formula id="inline-formula29-1094342012452166">
<mml:math id="mml-inline29-1094342012452166">
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:math>
</inline-formula>.</p>
<p>By interchanging the order of integration and summation and using its symmetry, <xref ref-type="bibr" rid="bibr31-1094342012452166">Zhang et al. (2007</xref>) showed that <xref ref-type="disp-formula" rid="disp-formula3-1094342012452166">Equation (3)</xref> is mathematically equivalent to<disp-formula id="disp-formula4-1094342012452166">
<label>4</label>
<mml:math id="mml-disp4-1094342012452166">
<mml:mi>P</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">=</mml:mo>
<mml:mrow>
<mml:msubsup>
<mml:mo stretchy="false">∫</mml:mo>
<mml:mn>0</mml:mn>
<mml:mrow>
<mml:mn>2</mml:mn>
<mml:mi mathvariant="italic">π</mml:mi>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
<mml:msup>
<mml:mfenced close="|" open="|">
<mml:mrow>
<mml:mrow>
<mml:munderover>
<mml:mo movablelimits="false" stretchy="false">∑</mml:mo>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mi>M</mml:mi>
</mml:munderover>
</mml:mrow>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>m</mml:mi>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mrow>
<mml:mo>|</mml:mo>
</mml:mrow>
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>m</mml:mi>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mrow>
<mml:mo>|</mml:mo>
</mml:mrow>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
<mml:msup>
<mml:mi>e</mml:mi>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:msubsup>
<mml:mi mathvariant="italic">τ</mml:mi>
<mml:mi>m</mml:mi>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:mfenced>
<mml:mn>2</mml:mn>
</mml:msup>
<mml:mrow>
</mml:mrow>
<mml:mi>d</mml:mi>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
</mml:math>
<graphic alternate-form-of="disp-formula4-1094342012452166" xlink:href="10.1177_1094342012452166-eq4.tif"/>
</disp-formula>
</p>
<p>which reduces the number of computations of the SRP-PHAT by a factor of <inline-formula id="inline-formula30-1094342012452166">
<mml:math id="mml-inline30-1094342012452166">
<mml:mi>M</mml:mi>
</mml:math>
</inline-formula>. After <inline-formula id="inline-formula31-1094342012452166">
<mml:math id="mml-inline31-1094342012452166">
<mml:mi>P</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula> has been computed for all candidate positions using either <xref ref-type="disp-formula" rid="disp-formula3-1094342012452166">Equation (3)</xref> or <xref ref-type="disp-formula" rid="disp-formula4-1094342012452166">Equation (4)</xref>, we can estimate the sound source location as<disp-formula id="disp-formula5-1094342012452166">
<label>5</label>
<mml:math id="mml-disp5-1094342012452166">
<mml:mover accent="true">
<mml:mi>q</mml:mi>
<mml:mo accent="true" stretchy="false">ˆ</mml:mo>
</mml:mover>
<mml:mo stretchy="false">=</mml:mo>
<mml:munder>
<mml:mrow>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="normal">a</mml:mi>
<mml:mi mathvariant="normal">r</mml:mi>
<mml:mi mathvariant="normal">g</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="normal">m</mml:mi>
<mml:mi mathvariant="normal">a</mml:mi>
<mml:mi mathvariant="normal">x</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mo stretchy="false">∈</mml:mo>
<mml:mrow>
<mml:mi mathvariant="script">Q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:munder>
<mml:mi>P</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">,</mml:mo>
</mml:math>
<graphic alternate-form-of="disp-formula5-1094342012452166" xlink:href="10.1177_1094342012452166-eq5.tif"/>
</disp-formula>
</p>
<p>where <inline-formula id="inline-formula32-1094342012452166">
<mml:math id="mml-inline32-1094342012452166">
<mml:mrow>
<mml:mi mathvariant="script">Q</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula> denotes a set of points in space that represent all candidate locations.</p>
</sec>
<sec id="section4-1094342012452166">
<title>2.2. Time domain SRP-PHAT</title>
<p>According to the original proposal by <xref ref-type="bibr" rid="bibr7-1094342012452166">DiBiase (2000</xref>), the SRP-PHAT can also be computed by summing the PHAT-weighted generalized cross correlations (GCC-PHAT) of all possible pairs of the set of microphones. The GCC-PHAT (<xref ref-type="bibr" rid="bibr14-1094342012452166">Knapp and Carter, 1976</xref>) between two microphones <inline-formula id="inline-formula33-1094342012452166">
<mml:math id="mml-inline33-1094342012452166">
<mml:mi>m</mml:mi>
</mml:math>
</inline-formula> and <inline-formula id="inline-formula34-1094342012452166">
<mml:math id="mml-inline34-1094342012452166">
<mml:mi>l</mml:mi>
</mml:math>
</inline-formula> may be defined as<disp-formula id="disp-formula6-1094342012452166">
<label>6</label>
<mml:math id="mml-disp6-1094342012452166">
<mml:msub>
<mml:mi>R</mml:mi>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">τ</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">=</mml:mo>
<mml:mrow>
<mml:mfrac>
<mml:mn>1</mml:mn>
<mml:mrow>
<mml:mn>2</mml:mn>
<mml:mi mathvariant="italic">π</mml:mi>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
<mml:mrow>
<mml:msubsup>
<mml:mo stretchy="false">∫</mml:mo>
<mml:mn>0</mml:mn>
<mml:mrow>
<mml:mn>2</mml:mn>
<mml:mi mathvariant="italic">π</mml:mi>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>m</mml:mi>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:msubsup>
<mml:mi>X</mml:mi>
<mml:mi>l</mml:mi>
<mml:mo stretchy="false">∗</mml:mo>
</mml:msubsup>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mrow>
<mml:mo>|</mml:mo>
</mml:mrow>
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>k</mml:mi>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:msubsup>
<mml:mi>X</mml:mi>
<mml:mi>l</mml:mi>
<mml:mo stretchy="false">∗</mml:mo>
</mml:msubsup>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mrow>
<mml:mo>|</mml:mo>
</mml:mrow>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
<mml:msup>
<mml:mi>e</mml:mi>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:mi mathvariant="italic">τ</mml:mi>
</mml:mrow>
</mml:msup>
<mml:mrow>
</mml:mrow>
<mml:mi>d</mml:mi>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
</mml:math>
<graphic alternate-form-of="disp-formula6-1094342012452166" xlink:href="10.1177_1094342012452166-eq6.tif"/>
</disp-formula>
</p>
<p>We can note that the SRP-PHAT in <xref ref-type="disp-formula" rid="disp-formula3-1094342012452166">Equation (3)</xref> is equivalent to the summation of <xref ref-type="disp-formula" rid="disp-formula6-1094342012452166">Equation (6)</xref> over all microphone pairs except for the scale factor. This allows us to represent the SRP-PHAT in terms of <xref ref-type="disp-formula" rid="disp-formula6-1094342012452166">Equation (6)</xref><disp-formula id="disp-formula7-1094342012452166">
<label>7</label>
<mml:math id="mml-disp7-1094342012452166">
<mml:mi>P</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">=</mml:mo>
<mml:mrow>
<mml:munderover>
<mml:mo movablelimits="false" stretchy="false">∑</mml:mo>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mi>M</mml:mi>
</mml:munderover>
</mml:mrow>
<mml:mrow>
<mml:munderover>
<mml:mo movablelimits="false" stretchy="false">∑</mml:mo>
<mml:mrow>
<mml:mi>l</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mi>m</mml:mi>
<mml:mo stretchy="false">+</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mi>M</mml:mi>
</mml:munderover>
</mml:mrow>
<mml:msub>
<mml:mi>R</mml:mi>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:msubsup>
<mml:mi mathvariant="italic">τ</mml:mi>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:msubsup>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">,</mml:mo>
</mml:math>
<graphic alternate-form-of="disp-formula7-1094342012452166" xlink:href="10.1177_1094342012452166-eq7.tif"/>
</disp-formula>
</p>
<p>where the number of summations has been further reduced from <inline-formula id="inline-formula35-1094342012452166">
<mml:math id="mml-inline35-1094342012452166">
<mml:msup>
<mml:mi>M</mml:mi>
<mml:mn>2</mml:mn>
</mml:msup>
</mml:math>
</inline-formula> to <inline-formula id="inline-formula36-1094342012452166">
<mml:math id="mml-inline36-1094342012452166">
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
<mml:mrow>
<mml:mo>/</mml:mo>
</mml:mrow>
<mml:mn>2</mml:mn>
</mml:math>
</inline-formula>, without affecting the SSL results, owing to the symmetry of the GCC-PHAT in <xref ref-type="disp-formula" rid="disp-formula6-1094342012452166">Equation (6)</xref>.</p>
<p>Although <xref ref-type="disp-formula" rid="disp-formula3-1094342012452166">Equations (3)</xref>, (<xref ref-type="disp-formula" rid="disp-formula4-1094342012452166">4</xref>), and (<xref ref-type="disp-formula" rid="disp-formula7-1094342012452166">7</xref>) are mathematically equivalent, the computational complexity of a discrete implementation of <xref ref-type="disp-formula" rid="disp-formula7-1094342012452166">Equation (7)</xref> costs less than the corresponding discrete versions of <xref ref-type="disp-formula" rid="disp-formula3-1094342012452166">Equations (3)</xref> or (<xref ref-type="disp-formula" rid="disp-formula4-1094342012452166">4</xref>). This is due to the fact that the GCC-PHAT in <xref ref-type="disp-formula" rid="disp-formula6-1094342012452166">Equation (6)</xref> is independent of the source location <inline-formula id="inline-formula37-1094342012452166">
<mml:math id="mml-inline37-1094342012452166">
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:math>
</inline-formula>. Thus, for the double summation in <xref ref-type="disp-formula" rid="disp-formula7-1094342012452166">Equation (7)</xref>, all we need is to access memory positions of <inline-formula id="inline-formula38-1094342012452166">
<mml:math id="mml-inline38-1094342012452166">
<mml:msub>
<mml:mi>R</mml:mi>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">τ</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula> corresponding to the TDOA <inline-formula id="inline-formula39-1094342012452166">
<mml:math id="mml-inline39-1094342012452166">
<mml:msubsup>
<mml:mi mathvariant="italic">τ</mml:mi>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:msubsup>
</mml:math>
</inline-formula> for a proposed source location <inline-formula id="inline-formula40-1094342012452166">
<mml:math id="mml-inline40-1094342012452166">
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:math>
</inline-formula> once <inline-formula id="inline-formula41-1094342012452166">
<mml:math id="mml-inline41-1094342012452166">
<mml:msub>
<mml:mi>R</mml:mi>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">τ</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula> is computed for all microphone pairs. In contrast, the frequency-domain representations in <xref ref-type="disp-formula" rid="disp-formula3-1094342012452166">Equations (3)</xref> and (<xref ref-type="disp-formula" rid="disp-formula4-1094342012452166">4</xref>) require complex multiplications and evaluation of an integral for each source location <inline-formula id="inline-formula42-1094342012452166">
<mml:math id="mml-inline42-1094342012452166">
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:math>
</inline-formula>. The computational complexity for each of these methods will be described in more detail in Section 3.</p>
</sec>
<sec id="section5-1094342012452166">
<title>2.3. Cubic spline interpolation for TDSP</title>
<p>Although the computational complexity of the TDSP algorithm is much less than that of the FDSP, it suffers the loss of its accuracy caused by a quantization process in the TDOAs, i.e.<inline-formula id="inline-formula43-1094342012452166">
<mml:math id="mml-inline43-1094342012452166">
<mml:mi mathvariant="italic">τ</mml:mi>
</mml:math>
</inline-formula> in <xref ref-type="disp-formula" rid="disp-formula6-1094342012452166">Equation (6)</xref> should be an integer as a sample index for the discrete time domain signal whereas <inline-formula id="inline-formula44-1094342012452166">
<mml:math id="mml-inline44-1094342012452166">
<mml:msubsup>
<mml:mi mathvariant="italic">τ</mml:mi>
<mml:mi>m</mml:mi>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:msubsup>
</mml:math>
</inline-formula> in <xref ref-type="disp-formula" rid="disp-formula3-1094342012452166">Equation (3)</xref> can have any precision that the computing environment allows. Therefore, it is often interesting to use some kind of interpolation technique to increase its accuracy. For instance, <xref ref-type="bibr" rid="bibr27-1094342012452166">Tervo and Lokki (2008</xref>) compared parabolic fitting, exponential fitting and Fourier-interpolation methods, concluding that the exponential fitting was the best among the three. <xref ref-type="bibr" rid="bibr26-1094342012452166">Silverman et al. (2005</xref>) claimed that using 64:1 FIR filter interpolation, the precision loss in the TDSP becomes negligible according to their experiments. However, they did not provide any mathematical proof or analysis for satisfying this condition. Furthermore, <xref ref-type="bibr" rid="bibr8-1094342012452166">Do and Silverman (2007</xref>) used the cubic spline interpolation (CSI) algorithm, which is shown to be as precise as the FIR filter interpolation but faster. In this work we have also chosen the CSI for interpolating the SRP-PHAT for two reasons: it provides reasonably accurate results and is well suited for GPU implementation due to already existing fast GPU-based tridiagonal system solvers, which is a crucial step of the CSI and is to be detailed next.</p>
<p>First, one may choose among some variations of the CSI, depending on the boundary conditions. We found that varying these conditions has negligible impact on the final result of the TDISP, so we chose the natural splines conditions, since it simplifies the GPU implementation as will be shown next. In addition, from this point on, we treat the GCC-PHAT <inline-formula id="inline-formula45-1094342012452166">
<mml:math id="mml-inline45-1094342012452166">
<mml:msub>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">R</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula> as a discrete-time vector instead of a continuous variable.</p>
<p>For the CSI implementation, despite the fact that it is a simple process itself, there are some details when it comes to applying interpolation to the SRP-PHAT algorithm. Since the delay is quantized through the sampling of the continuous signal prior to accessing the vector <inline-formula id="inline-formula46-1094342012452166">
<mml:math id="mml-inline46-1094342012452166">
<mml:msub>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">R</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula>, the GCC-PHAT values are the candidates for the interpolation. Furthermore, we may note that when summing the GCC-PHATs using <xref ref-type="disp-formula" rid="disp-formula7-1094342012452166">Equation (7)</xref>, the range of TDOAs that will actually be used to access <inline-formula id="inline-formula47-1094342012452166">
<mml:math id="mml-inline47-1094342012452166">
<mml:msub>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">R</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula> is smaller than the range of values it represents. In addition, if we compute the GCC-PHAT using the DFT as in <xref ref-type="disp-formula" rid="disp-formula6-1094342012452166">Equation (6)</xref>, then the values for negative TDOAs are wrapped around and appear at the end of the vector <inline-formula id="inline-formula48-1094342012452166">
<mml:math id="mml-inline48-1094342012452166">
<mml:msub>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">R</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula>. Therefore, we may chose only a set of its values for the interpolation and properly adjust the values for the negative TDOAs, that is<disp-formula id="disp-formula8-1094342012452166">
<label>8</label>
<mml:math id="mml-disp8-1094342012452166">
<mml:msup>
<mml:msub>
<mml:mi>R</mml:mi>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>′</mml:mo>
</mml:msup>
<mml:mo stretchy="false">[</mml:mo>
<mml:mi>i</mml:mi>
<mml:mo stretchy="false">]</mml:mo>
<mml:mo stretchy="false">=</mml:mo>
<mml:msub>
<mml:mi>R</mml:mi>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">[</mml:mo>
<mml:mi>j</mml:mi>
<mml:mo stretchy="false">]</mml:mo>
<mml:mo stretchy="false">,</mml:mo>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="normal">w</mml:mi>
<mml:mi mathvariant="normal">h</mml:mi>
<mml:mi mathvariant="normal">e</mml:mi>
<mml:mi mathvariant="normal">r</mml:mi>
<mml:mi mathvariant="normal">e</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mfenced close="" open="{">
<mml:mrow>
<mml:mtable columnspacing="1em" rowspacing="4pt">
<mml:mtr>
<mml:mtd>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mi>i</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="normal">i</mml:mi>
<mml:mi mathvariant="normal">f</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mn>0</mml:mn>
<mml:mo stretchy="false">≤</mml:mo>
<mml:mi>i</mml:mi>
<mml:mo stretchy="false">≤</mml:mo>
<mml:mi>V</mml:mi>
</mml:mrow>
</mml:mtd>
<mml:mtd>
<mml:mrow>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mi>N</mml:mi>
<mml:mo stretchy="false">+</mml:mo>
<mml:mi>i</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="normal">i</mml:mi>
<mml:mi mathvariant="normal">f</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mo stretchy="false">−</mml:mo>
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">≤</mml:mo>
<mml:mi>i</mml:mi>
<mml:mo stretchy="false">≤</mml:mo>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:mtd>
<mml:mtd>
<mml:mrow>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mrow>
</mml:mfenced>
</mml:math>
<graphic alternate-form-of="disp-formula8-1094342012452166" xlink:href="10.1177_1094342012452166-eq8.tif"/>
</disp-formula>
</p>
<p>for <inline-formula id="inline-formula49-1094342012452166">
<mml:math id="mml-inline49-1094342012452166">
<mml:mi>i</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mo stretchy="false">−</mml:mo>
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mo stretchy="false">−</mml:mo>
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">+</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mo stretchy="false">…</mml:mo>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>0</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mo stretchy="false">…</mml:mo>
<mml:mo stretchy="false">,</mml:mo>
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mi>V</mml:mi>
</mml:math>
</inline-formula>, where <inline-formula id="inline-formula50-1094342012452166">
<mml:math id="mml-inline50-1094342012452166">
<mml:mi>V</mml:mi>
</mml:math>
</inline-formula> is set to the largest possible absolute value of TDOA given the microphone positions and search grid coordinates and <inline-formula id="inline-formula51-1094342012452166">
<mml:math id="mml-inline51-1094342012452166">
<mml:mi>N</mml:mi>
</mml:math>
</inline-formula> denotes the DFT length.</p>
<p>In particular, it can be noted that the largest possible TDOA value occurs for the points at the so-called ‘end-fire’ configuration where the points are located on the line that connects the microphone pair with the largest spacing, and that are also not in between them. In this case, the largest possible TDOA can be calculated as<disp-formula id="disp-formula9-1094342012452166">
<label>9</label>
<mml:math id="mml-disp9-1094342012452166">
<mml:msub>
<mml:mi>V</mml:mi>
<mml:mrow>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="normal">m</mml:mi>
<mml:mi mathvariant="normal">a</mml:mi>
<mml:mi mathvariant="normal">x</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">=</mml:mo>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:mfenced close="∥" open="∥">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">x</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo stretchy="false">−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">x</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:mfenced>
</mml:mrow>
<mml:mrow>
<mml:mi>C</mml:mi>
<mml:mi>T</mml:mi>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
<mml:mo stretchy="false">,</mml:mo>
</mml:math>
<graphic alternate-form-of="disp-formula9-1094342012452166" xlink:href="10.1177_1094342012452166-eq9.tif"/>
</disp-formula>
</p>
<p>where <inline-formula id="inline-formula52-1094342012452166">
<mml:math id="mml-inline52-1094342012452166">
<mml:msub>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">x</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:math>
</inline-formula> and <inline-formula id="inline-formula53-1094342012452166">
<mml:math id="mml-inline53-1094342012452166">
<mml:msub>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">x</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:math>
</inline-formula> are the positions of microphones with the largest spacing, <inline-formula id="inline-formula54-1094342012452166">
<mml:math id="mml-inline54-1094342012452166">
<mml:mo stretchy="false">∥</mml:mo>
<mml:mo stretchy="false">⋅</mml:mo>
<mml:mo stretchy="false">∥</mml:mo>
</mml:math>
</inline-formula> denotes the Euclidean distance and <inline-formula id="inline-formula55-1094342012452166">
<mml:math id="mml-inline55-1094342012452166">
<mml:mi>C</mml:mi>
</mml:math>
</inline-formula> is the speed of sound. Given this, <inline-formula id="inline-formula56-1094342012452166">
<mml:math id="mml-inline56-1094342012452166">
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:msub>
<mml:mi>V</mml:mi>
<mml:mrow>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="normal">m</mml:mi>
<mml:mi mathvariant="normal">a</mml:mi>
<mml:mi mathvariant="normal">x</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula> is a plausible choice especially when the search region is not static along the entire application. Note, however, that setting <inline-formula id="inline-formula57-1094342012452166">
<mml:math id="mml-inline57-1094342012452166">
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:msub>
<mml:mi>V</mml:mi>
<mml:mrow>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="normal">m</mml:mi>
<mml:mi mathvariant="normal">a</mml:mi>
<mml:mi mathvariant="normal">x</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula> requires higher computational cost of the interpolation process especially when the range of the actual TDOA values for the given microphone configuration and search space are much smaller than <inline-formula id="inline-formula58-1094342012452166">
<mml:math id="mml-inline58-1094342012452166">
<mml:msub>
<mml:mi>V</mml:mi>
<mml:mrow>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="normal">m</mml:mi>
<mml:mi mathvariant="normal">a</mml:mi>
<mml:mi mathvariant="normal">x</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula>. Considering this we can further decrease the value of <inline-formula id="inline-formula59-1094342012452166">
<mml:math id="mml-inline59-1094342012452166">
<mml:mi>V</mml:mi>
</mml:math>
</inline-formula> by selecting<disp-formula id="disp-formula10-1094342012452166">
<label>10</label>
<mml:math id="mml-disp10-1094342012452166">
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:munder>
<mml:mrow>
<mml:mfenced close="⌉" open="⌈">
<mml:mrow>
<mml:mo form="prefix" movablelimits="true">max</mml:mo>
<mml:mfenced close=")" open="(">
<mml:mrow>
<mml:mfenced close="|" open="|">
<mml:mrow>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msubsup>
<mml:mi mathvariant="italic">τ</mml:mi>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
<mml:mi>T</mml:mi>
</mml:mfrac>
</mml:mrow>
</mml:mrow>
</mml:mfenced>
</mml:mrow>
</mml:mfenced>
</mml:mrow>
</mml:mfenced>
</mml:mrow>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mo stretchy="false">+</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">≤</mml:mo>
<mml:mi>l</mml:mi>
<mml:mo stretchy="false">≤</mml:mo>
<mml:mi>M</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">≤</mml:mo>
<mml:mi>m</mml:mi>
<mml:mo stretchy="false">≤</mml:mo>
<mml:mi>M</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mo stretchy="false">∈</mml:mo>
<mml:mrow>
<mml:mi mathvariant="script">Q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:mover>
</mml:mrow>
</mml:mover>
</mml:mrow>
</mml:munder>
<mml:mo stretchy="false">,</mml:mo>
</mml:math>
<graphic alternate-form-of="disp-formula10-1094342012452166" xlink:href="10.1177_1094342012452166-eq10.tif"/>
</disp-formula>
</p>
<p>which can be computed pre-runtime. However, since it depends on the search region <inline-formula id="inline-formula60-1094342012452166">
<mml:math id="mml-inline60-1094342012452166">
<mml:mrow>
<mml:mi mathvariant="script">Q</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula>, it must be re-computed if the search region is changed dynamically.</p>
<p>Once <inline-formula id="inline-formula61-1094342012452166">
<mml:math id="mml-inline61-1094342012452166">
<mml:msub>
<mml:mrow>
<mml:mrow>
<mml:msup>
<mml:mi mathvariant="bold">R</mml:mi>
<mml:mo>′</mml:mo>
</mml:msup>
</mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula> has been computed, it is then possible to interpolate between its values using a CSI algorithm in order to obtain <inline-formula id="inline-formula62-1094342012452166">
<mml:math id="mml-inline62-1094342012452166">
<mml:msubsup>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">R</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>C</mml:mi>
<mml:mi>S</mml:mi>
<mml:mi>I</mml:mi>
</mml:mrow>
</mml:msubsup>
</mml:math>
</inline-formula>, a length <inline-formula id="inline-formula63-1094342012452166">
<mml:math id="mml-inline63-1094342012452166">
<mml:mo stretchy="false">(</mml:mo>
<mml:mn>2</mml:mn>
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
<mml:mi>E</mml:mi>
<mml:mo stretchy="false">+</mml:mo>
<mml:mn>1</mml:mn>
</mml:math>
</inline-formula> interpolated GCC-PHAT for each pair of microphones with <inline-formula id="inline-formula64-1094342012452166">
<mml:math id="mml-inline64-1094342012452166">
<mml:mi>E</mml:mi>
</mml:math>
</inline-formula> being the interpolation factor. This can be done by solving a <inline-formula id="inline-formula65-1094342012452166">
<mml:math id="mml-inline65-1094342012452166">
<mml:mo stretchy="false">(</mml:mo>
<mml:mn>2</mml:mn>
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
<mml:mrow>
<mml:mrow>
<mml:mtext mathvariant="normal"> </mml:mtext>
<mml:mi mathvariant="normal">b</mml:mi>
<mml:mi mathvariant="normal">y</mml:mi>
<mml:mtext mathvariant="normal"> </mml:mtext>
</mml:mrow>
</mml:mrow>
<mml:mo stretchy="false">(</mml:mo>
<mml:mn>2</mml:mn>
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula> tridiagonal system, as in <xref ref-type="disp-formula" rid="disp-formula11-1094342012452166">Equation (11)</xref> and doing some algebraic operations:<disp-formula id="disp-formula11-1094342012452166">
<label>11</label>
<mml:math id="mml-disp11-1094342012452166">
<mml:mfenced close="]" open="[">
<mml:mrow>
<mml:mtable columnspacing="1em" rowspacing="4pt">
<mml:mtr>
<mml:mtd>
<mml:mn>4</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mn>1</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mn>0</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mo stretchy="false">⋯</mml:mo>
</mml:mtd>
<mml:mtd>
<mml:mn>0</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mn>0</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mn>0</mml:mn>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mn>1</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mn>4</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mn>1</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mo stretchy="false">⋯</mml:mo>
</mml:mtd>
<mml:mtd>
<mml:mn>0</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mn>0</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mn>0</mml:mn>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mn>0</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mn>1</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mn>4</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mo stretchy="false">⋯</mml:mo>
</mml:mtd>
<mml:mtd>
<mml:mn>0</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mn>0</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mn>0</mml:mn>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mo stretchy="false">⋮</mml:mo>
</mml:mtd>
<mml:mtd>
<mml:mo stretchy="false">⋮</mml:mo>
</mml:mtd>
<mml:mtd>
<mml:mo stretchy="false">⋮</mml:mo>
</mml:mtd>
<mml:mtd>
<mml:mo stretchy="false">⋱</mml:mo>
</mml:mtd>
<mml:mtd>
<mml:mo stretchy="false">⋮</mml:mo>
</mml:mtd>
<mml:mtd>
<mml:mo stretchy="false">⋮</mml:mo>
</mml:mtd>
<mml:mtd>
<mml:mo stretchy="false">⋮</mml:mo>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mn>0</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mn>0</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mn>0</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mo stretchy="false">⋯</mml:mo>
</mml:mtd>
<mml:mtd>
<mml:mn>4</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mn>1</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mn>0</mml:mn>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mn>0</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mn>0</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mn>0</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mo stretchy="false">⋯</mml:mo>
</mml:mtd>
<mml:mtd>
<mml:mn>1</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mn>4</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mn>1</mml:mn>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mn>0</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mn>0</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mn>0</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mo stretchy="false">⋯</mml:mo>
</mml:mtd>
<mml:mtd>
<mml:mn>0</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mn>1</mml:mn>
</mml:mtd>
<mml:mtd>
<mml:mn>4</mml:mn>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mrow>
</mml:mrow>
</mml:mtd>
<mml:mtd>
<mml:mrow>
</mml:mrow>
</mml:mtd>
<mml:mtd>
<mml:mrow>
</mml:mrow>
</mml:mtd>
<mml:mtd>
<mml:mrow>
</mml:mrow>
</mml:mtd>
<mml:mtd>
<mml:mrow>
</mml:mrow>
</mml:mtd>
<mml:mtd>
<mml:mrow>
</mml:mrow>
</mml:mtd>
<mml:mtd>
<mml:mrow>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mrow>
</mml:mfenced>
<mml:mo stretchy="false">×</mml:mo>
<mml:mfenced close="]" open="[">
<mml:mrow>
<mml:mtable columnspacing="1em" rowspacing="4pt">
<mml:mtr>
<mml:mtd>
<mml:mrow>
<mml:mi mathvariant="normal">Φ</mml:mi>
<mml:mo stretchy="false">[</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">]</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mrow>
<mml:mi mathvariant="normal">Φ</mml:mi>
<mml:mo stretchy="false">[</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo stretchy="false">]</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mrow>
<mml:mi mathvariant="normal">Φ</mml:mi>
<mml:mo stretchy="false">[</mml:mo>
<mml:mn>3</mml:mn>
<mml:mo stretchy="false">]</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mo stretchy="false">⋮</mml:mo>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mrow>
<mml:mi mathvariant="normal">Φ</mml:mi>
<mml:mo stretchy="false">[</mml:mo>
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>3</mml:mn>
<mml:mo stretchy="false">]</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mrow>
<mml:mi mathvariant="normal">Φ</mml:mi>
<mml:mo stretchy="false">[</mml:mo>
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo stretchy="false">]</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mrow>
<mml:mi mathvariant="normal">Φ</mml:mi>
<mml:mo stretchy="false">[</mml:mo>
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">]</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mrow>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mrow>
</mml:mfenced>
<mml:mo stretchy="false">=</mml:mo>
<mml:mfenced close="]" open="[">
<mml:mrow>
<mml:mtable columnspacing="1em" rowspacing="4pt">
<mml:mtr>
<mml:mtd>
<mml:mrow>
<mml:mi>Y</mml:mi>
<mml:mo stretchy="false">[</mml:mo>
<mml:mn>0</mml:mn>
<mml:mo stretchy="false">]</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mrow>
<mml:mi>Y</mml:mi>
<mml:mo stretchy="false">[</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">]</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mrow>
<mml:mi>Y</mml:mi>
<mml:mo stretchy="false">[</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo stretchy="false">]</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mo stretchy="false">⋮</mml:mo>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mrow>
<mml:mi>Y</mml:mi>
<mml:mo stretchy="false">[</mml:mo>
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>4</mml:mn>
<mml:mo stretchy="false">]</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mrow>
<mml:mi>Y</mml:mi>
<mml:mo stretchy="false">[</mml:mo>
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>3</mml:mn>
<mml:mo stretchy="false">]</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mrow>
<mml:mi>Y</mml:mi>
<mml:mo stretchy="false">[</mml:mo>
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo stretchy="false">]</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mrow>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mrow>
</mml:mfenced>
</mml:math>
<graphic alternate-form-of="disp-formula11-1094342012452166" xlink:href="10.1177_1094342012452166-eq11.tif"/>
</disp-formula>
</p>
<p>The right-hand side vector <inline-formula id="inline-formula66-1094342012452166">
<mml:math id="mml-inline66-1094342012452166">
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">Y</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:math>
</inline-formula> can be determined through some operations on <inline-formula id="inline-formula67-1094342012452166">
<mml:math id="mml-inline67-1094342012452166">
<mml:msub>
<mml:mrow>
<mml:mrow>
<mml:msup>
<mml:mi mathvariant="bold">R</mml:mi>
<mml:mo>′</mml:mo>
</mml:msup>
</mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula>, and the unknown vector <inline-formula id="inline-formula68-1094342012452166">
<mml:math id="mml-inline68-1094342012452166">
<mml:mi mathvariant="normal">Φ</mml:mi>
</mml:math>
</inline-formula> is used to compute the splines coefficients through other operations. Both processes involving these vectors are explained in Section 5.4. Once the interpolation is done, we may use <inline-formula id="inline-formula69-1094342012452166">
<mml:math id="mml-inline69-1094342012452166">
<mml:msubsup>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">R</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>C</mml:mi>
<mml:mi>S</mml:mi>
<mml:mi>I</mml:mi>
</mml:mrow>
</mml:msubsup>
</mml:math>
</inline-formula> instead of <inline-formula id="inline-formula70-1094342012452166">
<mml:math id="mml-inline70-1094342012452166">
<mml:msub>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">R</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula> in <xref ref-type="disp-formula" rid="disp-formula7-1094342012452166">Equation (7)</xref> to compute the TDISP.</p>
</sec>
</sec>
<sec id="section6-1094342012452166">
<title>3. Computational complexity analysis</title>
<p>With a fixed microphone array and search region, we can compute some parts of the algorithm pre-runtime (<xref ref-type="bibr" rid="bibr15-1094342012452166">Lee and Kalker, 2010</xref>). In particular, given the search region <inline-formula id="inline-formula71-1094342012452166">
<mml:math id="mml-inline71-1094342012452166">
<mml:mrow>
<mml:mi mathvariant="script">Q</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula> and the position of all <inline-formula id="inline-formula72-1094342012452166">
<mml:math id="mml-inline72-1094342012452166">
<mml:mi>M</mml:mi>
</mml:math>
</inline-formula> microphones, we can precompute all of the TDOAs <inline-formula id="inline-formula73-1094342012452166">
<mml:math id="mml-inline73-1094342012452166">
<mml:msubsup>
<mml:mi mathvariant="italic">τ</mml:mi>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:msubsup>
</mml:math>
</inline-formula> that will be used along the entire application, in <xref ref-type="disp-formula" rid="disp-formula4-1094342012452166">Equation (4)</xref> or <xref ref-type="disp-formula" rid="disp-formula7-1094342012452166">Equation (7)</xref>. For this reason, we only consider runtime computations in computational complexity analysis. In addition, we assume the use of the fast Fourier transform (FFT) for the DFT computation, and denote <inline-formula id="inline-formula74-1094342012452166">
<mml:math id="mml-inline74-1094342012452166">
<mml:mi>N</mml:mi>
</mml:math>
</inline-formula> as the initial number of audio samples used for computing a single frame of the SRP-PHAT, and <inline-formula id="inline-formula75-1094342012452166">
<mml:math id="mml-inline75-1094342012452166">
<mml:mi>K</mml:mi>
</mml:math>
</inline-formula> as the number of frequency bins for computing the integrals in <xref ref-type="disp-formula" rid="disp-formula4-1094342012452166">Equation (4)</xref> or in <xref ref-type="disp-formula" rid="disp-formula6-1094342012452166">Equation (6)</xref>, where <inline-formula id="inline-formula76-1094342012452166">
<mml:math id="mml-inline76-1094342012452166">
<mml:mi>K</mml:mi>
<mml:mo stretchy="false">≤</mml:mo>
<mml:mi>N</mml:mi>
<mml:mrow>
<mml:mo>/</mml:mo>
</mml:mrow>
<mml:mn>2</mml:mn>
<mml:mo stretchy="false">+</mml:mo>
<mml:mn>1</mml:mn>
</mml:math>
</inline-formula> as a result of the FFT.</p>
<sec id="section7-1094342012452166">
<title>3.1. FDSP cost</title>
<p>Recalling that the algorithm depends on <inline-formula id="inline-formula77-1094342012452166">
<mml:math id="mml-inline77-1094342012452166">
<mml:mi>N</mml:mi>
</mml:math>
</inline-formula> (the FFT size), <inline-formula id="inline-formula78-1094342012452166">
<mml:math id="mml-inline78-1094342012452166">
<mml:mi>K</mml:mi>
</mml:math>
</inline-formula>, <inline-formula id="inline-formula79-1094342012452166">
<mml:math id="mml-inline79-1094342012452166">
<mml:mi>Q</mml:mi>
</mml:math>
</inline-formula> (the number of SSL candidates) and the <inline-formula id="inline-formula80-1094342012452166">
<mml:math id="mml-inline80-1094342012452166">
<mml:mi>M</mml:mi>
</mml:math>
</inline-formula> (the number microphones), we may define the asymptotic computational complexity of the FDSP as being <inline-formula id="inline-formula81-1094342012452166">
<mml:math id="mml-inline81-1094342012452166">
<mml:mi>O</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>N</mml:mi>
<mml:mi>Q</mml:mi>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula>. This usually implies a very large computational cost mostly due to <inline-formula id="inline-formula82-1094342012452166">
<mml:math id="mml-inline82-1094342012452166">
<mml:mi>Q</mml:mi>
</mml:math>
</inline-formula> because <inline-formula id="inline-formula83-1094342012452166">
<mml:math id="mml-inline83-1094342012452166">
<mml:mi>Q</mml:mi>
<mml:mo stretchy="false">≫</mml:mo>
<mml:mi>N</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mi>K</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mi>M</mml:mi>
</mml:math>
</inline-formula> in typical scenarios. In a detailed analysis, a discrete-time implementation of the SRP-PHAT requires the following number of arithmetic operations (additions and multiplications) at runtime (<xref ref-type="bibr" rid="bibr15-1094342012452166">Lee and Kalker, 2010</xref>).
<list list-type="bullet">
<list-item>
<p>FFT: <inline-formula id="inline-formula84-1094342012452166">
<mml:math id="mml-inline84-1094342012452166">
<mml:mrow>
<mml:mfrac>
<mml:mn>5</mml:mn>
<mml:mn>2</mml:mn>
</mml:mfrac>
</mml:mrow>
<mml:mi>M</mml:mi>
<mml:mi>N</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mo form="prefix" movablelimits="false">log</mml:mo>
</mml:mrow>
<mml:mn>2</mml:mn>
</mml:msub>
<mml:mi>N</mml:mi>
</mml:math>
</inline-formula> operations; </p>
</list-item>
<list-item>
<p>PHAT: <inline-formula id="inline-formula85-1094342012452166">
<mml:math id="mml-inline85-1094342012452166">
<mml:mn>10</mml:mn>
<mml:mi>M</mml:mi>
<mml:mi>K</mml:mi>
</mml:math>
</inline-formula> operations (<xref ref-type="bibr" rid="bibr8-1094342012452166">Do et al., 2007</xref>);</p>
</list-item>
<list-item>
<p>SRP: <inline-formula id="inline-formula86-1094342012452166">
<mml:math id="mml-inline86-1094342012452166">
<mml:mn>8</mml:mn>
<mml:mi>M</mml:mi>
<mml:mi>K</mml:mi>
<mml:mi>Q</mml:mi>
<mml:mo stretchy="false">+</mml:mo>
<mml:mn>4</mml:mn>
<mml:mi>K</mml:mi>
<mml:mi>Q</mml:mi>
</mml:math>
</inline-formula> operations.</p>
</list-item>
</list>
</p>
<p>For example, if search grid points are in a two-dimensional space of 2m <inline-formula id="inline-formula87-1094342012452166">
<mml:math id="mml-inline87-1094342012452166">
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula> 2m with a uniform grid spacing of 0.02m, we have the total number of <inline-formula id="inline-formula88-1094342012452166">
<mml:math id="mml-inline88-1094342012452166">
<mml:mi>Q</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>10</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>000</mml:mn>
</mml:math>
</inline-formula> candidate locations. With this search space, for a system with <inline-formula id="inline-formula89-1094342012452166">
<mml:math id="mml-inline89-1094342012452166">
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>8</mml:mn>
</mml:math>
</inline-formula> microphones with an equidistant spacing of 0.08m, <inline-formula id="inline-formula90-1094342012452166">
<mml:math id="mml-inline90-1094342012452166">
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>N</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>048</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula>-point FFT, and <inline-formula id="inline-formula91-1094342012452166">
<mml:math id="mml-inline91-1094342012452166">
<mml:mi>K</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>024</mml:mn>
</mml:math>
</inline-formula>, the FDSP requires <inline-formula id="inline-formula92-1094342012452166">
<mml:math id="mml-inline92-1094342012452166">
<mml:mn>6.968</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
<mml:msup>
<mml:mn>10</mml:mn>
<mml:mn>8</mml:mn>
</mml:msup>
</mml:math>
</inline-formula> operations per frame.</p>
</sec>
<sec id="section8-1094342012452166">
<title>3.2. TDISP cost</title>
<p>Remembering that for the TDSP the computation of <inline-formula id="inline-formula93-1094342012452166">
<mml:math id="mml-inline93-1094342012452166">
<mml:msub>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">R</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula> in <xref ref-type="disp-formula" rid="disp-formula6-1094342012452166">Equation (6)</xref> is done prior to <inline-formula id="inline-formula94-1094342012452166">
<mml:math id="mml-inline94-1094342012452166">
<mml:mi>P</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula> in <xref ref-type="disp-formula" rid="disp-formula7-1094342012452166">Equation (7)</xref>, the asymptotic computational cost of the TDSP may be seen as <inline-formula id="inline-formula95-1094342012452166">
<mml:math id="mml-inline95-1094342012452166">
<mml:mi>O</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msup>
<mml:mi>M</mml:mi>
<mml:mn>2</mml:mn>
</mml:msup>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>K</mml:mi>
<mml:mo stretchy="false">+</mml:mo>
<mml:mi>Q</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula>, and of the TDISP as <inline-formula id="inline-formula96-1094342012452166">
<mml:math id="mml-inline96-1094342012452166">
<mml:mi>O</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msup>
<mml:mi>M</mml:mi>
<mml:mn>2</mml:mn>
</mml:msup>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>K</mml:mi>
<mml:mo stretchy="false">+</mml:mo>
<mml:mi>Q</mml:mi>
<mml:mo stretchy="false">+</mml:mo>
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula>. Now for a practical example, we first recall that <inline-formula id="inline-formula97-1094342012452166">
<mml:math id="mml-inline97-1094342012452166">
<mml:msub>
<mml:mi>R</mml:mi>
<mml:mrow>
<mml:mi>l</mml:mi>
<mml:mi>m</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">[</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">]</mml:mo>
<mml:mo stretchy="false">=</mml:mo>
<mml:msubsup>
<mml:mi>R</mml:mi>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
<mml:mo stretchy="false">∗</mml:mo>
</mml:msubsup>
<mml:mo stretchy="false">[</mml:mo>
<mml:mi>N</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">]</mml:mo>
</mml:math>
</inline-formula>, and thus, most <inline-formula id="inline-formula98-1094342012452166">
<mml:math id="mml-inline98-1094342012452166">
<mml:msup>
<mml:mi>M</mml:mi>
<mml:mn>2</mml:mn>
</mml:msup>
</mml:math>
</inline-formula> terms become <inline-formula id="inline-formula99-1094342012452166">
<mml:math id="mml-inline99-1094342012452166">
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mn>2</mml:mn>
</mml:mfrac>
</mml:mrow>
</mml:math>
</inline-formula>. In addition, we first analyze separately the TDSP and the CSI. For the TDSP, we have the following:
<list list-type="bullet">
<list-item>
<p>FFT: <inline-formula id="inline-formula100-1094342012452166">
<mml:math id="mml-inline100-1094342012452166">
<mml:mrow>
<mml:mfrac>
<mml:mn>5</mml:mn>
<mml:mn>2</mml:mn>
</mml:mfrac>
</mml:mrow>
<mml:mi>M</mml:mi>
<mml:mi>N</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mo form="prefix" movablelimits="false">log</mml:mo>
</mml:mrow>
<mml:mn>2</mml:mn>
</mml:msub>
<mml:mi>N</mml:mi>
</mml:math>
</inline-formula> operations; </p>
</list-item>
<list-item>
<p>PHAT: <inline-formula id="inline-formula101-1094342012452166">
<mml:math id="mml-inline101-1094342012452166">
<mml:mn>5</mml:mn>
<mml:mi>N</mml:mi>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula> operations (<xref ref-type="bibr" rid="bibr9-1094342012452166">Do et al., 2007</xref>);</p>
</list-item>
<list-item>
<p>IFFT: <inline-formula id="inline-formula102-1094342012452166">
<mml:math id="mml-inline102-1094342012452166">
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mn>2</mml:mn>
</mml:mfrac>
</mml:mrow>
<mml:mo stretchy="false">⋅</mml:mo>
<mml:mrow>
<mml:mfrac>
<mml:mn>5</mml:mn>
<mml:mn>2</mml:mn>
</mml:mfrac>
</mml:mrow>
<mml:mi>N</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mo form="prefix" movablelimits="false">log</mml:mo>
</mml:mrow>
<mml:mn>2</mml:mn>
</mml:msub>
<mml:mi>N</mml:mi>
</mml:math>
</inline-formula> operations;</p>
</list-item>
<list-item>
<p>SRP: <inline-formula id="inline-formula103-1094342012452166">
<mml:math id="mml-inline103-1094342012452166">
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mn>2</mml:mn>
</mml:mfrac>
</mml:mrow>
<mml:mo stretchy="false">⋅</mml:mo>
<mml:mi>Q</mml:mi>
</mml:math>
</inline-formula> operations.</p>
</list-item>
</list>
</p>
<p>For the NCSI algorithm, we have to find the splines coefficients for all of the <inline-formula id="inline-formula104-1094342012452166">
<mml:math id="mml-inline104-1094342012452166">
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mn>2</mml:mn>
</mml:mfrac>
</mml:mrow>
</mml:math>
</inline-formula> GCC-PHATs, and compute the new points using those coefficients. This is done in three separate processes, with the following computational costs:</p>
<list list-type="bullet">
<list-item>
<p>Thomas tridiagonal solver, <inline-formula id="inline-formula105-1094342012452166">
<mml:math id="mml-inline105-1094342012452166">
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mn>2</mml:mn>
</mml:mfrac>
</mml:mrow>
<mml:mo stretchy="false">(</mml:mo>
<mml:mn>8</mml:mn>
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>23</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula> operations;</p>
</list-item>
<list-item>
<p>find splines coefficients, <inline-formula id="inline-formula106-1094342012452166">
<mml:math id="mml-inline106-1094342012452166">
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mn>2</mml:mn>
</mml:mfrac>
</mml:mrow>
<mml:mo stretchy="false">(</mml:mo>
<mml:mn>16</mml:mn>
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>8</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula> operations;</p>
</list-item>
<list-item>
<p>generate interpolated points, <inline-formula id="inline-formula107-1094342012452166">
<mml:math id="mml-inline107-1094342012452166">
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mn>2</mml:mn>
</mml:mfrac>
</mml:mrow>
<mml:mo stretchy="false">(</mml:mo>
<mml:mn>12</mml:mn>
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>6</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
<mml:mi>E</mml:mi>
</mml:math>
</inline-formula> operations.</p>
</list-item>
</list>
<p>Using <inline-formula id="inline-formula108-1094342012452166">
<mml:math id="mml-inline108-1094342012452166">
<mml:mi>E</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>10</mml:mn>
</mml:math>
</inline-formula> (10:1 interpolation), <inline-formula id="inline-formula109-1094342012452166">
<mml:math id="mml-inline109-1094342012452166">
<mml:mi>T</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mrow>
<mml:mfrac>
<mml:mn>1</mml:mn>
<mml:mrow>
<mml:mn>44</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>100</mml:mn>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="normal">H</mml:mi>
<mml:mi mathvariant="normal">z</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:math>
</inline-formula>, <inline-formula id="inline-formula110-1094342012452166">
<mml:math id="mml-inline110-1094342012452166">
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:msub>
<mml:mi>V</mml:mi>
<mml:mrow>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="normal">m</mml:mi>
<mml:mi mathvariant="normal">a</mml:mi>
<mml:mi mathvariant="normal">x</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula>, and the same parameters as those in Section 3.1, the TDSP needs a total of <inline-formula id="inline-formula111-1094342012452166">
<mml:math id="mml-inline111-1094342012452166">
<mml:mn>2.88</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
<mml:msup>
<mml:mn>10</mml:mn>
<mml:mn>6</mml:mn>
</mml:msup>
</mml:math>
</inline-formula> operations, and the TDISP a total of <inline-formula id="inline-formula112-1094342012452166">
<mml:math id="mml-inline112-1094342012452166">
<mml:mn>3.168</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
<mml:msup>
<mml:mn>10</mml:mn>
<mml:mn>6</mml:mn>
</mml:msup>
</mml:math>
</inline-formula> operations. Note that even though the TDSP costs about two orders of magnitudes less than the FDSP, it may still be impracticable for real-time applications if large values for <inline-formula id="inline-formula113-1094342012452166">
<mml:math id="mml-inline113-1094342012452166">
<mml:mi>Q</mml:mi>
</mml:math>
</inline-formula> and/or <inline-formula id="inline-formula114-1094342012452166">
<mml:math id="mml-inline114-1094342012452166">
<mml:mi>M</mml:mi>
</mml:math>
</inline-formula> are used. Furthermore, as mentioned before, this gain in computational complexity has the trade-off of reducing the algorithm’s accuracy (<xref ref-type="bibr" rid="bibr26-1094342012452166">Silverman et al., 2005</xref>), and therefore, using the TDISP helps alleviate this effect.</p>
</sec>
</sec>
<sec id="section9-1094342012452166">
<title>4. GPGPU using CUDA</title>
<p>In recent years, the increasing processing power of GPUs has led the scientific community to explore non-graphic-related computations onto these highly parallel architectures, first through vertex and fragment shaders, and more recently programming the device. This practice became even more feasible when NVIDIA released in 2006 their G80 chipset series (<xref ref-type="bibr" rid="bibr18-1094342012452166">NVIDIA Corporation 2006</xref>). This new architecture leveraged the first dedicated GPUs in the market that could be used for general-purpose computing through NVIDIA’s also newly created CUDA programming model (<xref ref-type="bibr" rid="bibr17-1094342012452166">Lindholm et al., 2008</xref>; <xref ref-type="bibr" rid="bibr13-1094342012452166">Kirk and Hwu, 2010</xref>). Later in 2010, NVIDIA launched their Fermi family cards (<xref ref-type="bibr" rid="bibr10-1094342012452166">Glaskowsky, 2009</xref>; <xref ref-type="bibr" rid="bibr23-1094342012452166">NVIDIA Corporation, 2011e</xref>), a successor of the GT200 series GPUs, that brought many advantages over its predecessors and now represent NVIDIA’s most powerful cards. For this reason, we will use the Fermi architecture for the explanations in this section.</p>
<p>However, it is important to mention that ATI/AMD also has their programming model, the Stream SDK (SSDK). Furthermore, there is also the OpenCL, an open industry standard that abstracts both CUDA and the SSDK, facilitating heterogeneous computing due to portability and vendor independence. Given these options, we chose CUDA over SSDK due to implementation practicality and over OpenCL due to performance reasons. Nevertheless, our algorithm could be easily ported to either programming model. In addition it may be compiled and run in any CUDA-enabled device thanks to the forward and backward compatibility introduced by NVIDIA’s Parallel Thread Execution (PTX) (<xref ref-type="bibr" rid="bibr21-1094342012452166">NVIDIA Corporation, 2011c</xref>,<xref ref-type="bibr" rid="bibr22-1094342012452166">d</xref>), a pseudo-assembly language that acts as a virtual machine between CUDA code and hardware-specific binary code.</p>
<p>From the point of view of hardware models, the NVIDIA GPU architecture has incrementally changed from different series and families in their basic concept. Currently, Fermi cards consist of a two-level hierarchy for the processors and three-level hierarchy for the memory, starting with the streaming multiprocessors (SMs) and global memory, respectively. As <xref ref-type="fig" rid="fig1-1094342012452166">Figure 1</xref> abstractedly illustrates, each SMs consist of 32 scalar processors (SPs; also commonly called CUDA cores), a hybrid on-chip region of configurable shared and L1 cache memories, and also texture and constant memories caches. Furthermore, all SMs share an area of DRAM that is cached by a L2 memory. While data in global memory (DRAM) can be accessed by any SP in any SM, data in shared memory is accessible only from within the SPs in the same SM. Since shared memory is on-chip, it is designed to be much faster than global memory, but also being limited to 48 kB out of the total 64 kB in the hybrid area. The remaining 16 kB is used as L1 cache. Note, however, that this region may be oppositely configured as 16 kB of shared memory and 48 kB of cache.</p>
<fig id="fig1-1094342012452166" position="float">
<label>Figure 1.</label>
<caption>
<p>Abstracted architecture of a NVIDIA’s Fermi GPU.</p>
</caption>
<graphic xlink:href="10.1177_1094342012452166-fig1.tif"/>
</fig>
<p>As GPU data must come from the computer’s global RAM, the PCI-Express (PCI-E) bus is used for the transference. Its current theoretical maximum throughput is 8 GB/s for the 2.0 versions (used by GPUs). Since this bandwidth is much lower than the peak bandwidth between the GPU’s global memory and its processors (192 GB/s theoretical for NVIDIA’s most recent non-dual cards), data transfers between CPU and GPU should be minimized in size and frequency (<xref ref-type="bibr" rid="bibr19-1094342012452166">NVIDIA Corporation, 2011a</xref>). This allows for the GPU’s fast access rate to be exploited and no transfer overheads to be created. Another feature that must be exploited in a GPU software is the fast thread switching. While a thread switch is very costly on the CPU, the GPU can handle this task with more ease. It is therefore encouraged to create more threads than the number of physical processors available. Such overload promotes high concurrency among all threads, and occupancy of the hardware, which is good, since some threads can be scheduled while others wait for memory transfers (<xref ref-type="bibr" rid="bibr19-1094342012452166">NVIDIA Corporation, 2011a</xref>). Both of these best practices are well exploited by the developed GPU algorithm, and will be better highlighted in later sections.</p>
<p>Now from the point of view of the software model, CUDA is a minor extension of the C and C++ languages that allows the writing of heterogeneous software, that is, programs that use both the CPU and GPU for its execution. This is done by designing GPU-turned functions called kernels, which execute in parallel across a set of threads. As represented in <xref ref-type="fig" rid="fig2-1094342012452166">Figure 2</xref>, each thread has a private local memory, which resides in the devices global memory. These threads are organized into a hierarchy by the programmer. A group of threads is called a block, and a group of blocks is called a grid. Thread blocks are sets of concurrent threads that may cooperate among themselves through barrier synchronization and access to the shared memory. The management of the threads (creating, scheduling and termination) is done automatically by the hardware at runtime. However, the programmer has to specify, for every kernel invocation, the size of the grid that will be executed by the kernel, and the size of its blocks. Also, only one grid may be designated to a kernel, and multiple kernels may be executed in parallel (new feature in the Fermi cards).</p>
<fig id="fig2-1094342012452166" position="float">
<label>Figure 2.</label>
<caption>
<p>CUDA abstraction of threads and memory.</p>
</caption>
<graphic xlink:href="10.1177_1094342012452166-fig2.tif"/>
</fig>
<p>These abstractions done by the CUDA programming model easily allow a two-level hierarchical indexing of all threads (similar to nested parallelism), multidimensional data manipulation and sharing, without making the programmer worry about functional correctness. However, some good practices should be adopted since there is some relationship between the software-level thread organization and the way the hardware handles the threads (<xref ref-type="bibr" rid="bibr19-1094342012452166">NVIDIA Corporation, 2011a</xref>). More precisely, each thread block is scheduled to a SM, and then split into groups of 32 threads called warps. Pairs of warps are then scheduled to the SPs by two warp scheduler units, and then successively run concurrently, in SIMT (single instruction multiple thread) fashion, until the whole block is executed. Given this process, the creation of potential divergent code flow between threads should be avoided, since it is something that is handled automatically by the hardware by serializing their execution. This may happen, e.g. when an if condition evaluates true within a thread and false in another one.</p>
<p>Furthermore, some other recommended practices should be prioritized (<xref ref-type="bibr" rid="bibr19-1094342012452166">NVIDIA Corporation, 2011a</xref>), such as creating blocks multiples of 32, so that no warp with less than 32 threads is scheduled, helping increase the occupancy of the GPU. However, the most important practice is to perform coalesced memory access in the GPU’s global memory, that is, all of the threads in a half-warp should access global memory at the same time, which is achieved by some coding patterns described in <xref ref-type="bibr" rid="bibr19-1094342012452166">NVIDIA Corporation (2011a</xref>), and may have some variations between different devices. In short, the simplest and most efficient way of achieving coalesced access is by making adjacent threads in warp access adjacent words in the global memory, without offsetting the accesses.</p>
</sec>
<sec id="section10-1094342012452166">
<title>5. GPU-based SRP-PHAT</title>
<p>The implementation of GPU-based algorithms should focus mainly on exploiting as much parallelism as possible (<xref ref-type="bibr" rid="bibr19-1094342012452166">NVIDIA Corporation, 2011a</xref>). Based on the CUDA’s abstraction of the GPU, it is possible to easily exploit two levels of parallelism in GPU-based routines (i.e. parallelize two nested loops). For FDSP and TDSP, this was done in a similar way. While the first level of parallelism is equal in both versions, the second one is different. Therefore, Section 5.1 presents the first parallelization both versions share, and Sections 5.2 and 5.3 present the individual second level of parallelization of each version.</p>
<sec id="section11-1094342012452166">
<title>5.1. Common parallelization</title>
<p>As described in Section 2.1, the SRP-PHAT must be evaluated once for every point in a search space <inline-formula id="inline-formula115-1094342012452166">
<mml:math id="mml-inline115-1094342012452166">
<mml:mrow>
<mml:mi mathvariant="script">Q</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula>, containing <inline-formula id="inline-formula116-1094342012452166">
<mml:math id="mml-inline116-1094342012452166">
<mml:mi>Q</mml:mi>
</mml:math>
</inline-formula> points. In CPU-based implementations, this is done in a serial manner, or at most, parallelized among the cores of the CPU. In our application, we parallelize the search space scanning as illustrated in <xref ref-type="fig" rid="fig3-1094342012452166">Figure 3</xref>. At a programming level this is the first parallelization in the software’s flow, thus implying the distribution of each candidate point to a single block of the kernel’s grid. More precisely, this is done before the kernel invocation by specifying its grid size as the same size of the search space.</p>
<fig id="fig3-1094342012452166" position="float">
<label>Figure 3.</label>
<caption>
<p>Serial scan versus our proposed parallel scan (first level of parallelization).</p>
</caption>
<graphic xlink:href="10.1177_1094342012452166-fig3.tif"/>
</fig>
<p>In this approach, each block will be scheduled to an SM of the GPU, which is an expected behavior, as described in Section 4. This makes the algorithm scalable to the GPU being used. The more SMs available, more parallelism will be achievable, while fewer SMs imply more concurrency (and less parallelism).</p>
<p>It is important to note that this parallel grid search approach can be applied to any search space-based SSL methods in general (<xref ref-type="bibr" rid="bibr29-1094342012452166">Tung et al., 1999</xref>; <xref ref-type="bibr" rid="bibr31-1094342012452166">Zhang et al., 2007</xref>; <xref ref-type="bibr" rid="bibr16-1094342012452166">Lee et al., 2008</xref>) only with the difference in the actual implementation of the computation at each block. In the next two sections, the case for the SRP-PHAT will be presented.</p>
</sec>
<sec id="section12-1094342012452166">
<title>5.2. Parallelization approach for FDSP</title>
<p>Since the first level of parallelism is done at a grid-to-block level for the parallel space scanning, the second is done by splitting each block into groups of threads for computing each point’s SRP-PHAT. Following the formulation of the SRP-PHAT, given by <xref ref-type="disp-formula" rid="disp-formula4-1094342012452166">Equation (4)</xref>, it can be noticed that its outermost iteration process is the integral (which in practice is a summation), and therefore it is the main candidate to be parallelized at a block-to-thread level. <xref ref-type="fig" rid="fig4-1094342012452166">Figure 4</xref> illustrates how the parallelization was done.</p>
<fig id="fig4-1094342012452166" position="float">
<label>Figure 4.</label>
<caption>
<p>Serial integral versus our proposed parallel integral (second level of parallelization).</p>
</caption>
<graphic xlink:href="10.1177_1094342012452166-fig4.tif"/>
</fig>
<p>Each block responsible for a point <inline-formula id="inline-formula117-1094342012452166">
<mml:math id="mml-inline117-1094342012452166">
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:math>
</inline-formula> is split into <inline-formula id="inline-formula118-1094342012452166">
<mml:math id="mml-inline118-1094342012452166">
<mml:mi>S</mml:mi>
</mml:math>
</inline-formula> new threads, each of which computes a portion of the FDSP’s integral. This implies a total of <inline-formula id="inline-formula119-1094342012452166">
<mml:math id="mml-inline119-1094342012452166">
<mml:mi>K</mml:mi>
<mml:mrow>
<mml:mo>/</mml:mo>
</mml:mrow>
<mml:mi>S</mml:mi>
</mml:math>
</inline-formula> iterations in order to calculate the whole integral (instead of <inline-formula id="inline-formula120-1094342012452166">
<mml:math id="mml-inline120-1094342012452166">
<mml:mi>K</mml:mi>
</mml:math>
</inline-formula>, as in the serial version). More precisely, in each iteration <inline-formula id="inline-formula121-1094342012452166">
<mml:math id="mml-inline121-1094342012452166">
<mml:mi>b</mml:mi>
</mml:math>
</inline-formula>, each <inline-formula id="inline-formula122-1094342012452166">
<mml:math id="mml-inline122-1094342012452166">
<mml:mi>s</mml:mi>
</mml:math>
</inline-formula>-indexed thread computes <inline-formula id="inline-formula123-1094342012452166">
<mml:math id="mml-inline123-1094342012452166">
<mml:mi>Z</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">=</mml:mo>
<mml:msup>
<mml:mfenced close="|" open="|">
<mml:mrow>
<mml:mrow>
<mml:msubsup>
<mml:mo movablelimits="false" stretchy="false">∑</mml:mo>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mi>M</mml:mi>
</mml:msubsup>
</mml:mrow>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>m</mml:mi>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mrow>
<mml:mo>|</mml:mo>
</mml:mrow>
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>m</mml:mi>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mrow>
<mml:mo>|</mml:mo>
</mml:mrow>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
<mml:msup>
<mml:mi>e</mml:mi>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:msubsup>
<mml:mi mathvariant="italic">τ</mml:mi>
<mml:mi>m</mml:mi>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:mfenced>
<mml:mn>2</mml:mn>
</mml:msup>
</mml:math>
</inline-formula>, for <inline-formula id="inline-formula124-1094342012452166">
<mml:math id="mml-inline124-1094342012452166">
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mi>s</mml:mi>
<mml:mo stretchy="false">+</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>b</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
<mml:mi>S</mml:mi>
</mml:math>
</inline-formula>, treating <inline-formula id="inline-formula125-1094342012452166">
<mml:math id="mml-inline125-1094342012452166">
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>m</mml:mi>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula> as a discrete-time vector (for simplicity) and using one-based indexing as in <xref ref-type="fig" rid="fig4-1094342012452166">Figure 4</xref>. Dividing each thread’s work like this allows them to access adjacent positions of the <inline-formula id="inline-formula126-1094342012452166">
<mml:math id="mml-inline126-1094342012452166">
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>m</mml:mi>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula> vector, leveraging from coalesced global memory accesses. For incrementing the computed value <inline-formula id="inline-formula127-1094342012452166">
<mml:math id="mml-inline127-1094342012452166">
<mml:mi>Z</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ω</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula> between successive iterations (process represented by the C++ operator <inline-formula id="inline-formula128-1094342012452166">
<mml:math id="mml-inline128-1094342012452166">
<mml:mo stretchy="false">+</mml:mo>
<mml:mo stretchy="false">=</mml:mo>
</mml:math>
</inline-formula>), we use, for each thread, one position of a shared memory array with length <inline-formula id="inline-formula129-1094342012452166">
<mml:math id="mml-inline129-1094342012452166">
<mml:mi>S</mml:mi>
</mml:math>
</inline-formula>. By the end of the last iteration, each position of the array will hold a partial result of the FDSP, which then have to be summed into one, so that the block finishes computing the SRP-PHAT of the point it represents. Note, however, that this summation has to be synchronized among the threads so that no wrong data is read/written, and for that, we use the parallel sum reduction algorithm described by Mark Harris in the documentation of the ‘reduction’ example that comes with NVIDIA’s GPU Computing SDK (<xref ref-type="bibr" rid="bibr12-1094342012452166">Harris, 2011</xref>). This is a very efficient reduction algorithm, especially when reducing shared memory arrays, as in our case.</p>
<p>Aside from our parallelization approach, note that the innermost iterations (the summation) could be the one to be parallelized, but this would obviously imply poorer performance, once it iterates only <inline-formula id="inline-formula130-1094342012452166">
<mml:math id="mml-inline130-1094342012452166">
<mml:mi>M</mml:mi>
</mml:math>
</inline-formula> times. That is, the number of microphones is generally small (<xref ref-type="bibr" rid="bibr2-1094342012452166">Brandstein and Ward, 2001</xref>) compared with <inline-formula id="inline-formula131-1094342012452166">
<mml:math id="mml-inline131-1094342012452166">
<mml:mi>K</mml:mi>
</mml:math>
</inline-formula>, and thus less threads would be created. Another issue is that the number of threads would not likely be a multiple of 32, what is something necessary to cope with the warp size recommendation mentioned in Section 4. For this reason, we chose <inline-formula id="inline-formula132-1094342012452166">
<mml:math id="mml-inline132-1094342012452166">
<mml:mi>S</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>64</mml:mn>
</mml:math>
</inline-formula>, which is the multiple of 32 that has experimentally shown to be the best choice among all possible multiples.</p>
</sec>
<sec id="section13-1094342012452166">
<title>5.3. Parallelization approach for TDSP</title>
<p>The TDSP, different from the FDSP, can be divided into two separate stages. The first part is where the GCC-PHATs are precomputed using <xref ref-type="disp-formula" rid="disp-formula6-1094342012452166">Equation (6)</xref>, and the second is the evaluation of the SRP-PHAT for each candidate source location, using <xref ref-type="disp-formula" rid="disp-formula7-1094342012452166">Equation (7)</xref>. For each stage, a separate kernel is developed, since their grid and block sizes must be different in order to achieve higher performance. <xref ref-type="fig" rid="fig5-1094342012452166">Figure 5</xref> illustrates how this first stage is processed.</p>
<fig id="fig5-1094342012452166" position="float">
<label>Figure 5.</label>
<caption>
<p>Parallel computation of the GCC-PHATS.</p>
</caption>
<graphic xlink:href="10.1177_1094342012452166-fig5.tif"/>
</fig>
<p>For this parallel computation of <xref ref-type="disp-formula" rid="disp-formula6-1094342012452166">Equation (6)</xref>, we also exploit two levels of parallelism. Each GCC-PHAT is assigned to a block, resulting in a grid of <inline-formula id="inline-formula133-1094342012452166">
<mml:math id="mml-inline133-1094342012452166">
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mn>2</mml:mn>
</mml:mfrac>
</mml:mrow>
</mml:math>
</inline-formula> blocks. Each block of threads is then divided into groups of <inline-formula id="inline-formula134-1094342012452166">
<mml:math id="mml-inline134-1094342012452166">
<mml:mi>S</mml:mi>
</mml:math>
</inline-formula> threads, each of which does a portion of the frequency domain computations (<inline-formula id="inline-formula135-1094342012452166">
<mml:math id="mml-inline135-1094342012452166">
<mml:mi>S</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>64</mml:mn>
</mml:math>
</inline-formula>, same as for the FDSP). These frequency domain computations are the PHAT-weighted cross power spectrum (CPS) of the pair of microphones the block represents. Here, the division of each block’s work is given in the same way as described in Section 5.2, except that the starting grid has <inline-formula id="inline-formula136-1094342012452166">
<mml:math id="mml-inline136-1094342012452166">
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mn>2</mml:mn>
</mml:mfrac>
</mml:mrow>
</mml:math>
</inline-formula> threads instead of <inline-formula id="inline-formula137-1094342012452166">
<mml:math id="mml-inline137-1094342012452166">
<mml:mi>Q</mml:mi>
</mml:math>
</inline-formula>, and the final results are not reduced in the end. Finally, to finish calculating the GCC-PHAT of each block, we do the inverse fast Fourier transform (IFFT) of the corresponding CPS. This is done using NVIDIA’s CUFFT library, which provides faster FFT/IFFT algorithms than other known CPU-based libraries (<xref ref-type="bibr" rid="bibr20-1094342012452166">NVIDIA Corporation, 2011b</xref>).</p>
<p>For the next step of the algorithm, first note that after launching the kernel of <xref ref-type="fig" rid="fig5-1094342012452166">Figure 5</xref>, a synchronization barrier is unavoidable due to the data dependency nature of the algorithm (to perform the TDSP, the GCC-PHATs computation must finish first). Given that, once the GCC-PHATs have been computed, it is then possible to compute the SRP-PHAT of each point starting with the grid search parallelization described in Section 5.1 (recalling it is used for both the FDSP and TDSP). For each candidate source, located at <inline-formula id="inline-formula138-1094342012452166">
<mml:math id="mml-inline138-1094342012452166">
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:math>
</inline-formula>, we need to sum an element of all <inline-formula id="inline-formula139-1094342012452166">
<mml:math id="mml-inline139-1094342012452166">
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mn>2</mml:mn>
</mml:mfrac>
</mml:mrow>
</mml:math>
</inline-formula> GCC-PHATs, where each element’s index corresponds to the TDOA <inline-formula id="inline-formula140-1094342012452166">
<mml:math id="mml-inline140-1094342012452166">
<mml:msubsup>
<mml:mi mathvariant="italic">τ</mml:mi>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:msubsup>
</mml:math>
</inline-formula> between the pair of microphones <inline-formula id="inline-formula141-1094342012452166">
<mml:math id="mml-inline141-1094342012452166">
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:math>
</inline-formula> and the location <inline-formula id="inline-formula142-1094342012452166">
<mml:math id="mml-inline142-1094342012452166">
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:math>
</inline-formula>. This step is suited for the second level of parallelism of the TDSP and is illustrated in <xref ref-type="fig" rid="fig6-1094342012452166">Figure 6</xref>. It is done similarly to the parallelization of the FDSP: each thread of the block is responsible for a portion of the SRP-PHAT, which will be summed together at the end. However, each thread’s task in this case is to retrieve values from the precomputed GCC-PHATs, based on the microphone pairs they represent.</p>
<fig id="fig6-1094342012452166" position="float">
<label>Figure 6.</label>
<caption>
<p>General GCC-PHATs summation approach versus our proposed parallel one (second level of parallelization).</p>
</caption>
<graphic xlink:href="10.1177_1094342012452166-fig6.tif"/>
</fig>
<p>One thing to notice is that, for TDSP, the block size is <inline-formula id="inline-formula143-1094342012452166">
<mml:math id="mml-inline143-1094342012452166">
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mn>2</mml:mn>
</mml:mfrac>
</mml:mrow>
</mml:math>
</inline-formula> instead of <inline-formula id="inline-formula144-1094342012452166">
<mml:math id="mml-inline144-1094342012452166">
<mml:mi>S</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>64</mml:mn>
</mml:math>
</inline-formula>. This is a drawback that degrades the algorithm performance since the warp size recommendation previously described is not satisfied (<inline-formula id="inline-formula145-1094342012452166">
<mml:math id="mml-inline145-1094342012452166">
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mn>2</mml:mn>
</mml:mfrac>
</mml:mrow>
</mml:math>
</inline-formula> will not likely be a multiple of 32). In addition, when accessing the memory in <inline-formula id="inline-formula146-1094342012452166">
<mml:math id="mml-inline146-1094342012452166">
<mml:msub>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">R</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula> through the process in <xref ref-type="fig" rid="fig6-1094342012452166">Figure 6</xref>, coalesced access to the global memory is not fulfilled. That is, reading <inline-formula id="inline-formula147-1094342012452166">
<mml:math id="mml-inline147-1094342012452166">
<mml:msub>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">R</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:mn>12</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">R</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:mn>13</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">,</mml:mo>
<mml:mo stretchy="false">…</mml:mo>
<mml:mo stretchy="false">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">R</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula> is not done sequentially, and therefore, does not leverage from the fact that when accessing memory positions that are coalesced, the GPU may read one whole sequential region with only one transaction. In our approach, the GPU issues one transaction per read. One way we alleviate this problem is by mapping <inline-formula id="inline-formula148-1094342012452166">
<mml:math id="mml-inline148-1094342012452166">
<mml:msub>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">R</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula> into texture memory. While texture memory is also mapped in the DRAM, it has a separate on-chip texture cache (recall <xref ref-type="fig" rid="fig1-1094342012452166">Figure 1</xref>) that may provide fast access to frequently read values in <inline-formula id="inline-formula149-1094342012452166">
<mml:math id="mml-inline149-1094342012452166">
<mml:msub>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">R</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula>.</p>
</sec>
<sec id="section14-1094342012452166">
<title>5.4. Parallelization of the cubic splines interpolation</title>
<p>The critical point in parallelizing the CSI in the GPU is solving the tridiagonal system (created from the values in <inline-formula id="inline-formula150-1094342012452166">
<mml:math id="mml-inline150-1094342012452166">
<mml:msubsup>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">R</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
<mml:mo>′</mml:mo>
</mml:msubsup>
</mml:math>
</inline-formula>), since there are dependencies between adjacent loop iterations of the algorithm. Other steps are easier to implement, once they summarize to mathematical operations and vector manipulations. In view of that, we use a recently developed GPU-based tridiagonal solver that is available in the CUDPP library, a hybridization of cyclic reduction and parallel cyclic reduction (CR+PCR), which is fully described by <xref ref-type="bibr" rid="bibr32-1094342012452166">Zhang et al. (2010</xref>). This algorithm solves many large different tridiagonal systems in parallel, which is exactly the case of the TDISP: we have <inline-formula id="inline-formula151-1094342012452166">
<mml:math id="mml-inline151-1094342012452166">
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mn>2</mml:mn>
</mml:mfrac>
</mml:mrow>
</mml:math>
</inline-formula> different systems of order <inline-formula id="inline-formula152-1094342012452166">
<mml:math id="mml-inline152-1094342012452166">
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>2</mml:mn>
</mml:math>
</inline-formula> to solve.</p>
<p>However, before we can apply the CR+PCR algorithm, the tridiagonal system must be prepared by first extracting <inline-formula id="inline-formula153-1094342012452166">
<mml:math id="mml-inline153-1094342012452166">
<mml:msubsup>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">R</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
<mml:mo>′</mml:mo>
</mml:msubsup>
</mml:math>
</inline-formula> from <inline-formula id="inline-formula154-1094342012452166">
<mml:math id="mml-inline154-1094342012452166">
<mml:msub>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">R</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula>, as in <xref ref-type="disp-formula" rid="disp-formula8-1094342012452166">Equation (8)</xref>. This is done using CUDA’s built in asynchronous memory copies from GPU memory to GPU memory, and thus is a fast process (<xref ref-type="bibr" rid="bibr19-1094342012452166">NVIDIA Corporation, 2011a</xref>). After that, we perform some algebraic manipulations in <inline-formula id="inline-formula155-1094342012452166">
<mml:math id="mml-inline155-1094342012452166">
<mml:msubsup>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">R</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
<mml:mo>′</mml:mo>
</mml:msubsup>
</mml:math>
</inline-formula> to create the right-hand vector <inline-formula id="inline-formula156-1094342012452166">
<mml:math id="mml-inline156-1094342012452166">
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">Y</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:math>
</inline-formula> of the system, as illustrated in <xref ref-type="fig" rid="fig7-1094342012452166">Figure 7</xref>. The creation of <inline-formula id="inline-formula157-1094342012452166">
<mml:math id="mml-inline157-1094342012452166">
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">Y</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:math>
</inline-formula> is done by a kernel composed of a grid of <inline-formula id="inline-formula158-1094342012452166">
<mml:math id="mml-inline158-1094342012452166">
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mn>2</mml:mn>
</mml:mfrac>
</mml:mrow>
</mml:math>
</inline-formula> blocks, since each tridiagonal system is related to one pair of microphones. Each block is divided into <inline-formula id="inline-formula159-1094342012452166">
<mml:math id="mml-inline159-1094342012452166">
<mml:mn>2</mml:mn>
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>2</mml:mn>
</mml:math>
</inline-formula> threads that will each compute an element of <inline-formula id="inline-formula160-1094342012452166">
<mml:math id="mml-inline160-1094342012452166">
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">Y</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:math>
</inline-formula>. Note that for each element of <inline-formula id="inline-formula161-1094342012452166">
<mml:math id="mml-inline161-1094342012452166">
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">Y</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:math>
</inline-formula>, we must have three memory accesses into <inline-formula id="inline-formula162-1094342012452166">
<mml:math id="mml-inline162-1094342012452166">
<mml:msubsup>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">R</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
<mml:mo>′</mml:mo>
</mml:msubsup>
</mml:math>
</inline-formula> which may be slow. For this reason, during the kernel’s initiation, the entire <inline-formula id="inline-formula163-1094342012452166">
<mml:math id="mml-inline163-1094342012452166">
<mml:msubsup>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">R</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
<mml:mo>′</mml:mo>
</mml:msubsup>
</mml:math>
</inline-formula> array is loaded into the shared memory. Finally, for the creation of the coefficient matrix in <xref ref-type="disp-formula" rid="disp-formula11-1094342012452166">Equation (11)</xref>, we allocate the values pre-runtime, since they do not change over different systems.</p>
<fig id="fig7-1094342012452166" position="float">
<label>Figure 7.</label>
<caption>
<p>Parallel preparation of all tridiagonal systems.</p>
</caption>
<graphic xlink:href="10.1177_1094342012452166-fig7.tif"/>
</fig>
<p>After the preparation of the tridiagonal system, the CUDPP’s CR+PCR algorithm is executed in order to obtain the unknown <inline-formula id="inline-formula164-1094342012452166">
<mml:math id="mml-inline164-1094342012452166">
<mml:mi mathvariant="normal">Φ</mml:mi>
</mml:math>
</inline-formula> vector from <xref ref-type="disp-formula" rid="disp-formula11-1094342012452166">Equation (11)</xref>. Using <inline-formula id="inline-formula165-1094342012452166">
<mml:math id="mml-inline165-1094342012452166">
<mml:mi mathvariant="normal">Φ</mml:mi>
</mml:math>
</inline-formula> we may determine the four coefficients, <inline-formula id="inline-formula166-1094342012452166">
<mml:math id="mml-inline166-1094342012452166">
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo stretchy="false">,</mml:mo>
<mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo stretchy="false">,</mml:mo>
<mml:msub>
<mml:mi>c</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo stretchy="false">,</mml:mo>
<mml:msub>
<mml:mi>d</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> of the <inline-formula id="inline-formula167-1094342012452166">
<mml:math id="mml-inline167-1094342012452166">
<mml:mn>2</mml:mn>
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>2</mml:mn>
</mml:math>
</inline-formula> splines of each GCC-PHAT (<inline-formula id="inline-formula168-1094342012452166">
<mml:math id="mml-inline168-1094342012452166">
<mml:mi>i</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>0</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mo stretchy="false">…</mml:mo>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>2</mml:mn>
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>2</mml:mn>
</mml:math>
</inline-formula>). This is something needed before <inline-formula id="inline-formula169-1094342012452166">
<mml:math id="mml-inline169-1094342012452166">
<mml:msubsup>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">R</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
<mml:mo>′</mml:mo>
</mml:msubsup>
</mml:math>
</inline-formula> may be interpolated into <inline-formula id="inline-formula170-1094342012452166">
<mml:math id="mml-inline170-1094342012452166">
<mml:msubsup>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">R</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>C</mml:mi>
<mml:mi>S</mml:mi>
<mml:mi>I</mml:mi>
</mml:mrow>
</mml:msubsup>
</mml:math>
</inline-formula>. In our approach these coefficients are determined in the same kernel used for the interpolation. <xref ref-type="fig" rid="fig8-1094342012452166">Figure 8</xref> illustrates this process. Finally, after the execution of this routine, we may use <inline-formula id="inline-formula171-1094342012452166">
<mml:math id="mml-inline171-1094342012452166">
<mml:msubsup>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">R</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>C</mml:mi>
<mml:mi>S</mml:mi>
<mml:mi>I</mml:mi>
</mml:mrow>
</mml:msubsup>
</mml:math>
</inline-formula> instead of <inline-formula id="inline-formula172-1094342012452166">
<mml:math id="mml-inline172-1094342012452166">
<mml:msubsup>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">R</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
<mml:mo>′</mml:mo>
</mml:msubsup>
</mml:math>
</inline-formula> in the approach described in <xref ref-type="fig" rid="fig6-1094342012452166">Figure 6</xref> to compute the TDISP.</p>
<fig id="fig8-1094342012452166" position="float">
<label>Figure 8.</label>
<caption>
<p>Parallel computation of splines coefficients and interpolated GCC-PHATs.</p>
</caption>
<graphic xlink:href="10.1177_1094342012452166-fig8.tif"/>
</fig>
<p>In an overview of our whole GPU-based NCSI approach, it is important to note that even though there are many accesses to the GPU’s global memory, they are all performed in a coalesced fashion, which is the optimal way to do it. Furthermore, an advantage of having the NCSI implemented in the GPU is that there is no need to transfer data between the CPU and the GPU after the process in <xref ref-type="fig" rid="fig5-1094342012452166">Figure 5</xref>, what would be highly time consuming. This means that even if we get no speed-up using this approach, it is still better than having to transfer data through the PCI-E and computing it on the CPU.</p>
</sec>
</sec>
<sec id="section15-1094342012452166">
<title>6. Experimental evaluation</title>
<p>In order to evaluate the performance of our GPU SRP-PHATs we have planned a set of experiments. We used CUDA/C++ implementations for both versions of the algorithm in order to make comparisons of their execution time while running on different devices: an Intel Core I7-950 CPU, a GeForce GTS 360M GPU, and a GeForce GTX 570 GPU. The used CPU is equipped with 4 cores that run on a frequency range of 3.06–3.33 GHz, support 8 threads via hyperthreading, and is nowadays considered a high-end processor. The GTS 360M is a mobile GPU equipped with 96 cores, each running on a frequency of 575 MHz, and is nowadays classified as mid-range. Finally, the GTX 570 is a more powerful high-end GPU of the Fermi family and it is equipped with 480 cores, each at a 732 MHz frequency. For the CPU implementation, we have parallelized it using the OpenMP API (<xref ref-type="bibr" rid="bibr4-1094342012452166">Chapman et al., 2007</xref>) and, although not explicitly vectorized in the implementation, we have set the compiler to automatically generate intrinsic SSE functions when possible. Moreover, for sake of simplicity, we named the experiments run on the GTS 360M as GPU1, on the GTX 570 as GPU2 and on the Core I7 as CPU.</p>
<p>
<xref ref-type="fig" rid="fig9-1094342012452166">Figures 9</xref>, <xref ref-type="fig" rid="fig10-1094342012452166">10</xref> and <xref ref-type="fig" rid="fig11-1094342012452166">11</xref> illustrate the execution times for the FDSP, TDSP and TDISP algorithms, all run for CPU, GPU1 and GPU2. The plots on the left illustrate the growing behavior of the runtime as the number of search points increases from <inline-formula id="inline-formula173-1094342012452166">
<mml:math id="mml-inline173-1094342012452166">
<mml:mi>Q</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>000</mml:mn>
</mml:math>
</inline-formula> to <inline-formula id="inline-formula174-1094342012452166">
<mml:math id="mml-inline174-1094342012452166">
<mml:mi>Q</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>360</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>000</mml:mn>
</mml:math>
</inline-formula> and with a constant <inline-formula id="inline-formula175-1094342012452166">
<mml:math id="mml-inline175-1094342012452166">
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>8</mml:mn>
</mml:math>
</inline-formula>. The plots on the right present the same idea, but related to the variation of the number of microphones, <inline-formula id="inline-formula176-1094342012452166">
<mml:math id="mml-inline176-1094342012452166">
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>8</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mo stretchy="false">…</mml:mo>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>120</mml:mn>
</mml:math>
</inline-formula> and fixing <inline-formula id="inline-formula177-1094342012452166">
<mml:math id="mml-inline177-1094342012452166">
<mml:mi>Q</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>3</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>600</mml:mn>
</mml:math>
</inline-formula>. For the measurements, the average execution time of 100 consecutive runs was taken for each parametrization. For the remaining parameters, we set, <inline-formula id="inline-formula178-1094342012452166">
<mml:math id="mml-inline178-1094342012452166">
<mml:mi>N</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>4</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>096</mml:mn>
</mml:math>
</inline-formula>, <inline-formula id="inline-formula179-1094342012452166">
<mml:math id="mml-inline179-1094342012452166">
<mml:mi>K</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>048</mml:mn>
</mml:math>
</inline-formula>, <inline-formula id="inline-formula180-1094342012452166">
<mml:math id="mml-inline180-1094342012452166">
<mml:mi>S</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>64</mml:mn>
</mml:math>
</inline-formula>, <inline-formula id="inline-formula181-1094342012452166">
<mml:math id="mml-inline181-1094342012452166">
<mml:mi>E</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>10</mml:mn>
</mml:math>
</inline-formula> (same as <xref ref-type="bibr" rid="bibr8-1094342012452166">Do and Silverman (2007</xref>)) and <inline-formula id="inline-formula182-1094342012452166">
<mml:math id="mml-inline182-1094342012452166">
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:msub>
<mml:mi>V</mml:mi>
<mml:mrow>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="normal">m</mml:mi>
<mml:mi mathvariant="normal">a</mml:mi>
<mml:mi mathvariant="normal">x</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>72</mml:mn>
</mml:math>
</inline-formula> (owing to <inline-formula id="inline-formula183-1094342012452166">
<mml:math id="mml-inline183-1094342012452166">
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>8</mml:mn>
</mml:math>
</inline-formula>, an equidistant spacing of 0.08 m and a sampling frequency of <inline-formula id="inline-formula184-1094342012452166">
<mml:math id="mml-inline184-1094342012452166">
<mml:mn>44</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>100</mml:mn>
</mml:math>
</inline-formula> Hz). Furthermore, the plots’ vertical axes use a logarithmic scale for better visualization of the time differences.</p>
<fig id="fig9-1094342012452166" position="float">
<label>Figure 9.</label>
<caption>
<p>Execution time for the FDSP algorithm varying parameters <inline-formula id="inline-formula189-1094342012452166">
<mml:math id="mml-inline189-1094342012452166">
<mml:mi>Q</mml:mi>
</mml:math>
</inline-formula> (left) and <inline-formula id="inline-formula190-1094342012452166">
<mml:math id="mml-inline190-1094342012452166">
<mml:mi>M</mml:mi>
</mml:math>
</inline-formula> (right).</p>
</caption>
<graphic xlink:href="10.1177_1094342012452166-fig9.tif"/>
</fig>
<fig id="fig10-1094342012452166" position="float">
<label>Figure 10.</label>
<caption>
<p>Execution time for the TDSP algorithm varying parameters <inline-formula id="inline-formula187-1094342012452166">
<mml:math id="mml-inline187-1094342012452166">
<mml:mi>Q</mml:mi>
</mml:math>
</inline-formula> (left) and <inline-formula id="inline-formula188-1094342012452166">
<mml:math id="mml-inline188-1094342012452166">
<mml:mi>M</mml:mi>
</mml:math>
</inline-formula> (right).</p>
</caption>
<graphic xlink:href="10.1177_1094342012452166-fig10.tif"/>
</fig>
<fig id="fig11-1094342012452166" position="float">
<label>Figure 11.</label>
<caption>
<p>Execution time for the TDISP algorithm varying parameters <inline-formula id="inline-formula185-1094342012452166">
<mml:math id="mml-inline185-1094342012452166">
<mml:mi>Q</mml:mi>
</mml:math>
</inline-formula> (left) and <inline-formula id="inline-formula186-1094342012452166">
<mml:math id="mml-inline186-1094342012452166">
<mml:mi>M</mml:mi>
</mml:math>
</inline-formula> (right).</p>
</caption>
<graphic xlink:href="10.1177_1094342012452166-fig11.tif"/>
</fig>
<p>We may observe that for all of the presented experiments, and for the three algorithms, the GPU versions outperform the CPU version. We achieved runtime reductions of around <inline-formula id="inline-formula191-1094342012452166">
<mml:math id="mml-inline191-1094342012452166">
<mml:mn>275</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula> for the FDSP algorithm, and reductions of around <inline-formula id="inline-formula192-1094342012452166">
<mml:math id="mml-inline192-1094342012452166">
<mml:mn>70</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula> for the TDSP and TDISP algorithm. For more detailed comparison, <xref ref-type="table" rid="table1-1094342012452166">Tables 1</xref> and <xref ref-type="table" rid="table2-1094342012452166">2</xref> show the exact measured speedups of the experiments GPU1 and GPU2 compared with CPU, for the same parameterizations as those of the plots.</p>
<table-wrap id="table1-1094342012452166" position="float">
<label>Table 1.</label>
<caption>
<p>Speedups of GPU1 and GPU2 compared with CPU for different search spaces.</p>
</caption>
<graphic alternate-form-of="table1-1094342012452166" xlink:href="10.1177_1094342012452166-table1.tif"/>
<table>
<thead>
<tr>
<th colspan="2" rowspan="2">
</th>
<th colspan="4">Search Space Size (<inline-formula id="inline-formula193-1094342012452166">
<mml:math id="mml-inline193-1094342012452166">
<mml:mi>Q</mml:mi>
</mml:math>
</inline-formula>)</th>
</tr>
<tr>
<th>
<inline-formula id="inline-formula194-1094342012452166">
<mml:math id="mml-inline194-1094342012452166">
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>000</mml:mn>
</mml:math>
</inline-formula>
</th>
<th>
<inline-formula id="inline-formula195-1094342012452166">
<mml:math id="mml-inline195-1094342012452166">
<mml:mn>40</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>000</mml:mn>
</mml:math>
</inline-formula>
</th>
<th>
<inline-formula id="inline-formula196-1094342012452166">
<mml:math id="mml-inline196-1094342012452166">
<mml:mn>160</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>000</mml:mn>
</mml:math>
</inline-formula>
</th>
<th>
<inline-formula id="inline-formula197-1094342012452166">
<mml:math id="mml-inline197-1094342012452166">
<mml:mn>360</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>000</mml:mn>
</mml:math>
</inline-formula>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
</td>
<td>GPU1</td>
<td>
<inline-formula id="inline-formula198-1094342012452166">
<mml:math id="mml-inline198-1094342012452166">
<mml:mn>61.24</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula199-1094342012452166">
<mml:math id="mml-inline199-1094342012452166">
<mml:mn>60.61</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula200-1094342012452166">
<mml:math id="mml-inline200-1094342012452166">
<mml:mn>59.27</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula201-1094342012452166">
<mml:math id="mml-inline201-1094342012452166">
<mml:mn>60.66</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
</tr>
<tr>
<td>
<bold>FDSP</bold>
</td>
<td>GPU2</td>
<td>
<inline-formula id="inline-formula202-1094342012452166">
<mml:math id="mml-inline202-1094342012452166">
<mml:mn>276.01</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula203-1094342012452166">
<mml:math id="mml-inline203-1094342012452166">
<mml:mn>276.04</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula204-1094342012452166">
<mml:math id="mml-inline204-1094342012452166">
<mml:mn>275.7</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula205-1094342012452166">
<mml:math id="mml-inline205-1094342012452166">
<mml:mn>276.43</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
</tr>
<tr>
<td>
</td>
<td>GPU1</td>
<td>
<inline-formula id="inline-formula206-1094342012452166">
<mml:math id="mml-inline206-1094342012452166">
<mml:mn>7.72</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula207-1094342012452166">
<mml:math id="mml-inline207-1094342012452166">
<mml:mn>9.88</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula208-1094342012452166">
<mml:math id="mml-inline208-1094342012452166">
<mml:mn>9.67</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula209-1094342012452166">
<mml:math id="mml-inline209-1094342012452166">
<mml:mn>10.8</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
</tr>
<tr>
<td>
<bold>TDSP</bold>
</td>
<td>GPU2</td>
<td>
<inline-formula id="inline-formula210-1094342012452166">
<mml:math id="mml-inline210-1094342012452166">
<mml:mn>41.79</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula211-1094342012452166">
<mml:math id="mml-inline211-1094342012452166">
<mml:mn>51.33</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula212-1094342012452166">
<mml:math id="mml-inline212-1094342012452166">
<mml:mn>49.62</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula213-1094342012452166">
<mml:math id="mml-inline213-1094342012452166">
<mml:mn>55.24</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
</tr>
<tr>
<td>
</td>
<td>GPU1</td>
<td>
<inline-formula id="inline-formula214-1094342012452166">
<mml:math id="mml-inline214-1094342012452166">
<mml:mn>6.94</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula215-1094342012452166">
<mml:math id="mml-inline215-1094342012452166">
<mml:mn>8.54</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula216-1094342012452166">
<mml:math id="mml-inline216-1094342012452166">
<mml:mn>8.73</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula217-1094342012452166">
<mml:math id="mml-inline217-1094342012452166">
<mml:mn>9.31</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
</tr>
<tr>
<td>
<bold>TDISP</bold>
</td>
<td>GPU2</td>
<td>
<inline-formula id="inline-formula218-1094342012452166">
<mml:math id="mml-inline218-1094342012452166">
<mml:mn>29.41</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula219-1094342012452166">
<mml:math id="mml-inline219-1094342012452166">
<mml:mn>37.89</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula220-1094342012452166">
<mml:math id="mml-inline220-1094342012452166">
<mml:mn>48.11</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula221-1094342012452166">
<mml:math id="mml-inline221-1094342012452166">
<mml:mn>49.68</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
</tr>
</tbody>
</table>
</table-wrap>
<table-wrap id="table2-1094342012452166" position="float">
<label>Table 2.</label>
<caption>
<p>Speedups of GPU1 and GPU2 compared with CPU for an increasing number of microphones.</p>
</caption>
<graphic alternate-form-of="table2-1094342012452166" xlink:href="10.1177_1094342012452166-table2.tif"/>
<table>
<thead>
<tr>
<th colspan="2" rowspan="2">
</th>
<th colspan="6">Number of microphones (<inline-formula id="inline-formula222-1094342012452166">
<mml:math id="mml-inline222-1094342012452166">
<mml:mi>M</mml:mi>
</mml:math>
</inline-formula>)</th>
</tr>
<tr>
<th>
<inline-formula id="inline-formula223-1094342012452166">
<mml:math id="mml-inline223-1094342012452166">
<mml:mn>8</mml:mn>
</mml:math>
</inline-formula>
</th>
<th>
<inline-formula id="inline-formula224-1094342012452166">
<mml:math id="mml-inline224-1094342012452166">
<mml:mn>40</mml:mn>
</mml:math>
</inline-formula>
</th>
<th>
<inline-formula id="inline-formula225-1094342012452166">
<mml:math id="mml-inline225-1094342012452166">
<mml:mn>60</mml:mn>
</mml:math>
</inline-formula>
</th>
<th>
<inline-formula id="inline-formula226-1094342012452166">
<mml:math id="mml-inline226-1094342012452166">
<mml:mn>80</mml:mn>
</mml:math>
</inline-formula>
</th>
<th>
<inline-formula id="inline-formula227-1094342012452166">
<mml:math id="mml-inline227-1094342012452166">
<mml:mn>100</mml:mn>
</mml:math>
</inline-formula>
</th>
<th>
<inline-formula id="inline-formula228-1094342012452166">
<mml:math id="mml-inline228-1094342012452166">
<mml:mn>120</mml:mn>
</mml:math>
</inline-formula>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
</td>
<td>GPU1</td>
<td>
<inline-formula id="inline-formula229-1094342012452166">
<mml:math id="mml-inline229-1094342012452166">
<mml:mn>62.81</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula230-1094342012452166">
<mml:math id="mml-inline230-1094342012452166">
<mml:mn>59.34</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula231-1094342012452166">
<mml:math id="mml-inline231-1094342012452166">
<mml:mn>61.93</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula232-1094342012452166">
<mml:math id="mml-inline232-1094342012452166">
<mml:mn>62.43</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula233-1094342012452166">
<mml:math id="mml-inline233-1094342012452166">
<mml:mn>59.50</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula234-1094342012452166">
<mml:math id="mml-inline234-1094342012452166">
<mml:mn>61.42</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
</tr>
<tr>
<td>
<bold>FDSP</bold>
</td>
<td>GPU2</td>
<td>
<inline-formula id="inline-formula235-1094342012452166">
<mml:math id="mml-inline235-1094342012452166">
<mml:mn>268.88</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula236-1094342012452166">
<mml:math id="mml-inline236-1094342012452166">
<mml:mn>269.89</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula237-1094342012452166">
<mml:math id="mml-inline237-1094342012452166">
<mml:mn>267.17</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula238-1094342012452166">
<mml:math id="mml-inline238-1094342012452166">
<mml:mn>268.27</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula239-1094342012452166">
<mml:math id="mml-inline239-1094342012452166">
<mml:mn>269.01</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula240-1094342012452166">
<mml:math id="mml-inline240-1094342012452166">
<mml:mn>270.46</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
</tr>
<tr>
<td>
</td>
<td>GPU1</td>
<td>
<inline-formula id="inline-formula241-1094342012452166">
<mml:math id="mml-inline241-1094342012452166">
<mml:mn>13.93</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula242-1094342012452166">
<mml:math id="mml-inline242-1094342012452166">
<mml:mn>18.72</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula243-1094342012452166">
<mml:math id="mml-inline243-1094342012452166">
<mml:mn>18.39</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula244-1094342012452166">
<mml:math id="mml-inline244-1094342012452166">
<mml:mn>19.52</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula245-1094342012452166">
<mml:math id="mml-inline245-1094342012452166">
<mml:mn>19.40</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula246-1094342012452166">
<mml:math id="mml-inline246-1094342012452166">
<mml:mn>19.98</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
</tr>
<tr>
<td>
<bold>TDSP</bold>
</td>
<td>GPU2</td>
<td>
<inline-formula id="inline-formula247-1094342012452166">
<mml:math id="mml-inline247-1094342012452166">
<mml:mn>44.50</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula248-1094342012452166">
<mml:math id="mml-inline248-1094342012452166">
<mml:mn>67.59</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula249-1094342012452166">
<mml:math id="mml-inline249-1094342012452166">
<mml:mn>66.38</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula250-1094342012452166">
<mml:math id="mml-inline250-1094342012452166">
<mml:mn>70.47</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula251-1094342012452166">
<mml:math id="mml-inline251-1094342012452166">
<mml:mn>70.03</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula252-1094342012452166">
<mml:math id="mml-inline252-1094342012452166">
<mml:mn>69.97</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
</tr>
<tr>
<td>
</td>
<td>GPU1</td>
<td>
<inline-formula id="inline-formula253-1094342012452166">
<mml:math id="mml-inline253-1094342012452166">
<mml:mn>12.26</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula254-1094342012452166">
<mml:math id="mml-inline254-1094342012452166">
<mml:mn>17.53</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula255-1094342012452166">
<mml:math id="mml-inline255-1094342012452166">
<mml:mn>17.64</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula256-1094342012452166">
<mml:math id="mml-inline256-1094342012452166">
<mml:mn>17.37</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula257-1094342012452166">
<mml:math id="mml-inline257-1094342012452166">
<mml:mn>18.44</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula258-1094342012452166">
<mml:math id="mml-inline258-1094342012452166">
<mml:mn>18.88</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
</tr>
<tr>
<td>
<bold>TDISP</bold>
</td>
<td>GPU2</td>
<td>
<inline-formula id="inline-formula259-1094342012452166">
<mml:math id="mml-inline259-1094342012452166">
<mml:mn>42.21</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula260-1094342012452166">
<mml:math id="mml-inline260-1094342012452166">
<mml:mn>51.27</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula261-1094342012452166">
<mml:math id="mml-inline261-1094342012452166">
<mml:mn>62.59</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula262-1094342012452166">
<mml:math id="mml-inline262-1094342012452166">
<mml:mn>61.97</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula263-1094342012452166">
<mml:math id="mml-inline263-1094342012452166">
<mml:mn>61.14</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
<td>
<inline-formula id="inline-formula264-1094342012452166">
<mml:math id="mml-inline264-1094342012452166">
<mml:mn>56.03</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>
</td>
</tr>
</tbody>
</table>
</table-wrap>
<p>Analyzing the speed gains, we first notice that they are higher for the FDSP. This may be explained mainly by two reasons. First, the TDSP (TDISP too) inevitably requires a high number of memory accesses to the GPU’s global memory in a non-sequential fashion (recall this is related to the TDOAs <inline-formula id="inline-formula265-1094342012452166">
<mml:math id="mml-inline265-1094342012452166">
<mml:msubsup>
<mml:mi mathvariant="italic">τ</mml:mi>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mi>l</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
</mml:mrow>
</mml:msubsup>
</mml:math>
</inline-formula>). This ends up violating the very important performance pattern previously described in Section 4: coalesced memory accesses. Secondly, the block size of the TDSP kernel (recall <xref ref-type="fig" rid="fig6-1094342012452166">Figure 6</xref>) is not a multiple of 32, which is also not encouraged due to the warp size restriction also mentioned before. Nevertheless, the GPU TDSP and TDISP still benefits a lot from aspects such as the GPU-based FFT/IFFT algorithms and the parallel computation of each point’s SRP-PHAT, still providing a significant speedup over a CPU version.</p>
<p>In addition, for the TDSP and TDISP, the speedups are higher when varying the parameter <inline-formula id="inline-formula266-1094342012452166">
<mml:math id="mml-inline266-1094342012452166">
<mml:mi>M</mml:mi>
</mml:math>
</inline-formula> than when varying the parameter <inline-formula id="inline-formula267-1094342012452166">
<mml:math id="mml-inline267-1094342012452166">
<mml:mi>Q</mml:mi>
</mml:math>
</inline-formula>. This may be explained by the fact that when a high number of microphones is used, the TDSP and the interpolation routines benefit from more GPU power, which mainly happens during the computation of the GCC-PHATs (<xref ref-type="fig" rid="fig5-1094342012452166">Figure 5</xref>) and during the CSI kernel (<xref ref-type="fig" rid="fig8-1094342012452166">Figure 8</xref>). When <inline-formula id="inline-formula268-1094342012452166">
<mml:math id="mml-inline268-1094342012452166">
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>8</mml:mn>
</mml:math>
</inline-formula>, for example, the grid size will be <inline-formula id="inline-formula269-1094342012452166">
<mml:math id="mml-inline269-1094342012452166">
<mml:mn>28</mml:mn>
</mml:math>
</inline-formula> for those routines, which provides a low occupancy of the GPU, especially the GTX 570, that has 480 cores. On the other hand, when <inline-formula id="inline-formula270-1094342012452166">
<mml:math id="mml-inline270-1094342012452166">
<mml:mi>M</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>120</mml:mn>
</mml:math>
</inline-formula>, the grid size will be <inline-formula id="inline-formula271-1094342012452166">
<mml:math id="mml-inline271-1094342012452166">
<mml:mn>7</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>140</mml:mn>
</mml:math>
</inline-formula>, providing more occupancy of the GPU.</p>
<p>An additional observation is that the speedups, for the TDSP, are higher when interpolation is not being used. This happens because the GPU-based CSI does not provide a high speedup itself, causing the overall TDISP speedups to drop. <xref ref-type="fig" rid="fig12-1094342012452166">Figure 12</xref> shows a comparison of GPU1, GPU2 and CPU for the CSI alone as well as how much of the TDISP is occupied by the CSI. In the figure, we may notice that, although the CSI alone indeed provides a speedup, it represents a higher proportion of the TDISP in the GPU than it does in the CPU. This is explained by the fact that the speedup of the TDSP is much higher than the CSI (<inline-formula id="inline-formula272-1094342012452166">
<mml:math id="mml-inline272-1094342012452166">
<mml:mn>70</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula> against <inline-formula id="inline-formula273-1094342012452166">
<mml:math id="mml-inline273-1094342012452166">
<mml:mn>11</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula> in the best scenario). In fact, the CSI algorithm is not very favorable for a GPU implementation. Solving a tridiagonal system requires direct dependency between adjacent loop iterations, making it hard to be parallelized. This reflects directly into the CR+PCR algorithm we use (<xref ref-type="bibr" rid="bibr32-1094342012452166">Zhang et al., 2010</xref>), to which it is reported speedups around <inline-formula id="inline-formula274-1094342012452166">
<mml:math id="mml-inline274-1094342012452166">
<mml:mn>12</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula> over CPU versions. Moreover all kernels related to the CSI also have block sizes not a multiple of 32 and do not perfectly achieve the recommended memory access patterns. Nevertheless, it is important to mention that it is still highly beneficial to perform the CSI in the GPU, for the reason that transferring all of the GCC-PHATs back to CPU would be much more time consuming.</p>
<fig id="fig12-1094342012452166" position="float">
<label>Figure 12.</label>
<caption>
<p>Execution time for the CSI algorithm (left) and proportion of the TDISP that is occupied by the CSI (right). Both graphs are for varying number of microphones.</p>
</caption>
<graphic xlink:href="10.1177_1094342012452166-fig12.tif"/>
</fig>
<p>In a overview of our algorithm, its main advantage may be seen as the high-speed gains over its CPU version, but we highlight that another benefit of using the GPU for the heavy processing is that the CPU is left free for any other tasks that might be run parallel to the SRP-PHATs. An example would be multimodal speaker localization using audio and video information, in which the CPU could be used for processing video data. Furthermore, we may observe that our algorithms are highly scalable to the GPU’s available power, once the runtimes were higher for the GTX 570. This implies that one can always appeal to better devices when faster executions are needed, i.e. when higher values of <inline-formula id="inline-formula275-1094342012452166">
<mml:math id="mml-inline275-1094342012452166">
<mml:mi>Q</mml:mi>
</mml:math>
</inline-formula> and/or <inline-formula id="inline-formula276-1094342012452166">
<mml:math id="mml-inline276-1094342012452166">
<mml:mi>M</mml:mi>
</mml:math>
</inline-formula> are used. However, it is interesting to note that even the GTS 360M runs the SRP-PHATs faster than the Core i7-950, which is a high-end CPU.</p>
</sec>
<sec id="section16-1094342012452166">
<title>7. Conclusions</title>
<p>In this paper we have presented efficient GPU approaches for both the frequency-domain and time-domain versions of the SRP-PHAT. These formulations of the algorithm in practice differ in their computational complexity and precision, making them individually preferable in different situations. Although the accuracy of the time-domain version is lower, it is a common practice to enhance it using interpolation techniques. For that reason, we also presented here a GPU approach for computing the one-dimensional cubic splines interpolation algorithm. When comparing our algorithms using a GTX 570 and a Core i7-950, our experimental results indicate that the TD version reaches speedups up to <inline-formula id="inline-formula277-1094342012452166">
<mml:math id="mml-inline277-1094342012452166">
<mml:mn>70</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>, the FD up to <inline-formula id="inline-formula278-1094342012452166">
<mml:math id="mml-inline278-1094342012452166">
<mml:mn>275</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula> and the interpolation up to <inline-formula id="inline-formula279-1094342012452166">
<mml:math id="mml-inline279-1094342012452166">
<mml:mn>11</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
</mml:math>
</inline-formula>. Furthermore, using our proposed implementations gives the additional advantages of leaving the CPU free to process any other task parallel to the GPU, and also allow for any further modifications of the algorithm that may improve its speed, while their original formulations were not altered. Finally, future work will aim at alternatives for improving the TD version, as it is a memory problematic algorithm for the GPU.</p>
</sec>
</body>
<back>
<fn-group>
<fn fn-type="financial-disclosure" id="fn1-1094342012452166">
<label>Funding</label>
<p>This work was developed in cooperation with Hewlett-Packard Brasil Ltda. using incentives of Brazilian Informatics Law (Law n 8.2.48 of 1991). This work was partially supported by Brazilian research agency CNPq.</p>
</fn>
</fn-group>
<ref-list>
<title>References</title>
<ref id="bibr1-1094342012452166">
<citation citation-type="journal">
<person-group person-group-type="author">
<name>
<surname>Brandstein</surname>
<given-names>M</given-names>
</name>
<name>
<surname>Adcock</surname>
<given-names>J</given-names>
</name>
<name>
<surname>Silverman</surname>
<given-names>H</given-names>
</name>
</person-group> (<year>1995</year>) <article-title>A practical time-delay estimator for localizing speech sources with a microphone array</article-title>. <source>Computer Speech and Language</source> <volume>9</volume>: <fpage>153</fpage>–<lpage>169</lpage>.</citation>
</ref>
<ref id="bibr2-1094342012452166">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Brandstein</surname>
<given-names>M</given-names>
</name>
<name>
<surname>Ward</surname>
<given-names>D</given-names>
</name>
</person-group> eds (<year>2001</year>) <source>Microphone arrays: signal processing techniques and applications</source> <edition>(1st edn)</edition>. <publisher-loc>New York</publisher-loc>: <publisher-name>Springer</publisher-name>.</citation>
</ref>
<ref id="bibr3-1094342012452166">
<citation citation-type="journal">
<person-group person-group-type="author">
<name>
<surname>Brandstein</surname>
<given-names>MS</given-names>
</name>
<name>
<surname>Adcock</surname>
<given-names>JE</given-names>
</name>
<name>
<surname>Silverman</surname>
<given-names>HF</given-names>
</name>
</person-group> (<year>1997</year>) <article-title>A closed-form location estimator for use with room environment microphone arrays</article-title>. <source>IEEE Transactions on Speech and Audio Processing</source> <volume>5</volume>: <fpage>45</fpage>–<lpage>50</lpage>.</citation>
</ref>
<ref id="bibr4-1094342012452166">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Chapman</surname>
<given-names>B</given-names>
</name>
<name>
<surname>Jost</surname>
<given-names>G</given-names>
</name>
<name>
<surname>vand der Pas</surname>
<given-names>R</given-names>
</name>
</person-group> (<year>2007</year>) <source>Using OpenMP: Portable Shared Memory Parallel Programming (Scientific and Engineering Computation)</source>. <publisher-loc>Cambridge, MA</publisher-loc>: <publisher-name>The MIT Press</publisher-name>.</citation>
</ref>
<ref id="bibr5-1094342012452166">
<citation citation-type="web">
<person-group person-group-type="author">
<name>
<surname>da Silveira</surname>
<given-names>LG</given-names>
</name>
<name>
<surname>Minotto</surname>
<given-names>VP</given-names>
</name>
<name>
<surname>Jung</surname>
<given-names>CR</given-names>
</name>
<name>
<surname>Lee</surname>
<given-names>B</given-names>
</name>
</person-group> (<year>2010</year>) <article-title>A GPU Implementation of the SRP-PHAT Sound Source Localization Algorithm</article-title>. In <source>International Workshop on Acoustic Echo and Noise Control</source>, <ext-link ext-link-type="uri" xlink:href="http://www.iwaenc.org/proceedings/2010/HTML/Uploads/1062.pdf">http://www.iwaenc.org/proceedings/2010/HTML/Uploads/1062.pdf</ext-link>.</citation>
</ref>
<ref id="bibr6-1094342012452166">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Dey</surname>
<given-names>P</given-names>
</name>
<name>
<surname>Selvaraj</surname>
<given-names>M</given-names>
</name>
<name>
<surname>Lee</surname>
<given-names>B</given-names>
</name>
</person-group> (<year>2011</year>). <article-title>Robust user context analysis for multimodal interfaces</article-title>. In <source>Proceedings 13th International Conference on Multimodal Interaction (ICMI)</source>, <publisher-name>Alicante</publisher-name>, <publisher-loc>Spain</publisher-loc>, pp. <fpage>81</fpage>–<lpage>88</lpage>.</citation>
</ref>
<ref id="bibr7-1094342012452166">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>DiBiase</surname>
<given-names>JH</given-names>
</name>
</person-group> (<year>2000</year>) <source>A High-Accuracy, Low-Latency Technique for Talker Localization in Reverberant Environments Using Microphone Arrays</source>. <publisher-name>Ph.D. thesis</publisher-name>, <publisher-loc>Brown University</publisher-loc>.</citation>
</ref>
<ref id="bibr8-1094342012452166">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Do</surname>
<given-names>H</given-names>
</name>
<name>
<surname>Silverman</surname>
<given-names>HF</given-names>
</name>
</person-group> (<year>2007</year>) <article-title>A fast microphone array SRP-PHAT source location implementation using coarse-to-fine region contraction (CFRC)</article-title>. In <source>2007 IEEE Workshop on Applications of Signal Processing to Audio and Acoustics</source>, pp. <fpage>295</fpage>–<lpage>298</lpage>.</citation>
</ref>
<ref id="bibr9-1094342012452166">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Do</surname>
<given-names>H</given-names>
</name>
<name>
<surname>Silverman</surname>
<given-names>H</given-names>
</name>
<name>
<surname>Yu</surname>
<given-names>Y</given-names>
</name>
</person-group> (<year>2007</year>) <article-title>A real-time SRP-PHAT source location implementation using stochastic region contraction (SRC) on a large-aperture microphone array</article-title>. In <source>IEEE International Conference on Acoustics, Speech and Signal Processing, 2007 (ICASSP 2007)</source>, <volume>vol. 1</volume>, pp. I–121–I–124.</citation>
</ref>
<ref id="bibr10-1094342012452166">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Glaskowsky</surname>
<given-names>PN</given-names>
</name>
</person-group> (<year>2009</year>) <source>NVIDIA’s Fermi: The First Complete GPU Computing Architecture</source>. <publisher-name>Technical report</publisher-name>, <publisher-loc>NVIDIA Corporation</publisher-loc>.</citation>
</ref>
<ref id="bibr11-1094342012452166">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Govindaraju</surname>
<given-names>NK</given-names>
</name>
<name>
<surname>Lloyd</surname>
<given-names>B</given-names>
</name>
<name>
<surname>Dotsenko</surname>
<given-names>Y</given-names>
</name>
<name>
<surname>Smith</surname>
<given-names>B</given-names>
</name>
<name>
<surname>Manferdelli</surname>
<given-names>J</given-names>
</name>
</person-group> (<year>2008</year>) <article-title>High performance discrete Fourier transforms on graphics processors</article-title>. In <source>Proceedings of the 2008 ACM/IEEE conference on Supercomputing, (SC ’08)</source>. <publisher-loc>Piscataway, NJ</publisher-loc>: <publisher-name>IEEE Press</publisher-name>, pp. <fpage>2:1</fpage>–<lpage>2:12</lpage>.</citation>
</ref>
<ref id="bibr12-1094342012452166">
<citation citation-type="web">
<person-group person-group-type="author">
<name>
<surname>Harris</surname>
<given-names>M</given-names>
</name>
</person-group> (<year>2011</year>) <source>Optimizing Parallel Reduction in CUDA</source>. <publisher-name>NVIDIA Corporation</publisher-name>. <ext-link ext-link-type="uri" xlink:href="http://developer.nvidia.com/cuda-downloads">http://developer.nvidia.com/cuda-downloads</ext-link>. <comment>Accessed February 2012</comment>.</citation>
</ref>
<ref id="bibr13-1094342012452166">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Kirk</surname>
<given-names>DB</given-names>
</name>
<name>
<surname>Hwu</surname>
<given-names>W-m</given-names>
</name>
</person-group> (<year>2010</year>) <source>Programming Massively Parallel Processors: A Hands-on Approach</source>. <publisher-loc>San mateo, CA</publisher-loc>: <publisher-name>Morgan Kaufmann</publisher-name>.</citation>
</ref>
<ref id="bibr14-1094342012452166">
<citation citation-type="journal">
<person-group person-group-type="author">
<name>
<surname>Knapp</surname>
<given-names>C</given-names>
</name>
<name>
<surname>Carter</surname>
<given-names>G</given-names>
</name>
</person-group> (<year>1976</year>) <article-title>The generalized correlation method for estimation of time delay</article-title>. <source>IEEE Transactions on Acoustics, Speech and Signal Processing</source> <volume>24</volume>: <fpage>320</fpage>–<lpage>327</lpage>.</citation>
</ref>
<ref id="bibr15-1094342012452166">
<citation citation-type="web">
<person-group person-group-type="author">
<name>
<surname>Lee</surname>
<given-names>B</given-names>
</name>
<name>
<surname>Kalker</surname>
<given-names>T</given-names>
</name>
</person-group> (<year>2010</year>) <article-title>A vectorized method for computationally efficient SRP-PHAT sound source localization</article-title>. In <source>International Workshop on Acoustic Echo and Noise Control</source>, <ext-link ext-link-type="uri" xlink:href="http://www.iwaenc.org/proceedings/2010/HTML/Uploads/1086.pdf">http://www.iwaenc.org/proceedings/2010/HTML/Uploads/1086.pdf</ext-link>.</citation>
</ref>
<ref id="bibr16-1094342012452166">
<citation citation-type="web">
<person-group person-group-type="author">
<name>
<surname>Lee</surname>
<given-names>B</given-names>
</name>
<name>
<surname>Kalker</surname>
<given-names>T</given-names>
</name>
<name>
<surname>Schafer</surname>
<given-names>RW</given-names>
</name>
</person-group> (<year>2008</year>) <article-title>Maximum-likelihood sound source localization with a multivariate complex Laplacian distribution</article-title>. In <source>International Workshop on Acoustic Echo and Noise Control</source>, <ext-link ext-link-type="uri" xlink:href="http://www.iwaenc.org/proceedings/2008/contents/papers/9053.pdf">http://www.iwaenc.org/proceedings/2008/contents/papers/9053.pdf</ext-link>.</citation>
</ref>
<ref id="bibr17-1094342012452166">
<citation citation-type="journal">
<person-group person-group-type="author">
<name>
<surname>Lindholm</surname>
<given-names>E</given-names>
</name>
<name>
<surname>Nickolls</surname>
<given-names>J</given-names>
</name>
<name>
<surname>Oberman</surname>
<given-names>S</given-names>
</name>
<name>
<surname>Montrym</surname>
<given-names>J</given-names>
</name>
</person-group> (<year>2008</year>) <article-title>NVIDIA Tesla: A unified graphics and computing architecture</article-title>. <source>IEEE Micro</source> <volume>28</volume>: <fpage>39</fpage>–<lpage>55</lpage>.</citation>
</ref>
<ref id="bibr18-1094342012452166">
<citation citation-type="book">
<collab collab-type="author">NVIDIA Corporation</collab> (<year>2006</year>) <source>NVIDIA GeForce 8800 GPU Architecture Overview</source>. <publisher-name>Technical report</publisher-name>, <publisher-loc>NVIDIA Corporation</publisher-loc>.</citation>
</ref>
<ref id="bibr19-1094342012452166">
<citation citation-type="web">
<collab collab-type="author">NVIDIA Corporation</collab> (<year>2011a</year>) <source>CUDA Best Practices Guide</source>. <publisher-name>NVIDIA Corporation</publisher-name>. <ext-link ext-link-type="uri" xlink:href="http://developer.nvidia.com/cuda-downloads">http://developer.nvidia.com/cuda-downloads</ext-link>. <comment>Accessed February 2012</comment>.</citation>
</ref>
<ref id="bibr20-1094342012452166">
<citation citation-type="web">
<collab collab-type="author">NVIDIA Corporation</collab> (<year>2011b</year>) <source>CUDA CUFFT Library</source>. <publisher-name>NVIDIA Corporation</publisher-name>. <ext-link ext-link-type="uri" xlink:href="http://developer.nvidia.com/cuda-downloads">http://developer.nvidia.com/cuda-downloads</ext-link>. <comment>Accessed February 2012</comment>.</citation>
</ref>
<ref id="bibr21-1094342012452166">
<citation citation-type="web">
<collab collab-type="author">NVIDIA Corporation</collab> (<year>2011c</year>) <source>CUDA Programming Guide</source>. <publisher-name>NVIDIA Corporation</publisher-name>. <ext-link ext-link-type="uri" xlink:href="http://developer.nvidia.com/cuda-downloads">http://developer.nvidia.com/cuda-downloads</ext-link>. <comment>Accessed February 2012</comment>.</citation>
</ref>
<ref id="bibr22-1094342012452166">
<citation citation-type="web">
<collab collab-type="author">NVIDIA Corporation</collab> (<year>2011d</year>) <source>Fermi Compatibility Guide</source>. <publisher-name>NVIDIA Corporation</publisher-name>. <ext-link ext-link-type="uri" xlink:href="http://developer.download.nvidia.com/compute/DevZone/docs/html/C/doc/Fermi_Compatibility_Guide.pdf">http://developer.download.nvidia.com/compute/DevZone/docs/html/C/doc/Fermi_Compatibility_Guide.pdf</ext-link>. <comment>Accessed April 2012</comment>.</citation>
</ref>
<ref id="bibr23-1094342012452166">
<citation citation-type="book">
<collab collab-type="author">NVIDIA Corporation</collab> (<year>2011e</year>) <source>NVIDIA’s Next Generation CUDA Compute Architecture: Fermi</source>. <publisher-name>Technical Report</publisher-name>, <publisher-loc>NVIDIA Corporation</publisher-loc>.</citation>
</ref>
<ref id="bibr24-1094342012452166">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Omologo</surname>
<given-names>M</given-names>
</name>
<name>
<surname>Svaizer</surname>
<given-names>P</given-names>
</name>
<name>
<surname>Mori</surname>
<given-names>RD</given-names>
</name>
</person-group> (<year>1997</year>) <article-title>Acoustic transduction</article-title>. <source>Spoken Dialogues with Computers</source>. <publisher-loc>Orlando, FL</publisher-loc>: <publisher-name>Academic Press</publisher-name>.</citation>
</ref>
<ref id="bibr25-1094342012452166">
<citation citation-type="journal">
<person-group person-group-type="author">
<name>
<surname>Savioja</surname>
<given-names>L</given-names>
</name>
<name>
<surname>Välimäki</surname>
<given-names>V</given-names>
</name>
<name>
<surname>Smith</surname>
<given-names>JO</given-names>
</name>
</person-group> (<year>2011</year>) <article-title>Audio signal processing using graphics processing units</article-title>. <source>Journal of the Audio Engineering Society</source> <volume>59</volume>: <fpage>3</fpage>–<lpage>19</lpage>.</citation>
</ref>
<ref id="bibr26-1094342012452166">
<citation citation-type="journal">
<person-group person-group-type="author">
<name>
<surname>Silverman</surname>
<given-names>H</given-names>
</name>
<name>
<surname>Yu</surname>
<given-names>Y</given-names>
</name>
<name>
<surname>Sachar</surname>
<given-names>J</given-names>
</name>
<name>
<surname>Patterson</surname>
<given-names>IWR</given-names>
</name>
</person-group> (<year>2005</year>) <article-title>Performance of real-time source-location estimators for a large-aperture microphone array</article-title>. <source>IEEE Transactions on Speech and Audio Processing</source> <volume>13</volume>: <fpage>593</fpage>–<lpage>606</lpage>.</citation>
</ref>
<ref id="bibr27-1094342012452166">
<citation citation-type="web">
<person-group person-group-type="author">
<name>
<surname>Tervo</surname>
<given-names>S</given-names>
</name>
<name>
<surname>Lokki</surname>
<given-names>T</given-names>
</name>
</person-group> (<year>2008</year>) <article-title>Interpolation Methods for the SRP-PHAT Algorithm</article-title>. In <source>International Workshop on Acoustic Echo and Noise Control</source>, <ext-link ext-link-type="uri" xlink:href="http://www.iwaenc.org/proceedings/2008/contents/papers/9037.pdf">http://www.iwaenc.org/proceedings/2008/contents/papers/9037.pdf</ext-link>.</citation>
</ref>
<ref id="bibr28-1094342012452166">
<citation citation-type="journal">
<person-group person-group-type="author">
<name>
<surname>Tsingos</surname>
<given-names>N</given-names>
</name>
</person-group> (<year>2009</year>) <article-title>Using programmable graphics hardware for acoustics and audio rendering</article-title>. <source>Audio Engineering Society Convention</source> <volume>127</volume>
<issue>(59, 9)</issue>: <fpage>1</fpage>–<lpage>16</lpage>.</citation>
</ref>
<ref id="bibr29-1094342012452166">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Tung</surname>
<given-names>T</given-names>
</name>
<name>
<surname>Yao</surname>
<given-names>K</given-names>
</name>
<name>
<surname>Chen</surname>
<given-names>D</given-names>
</name>
<name>
<surname>Hudson</surname>
<given-names>R</given-names>
</name>
<name>
<surname>Reed</surname>
<given-names>C</given-names>
</name>
</person-group> (<year>1999</year>) <article-title>Source localization and spatial filtering using wideband music and maximum power beamforming for multimedia applications</article-title>. In <source>1999 IEEE Workshop on Signal Processing Systems, 1999 (SiPS 99)</source>, pp. <fpage>625</fpage>–<lpage>634</lpage>.</citation>
</ref>
<ref id="bibr30-1094342012452166">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Wölfel</surname>
<given-names>M</given-names>
</name>
<name>
<surname>McDonough</surname>
<given-names>J</given-names>
</name>
</person-group> (<year>2009</year>) <source>Distant Speech Recognition</source>, <edition>1st edn</edition>. <publisher-loc>Chichester</publisher-loc>: <publisher-name>John Wiley &amp; Sons</publisher-name>.</citation>
</ref>
<ref id="bibr31-1094342012452166">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Zhang</surname>
<given-names>C</given-names>
</name>
<name>
<surname>Zhang</surname>
<given-names>Z</given-names>
</name>
<name>
<surname>Florencio</surname>
<given-names>D</given-names>
</name>
</person-group> (<year>2007</year>) <article-title>Maximum likelihood sound source localization for multipledirectional microphones</article-title>. In <source>IEEE International Conference of Acoustics, Speech and Signal Processing, 2007 (ICASSP 2007)</source>, <volume>vol. 1</volume>, pp. <fpage>I</fpage>–<lpage>125</lpage>–<fpage>I</fpage>–<lpage>128</lpage>.</citation>
</ref>
<ref id="bibr32-1094342012452166">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Zhang</surname>
<given-names>Y</given-names>
</name>
<name>
<surname>Cohen</surname>
<given-names>J</given-names>
</name>
<name>
<surname>Owens</surname>
<given-names>JD</given-names>
</name>
</person-group> (<year>2010</year>) <article-title>Fast tridiagonal solvers on the GPU</article-title>. In <source>Proceedings of the 15th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPoPP</source> <volume>2010</volume>), pp. <fpage>127</fpage>–<lpage>136</lpage>.</citation>
</ref>
</ref-list>
</back>
</article>