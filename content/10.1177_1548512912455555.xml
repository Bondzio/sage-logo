<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD Journal Publishing DTD v2.3 20070202//EN" "journalpublishing.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" xml:lang="en">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">DMS</journal-id>
<journal-id journal-id-type="hwp">spdms</journal-id>
<journal-title>The Journal of Defense Modeling and Simulation: Applications, Methodology, Technology</journal-title>
<issn pub-type="ppub">1548-5129</issn>
<issn pub-type="epub">1557-380X</issn>
<publisher>
<publisher-name>SAGE Publications</publisher-name>
<publisher-loc>Sage UK: London, England</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1177/1548512912455555</article-id>
<article-id pub-id-type="publisher-id">10.1177_1548512912455555</article-id>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Original Articles</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>Metric driven mobility modeling in tactical networks</article-title>
</title-group>
<contrib-group content-type="issue">
<contrib contrib-type="guest-editor">
<name><surname>Henshaw</surname><given-names>Michael</given-names></name>
</contrib>
<contrib contrib-type="guest-editor">
<name><surname>Brathen</surname><given-names>Karsten</given-names></name>
</contrib>
<contrib contrib-type="guest-editor">
<name><surname>Isler</surname><given-names>Veysi</given-names></name>
</contrib>
</contrib-group>
<contrib-group>
<contrib contrib-type="author">
<name><surname>Ray</surname><given-names>Sucharita</given-names></name>
<xref ref-type="aff" rid="aff1-1548512912455555">1</xref>
</contrib>
<contrib contrib-type="author" corresp="yes">
<name><surname>La Porta</surname><given-names>Thomas</given-names></name>
<xref ref-type="aff" rid="aff1-1548512912455555">1</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Basu</surname><given-names>Prithwish</given-names></name>
<xref ref-type="aff" rid="aff2-1548512912455555">2</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Cao</surname><given-names>Guohong</given-names></name>
<xref ref-type="aff" rid="aff1-1548512912455555">1</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Shaffer</surname><given-names>Scott</given-names></name>
<xref ref-type="aff" rid="aff3-1548512912455555">3</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Dent</surname><given-names>Dave</given-names></name>
<xref ref-type="aff" rid="aff3-1548512912455555">3</xref>
</contrib>
</contrib-group>
<aff id="aff1-1548512912455555"><label>1</label>The Pennsylvania State University, University Park, USA</aff>
<aff id="aff2-1548512912455555"><label>2</label>BBN, USA</aff>
<aff id="aff3-1548512912455555"><label>3</label>U.S. Army Research Lab, USA</aff>
<author-notes>
<corresp id="corresp1-1548512912455555">Thomas La Porta, 360B IST Building, Penn State University, University Park, PA 16802, USA. Email: <email>tlp@cse.psu.edu</email></corresp>
</author-notes>
<pub-date pub-type="epub-ppub">
<month>4</month>
<year>2013</year>
</pub-date>
<volume>10</volume>
<issue>2</issue>
<issue-title>Special Issue: Modelling and Simulation for NEC</issue-title>
<fpage>161</fpage>
<lpage>179</lpage>
<permissions>
<copyright-statement>© 2012 The Society for Modeling and Simulation International</copyright-statement>
<copyright-year>2012</copyright-year>
<copyright-holder content-type="society">The Society for Modeling and Simulation International</copyright-holder>
</permissions>
<abstract>
<p>Mobility management is a key aspect of designing and evaluating protocols for Mobile Ad Hoc Networks (MANETs). The high mobility of nodes in a MANET constantly causes the network topology to change. Mobility patterns of nodes have a direct effect on fundamental network characteristics, such as path length, neighborhood size, and link stability. Consequently, the network performance is strongly affected by the nature of mobility patterns. While evaluating protocols for a specific MANET application, it becomes imperative to use a mobility model that is able to capture the movement of nodes in an accurate manner. The objective of this work is to produce mobility models that are able to describe tactical mobility in military applications of MANETs. We provide models of four tactical scenarios, show that these models are accurate compared to synthetic traces, and that when used to evaluate network protocols, they provide different conclusions than when using generic mobility models.</p>
</abstract>
<kwd-group>
<kwd>mobility</kwd>
<kwd>Mobile Ad Hoc Network</kwd>
<kwd>caching</kwd>
<kwd>models</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="section1-1548512912455555" sec-type="intro">
<title>1. Introduction</title>
<p>Modern day warfare has evolved into an amalgamation of complex military tactics and highly advanced information technology. In addition to developing powerful strategies, the United States Department of Defense has pioneered a new military doctrine called network-enabled operations<sup><xref ref-type="bibr" rid="bibr1-1548512912455555">1</xref></sup> that aims at forming robustly networked forces on the battlefield, with enhanced information sharing, higher collaboration, and increased speed of command, resulting in a dramatic increase in mission effectiveness. Supporting network-enabled operations calls for the deployment of a complex communication network and the accurate analysis of network protocols. Communication in military scenarios is often carried out using tactical Mobile Ad Hoc Networks (MANETs), comprising wireless mobile nodes forming self-configuring networks without using any existing infrastructure. A key characteristic of these networks is high mobility of nodes, which results in a dynamic and rapidly changing network topology. Hence, while evaluating protocol performance in MANETs, it is essential to be able to capture the mobility of nodes accurately. An effective means of doing this is through the development of mobility models.</p>
<p>Mobility models are designed to describe the movement pattern of mobile users and capture how their location, velocity, and acceleration change over time. Since mobility patterns play a significant role in determining protocol performance in a MANET, it is desirable for mobility models to emulate the movement pattern of the targeted real-life scenario to a reasonable extent. Otherwise, the observations made and the conclusions drawn from the simulation studies may be misleading. Thus, when evaluating MANET protocols, it is necessary to choose the most appropriate underlying mobility model.</p>
<p>In this work we aim at developing tactical mobility models that are accurately able to capture the movement pattern of soldiers executing military maneuvers. Several research efforts have been made in the past towards modeling mobility in MANETs, but in this work we find conventional mobility models to substantially deviate from the real-life movement patterns of military scenarios. Hence, we develop tactical mobility models with the motivation of using them to effectively evaluate the performance of communication protocols for military applications, so that more informed decisions can be made towards network-enabled operations. This work can be extended further by overlaying different communication models and information objects to understand social interaction and how information flows among nodes in military scenarios. The following is an outline of this paper.</p>
<p>In the second section, we begin by summarizing some of the related research work and specifically discuss the mobility simulator used in this work for modeling military tactics. The third section demonstrates the modeling of three tactical scenarios. This is done using three approaches, including simulations for generating synthetic mobility traces, design of a motion model using fundamental laws of physics and, finally, mathematical modeling using regression analysis. Further, in this section we evaluate the errors between the three approaches. In the fourth section, we describe how the tactical mobility models developed can be used for protocol evaluation, as well as how the performance changes if conventional models are used in place of tactical models. To illustrate this, we take the example of common data replication algorithms, and evaluate their performance with conventional mobility models, as well as with tactical models.</p>
</sec>
<sec id="section2-1548512912455555">
<title>2. Related work</title>
<p>The need to characterize the mobility of nodes in wireless ad hoc networks has drawn many researchers to the topic of mobility modeling. In this section we take a look at some well-known mobility models and closely study the specific tool that has been used to model tactical mobility in this paper.</p>
<sec id="section3-1548512912455555">
<title>2.1 Mobility models – an overview</title>
<p>The <italic>Random Walk</italic> model,<sup><xref ref-type="bibr" rid="bibr2-1548512912455555">2</xref></sup> also referred to as Brownian motion, is a random-based model where mobile nodes move freely without restrictions. In this model, for every new interval <italic>t</italic>, the speed and direction are picked randomly from [<italic>V</italic><sub>max</sub>, <italic>V</italic><sub>min</sub>] and (0,2π]. It is also possible for a node to pause between each interval for a time <italic>T</italic><sub><italic>pause</italic></sub>. The Random Walk model is memoryless. However, this is often not the case with real-life applications, as we will see in further sections.</p>
<p>In the <italic>Random Waypoint</italic> model,<sup><xref ref-type="bibr" rid="bibr3-1548512912455555">3</xref></sup> each mobile node randomly selects a target and travels towards this destination with constant velocity chosen uniformly from [0,<italic>V</italic><sub>max</sub>]. The velocity and direction of a node are chosen independent of other nodes. Upon reaching the destination, the node stops for a duration of <italic>T</italic><sub><italic>pause</italic></sub>. This process continues until the end of the real-time application. Random models over-simplify mobility and are especially unsuited for use in tactical networks where nodes have predefined target sets, velocity ranges, and regular behavior.</p>
<p>In <italic>Reference Point Group Mobility</italic> (RPGM),<sup><xref ref-type="bibr" rid="bibr4-1548512912455555">4</xref>,<xref ref-type="bibr" rid="bibr5-1548512912455555">5</xref></sup> nodes move in groups consisting of a leader node and other member nodes. The motion vector of the group leader <italic>V</italic><sub><italic>group</italic></sub>(<italic>t</italic>) is randomly chosen in each epoch, as described in Random Walk. The member nodes are uniformly distributed around the leader within a finite radius. This model is said to show ‘spatial dependency’, since the movement of a member node is dependent on its leader. Unlike the first two mobility models mentioned earlier, RPGM attempts to model correlated mobility.</p>
<p>The <italic>Manhattan Model</italic><sup><xref ref-type="bibr" rid="bibr6-1548512912455555">6</xref></sup> depicts vehicular mobility in a city like Manhattan, where mobility of vehicles is restricted to the freeways and streets of a region. This model is said to show ‘geographic restrictions’, unlike random models where nodes move freely throughout the simulation region.</p>
<p>In comparison to the models described above, military mobility is much more complex and structured. This is so because soldiers in a battlefield adhere to a predefined mission and code of conduct, which leaves less room for randomization in their movement. Military missions often show group mobility, but using the RPGM model would not suffice, since the movement of military groups is not random. Similarly, soldiers in a battlefield are also restricted to specific paths, but unlike the Manhattan Model, their choice of target and direction is well defined and not random. Due to dynamically changing locations of targets within a given physical terrain, military mobility shows a combination of temporal, spatial, and geographic dependencies.</p>
</sec>
<sec id="section4-1548512912455555">
<title>2.2 Universal Mobility Modeling Framework</title>
<p>Medina et al.<sup><xref ref-type="bibr" rid="bibr7-1548512912455555">7</xref></sup> developed the Universal Mobility Modeling Framework (UMMF), a tool that enables a general model to be parameterized in order to generate application-specific mobility models. The UMMF strives to decouple specific application semantics from mobility features and is able to capture all mobility scenarios in terms of three fundamental factors – Target Selection, Steering Behavior, and Locomotion. Nodes in the UMMF are modeled as autonomous agents capable of a certain amount of intelligence, such as adjusting their paths to avoid obstacles and reacting to dynamic events.</p>
<p>The UMMF tool uses Extensible Markup Language (XML) files as input, where configuration parameters for the scenario being modeled are defined. Some example parameters are target coordinates, target sets, number of nodes, number of groups, group size, steering behaviors, and obstacle coordinates. This input file is parsed by an event-driven simulation engine, which is responsible for node placement, topology evolution, calculation of network statistics, and so on. The UMMF generates an output that contains the coordinates of nodes versus time and statistics about mobility. We use this tool to generate synthetic traces, as described in the next section.</p>
</sec>
</sec>
<sec id="section5-1548512912455555">
<title>3. Tactical mobility models</title>
<p>This section describes the three new mobility models that have been developed as a part of this paper. These three scenarios belong to a wide variety of commonly used military tactics that have been studied and documented in Army Field Manuals<sup><xref ref-type="bibr" rid="bibr8-1548512912455555">8</xref>,<xref ref-type="bibr" rid="bibr9-1548512912455555">9</xref></sup> and by Johnson andWhitby.<sup><xref ref-type="bibr" rid="bibr10-1548512912455555">10</xref></sup> We understand that the actual mobility on the field might deviate from the planned movement as nodes encounter dynamic hostile events, difficult terrain, and so on during the mission. We keep these cases out of the scope of this paper and model simple military mobility that depicts the maneuvers as per plan. In the future this work can be extended to add noise and a possible event-driven decision-making process to the behavior of nodes, to capture dynamic environmental factors that cause deviation from planned military tactics.</p>
<p>The modeling of tactical mobility has been approached in three stages. In the first stage we simulate the scenario using the UMMF tool to generate synthetic traces of several network parameters as a function of time. Specifically, the network parameter of node degree, defined as the number of direct connections or neighbors a node has, has been studied in detail, as an example. In the second stage a motion model is developed that provides a graphical representation of the mobility, as well as mathematical equations for mobility parameters of interest. Finally, in the third stage, we perform time series analysis of node degree, using the traces generated by the UMMF, and present tractable mathematical equations using the technique of curve fitting. We then quantify the error between the mathematical equations and the traces.</p>
<sec id="section6-1548512912455555">
<title>3.1 Repeated Traversal</title>
<p>In the following sections, we illustrate the model for the Repeated Traversal military tactic.</p>
<sec id="section7-1548512912455555">
<title>3.1.1 Scenario description and traces</title>
<p>The objective of Repeated Traversal, described in detail in Army Field Manuals,<sup><xref ref-type="bibr" rid="bibr8-1548512912455555">8</xref>,<xref ref-type="bibr" rid="bibr9-1548512912455555">9</xref></sup> is to maximize the security of troops moving through an unknown, highly hostile terrain. When troops navigate through an unexamined terrain that is suspected to contain ambushes and traps, a common practice is to traverse through the area along the same path one squad after another. The ‘following’ squads depart along the same path, only when the ‘frontal’ squad has arrived at a target of confirmed security and has communicated information about the terrain to the other squads. Frontal squads may also have to rest and wait for the following squads to provide supply and back up. If an ‘unfriendly event’ is observed by the leading squad (such as a trap or bomb explosion), it communicates to the following squad so that the following squad avoids that route.</p>
<p>The movement in Repeated Traversal is very structured. It shows group mobility with an emphasis on inter-group communication. It is important for the leading group to be able to communicate information of the newly traversed terrain to the following group, so that they can plan their movement accordingly. The scenario can be described as an epoch-based model. The simplest case contains two groups in each epoch. It is necessary for these two groups to be able to communicate at the boundaries of each epoch, that is, once the groups have reached their destinations (for that epoch) they should be able to establish contact. <xref ref-type="fig" rid="fig1-1548512912455555">Figure 1</xref> shows two groups doing Repeated Traversal, from target T<sub>1</sub> to target T<sub>6</sub>.</p>
<fig id="fig1-1548512912455555" position="float">
<label>Figure 1.</label>
<caption>
<p>Schematic view of Repeated Traversal.</p>
</caption>
<graphic xlink:href="10.1177_1548512912455555-fig1.tif"/>
</fig>
<p>Traces were generated using the UMMF for several values of input parameters, such as velocity, inter-target distance, group size, and a large variety of seed values. <xref ref-type="fig" rid="fig2-1548512912455555">Figure 2</xref> shows the traces versus time of node degree (graph in red) and average path length (graph in blue).</p>
<fig id="fig2-1548512912455555" position="float">
<label>Figure 2.</label>
<caption>
<p>Mobility traces for Repeated Traversal (versus time; color online only).</p>
</caption>
<graphic xlink:href="10.1177_1548512912455555-fig2.tif"/>
</fig>
<p>Analyzing the UMMF traces, the following inferences can be made intuitively. When the leading group moves significantly slower than the following group, the groups remain in communication range for most of the epoch. Similarly, if the following group begins its movement before the leading group and the velocity of the leading group is not considerably higher, the groups remain in contact. In all other cases, the groups are most likely to move out of communication range initially, remain isolated and then come back in contact towards the end of the epoch. Hence, the curve for node degree versus time is typically a downward parabola. Change in group size only shifts the graph along the <italic>y</italic>-axis but does not alter the shape. On the other hand, change in relative velocity and pause time does affect the shape of the graph in different ways. Behavior of the graph remains consistent for variations in group sizes, as well as for simple and complex (involving dynamic events) mobility scenarios.</p>
</sec>
<sec id="section8-1548512912455555">
<title>3.1.2 Motion model</title>
<p>The motion model of a tactical scenario provides a graphic representation of the movement pattern of nodes. At this stage we create a new layer of abstraction, that of mobility parameters. These are variables of interest that can be directly calculated from the motion model using fundamental concepts of physics. Some examples are inter-group distance, defined as the distance between the center of the groups, and outage time. We formulate tractable mathematical equations for such parameters and describe their behavior over time. The graph of these mobility parameters can further be used to derive the behavior of other network parameters, such as the performance of routing protocols and algorithms in the tactical MANET.</p>
<p><xref ref-type="fig" rid="fig3-1548512912455555">Figure 3</xref> shows the motion model for the simplest case, which consists of two groups moving for one epoch. The variables in <xref ref-type="fig" rid="fig3-1548512912455555">Figure 3</xref> are shown in <xref ref-type="table" rid="table1-1548512912455555">Table 1</xref>. The epoch begins at time <italic>t</italic> = 0 when G<sub>1</sub> begins moving towards its target destination, which is a distance <italic>D</italic><sub>1</sub> away. G<sub>2</sub> waits at its position. <inline-formula id="inline-formula1-1548512912455555"><mml:math display="inline" id="math1-1548512912455555"><mml:mrow><mml:mi>Δ</mml:mi></mml:mrow></mml:math></inline-formula><italic>T</italic><sub><italic>p</italic></sub> time later, G<sub>2</sub> begins to move with velocity <italic>V</italic><sub>2</sub> as G<sub>1</sub> continues to advance. At time = <italic>t</italic><sub>1</sub>, G<sub>1</sub> arrives at its target while G<sub>2</sub> is still moving. The epoch finishes at time = <italic>T</italic><sub><italic>win</italic></sub>, when G<sub>2</sub> reaches its destination. G<sub>1</sub> waits at its position until G<sub>2</sub> has finished its movement.</p>
<fig id="fig3-1548512912455555" position="float">
<label>Figure 3.</label>
<caption>
<p>Motion model of Repeated Traversal.</p>
</caption>
<graphic xlink:href="10.1177_1548512912455555-fig3.tif"/>
</fig>
<table-wrap id="table1-1548512912455555" position="float">
<label>Table 1.</label>
<caption>
<p>Parameters for Repeated Traversal</p>
</caption>
<graphic alternate-form-of="table1-1548512912455555" xlink:href="10.1177_1548512912455555-table1.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="left"/>
</colgroup>
<thead>
<tr>
<th align="left">Variable</th>
<th align="left">Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td><italic>V</italic><sub>1</sub></td>
<td>Average speed of G<sub>1</sub> (leading group)</td>
</tr>
<tr>
<td><italic>V</italic><sub>2</sub></td>
<td>Average speed of G<sub>2</sub> (following group)</td>
</tr>
<tr>
<td><italic>D</italic><sub>1</sub></td>
<td>Distance to next target for G<sub>1</sub></td>
</tr>
<tr>
<td><italic>D</italic><sub>2</sub></td>
<td>Distance to next target for G<sub>2</sub></td>
</tr>
<tr>
<td>Δ<italic>T</italic><sub><italic>p</italic></sub></td>
<td>Difference in pause times of G<sub>1</sub> &amp; G<sub>2</sub></td>
</tr>
<tr>
<td><italic>T</italic><sub><italic>win</italic></sub></td>
<td>Size of epoch</td>
</tr>
<tr>
<td><italic>t</italic><sub>1</sub></td>
<td>Time taken by G<sub>1</sub> to reach its target destination;<italic>t</italic><sub>1</sub><italic>= D</italic><sub>1</sub>/<italic>V</italic><sub>1</sub></td>
</tr>
<tr>
<td><italic>t</italic><sub>2</sub></td>
<td>Time taken by G<sub>2</sub> to reach its target destination;<italic>t</italic><sub>2</sub><italic>= D</italic><sub>2</sub>/<italic>V</italic><sub>2</sub></td>
</tr>
</tbody>
</table>
</table-wrap>
<p>Now let us see how this motion model can be used to analyze the network parameter node degree. To do this, we identify inter-group distance, <italic>D</italic><sub><italic>g</italic></sub>(<italic>t</italic>), as an underlying mobility parameter that can be computed from the mobility model and the behavior of which is linked to that of node degree. For the first part of the epoch (0 <italic>&lt; t &lt; <inline-formula id="inline-formula2-1548512912455555"><mml:math display="inline" id="math2-1548512912455555"><mml:mrow><mml:mi>Δ</mml:mi></mml:mrow></mml:math></inline-formula> T</italic><sub><italic>p</italic></sub>), <italic>D</italic><sub><italic>g</italic></sub> increases due to G<sub>1</sub> moving away from G<sub>2</sub>. Hence:</p>
<p>
<disp-formula id="disp-formula1-1548512912455555">
<label>(1)</label>
<mml:math display="block" id="math3-1548512912455555">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>D</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>g</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>D</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>·</mml:mo>
<mml:mi>t</mml:mi>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula1-1548512912455555" xlink:href="10.1177_1548512912455555-eq1.tif"/>
</disp-formula>
</p>
<p>For the second part of the epoch (<italic><inline-formula id="inline-formula3-1548512912455555"><mml:math display="inline" id="math4-1548512912455555"><mml:mrow><mml:mi>Δ</mml:mi></mml:mrow></mml:math></inline-formula>T</italic><sub><italic>p</italic></sub><italic>&lt; t &lt; t</italic><sub>1</sub>), the <italic>D</italic><sub><italic>g</italic></sub> changes in accordance to the relative velocity between G<sub>1</sub> and G<sub>2</sub>. Hence:</p>
<p>
<disp-formula id="disp-formula2-1548512912455555">
<label>(2)</label>
<mml:math display="block" id="math5-1548512912455555">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>D</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>g</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>D</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>·</mml:mo>
<mml:mi>Δ</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>p</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>−</mml:mo>
<mml:mi>Δ</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>p</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>)</mml:mo>
</mml:mrow>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula2-1548512912455555" xlink:href="10.1177_1548512912455555-eq2.tif"/>
</disp-formula>
</p>
<p>In the last part of the epoch, <italic>D</italic><sub><italic>g</italic></sub> decreases as G2 comes closer to G1. Hence:</p>
<p>
<disp-formula id="disp-formula3-1548512912455555">
<label>(3)</label>
<mml:math display="block" id="math6-1548512912455555">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>D</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>g</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>D</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo>
<mml:mi>V</mml:mi>
<mml:mn>1</mml:mn>
<mml:mo>·</mml:mo>
<mml:mi>Δ</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>p</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>D</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">/</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>−</mml:mo>
<mml:mi>Δ</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>p</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mspace width="0.25em"/>
<mml:mo>−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>D</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">/</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>)</mml:mo>
</mml:mrow>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula3-1548512912455555" xlink:href="10.1177_1548512912455555-eq3.tif"/>
</disp-formula>
</p>
<p>Now consolidating the three cases using unit step functions we get</p>
<p>
<disp-formula id="disp-formula4-1548512912455555">
<label>(4)</label>
<mml:math display="block" id="math7-1548512912455555">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>D</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>g</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">[</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>D</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>·</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">]</mml:mo>
<mml:mo>·</mml:mo>
<mml:mi>u</mml:mi>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mi>Δ</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>p</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>−</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>+</mml:mo>
<mml:mo stretchy="false">[</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>D</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>·</mml:mo>
<mml:mi>Δ</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>p</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mspace width="0.25em"/>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>·</mml:mo>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>−</mml:mo>
<mml:mi>Δ</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>p</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo stretchy="false">]</mml:mo>
<mml:mo>·</mml:mo>
<mml:mi>u</mml:mi>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>−</mml:mo>
<mml:mi>Δ</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>p</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mspace width="0.25em"/>
<mml:mo>·</mml:mo>
<mml:mi>u</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>D</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">/</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>−</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>+</mml:mo>
<mml:mo stretchy="false">[</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>D</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>·</mml:mo>
<mml:mi>Δ</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>p</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mspace width="0.25em"/>
<mml:mo>·</mml:mo>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>D</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">/</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>−</mml:mo>
<mml:mi>Δ</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>p</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>·</mml:mo>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>D</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">/</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo stretchy="false">]</mml:mo>
<mml:mo>·</mml:mo>
<mml:mi>u</mml:mi>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>D</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">/</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mspace width="0.25em"/>
<mml:mspace width="0.25em"/>
<mml:mspace width="0.25em"/>
<mml:mspace width="0.25em"/>
<mml:mo>·</mml:mo>
<mml:mi>u</mml:mi>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>win</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>−</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>)</mml:mo>
</mml:mrow>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula4-1548512912455555" xlink:href="10.1177_1548512912455555-eq4.tif"/>
</disp-formula>
</p>
<p><xref ref-type="fig" rid="fig4-1548512912455555">Figure 4</xref> illustrates the typical behavior of <italic>D</italic><sub><italic>g</italic></sub> when <italic>V</italic><sub>1</sub> is considerably greater than <italic>V</italic><sub>2</sub>. This is the case we are most interested in, since there is the highest likelihood of loss of communication between the groups. As can be seen, <italic>D</italic><sub><italic>g</italic></sub>(<italic>t</italic>) begins at an initial value (here <italic>D</italic><sub>1</sub>) and increases until a maximum value of <italic>D</italic><sub><italic>g</italic>,max</sub> (point where the groups are farthest apart). Then it decreases and settles at the value <italic>D</italic><sub>2</sub>. Now, let us assume that once inter-group distance increases beyond a value of <italic>D</italic><sub><italic>threshold</italic></sub>, the two groups lose contact. So, given the communication model (and hence <italic>D</italic><sub><italic>threshold</italic></sub>), we can tell not only when we can expect a network partition (a point where a node degree would drop to the value of the group size), but also for how long we can expect the partition to remain. This is shown in this figure by the parameter <italic>T</italic><sub><italic>out</italic></sub>, which denotes outage time.</p>
<fig id="fig4-1548512912455555" position="float">
<label>Figure 4.</label>
<caption>
<p>Behavior of inter-group distance over time for Repeated Traversal.</p>
</caption>
<graphic xlink:href="10.1177_1548512912455555-fig4.tif"/>
</fig>
<p>In addition, using the signal propagation model for a specific military application undergoing Repeated Traversal, a clear mathematical relationship can be established between the signal strength and inter-group distance. This will easily enable the computation of node degree at any given instant of time during the mission.</p>
</sec>
<sec id="section9-1548512912455555">
<title>3.1.3 Curve fitting</title>
<p>In the third stage of modeling Repeated Traversal, we try to find the ‘best-fit’ equations to the curves generated for network parameters by the UMMF in Section 3.1.1. Here again we take the specific example of node degree. We have seen in Section 3.1.1 the effects input parameters such as group velocity and group size have on node degree. In this section we try to capture these ‘effects’ mathematically. The objective is to construct tractable mathematical equations for node degree as a function of time (λ(<italic>t</italic>)) for a given epoch, with the aim of performing regression analysis. Regression analysis<sup><xref ref-type="bibr" rid="bibr11-1548512912455555">11</xref>,<xref ref-type="bibr" rid="bibr12-1548512912455555">12</xref></sup> is a technique that allows one to understand how the value of a dependent variable (here node degree) changes when any one of the independent variables is varied while all other independent variables are kept fixed. Since the data points used here are those generated by the UMMF traces, the regression analysis is in essence curve fitting done for the mobility traces.</p>
<p>The problem further complicates as the dependent variable, node degree, being modeled here is in itself a function of time, denoted by λ(<italic>t</italic>). Hence, the problem is approached in two steps. In the first step we fit a generic curve for λ(<italic>t</italic>), which captures the broad behavior of node degree as a function of time, for any given set of input parameters. <xref ref-type="fig" rid="fig5-1548512912455555">Figure 5</xref> shows the true nature of the curve λ(<italic>t</italic>) and the approximate curve that we use to describe it. In <xref ref-type="fig" rid="fig5-1548512912455555">Figure 5</xref><italic>λ</italic><sub>max</sub><italic>= N</italic><sub><italic>tot</italic></sub>− 1, and <italic>λ</italic><sub>min</sub><italic>€</italic><italic>(λ</italic><sub>max</sub>,<italic>N</italic><sub><italic>grp</italic></sub>− 1), where <italic>N</italic><sub><italic>tot</italic></sub> is the total number of nodes in the systems and <italic>N</italic><sub><italic>grp</italic></sub> is the number of nodes in a group.</p>
<fig id="fig5-1548512912455555" position="float">
<label>Figure 5.</label>
<caption>
<p>Curve fitting for λ(<italic>t</italic>) in Repeated Traversal (color online only).</p>
</caption>
<graphic xlink:href="10.1177_1548512912455555-fig5.tif"/>
</fig>
<p>The true curve (shown in black in the figure) is the actual UMMF trace of λ(<italic>t</italic>), for a given set of input parameters and a particular seed value. To perform curve fitting, we run simulations with 20 different seed values for the same set of input parameters and averaged out the results. Hence, we obtain the approximate curve (shown in red in the figure), which captures the behavior of node degree within tolerable error margins. The general equation of node degree (λ) as a function of time (<italic>t</italic>) is of the form</p>
<p>
<disp-formula id="disp-formula5-1548512912455555">
<label>(5)</label>
<mml:math display="block" id="math8-1548512912455555">
<mml:mrow>
<mml:mi>λ</mml:mi>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>=</mml:mo>
<mml:mi>α</mml:mi>
<mml:msup>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msup>
<mml:mo>−</mml:mo>
<mml:mi>β</mml:mi>
<mml:mi>t</mml:mi>
<mml:mo>+</mml:mo>
<mml:mi>γ</mml:mi>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula5-1548512912455555" xlink:href="10.1177_1548512912455555-eq5.tif"/>
</disp-formula>
</p>
<p>where <italic>t</italic><italic>€</italic> [0,<italic>T</italic><sub><italic>win</italic></sub>) and coefficients <italic>α, β, γ</italic> are functions of the independent parameters.</p>
<p>Now we go on to identify the independent input parameters that affect the shape of the curve <italic>λ</italic>(<italic>t</italic>), and hence affect coefficients <italic>α, β</italic>, and <italic>γ</italic>. From the inferences of the trace-based analysis, in Section 3.1.1, we find group velocity and pause time to be two such parameters. Other variables, such as group size and inter-target distance, were found to only shift the curve along the vertical or horizontal axis (respectively) by an offset. Hence, we keep such quantities out of the curve-fitting model and perform time series analysis of <italic>λ</italic> with respect to group velocity (<italic>V</italic>) and pause time (<italic>T</italic><sub><italic>p</italic></sub>).</p>
<p>In this work, we use an online curve-fitting tool<sup><xref ref-type="bibr" rid="bibr13-1548512912455555">13</xref>,<xref ref-type="bibr" rid="bibr14-1548512912455555">14</xref></sup> that uses the least squares approach to curve fitting, that is, it tries to fit a given set of data points to a standard set of two-dimensional (2D) or three-dimensional (3D) functions with the aim of minimizing the sum of squared residuals. On performing curve fitting, the following equations were formulated, which define the dependence of coefficients <italic>α, β, γ</italic> on <italic>V</italic> and <italic>T</italic><sub><italic>p</italic></sub>:</p>
<p>
<disp-formula id="disp-formula6-1548512912455555">
<label>(6)</label>
<mml:math display="block" id="math9-1548512912455555">
<mml:mrow>
<mml:mi>α</mml:mi>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>b</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>p</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mi>V</mml:mi>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>d</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mi>V</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>p</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>;</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>1997</mml:mn>
<mml:mtext>e</mml:mtext>
<mml:mn>1</mml:mn>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>b</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>864</mml:mn>
<mml:mtext>e</mml:mtext>
<mml:mn>4</mml:mn>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mo>−</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>679</mml:mn>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula6-1548512912455555" xlink:href="10.1177_1548512912455555-eq6.tif"/>
</disp-formula>
</p>
<p>
<disp-formula id="disp-formula7-1548512912455555">
<label>(7)</label>
<mml:math display="block" id="math10-1548512912455555">
<mml:mrow>
<mml:mi>β</mml:mi>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>b</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mtext>ln</mml:mtext>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mi>V</mml:mi>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mtext>ln</mml:mtext>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>p</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>;</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mo>−</mml:mo>
<mml:mn>3</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>04</mml:mn>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>b</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mn>5</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>69</mml:mn>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mn>5</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>96</mml:mn>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext>Offset</mml:mtext>
<mml:mo>=</mml:mo>
<mml:mo>−</mml:mo>
<mml:mn>5</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>62</mml:mn>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula7-1548512912455555" xlink:href="10.1177_1548512912455555-eq7.tif"/>
</disp-formula>
</p>
<p>
<disp-formula id="disp-formula8-1548512912455555">
<label>(8)</label>
<mml:math display="block" id="math11-1548512912455555">
<mml:mrow>
<mml:mi>γ</mml:mi>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>3</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>b</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>3</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mi>V</mml:mi>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>3</mml:mn>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>p</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>;</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>3</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mn>0</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>3099</mml:mn>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>b</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>3</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mn>4</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>479</mml:mn>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>3</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mo>−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>85</mml:mn>
<mml:mtext>e</mml:mtext>
<mml:mo>−</mml:mo>
<mml:mn>4</mml:mn>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula8-1548512912455555" xlink:href="10.1177_1548512912455555-eq8.tif"/>
</disp-formula>
</p>
<p>In the above equations, the RMSE (root mean squared error = <inline-formula id="inline-formula4-1548512912455555"><mml:math display="inline" id="math12-1548512912455555"><mml:mrow><mml:msqrt><mml:mrow><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mover><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mo>−</mml:mo><mml:mi>θ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:msqrt><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>) was found to within a factor of 10<sup>−2</sup> to 10<sup>−4</sup> for each equation, indicating these equation are a good fit to the UMMF traces. The results of curve fitting comply with the requirements of regression analysis,<sup><xref ref-type="bibr" rid="bibr11-1548512912455555">11</xref>,<xref ref-type="bibr" rid="bibr12-1548512912455555">12</xref></sup> wherein the error is a normally distributed random variable with zero mean and constant variance.</p>
<p>In summary, the dependence of <italic>λ</italic>(<italic>t</italic>) on <italic>V</italic> and <italic>T</italic><sub><italic>p</italic></sub> is described by the following equation:</p>
<p>
<disp-formula id="disp-formula9-1548512912455555">
<label>(9)</label>
<mml:math display="block" id="math13-1548512912455555">
<mml:mrow>
<mml:mrow>
<mml:mi>λ</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">[</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>b</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>p</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mi>V</mml:mi>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>d</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mrow>
<mml:mi>VT</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>p</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">]</mml:mo>
<mml:msup>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msup>
<mml:mo>−</mml:mo>
<mml:mo stretchy="false">[</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>b</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mtext>ln</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mtext>ln</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>p</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>]</mml:mo>
</mml:mrow>
<mml:mi>t</mml:mi>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>3</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>b</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>3</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mi>V</mml:mi>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>3</mml:mn>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>p</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula9-1548512912455555" xlink:href="10.1177_1548512912455555-eq9.tif"/>
</disp-formula>
</p>
</sec>
<sec id="section10-1548512912455555">
<title>3.1.4 Error evaluation</title>
<p>In this section, we aim to capture the error margin by which the motion model and curve-fitting model deviate from the UMMF traces. As mentioned earlier, for the purpose of this work we assume the UMMF traces to be representative of the ground truth. We quantify the error by calculating the value of an example output parameter, namely outage time (<italic>T</italic><sub><italic>out</italic></sub>), using the three models and compare the results, for several sets of input parameters. <italic>T</italic><sub><italic>out</italic></sub> is specifically defined as the time for which the ‘leading’ and ‘following’ groups go out of communication range within the epoch. Note we use a free space propagation model; other models may be substituted to model the communication range. <xref ref-type="fig" rid="fig6-1548512912455555">Figure 6</xref> is a schematic representation of the calculation of <italic>T</italic><sub><italic>out</italic></sub> where <italic>N</italic><sub><italic>tot</italic></sub> is the total number of nodes in mission, <italic>N</italic><sub><italic>grp</italic></sub> is the number of nodes in a group, <italic>λ</italic><sub>max</sub> = <italic>N</italic><sub><italic>tot</italic></sub>− 1, <italic>λ</italic><sub><italic>Threshold</italic></sub> = <italic>N</italic><sub><italic>grp</italic></sub>− 1, <italic>D</italic><sub>1</sub> is the initial inter-group distance, <italic>D</italic><sub>2</sub> is the initial inter-group distance, and <italic>D</italic><sub><italic>Threshold</italic></sub> is the communication range.</p>
<fig id="fig6-1548512912455555" position="float">
<label>Figure 6.</label>
<caption>
<p>Calculation of <italic>T</italic><sub><italic>out</italic></sub> in tactical mobility models.</p>
</caption>
<graphic xlink:href="10.1177_1548512912455555-fig6.tif"/>
</fig>
<p>The relation between λ<sub><italic>Threshold</italic></sub> and <italic>D</italic><sub><italic>Threshold</italic></sub> is defined by the communication model used in the UMMF simulator, which assumes communication between two nodes/groups is lost once they move apart by a certain distance. Hence, we define <italic>D</italic><sub><italic>Threshold</italic></sub> as the maximal inter-group distance at which communication between groups is impaired, resulting in node degree reducing to λ<sub><italic>Threshold</italic></sub>.</p>
<p>We evaluate errors for the simplest case of Repeated Traversal, consisting of two groups undergoing this tactic in a single epoch. The corresponding UMMF traces, motion model and curve-fitting equations for this case are discussed extensively in the previous sections. We found group velocity (<italic>V</italic>) and pause time (<italic>T</italic><sub><italic>p</italic></sub>) to be the main two input parameters that impacted the behavior of node degree. We calculate <italic>T</italic><sub><italic>out</italic></sub> for the following three sets of input parameters:</p>
<list id="list1-1548512912455555" list-type="bullet">
<list-item><p>Case 1: low group velocity (<italic>V</italic>), <italic>V</italic><sub>1</sub> = <italic>V</italic><sub>2</sub>; velocity of leading and following groups are equal, small pause time (<italic>T</italic><sub><italic>p</italic></sub>);</p></list-item>
<list-item><p>Case 2: high group velocity (<italic>V</italic>), <italic>V</italic><sub>1</sub> = <italic>V</italic><sub>2</sub>; velocity of leading and following groups are equal, large pause time (<italic>T</italic><sub><italic>p</italic></sub>);</p></list-item>
<list-item><p>Case 3: low group velocity (<italic>V</italic>), <italic>V</italic><sub>1</sub> &gt; <italic>V</italic><sub>2</sub>; velocity of leading is greater than following group, small pause time (<italic>T</italic><sub><italic>p</italic></sub>).</p></list-item>
</list>
<p>For the motion model, the outage time is calculated using <xref ref-type="disp-formula" rid="disp-formula4-1548512912455555">Equation (4)</xref>. For the curve-fitting model, outage time is calculated using <xref ref-type="disp-formula" rid="disp-formula9-1548512912455555">Equation (9)</xref>. <xref ref-type="fig" rid="fig7-1548512912455555">Figure 7</xref> is a bar chart that schematically represents the values of outage time obtained from each model in all three cases. The error mark on the UMMF model bar shows the range of <italic>T</italic><sub><italic>out</italic></sub> results obtained from UMMF, for 10 runs of the simulation, with a variety of seed values and group sizes. The figure clearly shows that the <italic>T</italic><sub><italic>out</italic></sub> values calculated from the motion model and curve-fitting model always remain within the bounds of the UMMF results. Further, the figure also shows the error margin by which each model deviates from the UMMF traces. In Case 3 we do not consider the curve-fitting model, since this model assumes equal velocity for both groups and hence is not able to capture a scenario where <italic>V</italic><sub>1</sub> is greater than <italic>V</italic><sub>2</sub>. The above figure not only captures the level of accuracy of the motion and curve-fitting models, but also justifies our claim that group size does not affect the shape of the curve of node degree in Repeated Traversal.</p>
<fig id="fig7-1548512912455555" position="float">
<label>Figure 7.</label>
<caption>
<p>Bar chart representing error analysis for Repeated Traversal.</p>
</caption>
<graphic xlink:href="10.1177_1548512912455555-fig7.tif"/>
</fig>
</sec>
</sec>
<sec id="section11-1548512912455555">
<title>3.2 Bounding Overwatch</title>
<p>In the following sections, we describe the model for the Bounding Overwatch military tactic.</p>
<sec id="section12-1548512912455555">
<title>3.2.1 Scenario description and traces</title>
<p>The Bounding Overwatch tactic<sup><xref ref-type="bibr" rid="bibr9-1548512912455555">9</xref></sup> was designed to covertly capture the enemy (usually an enemy post or a small enemy troop) while keeping them engaged in other activity. Two or more troops work in collaboration such that one (or more) troop(s) covers by firing at the enemy and keeps them engaged while the other troop(s) advances to a new position, closer to the enemy. The firing troop(s) always halts at a position from where it is able to fire at the enemy and is behind an obstacle covering it. Once the advancing troop reaches its new target, it begins to fire from there while one of the troops that were firing previously advances to a new position. This pattern continues until one of the troops is able to reach the enemy post.</p>
<p>The movement pattern in Bounding Overwatch is found to be very structured. The scenario shows group mobility and the groups typically form reliable neighborhoods. Hence, a set of groups (forming a neighborhood) regularly go from ‘firing’ mode (where they remain static) to ‘advancing’ mode (where they move to a common destination, trying to maintain the neighborhood). <xref ref-type="fig" rid="fig8-1548512912455555">Figure 8</xref> shows two groups executing Bounding Overwatch.</p>
<fig id="fig8-1548512912455555" position="float">
<label>Figure 8.</label>
<caption>
<p>Schematic of Bounding Overwatch.</p>
</caption>
<graphic xlink:href="10.1177_1548512912455555-fig8.tif"/>
</fig>
<p>This scenario was simulated in UMMF as an epoch-based model with a base case of two neighborhoods in one epoch, and one group in each neighborhood. <xref ref-type="fig" rid="fig9-1548512912455555">Figures 9</xref> shows the traces for mobility parameters, such as node degree and average path length as a function of time. Here again the UMMF traces give some insight into the general behavior of node degree that can be expected in the Bounding Overwatch scenario. The regularity is clearly seen in λ(<italic>t</italic>), as its value rises to a maximal value, when communication is possible across neighborhoods, and then falls to a minimal value, when only nodes within a neighborhood are in contact. Again we find that change in group size only shifts the graph along the <italic>y</italic>-axis but does not alter shape, while change in group velocity alters the shape of the graph. Behavior of the graph remains consistent for variations in group sizes as well as for simple and complex (involving dynamic events) mobility scenarios.</p>
<fig id="fig9-1548512912455555" position="float">
<label>Figure 9.</label>
<caption>
<p>Mobility traces of Bounding Overwatch.</p>
</caption>
<graphic xlink:href="10.1177_1548512912455555-fig9.tif"/>
</fig>
</sec>
<sec id="section13-1548512912455555">
<title>3.2.2 Motion model</title>
<p><xref ref-type="fig" rid="fig10-1548512912455555">Figure 10</xref> is a schematic representation of the motion model for Bounding Overwatch. <xref ref-type="table" rid="table2-1548512912455555">Table 2</xref> includes the parameters of <xref ref-type="fig" rid="fig10-1548512912455555">Figure 10</xref>.</p>
<fig id="fig10-1548512912455555" position="float">
<label>Figure10.</label>
<caption>
<p>Motion model for Bounding Overwatch.</p>
</caption>
<graphic xlink:href="10.1177_1548512912455555-fig10.tif"/>
</fig>
<table-wrap id="table2-1548512912455555" position="float">
<label>Table 2.</label>
<caption>
<p>Parameters for Bounding Overwatch</p>
</caption>
<graphic alternate-form-of="table2-1548512912455555" xlink:href="10.1177_1548512912455555-table2.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="left"/>
</colgroup>
<thead>
<tr>
<th align="left">Variable</th>
<th align="left">Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td><italic>V</italic></td>
<td>Velocity of moving group (G<sub>2</sub>)</td>
</tr>
<tr>
<td><italic>D</italic><sub>1</sub></td>
<td>Initial inter-group distance</td>
</tr>
<tr>
<td><italic>D</italic><sub>2</sub></td>
<td>Final inter-group distance</td>
</tr>
<tr>
<td><italic>D</italic><sub><italic>max</italic></sub></td>
<td>Farthest that G<sub>2</sub> can go from G<sub>1</sub></td>
</tr>
<tr>
<td><italic>T</italic><sub><italic>win</italic></sub></td>
<td>Size of epoch</td>
</tr>
<tr>
<td>Θ<sub>1</sub></td>
<td>Initial angle of velocity vector</td>
</tr>
<tr>
<td>Θ<sub>2</sub></td>
<td>Final angle of velocity vector</td>
</tr>
</tbody>
</table>
</table-wrap>
<p>One group (G<sub>1</sub> in <xref ref-type="fig" rid="fig10-1548512912455555">Figure 10</xref>) remains stationary and fires at the enemy while the other group (G<sub>2</sub> in <xref ref-type="fig" rid="fig10-1548512912455555">Figure 10</xref>) advances to its next target. The approximate route taken by G<sub>2</sub> consists of two parts – the ‘Moving Away’ phase, where inter-group distance increases and the ‘Closing In’ phase, where inter-group distance decreases. We now take a closer look at the motion of G<sub>2</sub> in <xref ref-type="fig" rid="fig11-1548512912455555">Figure 11</xref>. Here, G<sub>2</sub> moves away from G<sub>1</sub> at an angle of <italic>θ</italic><sub>1</sub>, until it reaches a maximal distance of <italic>D</italic><sub>max</sub>. It then begins closing in towards its target at an angle of <italic>θ</italic><sub>2</sub>. Using the law of cosines, we formulate the following equations that describe the inter-group distance (between G<sub>1</sub> and G<sub>2</sub>) as a function of time (denoted here as <italic>d</italic>(<italic>t</italic>)):</p>
<fig id="fig11-1548512912455555" position="float">
<label>Figure 11.</label>
<caption>
<p>Motion model for Bounding Overwatch.</p>
</caption>
<graphic xlink:href="10.1177_1548512912455555-fig11.tif"/>
</fig>
<p>
<disp-formula id="disp-formula10-1548512912455555">
<label>(10)</label>
<mml:math display="block" id="math14-1548512912455555">
<mml:mrow>
<mml:mtext>For</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>the</mml:mtext>
<mml:mspace width="0.25em"/><mml:mo>‘</mml:mo><mml:mtext>Moving Away</mml:mtext><mml:mo>’</mml:mo><mml:mspace width="0.25em"/><mml:mtext>phase</mml:mtext><mml:mo>:</mml:mo><mml:mspace width="0.25em"/><mml:msup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>vt</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mspace width="0.25em"/><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>vt</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mtext>cos</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mi>Π</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>Θ</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula10-1548512912455555" xlink:href="10.1177_1548512912455555-eq10.tif"/>
</disp-formula>
</p>
<p>
<disp-formula id="disp-formula11-1548512912455555">
<label>(11)</label>
<mml:math display="block" id="math15-1548512912455555">
<mml:mrow>
<mml:mtext>For</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>the</mml:mtext>
<mml:mspace width="0.25em"/><mml:mo>‘</mml:mo><mml:mtext>Closing</mml:mtext><mml:mspace width="0.25em"/><mml:mtext>In</mml:mtext><mml:mo>’</mml:mo><mml:mspace width="0.25em"/><mml:mtext>phase</mml:mtext><mml:mo>:</mml:mo><mml:mspace width="0.25em"/><mml:msup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>vt</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mspace width="0.25em"/><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>vt</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mi>cos</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>Π</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>Θ</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula11-1548512912455555" xlink:href="10.1177_1548512912455555-eq11.tif"/>
</disp-formula>
</p>
<p>The graph in <xref ref-type="fig" rid="fig12-1548512912455555">Figure 12</xref> shows the expected behavior of <italic>d</italic>(<italic>t</italic>) for the epoch shown in <xref ref-type="fig" rid="fig10-1548512912455555">Figure 10</xref>. Given a threshold distance, beyond which groups lose contact, the outage time can easily be calculated, as shown in <xref ref-type="fig" rid="fig12-1548512912455555">Figure 12</xref>. Also, given the signal propagation model, the motion model equations can be used to calculate node degree at any instant of time within the epoch.</p>
<fig id="fig12-1548512912455555" position="float">
<label>Figure 12.</label>
<caption>
<p>Expected behavior of inter-group distance for Bounding Overwatch.</p>
</caption>
<graphic xlink:href="10.1177_1548512912455555-fig12.tif"/>
</fig>
</sec>
<sec id="section14-1548512912455555">
<title>3.2.3 Curve fitting</title>
<p>In the third stage of modeling Bounding Overwatch, we perform curve fitting using the tool and approach described in Section 3.1.3. <xref ref-type="fig" rid="fig13-1548512912455555">Figure 13</xref> shows the approximate curve for which we aim to find the best-fit equation. In the figure <italic>λ</italic><sub>max</sub><italic>= N</italic><sub><italic>tot</italic></sub>− 1, and <italic>λ</italic><sub>min</sub><italic>€</italic> (<italic>λ</italic><sub>max</sub>,<italic>N</italic><sub><italic>grp</italic></sub>−1).</p>
<fig id="fig13-1548512912455555" position="float">
<label>Figure 13.</label>
<caption>
<p>Curve fitting for Bounding Overwatch.</p>
</caption>
<graphic xlink:href="10.1177_1548512912455555-fig13.tif"/>
</fig>
<p>The general equation for this curve is given by</p>
<p>
<disp-formula id="disp-formula12-1548512912455555">
<label>(12)</label>
<mml:math display="block" id="math16-1548512912455555">
<mml:mrow>
<mml:mi>λ</mml:mi>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>=</mml:mo>
<mml:mi>α</mml:mi>
<mml:msup>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msup>
<mml:mo>−</mml:mo>
<mml:mi>β</mml:mi>
<mml:mi>t</mml:mi>
<mml:mo>+</mml:mo>
<mml:mi>γ</mml:mi>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula12-1548512912455555" xlink:href="10.1177_1548512912455555-eq12.tif"/>
</disp-formula>
</p>
<p>where <italic>t</italic><italic>€</italic> [0,<italic>T</italic><sub><italic>win</italic></sub>) and coefficients <italic>α, β, γ</italic> are functions of the independent input parameters.</p>
<p>Here again, we identify the input parameters that affect the shape of <italic>λ</italic>(<italic>t</italic>). From the UMMF traces that were analyzed in Section 3.2.1, group velocity (<italic>V</italic>) was found to be the input parameter that had a significant impact on the behavior of <italic>λ</italic>(<italic>t</italic>). All other variables, such as number of groups, group size, and inter-target distance, were found to merely shift the parabola of <italic>λ</italic>(<italic>t</italic>) by an offset along the <italic>y</italic> and <italic>x-</italic>axes. Hence, we perform curve fitting of <italic>λ</italic>(<italic>t</italic>) with respect to group velocity, <italic>V</italic>. As a result, the following equations were formulated, which describe the dependence of coefficients <italic>α, β, γ</italic> on <italic>V</italic>:</p>
<p>
<disp-formula id="disp-formula13-1548512912455555">
<label>(13)</label>
<mml:math display="block" id="math17-1548512912455555">
<mml:mrow>
<mml:mi>α</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">/</mml:mo>
<mml:mi>aV</mml:mi>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>+</mml:mo>
<mml:mi>b</mml:mi>
<mml:mspace width="0.25em"/>
<mml:msup>
<mml:mrow>
<mml:mtext>e</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>cV</mml:mi>
</mml:mrow>
</mml:msup>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>;</mml:mo>
<mml:mi>a</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>2</mml:mn>
<mml:mtext>e</mml:mtext>
<mml:mn>1</mml:mn>
<mml:mo>,</mml:mo>
<mml:mi>b</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>8</mml:mn>
<mml:mtext>e</mml:mtext>
<mml:mn>4</mml:mn>
<mml:mo>,</mml:mo>
<mml:mi>c</mml:mi>
<mml:mo>=</mml:mo>
<mml:mo>−</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>7</mml:mn>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula13-1548512912455555" xlink:href="10.1177_1548512912455555-eq13.tif"/>
</disp-formula>
</p>
<p>
<disp-formula id="disp-formula14-1548512912455555">
<label>(14)</label>
<mml:math display="block" id="math18-1548512912455555">
<mml:mrow>
<mml:mi>β</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi>a</mml:mi>
<mml:mo stretchy="false">/</mml:mo>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>+</mml:mo>
<mml:mi>b</mml:mi>
<mml:mspace width="0.25em"/>
<mml:msup>
<mml:mrow>
<mml:mtext>e</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mo>−</mml:mo>
<mml:mi>c</mml:mi>
<mml:mi>V</mml:mi>
</mml:mrow>
</mml:msup>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>+</mml:mo>
<mml:mtext>Offset</mml:mtext>
<mml:mo>;</mml:mo>
<mml:mi>a</mml:mi>
<mml:mo>=</mml:mo>
<mml:mo>−</mml:mo>
<mml:mn>3</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>,</mml:mo>
<mml:mi>b</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>5</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>7</mml:mn>
<mml:mo>,</mml:mo>
<mml:mi>c</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>5</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>9</mml:mn>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext>Offset</mml:mtext>
<mml:mo>=</mml:mo>
<mml:mo>−</mml:mo>
<mml:mn>5</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>6</mml:mn>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula14-1548512912455555" xlink:href="10.1177_1548512912455555-eq14.tif"/>
</disp-formula>
</p>
<p>
<disp-formula id="disp-formula15-1548512912455555">
<label>(15)</label>
<mml:math display="block" id="math19-1548512912455555">
<mml:mrow>
<mml:mi>γ</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi>aV</mml:mi>
<mml:mo>+</mml:mo>
<mml:mi>b</mml:mi>
<mml:mo>;</mml:mo>
<mml:mi>a</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>0</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>3</mml:mn>
<mml:mo>,</mml:mo>
<mml:mi>b</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>4</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>5</mml:mn>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula15-1548512912455555" xlink:href="10.1177_1548512912455555-eq15.tif"/>
</disp-formula>
</p>
<p>In the above equations, the RMSE was found to be within a factor of between 10<sup>−3</sup> and 10<sup>−5</sup> for each equation. In summary, the equation for <italic>λ</italic>(<italic>t</italic>) as a function of time and group velocity is</p>
<p>
<disp-formula id="disp-formula16-1548512912455555">
<label>(16)</label>
<mml:math display="block" id="math20-1548512912455555">
<mml:mrow>
<mml:mi>λ</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">[</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">/</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>b</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mspace width="0.25em"/>
<mml:msup>
<mml:mrow>
<mml:mi>e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msup>
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">]</mml:mo>
<mml:msup>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msup>
<mml:mo>−</mml:mo>
<mml:mo stretchy="false">[</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">/</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>b</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mspace width="0.25em"/>
<mml:msup>
<mml:mrow>
<mml:mi>e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msup>
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mspace width="0.25em"/>
<mml:mspace width="0.25em"/>
<mml:mo>+</mml:mo>
<mml:mtext>Offset</mml:mtext>
<mml:mo stretchy="false">]</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>3</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mi>V</mml:mi>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>b</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>3</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula16-1548512912455555" xlink:href="10.1177_1548512912455555-eq16.tif"/>
</disp-formula>
</p>
<p>The curve-fitting equations coupled with the UMMF traces provide the following insights into this scenario. As group velocity increases, the amount of time for which groups in different neighborhoods remain out of contact reduces. However, with increasing group velocity, link stability (the persistence of a link state) between groups decreases. Nodes typically try to maintain reliable neighborhoods and do not move between neighborhoods. Communication between neighborhoods is usually multi-hop, whereas within a neighborhood it can be both one hop or multi-hop. Thus, loss of communications between groups may cause network partitions.</p>
</sec>
<sec id="section15-1548512912455555">
<title>3.2.4 Error evaluation</title>
<p>To quantify the error of the motion model and curve-fitting model with respect to the UMMF traces, we consider the simplest case of Bounding Overwatch, wherein two groups undergo the mission with one group being stationary and the second group advancing in each epoch. Here the curve-fitting model has the input parameter of group velocity (<italic>V</italic>) and the motion model uses the direction of group velocity (<italic>θ</italic>) as an input, in addition to <italic>V</italic>. Here, <italic>T</italic><sub><italic>out</italic></sub> is specifically defined as the time for which the advancing group goes out of contact from the stationary group within the epoch. We calculate <italic>T</italic><sub><italic>out</italic></sub> for the following three sets of input parameters:</p>
<list id="list2-1548512912455555" list-type="bullet">
<list-item><p>Case 1: low group velocity (<italic>V), D</italic><sub>1</sub> (initial inter-group distance) and <italic>D</italic><sub>2</sub> (final inter-group distance) are comparable, medium angles of Moving Away and Closing In phases – specifically: <italic>θ</italic><sub>1</sub> = π/4; <italic>θ</italic><sub>2</sub> = 3π/4;</p></list-item>
<list-item><p>Case 2: high group velocity (<italic>V, D</italic><sub>1</sub><inline-formula id="inline-formula5-1548512912455555"><mml:math display="inline" id="math21-1548512912455555"><mml:mrow><mml:mo>≫</mml:mo></mml:mrow></mml:math></inline-formula><italic>D</italic><sub>2</sub>, <italic>D</italic><sub>max</sub> = <italic>D</italic><sub>1</sub>; inter-group distance starts at <italic>D</italic><sub>1</sub> and decreases to <italic>D</italic><sub>2</sub>, movement consists of only the Closing In phase and no Moving Away phase – specifically: <italic>θ</italic><sub>2</sub> = 3π/4;</p></list-item>
<list-item><p>Case 3: low group velocity (<italic>V</italic>), <italic>D</italic><sub>1</sub><inline-formula id="inline-formula6-1548512912455555"><mml:math display="inline" id="math22-1548512912455555"><mml:mrow><mml:mo>≪</mml:mo><mml:mspace width="0.25em"/></mml:mrow></mml:math></inline-formula><italic>D</italic><sub>2</sub>, <italic>D</italic><sub>max</sub> = <italic>D</italic><sub><italic>2</italic></sub>; inter-group distance starts at <italic>D</italic><sub>1</sub> and increases to <italic>D</italic><sub>2</sub>, movement consists of only the Moving Away phase and no Closing In phase, specifically: <italic>θ</italic><sub>1</sub> = π/4</p></list-item>
</list>
<p>For the motion model, the outage time is calculated using <xref ref-type="disp-formula" rid="disp-formula10-1548512912455555">Equations (10)</xref> and <xref ref-type="disp-formula" rid="disp-formula11-1548512912455555">(11)</xref>. For the curve-fitting model, outage time is calculated using <xref ref-type="disp-formula" rid="disp-formula16-1548512912455555">Equation (16)</xref>. The bar chart in <xref ref-type="fig" rid="fig14-1548512912455555">Figure 14</xref> schematically represents the values of outage time obtained from each model in all three cases</p>
<fig id="fig14-1548512912455555" position="float">
<label>Figure 14.</label>
<caption>
<p>Bar chart representing error analysis results for Bounding Overwatch.</p>
</caption>
<graphic xlink:href="10.1177_1548512912455555-fig14.tif"/>
</fig>
<p>Here again, the error bar on the UMMF model results shows the range of <italic>T</italic><sub><italic>out</italic></sub> results obtained from the tool for 10 runs of simulations with a variety of seed values. The figure clearly shows that the <italic>T</italic><sub><italic>out</italic></sub> values calculated from the motion model and curve-fitting model always remain within the bounds of the UMMF results. It is also interesting to note that, across Cases 2 and 3, we vary inter-target distance and find that the curve-fitting equations are able to produce good results, although inter-target distance is not considered as an independent input parameter. This proves our claim that parameters other than group velocity, such as inter-target distance, do not alter the shape of the <italic>λ</italic>(<italic>t</italic>) curve in a major way.</p>
</sec>
</sec>
<sec id="section16-1548512912455555">
<title>3.3 Pincer Movement</title>
<p>The third military tactic studied in this paper is known as Pincer Movement or Double Envelopment.</p>
<sec id="section17-1548512912455555">
<title>3.3.1 Scenario description and traces</title>
<p>Described in detail in Army Field Manuals,<sup><xref ref-type="bibr" rid="bibr8-1548512912455555">8</xref>,<xref ref-type="bibr" rid="bibr9-1548512912455555">9</xref></sup> the objective here is to surround the enemy troop from two or more directions, making it very easy to destroy them. This movement is a flanking attack from both sides of the enemy troops. A flanking attack is an attack on the sides of an opposing force. More units of the attacking force can move in from the front and rear and result in encircling the enemy. To avoid being a victim of this, a group of nodes can ensure that it is flanked by difficult terrain on both sides (e.g. river, marshy land, etc.). The key mobility features of this tactic are fast movement, small reaction time, and small groups. <xref ref-type="fig" rid="fig15-1548512912455555">Figure 15</xref> is a schematic representation of this scenario.</p>
<fig id="fig15-1548512912455555" position="float">
<label>Figure 15.</label>
<caption>
<p>Schematic view of Pincer Movement.</p>
</caption>
<graphic xlink:href="10.1177_1548512912455555-fig15.tif"/>
</fig>
<p>In contrast to the earlier two models, this scenario is not periodic or epoch based. The motion is comparatively less structured and defined. The specifications that can be defined for this scenario are the initial position of nodes (nodes are usually placed far from the enemy, behind obstacles), final position of nodes (final targets are strategically placed so that nodes encircle the enemy), and the velocity with which nodes advance. Here we simulate Pincer Movement with groups rather than individual nodes, since it is more common for small groups of soldiers to perform this task rather than individual soldiers scattering around the region. <xref ref-type="fig" rid="fig16-1548512912455555">Figure 16</xref> shows the traces for node degree and average path as a function of time.</p>
<fig id="fig16-1548512912455555" position="float">
<label>Figure 16.</label>
<caption>
<p>Mobility traces for Pincer Movement (versus time).</p>
</caption>
<graphic xlink:href="10.1177_1548512912455555-fig16.tif"/>
</fig>
<p>Running several simulations for different values of group velocity, initial node positions, and group sizes, we find that the behavior of node degree shows a decline followed by a steep rise. The value of node degree falls in the first part of the movement as the groups move away from each other while advancing towards the enemy. In the second part, the groups come closer to one another as they try to encircle the enemy and finally place themselves in a close-knit circle where most of the nodes are in contact. The simulations also show group velocity and initial inter-group distance (i.e. the distance between neighboring groups just before the beginning of the movement) to be two input parameters that affect the curve of node degree substantially. Other variables, such as group size and number of nodes, only shift the curve along the <italic>y</italic>-axis by an offset.</p>
<p>Since the Pincer Movement does not follow any specific pattern, we do not attempt to design a motion model for it and instead go on to the third stage of finding the best-fit curve to the UMMF traces and performing regression analysis.</p>
</sec>
<sec id="section18-1548512912455555">
<title>3.3.2 Curve fitting</title>
<p>In the third stage of modeling Pincer Movement, we perform curve fitting using the tool and approach described in Section 3.1.3. <xref ref-type="fig" rid="fig17-1548512912455555">Figure 17</xref> shows the approximate curve for which we aim to find the best-fit equation. In the figure, <italic>N</italic><sub><italic>in</italic></sub> is the number of nodes in contact initially, <italic>λ</italic><sub>max</sub><italic>= N</italic><sub><italic>tot</italic></sub>− 1, and <italic>λ</italic><sub>min</sub><italic>€</italic> (<italic>λ</italic><sub>max</sub>, <italic>N</italic><sub><italic>grp</italic></sub>−1).</p>
<fig id="fig17-1548512912455555" position="float">
<label>Figure 17.</label>
<caption>
<p>Curve fitting for Pincer Movement.</p>
</caption>
<graphic xlink:href="10.1177_1548512912455555-fig17.tif"/>
</fig>
<p>As can be seen in <xref ref-type="fig" rid="fig17-1548512912455555">Figure 17</xref>, the trace of node degree is approximated to a curve consisting of two line segments describing the two parts of Pincer Movement – the ‘Advancing’ phase (the downslope) and the ‘Surrounding’ phase (the upslope). The general equation that describes node degree as a function of time for both these phases is given below:</p>
<p>
<disp-formula id="disp-formula17-1548512912455555">
<label>(17)</label>
<mml:math display="block" id="math23-1548512912455555">
<mml:mrow>
<mml:mi>λ</mml:mi>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>=</mml:mo>
<mml:mi>mt</mml:mi>
<mml:mo>+</mml:mo>
<mml:mi>c</mml:mi>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula17-1548512912455555" xlink:href="10.1177_1548512912455555-eq17.tif"/>
</disp-formula>
</p>
<p>where <italic>m</italic> (slope of line) and <italic>c</italic> (<italic>y</italic>-axis intercept) are both functions of independent input parameters.</p>
<p>From the trace-based analysis in Section 3.3.1, the input parameters that were found to have a significant impact on the trace of <italic>λ</italic>(<italic>t</italic>) are the initial inter-group distance (denoted here by <italic>D</italic><sub><italic>i</italic></sub>) and group velocity (<italic>V</italic>). Using 3D curve fitting we formulate the following equations, which quantify the effect of <italic>D</italic><sub><italic>i</italic></sub> and <italic>V</italic> on the slope of the curve:</p>
<p>
<disp-formula id="disp-formula18-1548512912455555">
<label>(18)</label>
<mml:math display="block" id="math24-1548512912455555">
<mml:mrow>
<mml:mtext>For</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>the</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>downslope</mml:mtext>
<mml:mo>:</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>m</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi>a</mml:mi>
<mml:mo>+</mml:mo>
<mml:mi>b</mml:mi>
<mml:mo>*</mml:mo>
<mml:mtext>ln</mml:mtext>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>D</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>+</mml:mo>
<mml:mi>c</mml:mi>
<mml:mo>*</mml:mo>
<mml:mtext>ln</mml:mtext>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mi>V</mml:mi>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>;</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>a</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>3</mml:mn>
<mml:mtext>e</mml:mtext>
<mml:mo>−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>,</mml:mo>
<mml:mi>b</mml:mi>
<mml:mo>=</mml:mo>
<mml:mo>−</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>5</mml:mn>
<mml:mtext>e</mml:mtext>
<mml:mo>−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>,</mml:mo>
<mml:mi>c</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>4</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>2</mml:mn>
<mml:mtext>e</mml:mtext>
<mml:mo>−</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula18-1548512912455555" xlink:href="10.1177_1548512912455555-eq18.tif"/>
</disp-formula>
</p>
<p>
<disp-formula id="disp-formula19-1548512912455555">
<label>(19)</label>
<mml:math display="block" id="math25-1548512912455555">
<mml:mrow>
<mml:mtext>For the upslope</mml:mtext>
<mml:mo>:</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>m</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi>a</mml:mi>
<mml:mo>+</mml:mo>
<mml:mi>b</mml:mi>
<mml:mo>*</mml:mo>
<mml:mtext>ln</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>D</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>+</mml:mo>
<mml:mi>c</mml:mi>
<mml:mo>*</mml:mo>
<mml:mtext>ln</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>V</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>;</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>a</mml:mi>
<mml:mo>=</mml:mo>
<mml:mo>−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>3</mml:mn>
<mml:mi>e</mml:mi>
<mml:mo>−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>,</mml:mo>
<mml:mi>b</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>9</mml:mn>
<mml:mi>e</mml:mi>
<mml:mo>−</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo>,</mml:mo>
<mml:mi>c</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>7</mml:mn>
<mml:mi>e</mml:mi>
<mml:mo>−</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula19-1548512912455555" xlink:href="10.1177_1548512912455555-eq19.tif"/>
</disp-formula>
</p>
<p>For the above equations again, the RMSE values were a factor of between 10<sup>−2</sup> and 10<sup>−4</sup>, indicating that these results are indeed a good fit. Hence, consolidating these results, we have</p>
<p>
<disp-formula id="disp-formula20-1548512912455555">
<label>(20)</label>
<mml:math display="block" id="math26-1548512912455555">
<mml:mrow>
<mml:mi>λ</mml:mi>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>=</mml:mo>
<mml:mrow>
<mml:mo>[</mml:mo>
<mml:mi>a</mml:mi>
<mml:mo>+</mml:mo>
<mml:mi>b</mml:mi>
<mml:mo>*</mml:mo>
<mml:mtext>ln</mml:mtext>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>D</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>+</mml:mo>
<mml:mi>c</mml:mi>
<mml:mo>*</mml:mo>
<mml:mtext>ln</mml:mtext>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mi>V</mml:mi>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>]</mml:mo>
</mml:mrow>
<mml:mi>t</mml:mi>
<mml:mo>+</mml:mo>
<mml:mtext>Offset</mml:mtext>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula20-1548512912455555" xlink:href="10.1177_1548512912455555-eq20.tif"/>
</disp-formula>
</p>
<p>As can be seen in <xref ref-type="fig" rid="fig17-1548512912455555">Figure 17</xref>, the offset can easily be calculated for each phase, given the values of <italic>N</italic><sub><italic>in</italic></sub>, <italic>λ</italic><sub>max</sub> and <italic>λ</italic><sub>min</sub>.</p>
</sec>
<sec id="section19-1548512912455555">
<title>3.3.3 Error evaluation</title>
<p>The error evaluation for Pincer Movement is done for the example scenario where three groups attempt to encircle the enemy. The two important input parameters that impact the behavior of node degree are initial inter-group distance (<italic>D</italic><sub><italic>i</italic></sub>) and group velocity (<italic>V</italic>). For the curve-fitting model, outage time is calculated using <xref ref-type="disp-formula" rid="disp-formula20-1548512912455555">Equation (20)</xref>.</p>
<p>In the Pincer Movement scenario, <italic>T</italic><sub><italic>out</italic></sub> is specifically defined as the time for which the communication between the attacking groups is impaired. We do not consider the case where groups are able to communicate via two or more hops as a network outage. <italic>T</italic><sub><italic>out</italic></sub> is calculated for the following three sets of input parameters:</p>
<list id="list3-1548512912455555" list-type="bullet">
<list-item><p>Case 1: low group velocity (<italic>V</italic>), small initial inter-group distance (<italic>D</italic><sub><italic>i</italic></sub>), small group size;</p></list-item>
<list-item><p>Case 2: high group velocity (<italic>V</italic>), small initial inter-group distance (<italic>D</italic><sub><italic>i</italic></sub>), large group size;</p></list-item>
<list-item><p>Case 3: high group velocity (<italic>V</italic>), large initial inter-group distance (<italic>D</italic><sub><italic>i</italic></sub>), small group size.</p></list-item>
</list>
<p><xref ref-type="fig" rid="fig18-1548512912455555">Figure 18</xref> clearly shows that the curve-fitting model is able to produce results of outage time that are within the range of values produced by the UMMF, generated for 10 runs of each simulation with a variety of seed values. The error percentage by which the curve-fitting model deviates in each case is also represented in the figure. Across the three cases group size has been varied, which we had claimed previously to be a parameter that does not impact the shape of <italic>λ</italic>(<italic>t</italic>). The fact that varying this parameter does not reduce the accuracy of the curve-fitting model is proof of our claim.</p>
<fig id="fig18-1548512912455555" position="float">
<label>Figure 18.</label>
<caption>
<p>Bar chart representing error analysis results for Pincer Movement.</p>
</caption>
<graphic xlink:href="10.1177_1548512912455555-fig18.tif"/>
</fig>
<p>Hence the error analysis for Repeated Traversal, Bounding Overwatch, and Pincer scenarios show that the motion model and curve-fitting model are effectively able to capture a wide variety of input parameters in group-based tactical scenarios and are able to produce results within a bounded error margin. Therefore, both these approaches can prove to be very powerful when evaluating protocols for military scenarios where synthetic mobility traces are unavailable.</p>
</sec>
</sec>
</sec>
<sec id="section20-1548512912455555">
<title>4. Data replication in tactical networks</title>
<p>This section illustrates the application of tactical mobility models, developed in this paper, in evaluating the performance of data replication algorithms in military networks. We study the performance of different data replication schemes under different tactical mobility scenarios.</p>
<p>Zhang et al.<sup><xref ref-type="bibr" rid="bibr15-1548512912455555">15</xref></sup> have looked at the performance of four prominent data replication schemes in well-known mobility scenarios: Random Walk, Random Waypoint, Manhattan Model and RPGM. Zhang et al.<sup><xref ref-type="bibr" rid="bibr16-1548512912455555">16</xref></sup> extend this work to evaluate the performance of the same replication algorithms with the three tactical mobility models that have been developed in this paper, namely Repeated Traversal, Bounding Overwatch, and Pincer Movement. In the first work<sup><xref ref-type="bibr" rid="bibr15-1548512912455555">15</xref></sup> replication is considered to be between individual nodes, whereas in the second work<sup><xref ref-type="bibr" rid="bibr16-1548512912455555">16</xref></sup> replication occurs between groups.</p>
<p>In the following sections we begin with the motivation for this work and briefly explain the replication algorithms and evaluation metrics used. We then go on to our prime objective of characterizing the effects of tactical mobility on data replication schemes, comparing the output with results obtained with conventional mobility models and suggesting the best data replication scheme for each of the three military scenarios.</p>
<sec id="section21-1548512912455555">
<title>4.1 Motivation for data replication in military networks</title>
<p>The motivation for data replication in military networks is three fold. Firstly, the topology of military MANETs is highly dynamic. Nodes that are within one hop range at a given time instant may well move out of contact in the near future. Therefore, data must be replicated efficiently to ensure data availability. Secondly, military scenarios have a highly hostile environment, wherein nodes are prone to getting destroyed or scattered. Hence links are unstable, network partitions are common, and neighborhood sizes can change. If data is not replicated, information held by a node that gets destroyed will be lost forever. The last and most important factor is the criticality of information in tactical networks. Information carried by each node must be communicated for the mission to be successful. In the following section we summarize the data replication algorithms that have been evaluated, along with the metrics of evaluation. Further details can be found in Zhang et al.<sup><xref ref-type="bibr" rid="bibr15-1548512912455555">15</xref></sup></p>
</sec>
<sec id="section22-1548512912455555">
<title>4.2 Data replication – algorithms and metrics</title>
<p>In MANETs, it is important to choose data replication mechanisms that make the most judicious decision of which data items to replicate at which nodes, so as to best utilize the storage capacity of the network while ensuring high data availability and low data access delay. In this work we assume that there is a common set of data items that all nodes in the network try to access, albeit with different access probabilities. Hence, by the term replication we mean that nodes try to store copies of different data items in their own local memory, as well as within their reliable neighborhoods, so that there is higher data availability even when network partitions occur. Since group mobility is common in tactical networks, we break the problem into the following two parts:</p>
<list id="list4-1548512912455555" list-type="order">
<list-item><p>intra-group data replication – this algorithm defines the best way to replicate data within a group;</p></list-item>
<list-item><p>inter-group data replication – these techniques look at replicating data across groups.</p></list-item>
</list>
<sec id="section23-1548512912455555">
<title>4.2.1 Intra-group data replication</title>
<p>Zhang et al.<sup><xref ref-type="bibr" rid="bibr16-1548512912455555">16</xref></sup> present the novel Best Location Intra-Group Data Replication algorithm, which optimizes data access within a group by finding the ‘best’ node to store each data replica such that cost of data access, as well as degree of data redundancy, within the group is minimized. This is done by computing the following quantities:</p>
<list id="list5-1548512912455555" list-type="alpha-lower">
<list-item><p><italic>A</italic><sub><italic>i</italic></sub>: average access probability of a data item <italic>d</italic><sub><italic>i</italic></sub>;</p></list-item>
<list-item><p><italic>v</italic><sub><italic>kj</italic></sub>: expected access cost of data <italic>d</italic><sub><italic>j</italic></sub> at node <italic>n</italic><sub><italic>k</italic></sub>;</p></list-item>
</list>
<p><italic>v</italic><sub><italic>kj</italic></sub> is calculated as</p>
<p>
<disp-formula id="disp-formula21-1548512912455555">
<label>(21)</label>
<mml:math display="block" id="math27-1548512912455555">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>v</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>kj</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:msubsup>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>l</mml:mi>
</mml:mrow>
</mml:msubsup>
<mml:msub>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>ij</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>×</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>ijk</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula21-1548512912455555" xlink:href="10.1177_1548512912455555-eq21.tif"/>
</disp-formula>
</p>
<p>In the above equation <italic>a</italic><sub><italic>ij</italic></sub> is the access probability of data <italic>d</italic><sub><italic>j</italic></sub> at node <italic>n</italic><sub><italic>i</italic></sub> and <italic>c</italic><sub><italic>ijk</italic></sub> is the access cost of data <italic>d</italic><sub><italic>j</italic></sub> between nodes <italic>n</italic><sub><italic>i</italic></sub> and <italic>n</italic><sub><italic>k</italic></sub> in a group. The algorithm then finds the best replication location within the group, for each data item starting with the one with highest average access probability. Hence for each data item <italic>d</italic><sub><italic>j</italic></sub>, a node <italic>n</italic><sub><italic>i</italic></sub> is found within the group such that access cost, <italic>v</italic><sub><italic>ij</italic></sub>, is minimum. At each step, if the memory of the best possible location <italic>n</italic><sub><italic>i</italic></sub> is full, the replica of <italic>d</italic><sub><italic>j</italic></sub> is stored in the next best possible location (i.e. the node corresponding to the second lowest <italic>v</italic><sub><italic>ij</italic></sub>). This algorithm ensures the largest number of different data items in a group.</p>
</sec>
<sec id="section24-1548512912455555">
<title>4.2.2 Inter-group data replication</title>
<p>Zhang et al.<sup><xref ref-type="bibr" rid="bibr16-1548512912455555">16</xref></sup> studied the following data replication algorithms, at the granularity of groups.</p>
<list id="list6-1548512912455555" list-type="alpha-lower">
<list-item><p>Greedy Data Replication: the Greedy replication algorithm is non-cooperative, wherein a group always replicates its most frequently accessed data item.</p></list-item>
<list-item><p>Pairwise Cooperation Data Replication: in the Pairing algorithm, each group coordinates with one reliable neighbor to decide which data to replicate. The decision is taken based on the access frequency of data items for both groups, as well as the probability of group partition.</p></list-item>
<list-item><p>Reliable Neighboring Data Replication: in this algorithm groups share data with multiple Reliable Neighboring groups. Replication decisions are made based on the access frequencies of all cooperating groups within a neighborhood and the stability of links between them.</p></list-item>
</list>
</sec>
<sec id="section25-1548512912455555">
<title>4.2.3 Evaluation metrics</title>
<p>We define several metrics to evaluate data access delay and availability.</p>
<p>The average access delay, <italic>D</italic>, denotes the average number of hops from the query node to the nearest node containing the requested data:</p>
<p>
<disp-formula id="disp-formula22-1548512912455555">
<label>(22)</label>
<mml:math display="block" id="math28-1548512912455555">
<mml:mrow>
<mml:mi>D</mml:mi>
<mml:mo>=</mml:mo>
<mml:mfrac>
<mml:mrow>
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
</mml:munderover>
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>R</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>i</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:munderover>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>ij</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
</mml:munderover>
<mml:mi>R</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>i</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula22-1548512912455555" xlink:href="10.1177_1548512912455555-eq22.tif"/>
</disp-formula>
</p>
<p>where <italic>t</italic><sub><italic>ij</italic></sub> is the access delay of the <italic>j</italic>th request of node <italic>i; R</italic>(<italic>i</italic>) is a function that returns the number of requests initiated by node <italic>i</italic>.</p>
<p>The temporal distribution of the access delay, <italic>D</italic><sub><italic>k</italic></sub>, is used to define the access delay in the <italic>k</italic>th time interval and is quantified by</p>
<p>
<disp-formula id="disp-formula23-1548512912455555">
<label>(23)</label>
<mml:math display="block" id="math29-1548512912455555">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>D</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>k</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mfrac>
<mml:mrow>
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
</mml:munderover>
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>R</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>k</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>i</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:munderover>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>ij</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
</mml:munderover>
<mml:msub>
<mml:mrow>
<mml:mi>R</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>k</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>i</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula23-1548512912455555" xlink:href="10.1177_1548512912455555-eq23.tif"/>
</disp-formula>
</p>
<p>where <italic>R</italic><sub><italic>k</italic></sub>(<italic>i</italic>) is a function that returns the number of requests initiated by node <italic>i</italic> in the <italic>k</italic>th interval.</p>
<p>The geographical distribution of access delay in the sub area (<italic>h</italic><sub><italic>x</italic></sub>,<italic>h</italic><sub><italic>y</italic></sub>, <italic>D</italic><sub>(<italic>hx,hy</italic>)</sub>) is defined by</p>
<p>
<disp-formula id="disp-formula24-1548512912455555">
<label>(24)</label>
<mml:math display="block" id="math30-1548512912455555">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>D</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>h</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mrow>
<mml:mi>h</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>y</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:msubsup>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
</mml:msubsup>
<mml:msubsup>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>R</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>i</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:msubsup>
<mml:mi>ι</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>ij</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>h</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>h</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>y</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula24-1548512912455555" xlink:href="10.1177_1548512912455555-eq24.tif"/>
</disp-formula>
</p>
<p>where <italic>R</italic>(<italic>i</italic>) is a function that returns the number of requests initiated by node <italic>i; L</italic>(<italic>t</italic><sub><italic>ij</italic></sub>(<italic>h</italic><sub><italic>x</italic></sub>,<italic>h</italic><sub><italic>y</italic></sub>)) is a function that returns if the request takes place in the subarea (<italic>h</italic><sub><italic>x</italic></sub>,<italic>h</italic><sub><italic>y</italic></sub>).</p>
<p>The average availability, <italic>A</italic>, is defined as the average probability that an in initiated query is served successfully. The following equation quantifies this metric:</p>
<p>
<disp-formula id="disp-formula25-1548512912455555">
<label>(25)</label>
<mml:math display="block" id="math31-1548512912455555">
<mml:mrow>
<mml:mi>A</mml:mi>
<mml:mo>=</mml:mo>
<mml:mfrac>
<mml:mrow>
<mml:msubsup>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
</mml:msubsup>
<mml:msubsup>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>R</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>i</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:msubsup>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>ij</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:msubsup>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
</mml:msubsup>
<mml:mi>R</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>i</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula25-1548512912455555" xlink:href="10.1177_1548512912455555-eq25.tif"/>
</disp-formula>
</p>
<p>where <italic>s</italic><sub><italic>ij</italic></sub> denotes whether the <italic>j</italic>th request of node <italic>n</italic><sub><italic>i</italic></sub> is served (<italic>s</italic><sub><italic>ij</italic></sub> = 1) or not (<italic>s</italic><sub><italic>ij</italic></sub> = 0) and <italic>R</italic>(<italic>i</italic>) is a function that returns the number of requests initiated by node <italic>i</italic>.</p>
<p>Similar to <italic>D</italic><sub><italic>k</italic></sub>, <italic>A</italic><sub><italic>k</italic></sub> represents the temporal distribution of data availability in the <italic>k</italic>th time interval, defined specifically by the following equation:</p>
<p>
<disp-formula id="disp-formula26-1548512912455555">
<label>(26)</label>
<mml:math display="block" id="math32-1548512912455555">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>A</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>k</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mfrac>
<mml:mrow>
<mml:msubsup>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
</mml:msubsup>
<mml:msubsup>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>R</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>k</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>i</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:msubsup>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>ij</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:msubsup>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
</mml:msubsup>
<mml:msub>
<mml:mrow>
<mml:mi>R</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>k</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>i</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula26-1548512912455555" xlink:href="10.1177_1548512912455555-eq26.tif"/>
</disp-formula>
</p>
<p>where <italic>R</italic><sub><italic>k</italic></sub>(<italic>i</italic>) is a function that returns the number of requests initiated by node <italic>i</italic> in the <italic>k</italic>th interval.</p>
<p>The spatial distribution of data availability is given by</p>
<p>
<disp-formula id="disp-formula27-1548512912455555">
<label>(27)</label>
<mml:math display="block" id="math33-1548512912455555">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>A</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>h</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mrow>
<mml:mi>h</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>y</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:msubsup>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
</mml:msubsup>
<mml:msubsup>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>R</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>i</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:msubsup>
<mml:mi>ι</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>ij</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>h</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>h</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>y</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula27-1548512912455555" xlink:href="10.1177_1548512912455555-eq27.tif"/>
</disp-formula>
</p>
<p>where <italic>R</italic>(<italic>i</italic>) is a function that returns the number of requests initiated by node <italic>i; L</italic>(<italic>s</italic><sub><italic>ij</italic></sub>(<italic>h</italic><sub><italic>x</italic></sub>,<italic>h</italic><sub><italic>y</italic></sub>)) is a function that returns if the request takes place in the subarea (<italic>h</italic><sub><italic>x</italic></sub>,<italic>h</italic><sub><italic>y</italic></sub>).</p>
</sec>
</sec>
<sec id="section26-1548512912455555">
<title>4.3 Results and discussion</title>
<p>This section presents an in-depth analysis of the evaluation results for the inter-group replication algorithms under group-based tactical mobility models. We further compare the results obtained with our military scenarios, described by Zhang et al.,<sup><xref ref-type="bibr" rid="bibr16-1548512912455555">16</xref></sup> to those obtained when conventional mobility models are used with the same replication schemes, presented by Zhang et al.<sup><xref ref-type="bibr" rid="bibr15-1548512912455555">15</xref></sup></p>
<sec id="section27-1548512912455555">
<title>4.3.1 Average delay and average availability</title>
<p>The results for average data access delay and average data availability are presented in <xref ref-type="table" rid="table3-1548512912455555">Tables 3</xref> and <xref ref-type="table" rid="table4-1548512912455555">4</xref>.</p>
<table-wrap id="table3-1548512912455555" position="float">
<label>Table 3.</label>
<caption>
<p>Average data access delay</p>
</caption>
<graphic alternate-form-of="table3-1548512912455555" xlink:href="10.1177_1548512912455555-table3.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="char" char="."/>
<col align="char" char="."/>
<col align="char" char="."/>
</colgroup>
<thead>
<tr>
<th/>
<th align="left">RT mobility</th>
<th align="left">BO mobility</th>
<th align="left">PI mobility</th>
</tr>
</thead>
<tbody>
<tr>
<td>Greedy</td>
<td>1.822</td>
<td>1.963</td>
<td>1.695</td>
</tr>
<tr>
<td>Pairing</td>
<td>1.826</td>
<td>2.019</td>
<td>1.704</td>
</tr>
<tr>
<td>Neighboring</td>
<td>1.467</td>
<td>1.974</td>
<td>1.727</td>
</tr>
</tbody>
</table>
<table-wrap-foot>
<fn id="table-fn1-1548512912455555">
<p>RT: Repeated Traversal, BO: Bounded Overwatch, PI: Pincer Movement</p>
</fn>
</table-wrap-foot>
</table-wrap>
<table-wrap id="table4-1548512912455555" position="float">
<label>Table 4.</label>
<caption>
<p>Average data availability</p>
</caption>
<graphic alternate-form-of="table4-1548512912455555" xlink:href="10.1177_1548512912455555-table4.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="char" char="."/>
<col align="char" char="."/>
<col align="char" char="."/>
</colgroup>
<thead>
<tr>
<th/>
<th align="left">RT mobility</th>
<th align="left">BO mobility</th>
<th align="left">PI mobility</th>
</tr>
</thead>
<tbody>
<tr>
<td>Greedy</td>
<td>0.604</td>
<td>0.617</td>
<td>0.632</td>
</tr>
<tr>
<td>Pairing</td>
<td>0.826</td>
<td>0.823</td>
<td>0.517</td>
</tr>
<tr>
<td>Neighboring</td>
<td>0.603</td>
<td>0.893</td>
<td>0.463</td>
</tr>
</tbody>
</table>
<table-wrap-foot>
<fn id="table-fn2-1548512912455555">
<p>RT: Repeated Traversal, BO: Bounded Overwatch, PI: Pincer Movement</p>
</fn>
</table-wrap-foot>
</table-wrap>
<p>Here we note that access delay is computed only for the queries that are served successfully and can hence be a misleading metric if looked at independently. Scenarios can often show low access delay with certain replication schemes, because most of the requests are actually unsuccessful. Hence, access delay and data availability must always be studied together.</p>
<sec id="section28-1548512912455555">
<title>Repeated Traversal</title>
<p>The pairing algorithm in this scenario gives the highest average data availability, although its average delay is comparable to that of the other schemes. Intuitively, this result is consistent with our understanding of Repeated Traversal, where there is close collaboration between the ‘leading’ and ‘following’ groups. Hence, it is mutually beneficial for each pair of leading and following groups to share information in order to ensure maximal data availability.</p>
</sec>
<sec id="section29-1548512912455555">
<title>Bounding Overwatch</title>
<p>In Bounding Overwatch, groups try to maintain reliable neighborhoods during the mission, as was explained in Section 3.2.1. Hence in this tactic, nodes belonging to a neighborhood should effectively be able to share information, such that maximal data items are stored within the neighborhood. The results in <xref ref-type="table" rid="table3-1548512912455555">Tables 3</xref> and <xref ref-type="table" rid="table4-1548512912455555">4</xref> are consistent with our understanding, whereby the Reliable Neighboring algorithm gives the highest data availability with considerably low access delay. The Pairing algorithm emerges as the next best choice, but since neighborhoods in Bounding Overwatch can have more than two groups (unlike the case of Repeated Traversal), the Reliable Neighboring algorithm still exceeds its performance.</p>
</sec>
<sec id="section30-1548512912455555">
<title>Pincer Movement</title>
<p>The results for Pincer Movement clearly show the Greedy replication algorithm to be the best choice as it gives the highest data availability with the lowest access delay. This is so because in this scenario each group has its own strategic target and moves independently to achieve it as effectively as possible. Groups do not collaborate with one another during their movement. Hence, it is best for each group to act greedily and replicate the data items that are of maximum importance to it. In this case, cooperative algorithms such as Pairing and Neighboring replication work against the group’s interests as they try to share data with other neighboring groups. When these groups move out of communication range, the replicated data items are lost.</p>
</sec>
<sec id="section31-1548512912455555">
<title>Comparison with conventional mobility models</title>
<p>We now compare the results in <xref ref-type="table" rid="table3-1548512912455555">Tables 3</xref> and <xref ref-type="table" rid="table4-1548512912455555">4</xref> with those presented by Zhang et al.<sup><xref ref-type="bibr" rid="bibr15-1548512912455555">15</xref></sup> for average access delay and average availability. In this report, the Greedy, Pairing, and Neighborhood replication schemes work between individual nodes, whereas in our work these algorithms replicate data between groups. Further, the conclusions drawn from the RPGM model, which suggest that the group-based replication scheme should be used between nodes showing group mobility, has already been incorporated in our work through the Intra-Group Replication algorithm. Hence, we study the performance of the Greedy, Pairing, and Neighborhood replication schemes in Zhang et al.,<sup><xref ref-type="bibr" rid="bibr15-1548512912455555">15</xref></sup> assuming groups in place of nodes, and compare the results with those derived from our tactical models.</p>
<p>We find that none of the ‘general’ models in Zhang et al.<sup><xref ref-type="bibr" rid="bibr15-1548512912455555">15</xref></sup> are able to yield results that can be applied to all military scenarios. For example, the conclusions drawn from Random Walk model, where the Pairing algorithm performs best, cannot be applied to the Bounding Overwatch and Pincer scenarios. Moreover, although the Pairing algorithm also performs the best in Repeated Traversal, Random Walk cannot be used to depict this scenario because the reasoning in these two cases is drastically different. The Pairing algorithm works well in Random Walk because nodes only vibrate in their positions in this model and are hence able to maintain a stable link with a neighbor. On the other hand, in Repeated Traversal, two groups work in collaboration while moving through a terrain and hence the Pairing algorithm works well here. Similarly, neither the Random Waypoint nor the Manhattan Model is able to yield conclusions, along with accurate reasoning, that can be applied to tactical scenarios.</p>
</sec>
</sec>
<sec id="section32-1548512912455555">
<title>4.3.2 Temporal access delay and availability</title>
<p><xref ref-type="fig" rid="fig19-1548512912455555">Figures 19</xref><xref ref-type="fig" rid="fig20-1548512912455555"/><xref ref-type="fig" rid="fig21-1548512912455555"/><xref ref-type="fig" rid="fig22-1548512912455555"/><xref ref-type="fig" rid="fig23-1548512912455555"/><xref ref-type="fig" rid="fig24-1548512912455555"/><xref ref-type="fig" rid="fig25-1548512912455555"/>–<xref ref-type="fig" rid="fig26-1548512912455555">26</xref> schematically represent the temporal distribution of access delay and data availability for Greedy (blue curve), Pairing (red curve) and Neighboring (black curve) algorithms in each military scenario.</p>
<fig id="fig19-1548512912455555" position="float">
<label>Figure 19.</label>
<caption>
<p>Temporal dependency of data access delay: (a) RT mobility; (b) FO mobility; (c) PI mobility (color online only). RT: Repeated Traversal, BO: Bounded Overwatch, PI: Pincer Movement.</p>
</caption>
<graphic xlink:href="10.1177_1548512912455555-fig19.tif"/>
</fig>
<fig id="fig20-1548512912455555" position="float">
<label>Figure 20.</label>
<caption>
<p>Temporal dependency of data availability: (a) RT mobility; (b) FO mobility; (c) PI mobility (color online only). RT: Repeated Traversal, BO: Bounded Overwatch, PI: Pincer Movement.</p>
</caption>
<graphic xlink:href="10.1177_1548512912455555-fig20.tif"/>
</fig>
<fig id="fig21-1548512912455555" position="float">
<label>Figure 21.</label>
<caption>
<p>Spatial distribution of data access delay in Repeated Traversal.</p>
</caption>
<graphic xlink:href="10.1177_1548512912455555-fig21.tif"/>
</fig>
<fig id="fig22-1548512912455555" position="float">
<label>Figure 22.</label>
<caption>
<p>Spatial distribution of data availability in Repeated Traversal.</p>
</caption>
<graphic xlink:href="10.1177_1548512912455555-fig22.tif"/>
</fig>
<fig id="fig23-1548512912455555" position="float">
<label>Figure 23.</label>
<caption>
<p>Spatial distribution of data access delay in Bounding Overwatch.</p>
</caption>
<graphic xlink:href="10.1177_1548512912455555-fig23.tif"/>
</fig>
<fig id="fig24-1548512912455555" position="float">
<label>Figure 24.</label>
<caption>
<p>Spatial distribution of data availability in Bounding Overwatch.</p>
</caption>
<graphic xlink:href="10.1177_1548512912455555-fig24.tif"/>
</fig>
<fig id="fig25-1548512912455555" position="float">
<label>Figure 25.</label>
<caption>
<p>Spatial distribution of data access delay in Pincer Movement.</p>
</caption>
<graphic xlink:href="10.1177_1548512912455555-fig25.tif"/>
</fig>
<fig id="fig26-1548512912455555" position="float">
<label>Figure 26.</label>
<caption>
<p>Spatial distribution of data availability in Pincer Movement.</p>
</caption>
<graphic xlink:href="10.1177_1548512912455555-fig26.tif"/>
</fig>
<p><xref ref-type="fig" rid="fig19-1548512912455555">Figures 19(a)</xref> and <xref ref-type="fig" rid="fig20-1548512912455555">20(a)</xref> clearly show that the Pairing algorithm outperforms the other two in Repeated Traversal, with largely greater data availability than the other two schemes. The lower access delay curve for the Neighboring algorithm is misleading in this case, because while calculating access delay only the successfully served queries are considered. The low data availability curve for the Neighboring algorithm shows that most requests are not successful with this scheme.</p>
<p>From 19(b) and 20(b) the Neighboring algorithm can be seen to have the highest curve for data availability for Bounding Overwatch, along with a low access delay curve. The access delay curve for all three algorithms falls to a trough in the middle as groups are successfully able to replicate data within their reliable neighborhoods. Towards the end of the mission, access delay rises again as groups come closer together while trying to capture the enemy. This results in more requests being successfully served, although number of hops needed to do so increases.</p>
<p>In <xref ref-type="fig" rid="fig19-1548512912455555">Figures 19(c)</xref> and <xref ref-type="fig" rid="fig20-1548512912455555">20(c)</xref> the Greedy algorithm clearly emerges as the best choice in Pincer Movement, with the highest curve for data availability and the lowest curve for access delay. For all three tactical scenarios, not only do the temporal dependency curves help in making a more accurate decision regarding data replication, they can be analyzed more closely to reveal the instances when network partitions and link failures can be expected. Hence, we argue that the closer the underlying mobility model is to the real-life tactical movement pattern, the more informed the evaluation of protocols can be.</p>
</sec>
<sec id="section33-1548512912455555">
<title>4.3.3 Spatial access delay and availability</title>
<p><xref ref-type="fig" rid="fig21-1548512912455555">Figures 21</xref> and <xref ref-type="fig" rid="fig22-1548512912455555">22</xref> schematically represent the spatial distribution of access delay and data availability for Greedy, Pairing, and Neighboring algorithms in the Repeated Traversal scenario.</p>
<p>The arrows on <xref ref-type="fig" rid="fig21-1548512912455555">Figures 21(b)</xref> and <xref ref-type="fig" rid="fig22-1548512912455555">22(b)</xref> show the path taken by the nodes in this scenario. From <xref ref-type="fig" rid="fig21-1548512912455555">Figures 21</xref> and <xref ref-type="fig" rid="fig22-1548512912455555">22</xref> we find that access delay is comparable for the three schemes, but using the Pairing algorithm, information is shared such that there is high data availability throughout the path being traversed. The Neighboring algorithm does well in the beginning, when all groups are together at the start point, but its performance degrades subsequently as pairs of groups start to advance and network partitions occur. The Greedy algorithm does moderately well, but is clearly out performed by the Pairing scheme.</p>
<p><xref ref-type="fig" rid="fig23-1548512912455555">Figures 23</xref> and <xref ref-type="fig" rid="fig24-1548512912455555">24</xref> schematically represent the spatial distribution of access delay and data availability for Greedy, Pairing, and Neighboring algorithms in the Bounding Overwatch scenario.</p>
<p>The arrows on <xref ref-type="fig" rid="fig23-1548512912455555">Figures 23(c)</xref> and <xref ref-type="fig" rid="fig24-1548512912455555">24(c)</xref> show the path taken by nodes in this scenario. In <xref ref-type="fig" rid="fig23-1548512912455555">Figures 23</xref> and <xref ref-type="fig" rid="fig24-1548512912455555">24</xref>, Greedy and Neighboring algorithms show comparably low access delays (<xref ref-type="fig" rid="fig23-1548512912455555">Figures 23(a)</xref> and <xref ref-type="fig" rid="fig23-1548512912455555">23(c)</xref>), but <xref ref-type="fig" rid="fig24-1548512912455555">Figure 24(c)</xref> shows that the Neighboring scheme results in higher data availability throughout the route taken by nodes in this scenario. As expected, the access delay is lower in the beginning when all nodes are together at the initial target and increases as the mission progresses. This increase is visible in <xref ref-type="fig" rid="fig23-1548512912455555">Figure 23(c)</xref> along the increasing <italic>y</italic>-axis. The pairing algorithm performs the next best (<xref ref-type="fig" rid="fig24-1548512912455555">Figure 24(b)</xref>), followed by the Greedy mechanism (<xref ref-type="fig" rid="fig24-1548512912455555">Figure 24(a)</xref>), as we had also concluded from the temporal distribution graphs.</p>
<p><xref ref-type="fig" rid="fig25-1548512912455555">Figures 25</xref> and <xref ref-type="fig" rid="fig26-1548512912455555">26</xref> schematically represent the spatial distribution of access delay and data availability for the three replication algorithms in the Pincer Movement scenario.</p>
<p>These figures show that the Greedy algorithm ensures much higher data availability (<xref ref-type="fig" rid="fig26-1548512912455555">Figure 26(a)</xref>) than the other replication schemes, throughout the simulation area. For Pincer Movement also, the spatial access delay (<xref ref-type="fig" rid="fig25-1548512912455555">Figure 25(a)</xref>) is lower in the beginning of the mission, when groups are closer to one another, and increases as groups move apart when they try to encircle the enemy. The attempt to cooperatively share information in the Pairing and Neighboring algorithm degrades the performance of these schemes, resulting in very low data availability for the most part of the mission (<xref ref-type="fig" rid="fig26-1548512912455555">Figures 26(b)</xref> and <xref ref-type="fig" rid="fig26-1548512912455555">26(c)</xref>)</p>
<sec id="section34-1548512912455555">
<title>Comparison with conventional mobility models</title>
<p>We now compare the above results for spatial distribution of access delay and availability with those obtained with conventional models for the same metrics in Zhang et al.<sup><xref ref-type="bibr" rid="bibr15-1548512912455555">15</xref></sup> The spatial distribution graphs in Zhang et al.<sup><xref ref-type="bibr" rid="bibr15-1548512912455555">15</xref></sup> could not be included in this paper due to space constraints. These graphs show that in the Random Walk model access delay and availability are independent of location. There is a uniform distribution of both metrics throughout the simulation area. In the Random Waypoint model there is higher data availability and consequently lower access delay at the center of the region, suggesting that nodes tend to aggregate at the center. But this is not the case in military scenarios, as we have seen from the above figures. With RPGM, the spatial distribution graphs are similar to those of Random Walk and hence, although tactical missions show group mobility, RPGM is not a good indicator of the mobility pattern. These findings corroborate the fact that conventional models, such as Random Walk and Random way point (RWP), deviate largely from the true mobility patterns of tactical networks and therefore are not a good choice for representing military mobility.</p>
<p>In this section we find that the results of performance evaluation obtained with conventional mobility models are incorrect and misleading when applied to military scenarios. None of the conventional mobility models studied in this paper are able to succinctly capture the nuances of tactical mobility. This clearly demonstrates the importance of developing and using tactical mobility models while evaluating the performance of applications for military missions.</p>
</sec>
</sec>
</sec>
</sec>
<sec id="section35-1548512912455555" sec-type="conclusions">
<title>5. Conclusion</title>
<p>In this paper we construct tactical mobility models that closely capture the nuances of common military maneuvers. These models can be used effectively to evaluate the performance of network protocols for military applications.</p>
<p>We found military mobility to be very structured and well defined. Here again, we stress that we have looked at simple mobility that results from the planned military maneuvers. Specifically, the Repeated Traversal and Bounding Overwatch tactics were found to be epoch based, with node degree showing a regular behavior in each epoch. Moreover, in Repeated Traversal, high link stability was found between a pair of ‘leading’ and ‘following’ groups, whereas in Bounding Overwatch, groups tried to maintain reliable neighborhoods throughout the tactic. Pincer Movement was found to be less cooperative, with groups mainly aiming at fulfilling their individual objectives. The modeling of tactical mobility was done in three stages, by developing a UMMF model, a motion model, and a curve-fitting model for three common military tactics. Analyzing the errors between these models, we found that that both the motion model and the curve-fitting model yielded results that were within a bounded error margin of the results derived from the UMMF. Finally, we demonstrated the necessity and usability of tactical mobility models in military protocol evaluation by studying the problem of data replication in tactical networks. Our results show that conventional models are not able to capture key properties of tactical scenarios, such as link stability between reliable neighbors, higher node density around specific targets, and so on. They hence lead to misleading conclusions when applied to tactical scenarios. Therefore, in this paper we are clearly able to establish the need to model tactical mobility separately and use these models to capture the mobility for military applications.</p>
<p>In the future we aim to extend this work in two directions. Firstly, a degree of randomness should be added to the tactical models through noise and a possible decision-making process to capture how nodes would ‘react’ to dynamic events. Secondly, we aim to study social interactions and cognitive reasoning in military scenarios by overlaying information objects onto the tactical models and understanding how information flows through the tactical network.</p>
</sec>
</body>
<back>
<fn-group>
<fn fn-type="financial-disclosure">
<label>Funding</label>
<p>This work was supported by the Army Research Laboratory as a part of the Network Science Collaborative Technology Alliance and was accomplished under Cooperative Agreement Number W911NF-09-2-0053.</p>
</fn>
</fn-group>
<bio>
<title>Author Biographies</title>
<p><bold>Sucharita Ray</bold> is a software engineer at the Cloud Systems Management Technology Group at Cisco Systems, Inc. Her current work focuses on developing virtual network services for Cisco’s cloud infrastructure. She has been a receiver of the Cisco Achievement Program award. She received her MS from the Electrical Engineering at The Pennsylvania State University in 2011, during which she was a research assistant at the Networking and Security Research Center. Prior to that, she received her BE (honors) degree in Electronics from the BITS Pilani, India, in 2009. Her research interests include mobility management, communication in wireless networks, network virtualization, and cloud computing.</p>
<p><bold>Thomas F La Porta</bold> is the William E. Leonhard Chair Professor in the Computer Science and Engineering Department at Penn State. He received his BSEE and MSEE degrees from The Cooper Union, New York, and his PhD degree in Electrical Engineering from Columbia University, New York. He is an Institute of Electrical and Electronics Engineers (IEEE) Fellow, Bell Labs Fellow, received the Bell Labs Distinguished Technical Staff Award in 1996, and an Eta Kappa Nu Outstanding Young Electrical Engineer Award in 1996. He also won a Thomas Alva Edison Patent Awards in 2005 and 2009. He is the Director of the Communications Network Academic Research Center within the US Army Research Lab Network Science CTA.</p>
<p><bold>Prithwish Basu</bold> is a Senior Scientist at Raytheon BBN Technologies. He is the technical lead on the Network Science Collaborative Technology Alliance (NS CTA) program funded by the Army Research Laboratory (ARL) and the Principal Investigator for BBN on the International Technology Alliance (ITA) program that is jointly funded by ARL and UK MoD. Prithwish has published nearly 60 peer-reviewed articles in the field of networking, and his current interests include network science, network theory, and several aspects of mobile ad hoc, sensor, and disruption-tolerant networks. He holds a PhD in Computer Engineering from Boston University (2003) and a BTech in Computer Science and Engineering from IIT Delhi (1996). He received the MIT Technology Review’s Top 35 Innovators under 35 (TR35) award in 2006.</p>
<p><bold>Guohong Cao</bold> is a Professor in the Department of Computer Science and Engineering at the Pennsylvania State University. His research interests are wireless networks and mobile computing, and he has published more than 150 papers in these areas. He has served on the editorial board of <italic>IEEE Transactions on Mobile Computing</italic> and <italic>IEEE Transactions on Wireless Communications</italic>, and has served on the organizing and technical program committees of many conferences, including the TPC co-chair of IEEE infocom’2013. He was a recipient of the NSF CAREER award in 2001. He is a Fellow of the IEEE.</p>
<p><bold>Major Scott L Shaffer</bold> served as the Military Technology Transition Lead for the Computational and Information Sciences Directorate at the ARL from 2009 to 2011. He assisted in the development of military mobility scenarios to exploit high-performance computing and also conducted verification/validation of NS-CTA research for military applications. Major Shaffer is currently serving as an Assistant Product Manager for Program Executive Office Intelligence, Electronic Warfare &amp; Sensors with responsibilities for acquiring, developing, procuring, and sustaining information warfare products to support the Warfighter.</p>
<p><bold>Dave Dent</bold> currently serves as the Acting Associate Director of the Computation Information Sciences Directorate (CISD), US ARL. From 2000 to 2010, he worked in various leadership positions for the ARL to include serving as the CISD Technology Transition Manager from 2008 to 2010 with the key responsibility in supporting the Research Development and Engineering Command (RDECOM) Network Technology Focus Team (TFT). He has worked for over 25 years for the military.</p>
</bio>
<ref-list>
<title>References</title>
<ref id="bibr1-1548512912455555">
<label>1.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Alberts</surname><given-names>DS</given-names></name>
<name><surname>Garstka</surname><given-names>JJ</given-names></name>
<name><surname>Stein</surname><given-names>FP</given-names></name>
</person-group>. <article-title>Network centric warfare: developing and leveraging information superiority</article-title>. In: <source>DoD C4ISR cooperative research program</source>. <edition>2nd ed.</edition> (revised). <month>August</month> <year>1999</year>.</citation>
</ref>
<ref id="bibr2-1548512912455555">
<label>2.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Zonoozi</surname><given-names>MM</given-names></name>
<name><surname>Dassanayake</surname><given-names>P</given-names></name>
</person-group>. <article-title>User mobility modeling and characterization of mobility patterns</article-title>. <source>IEEE J Sel Area Commun</source> <year>1997</year>; <volume>15</volume>: <fpage>1239</fpage>–<lpage>1252</lpage>.</citation>
</ref>
<ref id="bibr3-1548512912455555">
<label>3.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Johnson</surname><given-names>DB</given-names></name>
<name><surname>Maltz</surname><given-names>DA</given-names></name>
</person-group>. <article-title>Dynamic source routing in adhoc networks</article-title>. <source>Mob Comput</source> <year>1996</year>; <volume>353</volume>: <fpage>153</fpage>–<lpage>181</lpage>.</citation>
</ref>
<ref id="bibr4-1548512912455555">
<label>4.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Hong</surname><given-names>X</given-names></name>
<name><surname>Gerla</surname><given-names>M</given-names></name>
<name><surname>Pei</surname><given-names>G</given-names></name><etal/>
</person-group>. <article-title>A group mobility model for ad hoc wireless networks</article-title>. In: <conf-name>proceedings of the ACM international workshop on modeling, analysis, and simulation of wireless and mobile systems (MSWiM)</conf-name>, <conf-date>August</conf-date> <year>1999</year>.</citation>
</ref>
<ref id="bibr5-1548512912455555">
<label>5.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Bai</surname><given-names>F</given-names></name>
<name><surname>Helmy</surname><given-names>A</given-names></name>
</person-group>. <article-title>A survey of mobility modeling and analysis in wireless adhoc networks</article-title>. In: <source>Wireless Adhoc and Sensor Networks, Wireless adhoc and Sensor Networks</source>. <publisher-loc>Boston, MA</publisher-loc>: <publisher-name>Kluwer Academic Publishers</publisher-name>, <year>2004</year>, pp <fpage>1</fpage>–<lpage>30</lpage>.</citation>
</ref>
<ref id="bibr6-1548512912455555">
<label>6.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Bai</surname><given-names>F</given-names></name>
<name><surname>Sadagopan</surname><given-names>N</given-names></name>
<name><surname>Helmy</surname><given-names>A</given-names></name>
</person-group>. <article-title>Important: a framework to systematically analyze the impact of mobility on performance of routing protocols for ad hoc networks</article-title>. In: <conf-name>proceedings of IEEE information communications conference (INFOCOM 2003)</conf-name>, <conf-loc>San Francisco, CA</conf-loc>, <conf-date>April</conf-date> <year>2003</year>.</citation>
</ref>
<ref id="bibr7-1548512912455555">
<label>7.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Medina</surname><given-names>A</given-names></name>
<name><surname>Gursun</surname><given-names>G</given-names></name>
<name><surname>Basu</surname><given-names>P</given-names></name><etal/>
</person-group>. <article-title>On the universal generation of mobility models</article-title>. In: <conf-name>proceedings of IEEE/ACM MASCOTS 2010</conf-name>, <conf-loc>Miami Beach, FL</conf-loc>, <conf-date>August</conf-date> <year>2010</year>.</citation>
</ref>
<ref id="bibr8-1548512912455555">
<label>8.</label>
<citation citation-type="web">
<article-title>Army Field Manuals</article-title>. <publisher-name>Doctrine and training publications</publisher-name>, <ext-link ext-link-type="uri" xlink:href="http://armypubs.army.mil/doctrine/active_fm.html">http://armypubs.army.mil/doctrine/active_fm.html</ext-link>.</citation>
</ref>
<ref id="bibr9-1548512912455555">
<label>9.</label>
<citation citation-type="web">
<article-title>Field Manual 3-21.8</article-title>. Chapter 3, Tactical movement, <ext-link ext-link-type="uri" xlink:href="https://rdl.train.army.mil/soldierPortal/atia/adlsc/view/public/23583-1/FM/3-21.8/chap3.htm">https://rdl.train.army.mil/soldierPortal/atia/adlsc/view/public/23583-1/FM/3-21.8/chap3.htm</ext-link> (<access-date>accessed August 2012</access-date>).</citation>
</ref>
<ref id="bibr10-1548512912455555">
<label>10.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Johnson</surname><given-names>R</given-names></name>
<name><surname>Whitby</surname><given-names>M</given-names></name>
<name><surname>France</surname><given-names>J</given-names></name>
</person-group>. <source>How to win on the battlefield: the 25 key tactics of all time</source>. <publisher-name>Thames and Hudson</publisher-name>, <year>2010</year>.</citation>
</ref>
<ref id="bibr11-1548512912455555">
<label>11.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Freund</surname><given-names>RJ</given-names></name>
<name><surname>Wilson</surname><given-names>WJ</given-names></name>
<name><surname>Sa</surname><given-names>P</given-names></name>
</person-group>. <source>Regression analysis: statistical modeling of a response variable</source>. <edition>2nd ed.</edition> <publisher-loc>San Diego</publisher-loc>: <publisher-name>Academic Press</publisher-name>, <year>2006</year>.</citation>
</ref>
<ref id="bibr12-1548512912455555">
<label>12.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Sen</surname><given-names>A</given-names></name>
<name><surname>Srivastava</surname><given-names>M</given-names></name>
</person-group>. <source>Regression analysis: theory, methods, and applications</source>. <publisher-loc>New York</publisher-loc>: <publisher-name>Springer</publisher-name>, <year>1990</year>.</citation>
</ref>
<ref id="bibr13-1548512912455555">
<label>13.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Björck</surname><given-names>Å</given-names></name>
</person-group>. <source>Numerical methods for least squares problems</source>. <publisher-loc>Philadelphia, PA</publisher-loc>:<publisher-name>SIAM</publisher-name>, <publisher-loc>Philadelphia, PA</publisher-loc>:<publisher-name>SIAM</publisher-name>, <year>1996</year>.</citation>
</ref>
<ref id="bibr14-1548512912455555">
<label>14.</label>
<citation citation-type="web">
<comment>Online Curve Fitting and Surface Fitting Web Site</comment>, <ext-link ext-link-type="uri" xlink:href="http://www.zunzun.com">www.zunzun.com</ext-link> (<access-date>accessed August 2012</access-date>).</citation>
</ref>
<ref id="bibr15-1548512912455555">
<label>15.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Zhang</surname><given-names>Y</given-names></name>
<name><surname>Cao</surname><given-names>G</given-names></name>
<name><surname>Krishnamachari</surname><given-names>B</given-names></name><etal/>
</person-group>. <source>On quantifying the effects of mobility on data replication in mobile ad hoc networks</source>. Technical Report CSE-11-017, <publisher-name>Penn State University</publisher-name>, <year>2011</year>.</citation>
</ref>
<ref id="bibr16-1548512912455555">
<label>16.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Zhang</surname><given-names>Y</given-names></name>
<name><surname>Ray</surname><given-names>S</given-names></name>
<name><surname>Cao</surname><given-names>G</given-names></name><etal/>
</person-group>. <article-title>Data replication in mobile tactical networks</article-title>. In: <conf-name>IEEE Milcom</conf-name>, <year>2011</year>.</citation>
</ref>
</ref-list>
</back>
</article>