<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD Journal Publishing DTD v2.3 20070202//EN" "journalpublishing.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" xml:lang="en">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">SIM</journal-id>
<journal-id journal-id-type="hwp">spsim</journal-id>
<journal-title>SIMULATION</journal-title>
<issn pub-type="ppub">0037-5497</issn>
<issn pub-type="epub">1741-3133</issn>
<publisher>
<publisher-name>SAGE Publications</publisher-name>
<publisher-loc>Sage UK: London, England</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1177/0037549712473512</article-id>
<article-id pub-id-type="publisher-id">10.1177_0037549712473512</article-id>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Articles</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>SimGine: A simulation engine for stochastic discrete-event systems based on SDES description</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<name><surname>Khalili</surname><given-names>Ali</given-names></name>
<xref ref-type="aff" rid="aff1-0037549712473512">1</xref>
</contrib>
<contrib contrib-type="author" corresp="yes">
<name><surname>Abdollahi Azgomi</surname><given-names>Mohammad</given-names></name>
<xref ref-type="aff" rid="aff1-0037549712473512">1</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Jalaly Bidgoly</surname><given-names>Amir</given-names></name>
<xref ref-type="aff" rid="aff1-0037549712473512">1</xref>
</contrib>
</contrib-group>
<aff id="aff1-0037549712473512"><label>1</label>School of Computer Engineering, Iran University of Science and Technology, Tehran, Iran</aff>
<author-notes>
<fn fn-type="other">
<p>A. Khalili is now at the Italian Institute of Technology (IIT), Genova, Italy.</p>
</fn>
<corresp id="corresp1-0037549712473512">M.A. Azgomi, School of Computer Engineering, Iran University of Science and Technology, Hengam St., Resalat Sq., Tehran 16846-13114, Iran. Email: <email>azgomi@iust.ac.ir</email></corresp>
</author-notes>
<pub-date pub-type="epub-ppub">
<month>4</month>
<year>2013</year>
</pub-date>
<volume>89</volume>
<issue>4</issue>
<fpage>539</fpage>
<lpage>555</lpage>
<permissions>
<copyright-statement>© 2013 The Society for Modeling and Simulation International</copyright-statement>
<copyright-year>2013</copyright-year>
<copyright-holder content-type="society">Simulation Councils Inc.</copyright-holder>
</permissions>
<abstract>
<p>Discrete-event systems have gained a lot of interest due to their wide range of applications, and discrete-event simulation is a useful method for the performance evaluation of such systems. In this domain, model-based evaluation methods play an important role and there are many formalisms and realistic experiments using these methods. In this paper, we introduce SimGine, a multi-formalism simulation engine for stochastic discrete-event systems based on SDES, which is a unified abstract description for stochastic discrete-event systems. The engine is also capable of rare-event simulation of models using the importance sampling technique, which makes it the first multi-formalism simulation tool with rare-event simulation capability. The XML-based input language of SimGine allows for definition of the required methods. The body of each method is expressed by codes in a high-level programming language and this provides a powerful and flexible approach for defining events with complex behavior. For the simulation of an existing model, a tool for translating models into the SimGine input language should be prepared. SimGine can be used as a stand-alone simulation tool or as a simulation engine in other tools.</p>
</abstract>
<kwd-group>
<kwd>Stochastic discrete-event systems</kwd>
<kwd>simulation engines</kwd>
<kwd>formal methods</kwd>
<kwd>discrete-event simulation</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="section1-0037549712473512" sec-type="intro">
<title>1. Introduction</title>
<p>The behavior of many systems which are increasingly important in our lives could be described as discrete-event systems. These systems have gained a lot of interest due to their wide range of applications. Numerous models and analysis algorithms have been developed and successfully put into practice. Stochastic discrete-event systems which can capture some randomness in event delays and probabilistic behavior are developed for evaluating quantitative measures of systems (such as dependability and performance).</p>
<p>There are many formalisms for stochastic discrete-event systems, such as stochastic extensions of Petri nets and stochastic process algebras.These methods can be used for the performance and dependability evaluation of many systems. All the various proposed discrete-event model classes share some common characteristics and many of the techniques that have been developed for one class are in principle applicable to all or most of them. SDES is a unified abstract description for stochastic discrete-event systems which can be regarded as a blueprint for an abstract data type with virtual elements instantiated for a certain model class by substituting the attributes with net-class dependent values and functions.<sup><xref ref-type="bibr" rid="bibr1-0037549712473512">1</xref></sup></p>
<p>For the evaluation of these discrete-event models, there are at least two common approaches: analytic solution and model simulation. Analytic methods, which usually are capable of providing exact solutions, require the models to conform to certain criteria. One of the major difficulties that analytic approaches suffer from is the state-space explosion. Another problem is that analytic approaches, which use numerical techniques, can only deal with models that satisfy the Markovian property. As a result, discrete-event simsimulationulation plays an important role in the evaluation of systems and remains a popular method despite the development of new analytic methods.</p>
<p>There are many modeling tools available and each of them is able to create and evaluate models of a special formalism. In this paper, we introduce SimGine, a simulation engine for discrete-event systems based on SDES description. This engine can be used as a framework for the simulation of stochastic discrete-event systems. To utilize this engine, the formalism and configuration (i.e. all required information including events, guards, reward variables, etc.) should be translated into the input language of the engine. The engine can be used as a stand-alone tool or as a simulation library in other tools for the evaluation of stochastic discrete-event systems. It is also capable of rare-event simulation of models using the importance sampling (IS) technique. Rare-event simulation is a key technique in mission- and safety-critical applications in which the traditional simulation techniques are not applicable. As far as we know, SimGine is the first multi-formalism simulation tool which is capable of simulating rare events.</p>
<p>The rest of the paper is organized as follows. In Section 2, we briefly introduce the related works. Section 3 gives the motivations of the work. Section 4 describes SimGine’s architecture and its input language. Enabling SimGine to simulate rare events is described in Section 5. The results of simulating two examples are given in Section 6. Section 7 presents a comparison of SimGine with other multi-formalism simulation tools. Finally, some concluding remarks are presented in Section 8.</p>
</sec>
<sec id="section2-0037549712473512">
<title>2. Related work</title>
<p>The modeling and simulation of complex systems requires the availability of appropriate modeling formalisms and tools. There are many modeling tools available, most of which support a single high-level formalism to evaluate the models based on one or more solution methods. Many of these tools not only support a limited number of formalisms, but also are specific to some application areas. TimeNet<sup><xref ref-type="bibr" rid="bibr2-0037549712473512">2</xref></sup> and UltraSAN<sup><xref ref-type="bibr" rid="bibr3-0037549712473512">3</xref></sup> are some famous examples of simulation or modeling tools supporting single formalism based on some specific extensions of stochastic Petri nets.</p>
<p>However, in many cases, no single analysis and modeling method can successfully cope with all aspects of a complex system and a multi-formalism approach which tries to achieve formalisms and techniques integration is very appealing.<sup><xref ref-type="bibr" rid="bibr4-0037549712473512">4</xref></sup> The earliest attempt in this direction, to the best of our knowledge, was the combination of multiple modeling formalisms in SHARPE.<sup><xref ref-type="bibr" rid="bibr5-0037549712473512">5</xref></sup> It is a tool for specifying and analyzing performance, reliability, and performability models, and is capable of evaluating multiple model types including generalized stochastic Petri nets (GSPNs), product form queuing networks, reliability block diagrams, and Markov chains, by simulation or analytic solution methods.</p>
<p>SMART<sup><xref ref-type="bibr" rid="bibr6-0037549712473512">6</xref></sup> is another software tool that integrates multiple modeling formalisms. It supports the analysis of models expressed in stochastic Petri nets and queuing networks. The aim of SMART is to implement the tool in a way that permits the easy integration of new solution techniques.</p>
<p>Möbius<sup><xref ref-type="bibr" rid="bibr7-0037549712473512">7</xref></sup> is an environment in which multiple modeling formalisms and solvers can interact, and a framework for building a software tool for dependability and performance evaluation of complex discrete-event systems. The aim of the Möbius framework was to develop a tool in which a number of different modeling formalisms and solution techniques can be integrated into a single modeling tool or software environment. The simulation engine of the Möbius modeling framework is a formalism-independent simulator to support different execution policies and to provide a graphical interface to launch and monitor simulation progress.<sup><xref ref-type="bibr" rid="bibr8-0037549712473512">8</xref></sup></p>
<p>OsMoSys<sup><xref ref-type="bibr" rid="bibr4-0037549712473512">4</xref></sup> is a multi-formalism, multi-solution, object-oriented modeling framework based on meta-modeling, which provides an effective means of achieving both explicit and implicit multi-formalism, as well as compositional modeling within a single formalism. In this framework, the meta-formalism is a language used to describe graph-based formalisms; in other words, formalisms whose elements are nodes and arcs, such as Petri nets, queueing networks, and fault trees.</p>
<p>MOSEL-2<sup><xref ref-type="bibr" rid="bibr9-0037549712473512">9</xref></sup> is a modeling environment which comprises a high-level modeling language that provides a simple way to describe stochastic processes, which can evaluate the model by numerical analysis or simulation. The environment reuses existing tools for the system analysis by translating MOSEL-2 model specifications into the tool-specific system descriptions of some third-party modeling tools including MOSES, SPNP, and TimeNET.<sup><xref ref-type="bibr" rid="bibr10-0037549712473512">10</xref></sup></p>
<p>Discrete-event system specification (DEVS) formalism<sup><xref ref-type="bibr" rid="bibr11-0037549712473512">11</xref></sup> is a general methodology for describing discrete-event systems whose states and input/output behavior can be described by sequences of events. It can be used to describe and simulate many classes of deterministic systems, including discrete-event systems. Stochastic behavior is achieved in DEVS simulations by modeling behavior resorting to pseudo-random generators (i.e. deterministic sequences with properties acceptable enough to consider them stochastic for the practical purposes at hand). In Sarjoughian and Elamvazhuthi,<sup><xref ref-type="bibr" rid="bibr12-0037549712473512">12</xref></sup> the authors have developed an integrated modeling and simulation tool called ‘component-based system modeler and simulator’ (CoSMoS) to combine (visual and logical) model development and simulation execution. CoSMoS is not a simulator or a simulation engine but it facilities the design of systems by visually developing logical models, and is able to translate models into Parallel-DEVS notation, which can be simulated by DEVS-Suit.<sup><xref ref-type="bibr" rid="bibr13-0037549712473512">13</xref></sup> The same approach can be applied to other modeling approaches and simulation engines,<sup><xref ref-type="bibr" rid="bibr12-0037549712473512">12</xref></sup> and for the sake of generality and uniformity of SDES notation, SimGine might be considered as an alternative for this purpose.</p>
<p>Stochastic DEVS specification (STDEVS)<sup><xref ref-type="bibr" rid="bibr14-0037549712473512">14</xref></sup> is a generalization of DEVS for stochastic systems based on the use of probability spaces. It provides a formal framework with a strong mathematical basis for modeling generalized non-deterministic discrete-event systems. It has been demonstrated that DEVS is a particular case of STDEVS for deterministic models. Therefore, computational implementations of DEVS simulation models resorting to pseudo-random number generators used in practice to mimic stochasticity are theoretically well formulated in the context of probability theory by means of STDEVS. In practice, STDEVS is an alternative to SDES, considered as the unified notation for the analysis of discrete-event systems in a simulation tool. When comparing SDES with STDEVS, we note that the SDES description only supports single models and does not handle model hierarchy in its original description (nevertheless, we are still able to extend it with a kind of model composition, e.g. by sharing variables among models), and to evaluate hierarchical high-level models, we have to flatten hierarchical compositions into a single SDES model. However, STDEVS has the inherent capability of composing models hierarchically, being therefore very suitable for modeling systems with different communicating components. On the other hand, STDEVS does not explicitly deal with features like immediate activities (with global probabilistic collision control) and activities’ reactivation. Despite the fact that DEVS gains lots of interest in the literature, which shows its generality, elegant design, and good theoretical basis, we believe that SDES is a flexible and general notation and a more convenient option to be used as a unified formalism in a simulation engine (where the formalism is likely aimed by an automated translation).</p>
<p>Considering the capabilities and limitations of the mentioned works, the next section describes our aims of developing SimGine and later, in Section 7, a comparison between SimGine and the most related of these works will be provided.</p>
</sec>
<sec id="section3-0037549712473512">
<title>3. Motivations and aims</title>
<p>The aim of a multi-formalism modeling tool is to support several specification language, model composition, and solution or simulation methods within an integrated environment. We believe that it is practically impossible to build a tool which can support the increasing number of modeling formalisms. Despite the advantage of available multi-formalisms modeling tools, this goal is not yet achieved practically. Many of the current multi-formalism modeling tools are not extensible, or are not generally available to other users for possible extensions. A few of the others, like Möbius, provide the possibility of extension for users. However, adding a new formalism to these frameworks is not an easy task.</p>
<p>From another viewpoint, discrete-event simulation faces some challenges. In mission- and safety-critical applications, the existence of some interested rare events makes the traditional discrete-event simulation methods inefficient. Standard simulation techniques are not practical in such applications, due to the required long simulation time. In such situations, rare-event simulation techniques are employed, which increase the occurrence probability of rare events, usually by utilizing an accelerator. However, rare-event simulation techniques have not yet gained sufficient interest in modeling and simulation tools despite their obvious advantages which are vital for industrial applications.</p>
<p>Our aim has been to develop a multi-formalism simulation engine, called SimGine, for stochastic discrete-event systems, which is extensible for use by third-party applications. The engine is based on SDES, a unified and easily understandable stochastic discrete-event description. SimGine can be used both as a stand-alone simulator and as a simulation library using the application programming interface (API). It uses an XML-based input language, which specifies the elements and the behavior of models using the programming language C#, which makes the engine suitable for modeling complex variables and behaviors. It facilities step-by-step simulation to help make model-debugging easier. In addition, it is capable of simulating rare events using IS, the most famous technique in rare-event simulation. To the best of our knowledge, SimGine is the first effort in utilizing rare-event simulation techniques in a multi-formalism modeling tool.</p>
</sec>
<sec id="section4-0037549712473512">
<title>4. SimGine: The new simulation engine</title>
<p>In this section, we introduce SimGine, the simulation engine that is based on SDES description. As we mentioned before, most stochastic discrete-event formalisms can be translated into SDES description, and thus, they can be simulated by SimGine. For each formalism, a translator should be developed to translate the corresponding model into the input language of SimGine.</p>
<sec id="section5-0037549712473512">
<title>4.1. The input language</title>
<p>The syntax and semantics of SimGine’s input language is designed to resemble the SDES description. Due to the benefits of extended mark-up language (XML), especially human- and machine-readability, representation of the input language is based on XML where each element of the language is represented by means of an XML tag that may contain some attributes and a value. <xref ref-type="fig" rid="fig1-0037549712473512">Figure 1</xref> shows the BNF-like grammar of the input language. In this figure, words in italics represent XML attributes and underlined words denote XML values in the language. Like any other XML document, the grammar of the input language can also be expressed by a document type definition (DTD).</p>
<fig id="fig1-0037549712473512" position="float">
<label>Figure 1.</label>
<caption>
<p>BNF-like grammar of input language of SimGine (as XML format).</p>
</caption>
<graphic xlink:href="10.1177_0037549712473512-fig1.tif"/>
</fig>
<p>A model includes the definitions of the state variables of the system, events, and reward structures, corresponding to <inline-formula id="inline-formula1-0037549712473512">
<mml:math display="inline" id="math1-0037549712473512">
<mml:mrow>
<mml:msup>
<mml:mrow>
<mml:mi>S</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math>
</inline-formula>, <inline-formula id="inline-formula2-0037549712473512">
<mml:math display="inline" id="math2-0037549712473512">
<mml:mrow>
<mml:msup>
<mml:mrow>
<mml:mi>A</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math>
</inline-formula>, and <inline-formula id="inline-formula3-0037549712473512">
<mml:math display="inline" id="math3-0037549712473512">
<mml:mrow>
<mml:mi>R</mml:mi>
<mml:msup>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math>
</inline-formula> in the SDES definition, respectively. In addition, a model may include some auxiliaries, which contain the definitions of the required constants, utility functions, and external source code needed in the simulation progress. Each utility function can be called by functions defined in the scope of the model. A utility function definition includes an <italic>identifier, parameters</italic>, and a <italic>body</italic>. The body of each function defines the type of return value of the function and a quoted string in an XML tag value which is written in a programming language and can include loops, local variable definitions, conditional statements, assignment statements, etc. The modeler can also import the required source code in some external files with the tag <italic>Using</italic> which specifies the location of the file containing the source code. This capability is useful for defining external functions (especially when they have numerous lines of code) and user-defined data types by means of class definition, which can also be used in other models; it makes them reusable and more structured. For example, the modeler can define some classes for queue, stack, and set data structures to be used in the model. In the current version of the engine, the programming language <ext-link ext-link-type="uri" xlink:href="http://C#.NET">C#.NET</ext-link> is selected for the input language and all parts of the model definition should follow the syntax and semantics of this language. For example, naming convention, method calls rules, and scope rules are the same as for C#.</p>
<p>State variables of the model should be defined in the <italic>Variables</italic> section. Each variable within a special type has a unique variable name (identifier). The type of each state variable can be a built-in type (e.g. bool, int, char, byte, float, etc.), an array of a built-in type, or any type defined by the user in the auxiliary (i.e. <italic>Using</italic> part). State variables can be used in any functions, but assigning a new value to them is permitted only in the <italic>action</italic> function defined for each event. The initial state-space of the model (<inline-formula id="inline-formula4-0037549712473512">
<mml:math display="inline" id="math4-0037549712473512">
<mml:mrow>
<mml:msubsup>
<mml:mrow>
<mml:mi>Val</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:math>
</inline-formula> in SDES notation) must be defined within the <italic>initializer</italic>, which is a function that does not return any value and initializes the state variables of the model. This method is executed before any trial of the simulation to initialize the model. The variables section may also include the <italic>CondChecker</italic> function to check and validate the values of state variables that will be executed after the execution of each event. This function, which implements <inline-formula id="inline-formula5-0037549712473512">
<mml:math display="inline" id="math5-0037549712473512">
<mml:mrow>
<mml:mi>Con</mml:mi>
<mml:msup>
<mml:mrow>
<mml:mi>d</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math>
</inline-formula>, can be used when all values belonging to a sort of state variable are not actually allowed.</p>
<p>The <italic>Events</italic> part includes events’ definitions of the models (<inline-formula id="inline-formula6-0037549712473512">
<mml:math display="inline" id="math6-0037549712473512">
<mml:mrow>
<mml:msup>
<mml:mrow>
<mml:mi>A</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math>
</inline-formula> in SDES notation). An event represents the basic unit of a model that facilitates changing the state of the system by modifying values of state variables. An event corresponds to a transition in stochastic Petri nets (like SPNs<sup><xref ref-type="bibr" rid="bibr15-0037549712473512">15</xref></sup> and GSPNs<sup><xref ref-type="bibr" rid="bibr16-0037549712473512">16</xref></sup>), an action in process algebras, an activity of a SAN,<sup><xref ref-type="bibr" rid="bibr17-0037549712473512">17</xref></sup> or a server of a queue in queueing networks, for example. In the current version of the engine, the definition of events in the input language is the same as SDES actions but with two differences. First, we have limited the degree of each action to one and it has exactly one variant and thus, we do not distinguish between an action and its modes (see the definition of SDES in <xref ref-type="app" rid="app1-0037549712473512">Appendix</xref> and Zimmermann<sup><xref ref-type="bibr" rid="bibr1-0037549712473512">1</xref></sup>). And second, we have extended the definition of actions in SDES (<inline-formula id="inline-formula7-0037549712473512">
<mml:math display="inline" id="math7-0037549712473512">
<mml:mrow>
<mml:msup>
<mml:mrow>
<mml:mi>A</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math>
</inline-formula>) with the reactivation<sup><xref ref-type="bibr" rid="bibr18-0037549712473512">18</xref></sup> concept. An action may reactivate as a state-dependent function while it is enabled. The action must start over when reactivation occurs and a new execution time must be chosen. Each event has a unique identifier. The following methods must be defined for each event (<xref ref-type="table" rid="table1-0037549712473512">Table 1</xref> shows the type of each method):</p>
<table-wrap id="table1-0037549712473512" position="float">
<label>Table 1.</label>
<caption>
<p>Types of functions’ return values.</p>
</caption>
<graphic alternate-form-of="table1-0037549712473512" xlink:href="10.1177_0037549712473512-table1.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="left"/>
</colgroup>
<thead>
<tr>
<th align="left">Function</th>
<th align="left">Type (of return value)</th>
</tr>
</thead>
<tbody>
<tr>
<td>initializer</td>
<td>void</td>
</tr>
<tr>
<td>condition checker</td>
<td>bool</td>
</tr>
<tr>
<td>precondition</td>
<td>bool</td>
</tr>
<tr>
<td>weight</td>
<td>float</td>
</tr>
<tr>
<td>priority</td>
<td>int</td>
</tr>
<tr>
<td>delay</td>
<td>float</td>
</tr>
<tr>
<td>action</td>
<td>void</td>
</tr>
<tr>
<td>reactivation predicate</td>
<td>bool</td>
</tr>
<tr>
<td>rate reward</td>
<td>float</td>
</tr>
<tr>
<td>impulse reward</td>
<td>float</td>
</tr>
</tbody>
</table>
</table-wrap>
<list id="list1-0037549712473512" list-type="bullet">
<list-item><p>Precondition: the body of a boolean function that determines the precondition of an event (<inline-formula id="inline-formula8-0037549712473512">
<mml:math display="inline" id="math8-0037549712473512">
<mml:mrow>
<mml:mi>En</mml:mi>
<mml:msup>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math>
</inline-formula> in SDES notation) in each state evaluates whether the event is enabled or not. While the precondition of an event is <italic>false</italic>, the event will not be executed.</p></list-item>
<list-item><p>Delay: the body of a function that specifies the execution time of the event (<inline-formula id="inline-formula9-0037549712473512">
<mml:math display="inline" id="math9-0037549712473512">
<mml:mrow>
<mml:mi>Dela</mml:mi>
<mml:msup>
<mml:mrow>
<mml:mi>y</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math>
</inline-formula> in SDES notation), in other words, the time that must elapse before the event executes, while it is enabled. Among all enabled events, the event with the earliest execution time will complete first. If the delay of an enabled event in a state is equal to zero, that event is regarded as an immediate event (like an immediate transition in stochastic Petri nets).</p></list-item>
<list-item><p>Priority: the body of a function which specifies the priority of the event (<inline-formula id="inline-formula10-0037549712473512">
<mml:math display="inline" id="math10-0037549712473512">
<mml:mrow>
<mml:mi>Pr</mml:mi>
<mml:msup>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math>
</inline-formula> in SDES notation). If two or more events are enabled and have the same execution time, the event with the highest priority executes first.</p></list-item>
<list-item><p>Weight: if two or more events with the same execution time share the highest priority, a probabilistic decision determines which event completes first. The weight function (i.e. <inline-formula id="inline-formula11-0037549712473512">
<mml:math display="inline" id="math11-0037549712473512">
<mml:mrow>
<mml:mi>Weigh</mml:mi>
<mml:msup>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math>
</inline-formula> in SDES notation) is mostly used for immediate events.</p></list-item>
<list-item><p>Action: the body of the completion function of the event which may change the state of the model (<inline-formula id="inline-formula12-0037549712473512">
<mml:math display="inline" id="math12-0037549712473512">
<mml:mrow>
<mml:mi>Exe</mml:mi>
<mml:msup>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math>
</inline-formula> in SDES notation). If the model has more than one enabled event, the simulator needs a selection algorithm for choosing the next event to complete. The simulation algorithm, including this selection process, is shown briefly in <xref ref-type="fig" rid="fig2-0037549712473512">Figure 2</xref> (due to lack of space, the detailed algorithm is omitted and just the general procedure is in the figure. For more details, please see SimGine documentation<sup><xref ref-type="bibr" rid="bibr19-0037549712473512">19</xref></sup>).</p></list-item>
<list-item><p>Reactivation predicate: the body of a function that returns a boolean value as the reactivation predicate. If the reactivation predicate of an enabled event holds in a state, the event restarts. Reactivation causes the event to behave like when it disables and then enables again immediately.</p></list-item>
</list>
<fig id="fig2-0037549712473512" position="float">
<label>Figure 2.</label>
<caption>
<p>Event-scheduling time-advance algorithm of SimGine.</p>
</caption>
<graphic xlink:href="10.1177_0037549712473512-fig2.tif"/>
</fig>
<p><xref ref-type="fig" rid="fig3-0037549712473512">Figure 3</xref> shows an example of a simple event named <italic>event1</italic> which has a precondition that makes it enabled when the state variable <italic>p1</italic> is equal to the state variable <italic>p2</italic>. The weight and the priority of <italic>event1</italic> are equal to <inline-formula id="inline-formula13-0037549712473512">
<mml:math display="inline" id="math13-0037549712473512">
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:math>
</inline-formula>. The delay function, as described before, must return a float value, and a predefined class (named <italic>Distribution</italic>) is available for the easy usage of the probability distributions. This class has some probability distribution functions, such as deterministic, exponential, Erlang, gamma, hyper-exponential, and lognormal. The execution rate of <italic>event1</italic> is exponential with the rate <inline-formula id="inline-formula14-0037549712473512">
<mml:math display="inline" id="math14-0037549712473512">
<mml:mrow>
<mml:mn>1</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>5</mml:mn>
</mml:mrow>
</mml:math>
</inline-formula> and it causes the incrementation of <italic>p1</italic> and the decrementing of <italic>p2</italic> by one.</p>
<p>In the <italic>Rewards</italic> section, the modeler defines the interesting reward variables (i.e. <inline-formula id="inline-formula15-0037549712473512">
<mml:math display="inline" id="math15-0037549712473512">
<mml:mrow>
<mml:mi>R</mml:mi>
<mml:msup>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math>
</inline-formula> in SDES notation) of the model to aid the evaluation of measures about the system. In this direction, SimGine supports reward variables at some instant or interval of time or in the steady-state.</p>
<fig id="fig3-0037549712473512" position="float">
<label>Figure 3.</label>
<caption>
<p>An event example.</p>
</caption>
<graphic xlink:href="10.1177_0037549712473512-fig3.tif"/>
</fig>
<p>The reward formalism supported by SimGine is similar to that in Sanders and Meyer.<sup><xref ref-type="bibr" rid="bibr20-0037549712473512">20</xref></sup> There are two classes of reward functions: impulse and rate reward functions that specify impulse and rate rewards, respectively. For each reward variable, the following items are required to be specified:</p>
<list id="list2-0037549712473512" list-type="bullet">
<list-item><p>Rate reward: a rate reward function is defined by the tag <italic>RR</italic> and specifies the rate at which the reward is accumulated for any state of the model. When the model is in a specific state, if the rate reward function returns the float value <italic>r</italic>, it means that while the model remains in that state, the reward will be accumulated at the rate <italic>r</italic>.</p></list-item>
<list-item><p>Impulse reward: impulse reward functions are specified by the tag <italic>IR</italic>. An impulse reward function specifies the amount of the reward earned when the state of the model changes by the execution of some particular events. For the observation of every desired event, a tag <italic>InCaseOf</italic> should be defined, which contains the body of a function that its return value characterizes the amount of the reward earned upon the execution of the event, where its name is specified in the tag’s attribute <italic>event</italic>. Impulse rewards are usually used to count the number of executions of an event during an interval of time.</p></list-item>
<list-item><p>Reward variable type: different problems need various classes of reward variables. Therefore, SimGine supports two types: <italic>transient</italic> and <italic>steady-state</italic>. The steady-state reward needs no more data, while the simulator requires more information when the transient type is selected, which must be defined in the tag <italic>Measurement</italic> that describes an interval of time that the reward must be earned in. The start and end points of an interval can be the same corresponding to an <italic>instant-of-time</italic> reward variable. The transient type can also have an option expressed as <italic>averaged</italic>. Using this option, the simulator computes the mean value of the reward in the specified time-interval (like an averaged interval-of-time reward variable in some other tools).</p></list-item>
<list-item><p>Confidence: when the simulator reaches the desired confidence interval in the specific confidence level for all reward variables, the simulation progress will be stopped. The confidence level can be <inline-formula id="inline-formula16-0037549712473512">
<mml:math display="inline" id="math16-0037549712473512">
<mml:mrow>
<mml:mn>0</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>95</mml:mn>
</mml:mrow>
</mml:math>
</inline-formula>, <inline-formula id="inline-formula17-0037549712473512">
<mml:math display="inline" id="math17-0037549712473512">
<mml:mrow>
<mml:mn>0</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>98</mml:mn>
</mml:mrow>
</mml:math>
</inline-formula>, <inline-formula id="inline-formula18-0037549712473512">
<mml:math display="inline" id="math18-0037549712473512">
<mml:mrow>
<mml:mn>0</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>99</mml:mn>
</mml:mrow>
</mml:math>
</inline-formula>, or <inline-formula id="inline-formula19-0037549712473512">
<mml:math display="inline" id="math19-0037549712473512">
<mml:mrow>
<mml:mn>0</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>999</mml:mn>
</mml:mrow>
</mml:math>
</inline-formula>. Greater levels with smaller intervals lead to more reliable results.</p></list-item>
</list>
<p><xref ref-type="fig" rid="fig4-0037549712473512">Figure 4</xref> shows an example of the reward structure in which a reward named <italic>rew1</italic>, composed of a rate reward and an impulse reward, is defined. The rate reward probes the state variable <italic>p1</italic> and causes <italic>rew1</italic> to earn one whenever it is equal to <inline-formula id="inline-formula20-0037549712473512">
<mml:math display="inline" id="math20-0037549712473512">
<mml:mrow>
<mml:mn>3</mml:mn>
</mml:mrow>
</mml:math>
</inline-formula>, in other words, the reward earned per unit of time in each state that holds the property ‘<inline-formula id="inline-formula21-0037549712473512">
<mml:math display="inline" id="math21-0037549712473512">
<mml:mrow>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
<mml:mo>=</mml:mo>
<mml:mn>3</mml:mn>
</mml:mrow>
</mml:math>
</inline-formula>’ is equal to <inline-formula id="inline-formula22-0037549712473512">
<mml:math display="inline" id="math22-0037549712473512">
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:math>
</inline-formula>. Also, the impulse reward causes the accumulation of <italic>rew1</italic> with <inline-formula id="inline-formula23-0037549712473512">
<mml:math display="inline" id="math23-0037549712473512">
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:math>
</inline-formula> or <inline-formula id="inline-formula24-0037549712473512">
<mml:math display="inline" id="math24-0037549712473512">
<mml:mrow>
<mml:mn>0</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>05</mml:mn>
</mml:mrow>
</mml:math>
</inline-formula> whenever <italic>event1</italic> or <italic>event2</italic> is executed, respectively.</p>
<fig id="fig4-0037549712473512" position="float">
<label>Figure 4.</label>
<caption>
<p>A reward structure example.</p>
</caption>
<graphic xlink:href="10.1177_0037549712473512-fig4.tif"/>
</fig>
</sec>
<sec id="section6-0037549712473512">
<title>4.2 The software architecture of SimGine</title>
<p>In this section, we briefly review the software architecture of SimGine. The overall software architecture of the tool, including its main components and their relationships, is depicted in <xref ref-type="fig" rid="fig5-0037549712473512">Figure 5</xref>. The three main components of the engine are the model parser, code generator, and SDES simulation manager. The input model is an XML file based on the input language, usually translated from a model in a high-level formalism. The translator, which is a third-party application, has the responsibility of translating high-level models into the input language. In the first step, the input model is checked by the model parser to validate syntax and semantic rules, in which the necessary information is prepared for the code generator. The code generator is responsible for constructing an executable code which includes the description of the input model, required for running the simulation. The simulation manager advances simulation progress and collects the information while running the simulation until it reaches a stop-criterion (such as the desired confidence interval, the maximum number of iterations, or any false value in the results of the condition checker). The SDES simulation manager acts as the underlying layer for simulator, animator, and rare-event simulator (described in the next section) sub-components. There is also a utility library which provides some utility functions available for all components of SimGine. For more information about software architecture, classes, and UML diagrams of SimGine, please see the SimGine developers’ manual.<sup><xref ref-type="bibr" rid="bibr19-0037549712473512">19</xref></sup></p>
<fig id="fig5-0037549712473512" position="float">
<label>Figure 5.</label>
<caption>
<p>Software architecture of SimGine.</p>
</caption>
<graphic xlink:href="10.1177_0037549712473512-fig5.tif"/>
</fig>
<p>SimGine can be used as a simulation engine library in third-party applications. For the simulation of a model, some objects and their methods provided by the library can be used. A graphical user interface (GUI) has also been developed that interacts with SimGine and so the engine can be used as a stand-alone simulation tool. This GUI allows users to edit SDES models and define simulation studies easily. In addition, the GUI provides features like step-by-step simulation (two screenshots of SimGine are shown in <xref ref-type="fig" rid="fig6-0037549712473512">Figures 6</xref> and <xref ref-type="fig" rid="fig7-0037549712473512">7</xref>). The SimGine GUI makes the modelers able to work with SDES models (as the input language of SimGine) and, as mentioned before, for working with high-level models, we need another application to build models and translate them into SDES. In this direction, we have also developed PDETool<sup><xref ref-type="bibr" rid="bibr21-0037549712473512">21</xref></sup> as an extensible modeling tool to build graphical and textual models and automatically translate them into the input language of SimGine. The aim of the tool is to provide some features for the construction of models and translating them into the input language of SimGine. It also provides features for the simulation and animation of high-level models. PDETool currently supports stochastic reward nets (SRNs), GSPNs, some extensions of stochastic activity networks (SANs), and RayLang.<sup><xref ref-type="bibr" rid="bibr22-0037549712473512">22</xref></sup></p>
<fig id="fig6-0037549712473512" position="float">
<label>Figure 6.</label>
<caption>
<p>A screenshot of the GUI of SimGine for editing models.</p>
</caption>
<graphic xlink:href="10.1177_0037549712473512-fig6.tif"/>
</fig>
<fig id="fig7-0037549712473512" position="float">
<label>Figure 7.</label>
<caption>
<p>Another screenshot of the GUI of SimGine for the step-by-step simulation of models.</p>
</caption>
<graphic xlink:href="10.1177_0037549712473512-fig7.tif"/>
</fig>
</sec>
</sec>
<sec id="section7-0037549712473512">
<title>5. Rare-event simulation within SimGine</title>
<p>As mentioned before, traditional simulation is not appropriate for systems with rare events due to the required long simulation time. In such situations, rare-event simulation techniques are used, which increase the occurrence probability of rare events, usually by utilizing an accelerator.</p>
<p>IS<sup><xref ref-type="bibr" rid="bibr23-0037549712473512">23</xref><xref ref-type="bibr" rid="bibr24-0037549712473512"/>–<xref ref-type="bibr" rid="bibr25-0037549712473512">25</xref></sup> and splitting<sup><xref ref-type="bibr" rid="bibr26-0037549712473512">26</xref><xref ref-type="bibr" rid="bibr27-0037549712473512"/>–<xref ref-type="bibr" rid="bibr28-0037549712473512">28</xref></sup> are famous variance reduction techniques for rare-event simulation. IS increases the probability of rare events by changing the probability laws that drive the evolution of the system. The model is then biased, but the bias is compensated for by the introduction of a function called the <italic>likelihood ratio</italic>, which is the ratio of the sample path in the original model to the altered model. The major difficulty in applying this method is to figure out how to change the probabilities, in which the IS estimator has much smaller variance than the original one. In the splitting method, however, the probability laws remain unchanged, but an artificial drift toward rare events is created by terminating some probability trajectories that seem to go away from it and by splitting (cloning) those that are going in the right direction.<sup><xref ref-type="bibr" rid="bibr27-0037549712473512">27</xref></sup><italic>RESTART</italic><sup><xref ref-type="bibr" rid="bibr29-0037549712473512">29</xref><xref ref-type="bibr" rid="bibr30-0037549712473512"/>–<xref ref-type="bibr" rid="bibr31-0037549712473512">31</xref></sup> is also a class of splitting which considers a threshold and kills the trajectories when they cross below it.</p>
<p>In this section, we discuss extending SimGine to support rare-event simulation. Among rare-event simulation techniques, IS is chosen for this purpose, being one of the most famous and successful techniques. To do so, we have extended SimGine with a rare-event simulation technique which is capable of simulating models using the IS technique. In the following, IS and its background theory is briefly reviewed, and then we explain how we have extended SimGine to support rare-event simulation. In this regard, in Section 5.2, the required changes in the syntax of the input language of SimGine will be described in detail. Afterward, Section 5.3 gives a technical description of the implementation of IS in the engine.</p>
<sec id="section8-0037549712473512">
<title>5.1. Importance sampling</title>
<p>IS<sup><xref ref-type="bibr" rid="bibr23-0037549712473512">23</xref><xref ref-type="bibr" rid="bibr24-0037549712473512"/>–<xref ref-type="bibr" rid="bibr25-0037549712473512">25</xref></sup> is one of the most effective and significant methods for rare-event simulation. Consider a model with the sample space <inline-formula id="inline-formula25-0037549712473512">
<mml:math display="inline" id="math25-0037549712473512">
<mml:mrow>
<mml:mi>Ω</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula>, the probability measure <inline-formula id="inline-formula26-0037549712473512">
<mml:math display="inline" id="math26-0037549712473512">
<mml:mrow>
<mml:mi>P</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula>, and a rare event <inline-formula id="inline-formula27-0037549712473512">
<mml:math display="inline" id="math27-0037549712473512">
<mml:mrow>
<mml:mi>ε</mml:mi>
<mml:mo>∈</mml:mo>
<mml:mi>Ω</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula>. The interest of evaluating the model is estimating the probability <inline-formula id="inline-formula28-0037549712473512">
<mml:math display="inline" id="math28-0037549712473512">
<mml:mrow>
<mml:mi>P</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>ε</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula>. We define the indicator function <inline-formula id="inline-formula29-0037549712473512">
<mml:math display="inline" id="math29-0037549712473512">
<mml:mrow>
<mml:mi>I</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>ε</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> to have the value <inline-formula id="inline-formula30-0037549712473512">
<mml:math display="inline" id="math30-0037549712473512">
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:math>
</inline-formula> when outcomes belong to <inline-formula id="inline-formula31-0037549712473512">
<mml:math display="inline" id="math31-0037549712473512">
<mml:mrow>
<mml:mi>ε</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula> and the value 0 in other cases. Let <inline-formula id="inline-formula32-0037549712473512">
<mml:math display="inline" id="math32-0037549712473512">
<mml:mrow>
<mml:mi>γ</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula> denote the probability <inline-formula id="inline-formula33-0037549712473512">
<mml:math display="inline" id="math33-0037549712473512">
<mml:mrow>
<mml:mi>P</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>ε</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula>. Consider a new distribution function <inline-formula id="inline-formula34-0037549712473512">
<mml:math display="inline" id="math34-0037549712473512">
<mml:mrow>
<mml:msup>
<mml:mrow>
<mml:mi>P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math>
</inline-formula> with the property that <inline-formula id="inline-formula35-0037549712473512">
<mml:math display="inline" id="math35-0037549712473512">
<mml:mrow>
<mml:msup>
<mml:mrow>
<mml:mi>P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msup>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>A</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>&gt;</mml:mo>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:math>
</inline-formula> where <inline-formula id="inline-formula36-0037549712473512">
<mml:math display="inline" id="math36-0037549712473512">
<mml:mrow>
<mml:mi>P</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>A</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>&gt;</mml:mo>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:math>
</inline-formula> for <inline-formula id="inline-formula37-0037549712473512">
<mml:math display="inline" id="math37-0037549712473512">
<mml:mrow>
<mml:mi>A</mml:mi>
<mml:mo>⊂</mml:mo>
<mml:mi>ε</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula>, such that</p>
<p><disp-formula id="disp-formula1-0037549712473512">
<label>(1)</label>
<mml:math display="block" id="math38-0037549712473512">
<mml:mrow>
<mml:mtable align="left">
<mml:mtr>
<mml:mtd columnalign="center">
<mml:mrow>
<mml:mi>P</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>ε</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>E</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>P</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">[</mml:mo>
<mml:mi>I</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>ε</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">]</mml:mo>
<mml:mo>=</mml:mo>
<mml:mo>∫</mml:mo>
<mml:mi>I</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>ε</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mi>dP</mml:mi>
<mml:mo>=</mml:mo>
<mml:mo>∫</mml:mo>
<mml:mi>I</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>ε</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mfrac>
<mml:mrow>
<mml:mi>d</mml:mi>
<mml:msup>
<mml:mrow>
<mml:mi>P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msup>
</mml:mrow>
<mml:mrow>
<mml:mi>d</mml:mi>
<mml:msup>
<mml:mrow>
<mml:mi>P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:mfrac>
<mml:mi>dP</mml:mi>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="center" columnspan="1">
<mml:mrow>
<mml:mo>=</mml:mo>
<mml:mo>∫</mml:mo>
<mml:mi>I</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>ε</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mfrac>
<mml:mrow>
<mml:mi>dP</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>d</mml:mi>
<mml:msup>
<mml:mrow>
<mml:mi>P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:mfrac>
<mml:mi>d</mml:mi>
<mml:msup>
<mml:mrow>
<mml:mi>P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msup>
<mml:mo>=</mml:mo>
<mml:mo>∫</mml:mo>
<mml:mi>I</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>ε</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mi>Ld</mml:mi>
<mml:msup>
<mml:mrow>
<mml:mi>P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msup>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>E</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:msup>
<mml:mrow>
<mml:mi>P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">[</mml:mo>
<mml:mi>LI</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>ε</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">]</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula1-0037549712473512" xlink:href="10.1177_0037549712473512-eq1.tif"/>
</disp-formula></p>
<p>Here, the quotient of the probability measure <inline-formula id="inline-formula38-0037549712473512">
<mml:math display="inline" id="math39-0037549712473512">
<mml:mrow>
<mml:mi>L</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi>dP</mml:mi>
<mml:mo stretchy="false">/</mml:mo>
<mml:mi>d</mml:mi>
<mml:msup>
<mml:mrow>
<mml:mi>P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math>
</inline-formula> is called the likelihood ratio. According to this, IS simulation for estimating <inline-formula id="inline-formula39-0037549712473512">
<mml:math display="inline" id="math40-0037549712473512">
<mml:mrow>
<mml:mi>γ</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula> can be performed as follows:<sup><xref ref-type="bibr" rid="bibr23-0037549712473512">23</xref></sup> generate <inline-formula id="inline-formula40-0037549712473512">
<mml:math display="inline" id="math41-0037549712473512">
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula> independent samples <inline-formula id="inline-formula41-0037549712473512">
<mml:math display="inline" id="math42-0037549712473512">
<mml:mrow>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>I</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>ε</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>L</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula>, <inline-formula id="inline-formula42-0037549712473512">
<mml:math display="inline" id="math43-0037549712473512">
<mml:mrow>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>I</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>ε</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>;</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>L</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>,</mml:mo>
<mml:mo>…</mml:mo>
<mml:mo>,</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>I</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>ε</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>;</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>L</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> of <inline-formula id="inline-formula43-0037549712473512">
<mml:math display="inline" id="math44-0037549712473512">
<mml:mrow>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>I</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>ε</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>;</mml:mo>
<mml:mi>L</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula>. Then use the following equation as an unbiased estimator of <inline-formula id="inline-formula44-0037549712473512">
<mml:math display="inline" id="math45-0037549712473512">
<mml:mrow>
<mml:mi>γ</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula>:</p>
<p><disp-formula id="disp-formula2-0037549712473512">
<label>(2)</label>
<mml:math display="block" id="math46-0037549712473512">
<mml:mrow>
<mml:msub>
<mml:mi>γ</mml:mi>
<mml:mi>n</mml:mi>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>P</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mfrac>
<mml:mn>1</mml:mn>
<mml:mi>n</mml:mi>
</mml:mfrac>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mi>n</mml:mi>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>I</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>ε</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:msub>
<mml:mi>L</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula2-0037549712473512" xlink:href="10.1177_0037549712473512-eq2.tif"/>
</disp-formula></p>
<p>In particular, the aim of IS is to find a <inline-formula id="inline-formula45-0037549712473512">
<mml:math display="inline" id="math47-0037549712473512">
<mml:mrow>
<mml:msup>
<mml:mrow>
<mml:mi>P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math>
</inline-formula> that minimizes the relative error, or equivalently, the variance of the output <inline-formula id="inline-formula46-0037549712473512">
<mml:math display="inline" id="math48-0037549712473512">
<mml:mrow>
<mml:mi>I</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>ε</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mi>L</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula>. Although in some cases a new distribution <inline-formula id="inline-formula47-0037549712473512">
<mml:math display="inline" id="math49-0037549712473512">
<mml:mrow>
<mml:msup>
<mml:mrow>
<mml:mi>P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math>
</inline-formula> that increases the probability <inline-formula id="inline-formula48-0037549712473512">
<mml:math display="inline" id="math50-0037549712473512">
<mml:mrow>
<mml:mi>ε</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula> might be a proper choice, usually there exist more constraints in selecting a good one. For more information about the characteristics of a good distribution function for IS, please see Juneja and Shahabuddin,<sup><xref ref-type="bibr" rid="bibr23-0037549712473512">23</xref></sup> Obal,<sup><xref ref-type="bibr" rid="bibr32-0037549712473512">32</xref></sup> and Nicola et al.<sup><xref ref-type="bibr" rid="bibr33-0037549712473512">33</xref></sup></p>
</sec>
<sec id="section9-0037549712473512">
<title>5.2. Rare-event simulation in SimGine</title>
<p>To make SimGine capable of simulating rare events, the syntax of input models is extended to having an optional method <italic>ISDelay</italic> in <italic>Event</italic> definition, which represents the new distribution function (i.e. <inline-formula id="inline-formula49-0037549712473512">
<mml:math display="inline" id="math51-0037549712473512">
<mml:mrow>
<mml:msup>
<mml:mrow>
<mml:mi>P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math>
</inline-formula> in IS theory reviewed in the previous subsection). It is a more powerful and flexible method for the definition of distribution functions compared to the other tools in this regard (like UltraSAN<sup><xref ref-type="bibr" rid="bibr3-0037549712473512">3</xref></sup> which uses governor definition).</p>
<p>As we mentioned in Section 5.1, IS uses a quotient called ‘likelihood ratio’ to achieve an unbiased estimator. Computing the ratio requires knowing not only the value of the event’s delay (returned by the <italic>ISDelay</italic> method), but also the exact information about the distribution of the execution time, including its probability density function (PDF) and cumulative distribution function (CDF). Thus, in IS simulation, we restrict events’ delay function to some standard distribution functions (i.e. distribution functions like exponential, normal, Weibull, and so on, but not deterministic) instead of unknown general ones. To make the SimGine parser capable of extracting the required information from <italic>Delay</italic> and <italic>ISDelay</italic> functions, their return type must be an explicit method call from the class <italic>Distribution</italic> (e.g. see the delay function defined in <xref ref-type="fig" rid="fig8-0037549712473512">Figure 8</xref>). The events with a deterministic execution time, like immediate transitions in GSPNs, as well as those which return a float number (rather than using an explicit call from the class <italic>Distribution</italic>), cannot be modified by the <italic>ISDelay</italic> function.</p>
<p>The next subsection gives a technical description of the implementation of IS technique in SimGine.</p>
<fig id="fig8-0037549712473512" position="float">
<label>Figure 8.</label>
<caption>
<p>An example of an <italic>Event</italic> for rare-event simulation.</p>
</caption>
<graphic xlink:href="10.1177_0037549712473512-fig8.tif"/>
</fig>
</sec>
<sec id="section10-0037549712473512">
<title>5.3. Software implementation of IS in SimGine</title>
<p>The performance measure in a discrete-event simulation is usually determined as a function of a sample path. The term <italic>sample path</italic> refers to the sequence of events that occur during the simulation. Therefore, an event is rare if the sample paths in which it occurs are rare. The IS approach alters the probability measure of the model to lead the simulation to rare-event sample paths and then correct the estimation using the likelihood ratio. The modeler is responsible for choosing a new probability measure (determined by <italic>ISDelay</italic> functions) to be used in IS technique. A good probability measure is the one which decreases the variance of the simulator to the lowest possible value.</p>
<p>To estimate the likelihood ratio, an iterative approach has been presented in Nicola et al.<sup><xref ref-type="bibr" rid="bibr33-0037549712473512">33</xref></sup> by maintaining an accurate description of the conditional density and distribution functions. We have adapted this approach for IS simulation in SimGine. Consider that the model state in the sample path is presented by <inline-formula id="inline-formula50-0037549712473512">
<mml:math display="inline" id="math52-0037549712473512">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>X</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>ω</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> where <inline-formula id="inline-formula51-0037549712473512">
<mml:math display="inline" id="math53-0037549712473512">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula> is the <inline-formula id="inline-formula52-0037549712473512">
<mml:math display="inline" id="math54-0037549712473512">
<mml:mrow>
<mml:msup>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>th</mml:mtext>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math>
</inline-formula> event in the sample path (starting with <inline-formula id="inline-formula53-0037549712473512">
<mml:math display="inline" id="math55-0037549712473512">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula>) and <inline-formula id="inline-formula54-0037549712473512">
<mml:math display="inline" id="math56-0037549712473512">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>ω</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula> presents the internal state of the model before the execution of the mentioned event. Let’s assume that <inline-formula id="inline-formula55-0037549712473512">
<mml:math display="inline" id="math57-0037549712473512">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula> denotes the execution time of <inline-formula id="inline-formula56-0037549712473512">
<mml:math display="inline" id="math58-0037549712473512">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula> and <inline-formula id="inline-formula57-0037549712473512">
<mml:math display="inline" id="math59-0037549712473512">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>+</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula> while <inline-formula id="inline-formula58-0037549712473512">
<mml:math display="inline" id="math60-0037549712473512">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:math>
</inline-formula>. The probability of the whole sample path is given by <xref ref-type="disp-formula" rid="disp-formula3-0037549712473512">equation (3)</xref> where <inline-formula id="inline-formula59-0037549712473512">
<mml:math display="inline" id="math61-0037549712473512">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>X</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
<mml:mo>,</mml:mo>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>X</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo><mml:mo>…</mml:mo>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>X</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> is the sequence of states in the sample path:</p>
<p><disp-formula id="disp-formula3-0037549712473512">
<label>(3)</label>
<mml:math display="block" id="math62-0037549712473512">
<mml:mrow>
<mml:mtable align="left">
<mml:mtr>
<mml:mtd columnalign="center">
<mml:mrow>
<mml:mi>P</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>X</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
<mml:mo>,</mml:mo>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:munderover>
<mml:mo>Π</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>0</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
<mml:mo>−</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:munderover>
<mml:mi>P</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>X</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>+</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">|</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>X</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula3-0037549712473512" xlink:href="10.1177_0037549712473512-eq3.tif"/>
</disp-formula></p>
<p>Let <inline-formula id="inline-formula60-0037549712473512">
<mml:math display="inline" id="math63-0037549712473512">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>f</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>,</mml:mo>
<mml:mi>e</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> and <inline-formula id="inline-formula61-0037549712473512">
<mml:math display="inline" id="math64-0037549712473512">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>F</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>,</mml:mo>
<mml:mi>e</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> be the PDF and CDF of the remaining execution time of the event <inline-formula id="inline-formula62-0037549712473512">
<mml:math display="inline" id="math65-0037549712473512">
<mml:mrow>
<mml:mi>e</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula> at the state <inline-formula id="inline-formula63-0037549712473512">
<mml:math display="inline" id="math66-0037549712473512">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>X</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula> where <inline-formula id="inline-formula64-0037549712473512">
<mml:math display="inline" id="math67-0037549712473512">
<mml:mrow>
<mml:mi>e</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula> is enabled in that state. Also, let <inline-formula id="inline-formula65-0037549712473512">
<mml:math display="inline" id="math68-0037549712473512">
<mml:mrow>
<mml:mi>F</mml:mi>
<mml:mo>′</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mo>.</mml:mo>
<mml:mo>,</mml:mo>
<mml:mi>e</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>−</mml:mo>
<mml:mi>F</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mo>.</mml:mo>
<mml:mo>,</mml:mo>
<mml:mi>e</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula>. Upon the next event, if the event <inline-formula id="inline-formula66-0037549712473512">
<mml:math display="inline" id="math69-0037549712473512">
<mml:mrow>
<mml:mi>e</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula> has not been executed yet and is still enabled, we will have</p>
<p><disp-formula id="disp-formula4-0037549712473512">
<label>(4)</label>
<mml:math display="block" id="math70-0037549712473512">
<mml:mrow>
<mml:mtable align="left">
<mml:mtr>
<mml:mtd columnalign="center">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>f</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>+</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>,</mml:mo>
<mml:mi>e</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>f</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mi>e</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>F</mml:mi>
<mml:mo>′</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mi>e</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="center" columnspan="1">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>F</mml:mi>
<mml:mo>′</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>+</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>,</mml:mo>
<mml:mi>e</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>F</mml:mi>
<mml:mo>′</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mi>e</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>F</mml:mi>
<mml:mo>′</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mi>e</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula4-0037549712473512" xlink:href="10.1177_0037549712473512-eq4.tif"/>
</disp-formula></p>
<p>And, for newly enabled events, we will have</p>
<p><disp-formula id="disp-formula5-0037549712473512">
<label>(5)</label>
<mml:math display="block" id="math71-0037549712473512">
<mml:mrow>
<mml:mtable align="left">
<mml:mtr>
<mml:mtd columnalign="center">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>f</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>+</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>,</mml:mo>
<mml:mi>e</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mi>f</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>,</mml:mo>
<mml:mi>e</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="center" columnspan="1">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>F</mml:mi>
<mml:mo>′</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>+</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>,</mml:mo>
<mml:mi>e</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mi>F</mml:mi>
<mml:mo>′</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>,</mml:mo>
<mml:mi>e</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula5-0037549712473512" xlink:href="10.1177_0037549712473512-eq5.tif"/>
</disp-formula></p>
<p><xref ref-type="disp-formula" rid="disp-formula5-0037549712473512">Equation (5)</xref> gives an iterative function for updating the conditional PDF and CDF in every sequence in the sample path. As in Nicola et al.,<sup><xref ref-type="bibr" rid="bibr33-0037549712473512">33</xref></sup><inline-formula id="inline-formula67-0037549712473512">
<mml:math display="inline" id="math72-0037549712473512">
<mml:mrow>
<mml:mi>P</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>X</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>+</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">|</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>X</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> can be given by <xref ref-type="disp-formula" rid="disp-formula6-0037549712473512">equation (6)</xref>, assuming that <inline-formula id="inline-formula68-0037549712473512">
<mml:math display="inline" id="math73-0037549712473512">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>E</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula> is the set of enabled events in the state <inline-formula id="inline-formula69-0037549712473512">
<mml:math display="inline" id="math74-0037549712473512">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>X</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula>, as follows:</p>
<p><disp-formula id="disp-formula6-0037549712473512">
<label>(6)</label>
<mml:math display="block" id="math75-0037549712473512">
<mml:mrow>
<mml:mtable align="left">
<mml:mtr>
<mml:mtd columnalign="center">
<mml:mrow>
<mml:mi>P</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>X</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>+</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">|</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>X</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>f</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:munder>
<mml:mo>Π</mml:mo>
<mml:mrow>
<mml:mi>e</mml:mi>
<mml:mo>∈</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>E</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>−</mml:mo>
<mml:mo stretchy="false">{</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">}</mml:mo>
</mml:mrow>
</mml:munder>
<mml:msub>
<mml:mrow>
<mml:mi>F</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mi>e</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula6-0037549712473512" xlink:href="10.1177_0037549712473512-eq6.tif"/>
</disp-formula></p>
<p>In the IS technique, the likelihood ratio is defined as the ratio of the probability of a sample path in the original model to the probability of the same path in the biased model. Thus, the likelihood ratio in the <inline-formula id="inline-formula70-0037549712473512">
<mml:math display="inline" id="math76-0037549712473512">
<mml:mrow>
<mml:msup>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>th</mml:mtext>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math>
</inline-formula> state is then given by</p>
<p><disp-formula id="disp-formula7-0037549712473512">
<label>(7)</label>
<mml:math display="block" id="math77-0037549712473512">
<mml:mrow>
<mml:mtable align="left">
<mml:mtr>
<mml:mtd columnalign="center">
<mml:mrow>
<mml:mi>L</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>X</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>+</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">|</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>X</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>f</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:msubsup>
<mml:mrow>
<mml:mi>f</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msubsup>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:mfrac>
<mml:munder>
<mml:mo>Π</mml:mo>
<mml:mrow>
<mml:mi>e</mml:mi>
<mml:mo>∈</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>E</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>−</mml:mo>
<mml:mo stretchy="false">{</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">}</mml:mo>
</mml:mrow>
</mml:munder>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>F</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mi>e</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>F</mml:mi>
<mml:msubsup>
<mml:mrow>
<mml:mo>′</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msubsup>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mi>e</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula7-0037549712473512" xlink:href="10.1177_0037549712473512-eq7.tif"/>
</disp-formula></p>
<p>where <inline-formula id="inline-formula71-0037549712473512">
<mml:math display="inline" id="math78-0037549712473512">
<mml:mrow>
<mml:msup>
<mml:mrow>
<mml:mi>f</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math>
</inline-formula> and <inline-formula id="inline-formula72-0037549712473512">
<mml:math display="inline" id="math79-0037549712473512">
<mml:mrow>
<mml:mi>F</mml:mi>
<mml:msup>
<mml:mrow>
<mml:mo>′</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math>
</inline-formula> are associated with the new probability distributions that are specified by the <italic>ISDelay</italic> function in the model. Using the above equation, the likelihood ratio associated with the whole sample path <inline-formula id="inline-formula73-0037549712473512">
<mml:math display="inline" id="math80-0037549712473512">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>X</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
<mml:mo>,</mml:mo>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula> is given by <xref ref-type="disp-formula" rid="disp-formula8-0037549712473512">equation (8)</xref>:</p>
<p><disp-formula id="disp-formula8-0037549712473512">
<label>(8)</label>
<mml:math display="block" id="math81-0037549712473512">
<mml:mrow>
<mml:mtable align="left">
<mml:mtr>
<mml:mtd columnalign="center">
<mml:mrow>
<mml:mi>L</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>X</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
<mml:mo>,</mml:mo>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:munderover>
<mml:mo>Π</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>0</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
<mml:mo>−</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:munderover>
<mml:mi>L</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>X</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>,</mml:mo>
<mml:mi>i</mml:mi>
<mml:mo>+</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:munderover>
<mml:mo>Π</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>0</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
<mml:mo>−</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:munderover>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>f</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:msubsup>
<mml:mrow>
<mml:mi>f</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msubsup>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:mfrac>
<mml:munder>
<mml:mo>Π</mml:mo>
<mml:mrow>
<mml:mi>e</mml:mi>
<mml:mo>∈</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>E</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>−</mml:mo>
<mml:mo stretchy="false">{</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">}</mml:mo>
</mml:mrow>
</mml:munder>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>F</mml:mi>
<mml:mo>′</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mi>e</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>F</mml:mi>
<mml:msubsup>
<mml:mrow>
<mml:mo>′</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msubsup>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mi>e</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula8-0037549712473512" xlink:href="10.1177_0037549712473512-eq8.tif"/>
</disp-formula></p>
<p>Consider <inline-formula id="inline-formula74-0037549712473512">
<mml:math display="inline" id="math82-0037549712473512">
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula> as the interested reward variable, defined by the modeler, which includes <italic>impulse rewards</italic> and <italic>rate reward</italic>. In traditional simulation, the value that is earned by the reward variable at the point in time <inline-formula id="inline-formula75-0037549712473512">
<mml:math display="inline" id="math83-0037549712473512">
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula> can be defined by <xref ref-type="disp-formula" rid="disp-formula9-0037549712473512">equation (9)</xref>:</p>
<p><disp-formula id="disp-formula9-0037549712473512">
<label>(9)</label>
<mml:math display="block" id="math84-0037549712473512">
<mml:mrow>
<mml:mtable align="left">
<mml:mtr>
<mml:mtd columnalign="center">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mi>rate</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>σ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>+</mml:mo>
<mml:munder>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>e</mml:mi>
<mml:mo>∈</mml:mo>
<mml:mi>SE</mml:mi>
</mml:mrow>
</mml:munder>
<mml:mi>imp</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>e</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula9-0037549712473512" xlink:href="10.1177_0037549712473512-eq9.tif"/>
</disp-formula></p>
<p>where <inline-formula id="inline-formula76-0037549712473512">
<mml:math display="inline" id="math85-0037549712473512">
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula> and <inline-formula id="inline-formula77-0037549712473512">
<mml:math display="inline" id="math86-0037549712473512">
<mml:mrow>
<mml:mi>SE</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula> denote the state of model and the set of events completed in time <inline-formula id="inline-formula78-0037549712473512">
<mml:math display="inline" id="math87-0037549712473512">
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula>, respectively. In IS, the reward structure is changed to <xref ref-type="disp-formula" rid="disp-formula10-0037549712473512">equation (10)</xref>:</p>
<p><disp-formula id="disp-formula10-0037549712473512">
<label>(10)</label>
<mml:math display="block" id="math88-0037549712473512">
<mml:mrow>
<mml:mtable align="left">
<mml:mtr>
<mml:mtd columnalign="center">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mi>rate</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>σ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>.</mml:mo>
<mml:mi>L</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>X</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
<mml:mo>,</mml:mo>
<mml:mi>N</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>+</mml:mo>
<mml:munder>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>e</mml:mi>
<mml:mo>∈</mml:mo>
<mml:mi>SE</mml:mi>
</mml:mrow>
</mml:munder>
<mml:mi>imp</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>e</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>.</mml:mo>
<mml:mi>L</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>X</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
<mml:mo>,</mml:mo>
<mml:mi>N</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula10-0037549712473512" xlink:href="10.1177_0037549712473512-eq10.tif"/>
</disp-formula></p>
<p>Here, <inline-formula id="inline-formula79-0037549712473512">
<mml:math display="inline" id="math89-0037549712473512">
<mml:mrow>
<mml:mi>N</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula> is the number of events that cause the simulation clock to exceed <inline-formula id="inline-formula80-0037549712473512">
<mml:math display="inline" id="math90-0037549712473512">
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula> in the sample path generation and <inline-formula id="inline-formula81-0037549712473512">
<mml:math display="inline" id="math91-0037549712473512">
<mml:mrow>
<mml:mi>L</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>X</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
<mml:mo>,</mml:mo>
<mml:mi>N</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> is the likelihood ratio corresponding to this sample path.</p>
<p>As mentioned earlier, the expected value of any performance or dependability measure can be expressed in terms of reward variables. They include the cumulative ones over a time interval, rewards computed in an instance of time, and steady-state rewards. This makes the engine capable of evaluating a wide range of problems with or without rare events.</p>
</sec>
</sec>
<sec id="section11-0037549712473512">
<title>6. Some examples executed by SimGine</title>
<p>As mentioned earlier, for the simulation of a model using SimGine, it must be translated into the input language of SimGine. In this section, we present two examples: a server modeled by SRNs and rare-event simulation of a SAN model. More complex examples of other formalisms, including SANs, CSANs, MOSEL, and PEPA, in addition to the complete script of the two examples, can be found at the SimGine homepage.<sup><xref ref-type="bibr" rid="bibr19-0037549712473512">19</xref></sup></p>
<sec id="section12-0037549712473512">
<title>6.1. The SRN model of a server system</title>
<p>In this subsection, the simulation results of a sample SRN model using SimGine are presented. The model shown in <xref ref-type="fig" rid="fig9-0037549712473512">Figure 9</xref> is a server system which delivers a service to its customers. The server in the system can deliver service to only one customer at a time and there is a first-in first-out (FIFO) queue in the system, modeled by the place <italic>Queue</italic>, in which the customers can wait. The size of the queue is limited to 50 customers. Two immediate transitions, <italic>enter2queue</italic> (with an inhibitor arc with multiplicity 50 to place <italic>Queue</italic>) and <italic>reject</italic> (with guard <inline-formula id="inline-formula82-0037549712473512">
<mml:math display="inline" id="math92-0037549712473512">
<mml:mrow>
<mml:mi>Queue</mml:mi>
<mml:mo>.</mml:mo>
<mml:mi>Mark</mml:mi>
<mml:mo>&gt;</mml:mo>
<mml:mn>50</mml:mn>
</mml:mrow>
</mml:math>
</inline-formula>) check the queue capacity. The arrival of customers into the system is exponentially distributed with the rate <inline-formula id="inline-formula83-0037549712473512">
<mml:math display="inline" id="math93-0037549712473512">
<mml:mrow>
<mml:mn>0</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>9</mml:mn>
</mml:mrow>
</mml:math>
</inline-formula>. If the queue is not empty, the server selects the first customer to be serviced in a time that is exponentially distributed with the rate <inline-formula id="inline-formula84-0037549712473512">
<mml:math display="inline" id="math94-0037549712473512">
<mml:mrow>
<mml:mn>1</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:math>
</inline-formula> (the execution of the transition <italic>service</italic>). The server may fail and be unable to deliver service to the customers during some periods of time. However, there is a repair person who can repair the server (the transition <italic>repair</italic>) when it has failed. The fail and repair of the server are also exponentially distributed events with the rates <inline-formula id="inline-formula85-0037549712473512">
<mml:math display="inline" id="math95-0037549712473512">
<mml:mrow>
<mml:mn>0</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:math>
</inline-formula> and <inline-formula id="inline-formula86-0037549712473512">
<mml:math display="inline" id="math96-0037549712473512">
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:math>
</inline-formula>, respectively.</p>
<fig id="fig9-0037549712473512" position="float">
<label>Figure 9.</label>
<caption>
<p>An example of SRN model.</p>
</caption>
<graphic xlink:href="10.1177_0037549712473512-fig9.tif"/>
</fig>
<p>The interesting measures of the system are the availability of the server and the average queue length in steady-state. Thus, two reward variables <italic>QLen</italic> and <italic>avlServer</italic> are defined: the first evaluates the marking of the place <italic>Queue</italic> and the other measures the <italic>srvAvailable</italic>’s marking.</p>
<p>The SRN model can be translated into the SimGine model. Parts of the translated model are shown in <xref ref-type="fig" rid="fig10-0037549712473512">Figure 10</xref>. As shown in the figure, all places are translated into integer variables where their values represent the marking of places. The transitions are also translated into events considering their guards and the connection and multiplicity of (ordinary and inhibitor) arcs. The results of simulations with the confidence level <inline-formula id="inline-formula87-0037549712473512">
<mml:math display="inline" id="math97-0037549712473512">
<mml:mrow>
<mml:mn>0</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>98</mml:mn>
<mml:mi>%</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula> within the confidence interval <inline-formula id="inline-formula88-0037549712473512">
<mml:math display="inline" id="math98-0037549712473512">
<mml:mrow>
<mml:mn>0</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>01</mml:mn>
</mml:mrow>
</mml:math>
</inline-formula> show that the average queue length is <inline-formula id="inline-formula89-0037549712473512">
<mml:math display="inline" id="math99-0037549712473512">
<mml:mrow>
<mml:mn>25</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>54</mml:mn>
</mml:mrow>
</mml:math>
</inline-formula> and the server is available <inline-formula id="inline-formula90-0037549712473512">
<mml:math display="inline" id="math100-0037549712473512">
<mml:mrow>
<mml:mn>90</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>9</mml:mn>
<mml:mi>%</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula> of the time.</p>
<fig id="fig10-0037549712473512" position="float">
<label>Figure 10.</label>
<caption>
<p>A part of an SRN model of the server system expressed in SimGine.</p>
</caption>
<graphic xlink:href="10.1177_0037549712473512-fig10.tif"/>
</fig>
</sec>
<sec id="section13-0037549712473512">
<title>6.2. Rare-event simulation of a SAN model</title>
<p>SANs<sup><xref ref-type="bibr" rid="bibr17-0037549712473512">17</xref>, <xref ref-type="bibr" rid="bibr18-0037549712473512">18</xref></sup> are a stochastic generalization of Petri nets. For this case study, consider the SAN model of the machine–repairman system presented in Obal,<sup><xref ref-type="bibr" rid="bibr32-0037549712473512">32</xref></sup> as depicted in <xref ref-type="fig" rid="fig11-0037549712473512">Figure 11</xref>.</p>
<fig id="fig11-0037549712473512" position="float">
<label>Figure 11.</label>
<caption>
<p>The SAN model of the delayed repair system.</p>
</caption>
<graphic xlink:href="10.1177_0037549712473512-fig11.tif"/>
</fig>
<p>The system consists of two types of components with different failure rates. The number of each working component in the system is modeled by the marking of the place as <italic>type_1</italic> and <italic>type_2</italic>. Timed activities <italic>fail_1</italic> and <italic>fail_2</italic> model the failure of a working component. The time to failures is exponentially distributed and its rate depends on the number of currently working components (i.e. the firing time is marking dependent to present load balancing), as shown in <xref ref-type="table" rid="table2-0037549712473512">Table 2</xref>. One repairman exists in the system, which waits for the failure of at least two components of the same type, and then begins to repair the whole group. After finishing the repair process, all components of that type will be as good as new ones. This repair policy is implemented in the input gate <italic>policy</italic> whose configuration is depicted in <xref ref-type="table" rid="table3-0037549712473512">Table 3</xref>. The <italic>repair</italic> activity is enabled if two or more components of either type have failed, and <italic>type_1</italic> component repair is given preemptive priority over the repair of <italic>type_2</italic> components. Upon completion, the action taken depends on the marking of the place <italic>failed_1</italic>. If two components of <italic>type_1</italic> have failed before the repair completes, then the <italic>type_1</italic> components are repaired; otherwise, <italic>type_2</italic> components are repaired (as implemented in the function of the input gate <italic>policy</italic>). If all components of both types fail, the system fails, and the repair activity halts, causing the failed state to be an absorbing state.</p>
<table-wrap id="table2-0037549712473512" position="float">
<label>Table 2.</label>
<caption>
<p>Distribution of timed activities.</p>
</caption>
<graphic alternate-form-of="table2-0037549712473512" xlink:href="10.1177_0037549712473512-table2.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="left"/>
</colgroup>
<thead>
<tr>
<th align="left">Activity</th>
<th align="left">Rate (<italic>exponential</italic>)</th>
</tr>
</thead>
<tbody>
<tr>
<td><italic>fail</italic>_1</td>
<td>0.005 *<italic>type</italic>_<italic>1. Mark</italic></td>
</tr>
<tr>
<td><italic>fail</italic>_2</td>
<td>0.01 *<italic>type</italic>_<italic>2. Mark</italic></td>
</tr>
<tr>
<td><italic>Repair</italic>
</td>
<td>1.0</td>
</tr>
</tbody>
</table>
</table-wrap>
<table-wrap id="table3-0037549712473512" position="float">
<label>Table 3.</label>
<caption>
<p>Configuration of the input gate <italic>policy.</italic></p>
</caption>
<graphic alternate-form-of="table3-0037549712473512" xlink:href="10.1177_0037549712473512-table3.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="left"/>
</colgroup>
<thead>
<tr>
<th align="left">Predicate</th>
<th align="left">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td>return ((type_1.Mark &gt; 0 || type_2.Mark &gt; 0) &amp;&amp; (failed_1.Mark == 2 || failed_2.Mark == 1));</td>
<td align="left">If(failed_1.Mark==2){<break/> failed_1.Mark=0;<break/> type_1.Mark=2;}<break/>else{<break/> failed_2.Mark=0;<break/> type_2.Mark=4; }</td>
</tr>
</tbody>
</table>
</table-wrap>
<p>Since we are interested in the unreliability of the modeled system in the interval <italic>[0,100]</italic> and failed state is an absorbing state, we can define the instance of time reward variable <italic>unreliability</italic> with no impulse reward and a rate reward, which determines the failed state in time <italic>100</italic> (i.e. <italic>if (type_1.Mark==0 &amp;&amp; type_2.Mark==0) return 1;</italic>). For using the IS technique, the IS delay function should be specified for fail activities. Here, the <italic>ISDelay</italic> is defined based on the one in Obal<sup><xref ref-type="bibr" rid="bibr32-0037549712473512">32</xref></sup> and is given in <xref ref-type="table" rid="table4-0037549712473512">Table 4</xref>. The results of the IS simulation, as well as the standard simulation, compared with the analytical results are shown in <xref ref-type="table" rid="table5-0037549712473512">Table 5</xref>. Simulations run within the confidence interval 0.1 and 95% of the confidence level on a 2.0GHz Intel Core2Duo laptop with 1.5GB RAM and Microsoft Windows XP.</p>
<table-wrap id="table4-0037549712473512" position="float">
<label>Table 4.</label>
<caption>
<p><italic>ISDelay</italic> function for <italic>fail</italic> activity in the model of <xref ref-type="fig" rid="fig11-0037549712473512">Figure 11</xref>.</p>
</caption>
<graphic alternate-form-of="table4-0037549712473512" xlink:href="10.1177_0037549712473512-table4.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="left"/>
</colgroup>
<thead>
<tr>
<th align="left">Activity</th>
<th align="left">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><italic>fail_1</italic>
</td>
<td>if((failed_1.Mark &gt;= 2 &amp;&amp; failed_2.Mark &gt;= 2)||(failed_1.Mark &gt;= 1 &amp;&amp; failed_2.Mark &gt;= 3))<break/>  return Distribution.Exponential(0.005*type_1.Mark/((.005*type_1.Mark+0.01*type_2.Mark)));<break/>else if((failed_1.Mark &gt;= 2 &amp;&amp; failed_2.Mark &gt;= 1)|| (failed_1.Mark &gt;= 1 &amp;&amp; failed_2.Mark &gt;= 2))<break/> return Distribution. Exponential (0.09*0.005*type_1.Mark/ ((.005*type_1.Mark+0.01*type_2.Mark)*(1-0.09)));</td>
</tr>
<tr>
<td><italic>fail_2</italic>
</td>
<td>if((failed_1.Mark &gt;= 2 &amp;&amp; failed_2.Mark &gt;= 2)||(failed_1.Mark &gt;= 1 &amp;&amp; failed_2.Mark &gt;= 3))<break/>  return Distribution.Exponential(0.01*type_2.Mark/((.005*type_1.Mark+0.01*type_2.Mark)));<break/>else if((failed_1.Mark &gt;= 2 &amp;&amp; failed_2.Mark &gt;= 1)|| (failed_1.Mark &gt;= 1 &amp;&amp; failed_2.Mark &gt;= 2))<break/> return Distribution.Exponential(0.09*0.01*type_2.Mark/ ((.005*type_1.Mark+0.01*type_2.Mark)*(1-0.09) ));</td>
</tr>
</tbody>
</table>
</table-wrap>
<table-wrap id="table5-0037549712473512" position="float">
<label>Table 5.</label>
<caption>
<p>Simulation results for the model of <xref ref-type="fig" rid="fig11-0037549712473512">Figure 11</xref>.</p>
</caption>
<graphic alternate-form-of="table5-0037549712473512" xlink:href="10.1177_0037549712473512-table5.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="left"/>
<col align="left"/>
<col align="left"/>
</colgroup>
<thead>
<tr>
<th/>
<th align="left">Analytical</th>
<th align="left">Traditional</th>
<th align="left">IS</th>
</tr>
</thead>
<tbody>
<tr>
<td>Result</td>
<td><inline-formula id="inline-formula91-0037549712473512">
<mml:math display="inline" id="math101-0037549712473512">
<mml:mrow>
<mml:mn>1</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>91</mml:mn>
<mml:mo>*</mml:mo>
<mml:msup>
<mml:mrow>
<mml:mn>10</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mo>−</mml:mo>
<mml:mn>6</mml:mn>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math>
</inline-formula>
</td>
<td><inline-formula id="inline-formula92-0037549712473512">
<mml:math display="inline" id="math102-0037549712473512">
<mml:mrow>
<mml:mn>1</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>71</mml:mn>
<mml:mo>*</mml:mo>
<mml:msup>
<mml:mrow>
<mml:mn>10</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mo>−</mml:mo>
<mml:mn>6</mml:mn>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math>
</inline-formula>
</td>
<td><inline-formula id="inline-formula93-0037549712473512">
<mml:math display="inline" id="math103-0037549712473512">
<mml:mrow>
<mml:mn>1</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>94</mml:mn>
<mml:mo>*</mml:mo>
<mml:msup>
<mml:mrow>
<mml:mn>10</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mo>−</mml:mo>
<mml:mn>6</mml:mn>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math>
</inline-formula>
</td>
</tr>
<tr>
<td>Relative error</td>
<td>–</td>
<td><inline-formula id="inline-formula94-0037549712473512">
<mml:math display="inline" id="math104-0037549712473512">
<mml:mrow>
<mml:mn>10</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>4</mml:mn>
<mml:mi>%</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula>
</td>
<td><inline-formula id="inline-formula95-0037549712473512">
<mml:math display="inline" id="math105-0037549712473512">
<mml:mrow>
<mml:mn>1</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>5</mml:mn>
<mml:mi>%</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula>
</td>
</tr>
<tr>
<td>Time</td>
<td>–</td>
<td><inline-formula id="inline-formula96-0037549712473512">
<mml:math display="inline" id="math106-0037549712473512">
<mml:mrow>
<mml:mn>2956</mml:mn>
</mml:mrow>
</mml:math>
</inline-formula>
</td>
<td><inline-formula id="inline-formula97-0037549712473512">
<mml:math display="inline" id="math107-0037549712473512">
<mml:mrow>
<mml:mn>16</mml:mn>
</mml:mrow>
</mml:math>
</inline-formula>
</td>
</tr>
<tr>
<td>Samples number</td>
<td>–</td>
<td><inline-formula id="inline-formula98-0037549712473512">
<mml:math display="inline" id="math108-0037549712473512">
<mml:mrow>
<mml:mn>224</mml:mn>
<mml:mo>,</mml:mo>
<mml:mn>632</mml:mn>
<mml:mo>,</mml:mo>
<mml:mn>000</mml:mn>
</mml:mrow>
</mml:math>
</inline-formula>
</td>
<td><inline-formula id="inline-formula99-0037549712473512">
<mml:math display="inline" id="math109-0037549712473512">
<mml:mrow>
<mml:mn>110</mml:mn>
<mml:mo>,</mml:mo>
<mml:mn>000</mml:mn>
</mml:mrow>
</mml:math>
</inline-formula>
</td>
</tr>
</tbody>
</table>
</table-wrap>
</sec>
</sec>
<sec id="section14-0037549712473512">
<title>7. Comparison</title>
<p>In this section, we briefly compare SimGine with other multi-formalism simulation tools. Among the available tools, we have selected those which are more related to SimGine: Möbius, MOSEL, SMART, SHARPE, and OsMoSys. For comparison purposes, we consider the capability of extending the tool, supporting step-by-step simulation, the capability of analytic solution of models, and supporting models’ interactions. By ‘extensibility’ we mean that the tool can be extended to evaluate new kinds of models instead of having a predefined set of supported models. Step-by-step simulation is a feature which enables the tool to support graphical representation of a simulation during the simulation progress (e.g. token play in Petri nets). Here we just consider simulation tools, but some of these tools are also able to evaluate models analytically.</p>
<p><xref ref-type="table" rid="table6-0037549712473512">Table 6</xref> presents the comparison of the multi-formalism simulation tools mentioned above. The mentioned tools were introduced in Section 2. Below, we briefly compare some of their features with SimGine:</p>
<list id="list3-0037549712473512" list-type="bullet">
<list-item><p>Möbius is an extensible multi-formalism modeling tool which provides this extensibility through the use of an abstract functional interface (AFI) that uses abstract classes to provide a formalism-independent interface. The complexity of the framework and poor documentation make the implementation of a new formalism without a direct Möbius developers team’s assistance impossible. Instead, SimGine has an XML-based language which makes it easier to evaluate new formalisms. Möbius does not support step-by-step simulation and rare-event simulation, and cannot be used as a library. However, it can analytically solve (Markovian) models and is able to evaluate composed models within different formalisms.</p></list-item>
<list-item><p>MOSEL is a textual language and environment. For evaluation, the model is specified in the language, and then the environment calls an external tool after having translated the MOSEL description into the respective tool’s description format. Therefore, it does not have any engine for model evaluation. The language also does not support rare-event simulation in its language constructs.</p></list-item>
<list-item><p>SMART permits extension of the tool by integrating new solution algorithms. It uses a declarative language to specify stochastic Petri nets and queuing networks. Models can interact by exchanging their results (which is a weak kind of model interaction compared to supporting the composed/hierarchical models).</p></list-item>
<list-item><p>Although SHARPE is not a simulation tool, it was an important and early effort in multi-formalism modeling tools in which models can be expressed in various formalisms. It can analytically evaluate models for performance and dependability analysis. SHARPE is not an extensible tool.</p></list-item>
<list-item><p>The OsMoSys approach to multi-formalism modeling is meta-modeling, to define and integrate different formalisms. The approach is different from SimGine and the aforementioned tools, and basically is an architecture for dealing with multi-solution when analyzing multi-formalism models. The methodology is based on the orchestration of different solvers which enables the interoperability among solution methods and solvers.</p></list-item>
</list>
<table-wrap id="table6-0037549712473512" position="float">
<label>Table 6.</label>
<caption>
<p>Comparison of the selected multi-formalism simulation tools (for stars, see the text).</p>
</caption>
<graphic alternate-form-of="table6-0037549712473512" xlink:href="10.1177_0037549712473512-table6.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="left"/>
<col align="left"/>
<col align="left"/>
<col align="left"/>
<col align="left"/>
<col align="left"/>
</colgroup>
<thead>
<tr>
<th/>
<th align="left">Möbius</th>
<th align="left">MOSEL</th>
<th align="left">SMART</th>
<th align="left">SHARPE</th>
<th align="left">OsMoSys</th>
<th align="left">SimGine</th>
</tr>
</thead>
<tbody>
<tr>
<td>Extensible</td>
<td>✓</td>
<td>–</td>
<td>*</td>
<td>–</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>Step-by-Step Sim.</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>✓</td>
</tr>
<tr>
<td>Rare-Event Sim.</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>✓</td>
</tr>
<tr>
<td>Analytical Solutions</td>
<td>✓</td>
<td>*</td>
<td>✓</td>
<td>✓</td>
<td>*</td>
<td>–</td>
</tr>
<tr>
<td>Library</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>✓</td>
</tr>
<tr>
<td>Models’ Interaction</td>
<td>✓</td>
<td>–</td>
<td>✓</td>
<td>✓</td>
<td>*</td>
<td>–</td>
</tr>
</tbody>
</table>
</table-wrap>
<p>SimGine is just a simulation engine and cannot solve models analytically. There is another ongoing project in PDELab, named SolvGine, with the aim of solving SDES models (with the same input language as SimGine). It is also notable that, unlike some of the mentioned tools, SimGine is not a modeling tool but a simulation engine, and so, it does not provide a GUI to build (high-level) models. As stated earlier, one can use SimGine in one’s own modeling tool, or use PDETool (which aims to provide an interface for constructing some high-level models and translating them into the SimGine input language).</p>
<p>Regarding hierarchical modeling, currently SimGine does not support hierarchical models directly and the modeler has to use a flat model. But the modeler can still create a composed high-level model and translate the flattened model into a SimGine model.</p>
</sec>
<sec id="section15-0037549712473512" sec-type="conclusions">
<title>8. Conclusions</title>
<p>In this paper, we introduced SimGine, a simulation engine based on a unified description, named SDES, for the simulation of stochastic discrete-event systems. Using SimGine, one can simulate models of various formalisms by translating them into the input language of the engine. For each kind of model, a translator should be developed. One of the important features of SimGine is its capability for rare-event simulation using the IS technique. As far as we know, this is the first multi-formalism simulation tool capable of simulating rare events.</p>
<p>Currently, we are working on the engine to support model composition. This capability will enable the engine to have hierarchical models in which each part of the model can be constructed using different formalisms. Another feature under development is an ongoing project called SolvGine for the analytic solution of Markovian models. Another future work is enabling the engine to perform parallel simulation. This is important because of emerging new multi-core architectures that will speed up the simulation progress.</p>
</sec>
</body>
<back>
<app-group>
<app id="app1-0037549712473512">
<title>Appendix: SDES description</title>
<p>A discrete-event system is a system that is in a state during some time interval, after which an atomic event might happen that changes the state of the system immediately.<sup><xref ref-type="bibr" rid="bibr1-0037549712473512">1</xref></sup> Several stochastic discrete-event models have been proposed, all of which share some common characteristics, and many of the algorithms and methods that have been developed for one model are applicable for many of them. SDES<sup><xref ref-type="bibr" rid="bibr1-0037549712473512">1</xref></sup> is a unified description for stochastic discrete-event systems. Popular model classes like automata, queuing networks, and Petri nets of different kinds with stochastic extensions are subclasses of stochastic discrete-event systems and can be translated into the introduced SDES description. In this section, we review the definition of SDES. For more information, please see Zimmermann.<sup><xref ref-type="bibr" rid="bibr1-0037549712473512">1</xref></sup></p>
<p>A stochastic discrete-event system SDES is a tuple</p>
<p><disp-formula id="disp-formula11-0037549712473512">
<mml:math display="block" id="math110-0037549712473512">
<mml:mrow>
<mml:mi>SDES</mml:mi>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>S</mml:mi>
<mml:mi>V</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo>,</mml:mo>
<mml:mi>A</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo>,</mml:mo>
<mml:mi>S</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo>,</mml:mo>
<mml:mi>R</mml:mi>
<mml:mi>V</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula11-0037549712473512" xlink:href="10.1177_0037549712473512-eq11.tif"/>
</disp-formula></p>
<p>which describes the finite set of state-variables <inline-formula id="inline-formula100-0037549712473512">
<mml:math display="block" id="math111-0037549712473512">
<mml:mrow>
<mml:mi>S</mml:mi>
<mml:msup>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math>
</inline-formula> and actions <inline-formula id="inline-formula101-0037549712473512">
<mml:math display="block" id="math112-0037549712473512">
<mml:mrow>
<mml:mi>A</mml:mi>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> together with the sort function <inline-formula id="inline-formula102-0037549712473512">
<mml:math display="block" id="math113-0037549712473512">
<mml:mrow>
<mml:mi>S</mml:mi>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> and the reward variables <inline-formula id="inline-formula103-0037549712473512">
<mml:math display="block" id="math114-0037549712473512">
<mml:mrow>
<mml:mi>R</mml:mi>
<mml:mi>V</mml:mi>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> correspond to the quantitative evaluation of the model. <inline-formula id="inline-formula104-0037549712473512">
<mml:math display="block" id="math115-0037549712473512">
<mml:mrow>
<mml:mi>S</mml:mi>
<mml:mi>V</mml:mi>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> is the finite set of <inline-formula id="inline-formula105-0037549712473512">
<mml:math display="block" id="math116-0037549712473512">
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula> state-variables, <inline-formula id="inline-formula106-0037549712473512">
<mml:math display="block" id="math117-0037549712473512">
<mml:mrow>
<mml:mi>S</mml:mi>
<mml:mi>V</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo>=</mml:mo>
<mml:mi>s</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>v</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mo>…</mml:mo>
<mml:mo>,</mml:mo>
<mml:mi>s</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>v</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula>, which is used to capture the states of the model. <inline-formula id="inline-formula107-0037549712473512">
<mml:math display="block" id="math118-0037549712473512">
<mml:mrow>
<mml:mi>S</mml:mi>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> is a function that associates an individual sort to each state-variable of <inline-formula id="inline-formula108-0037549712473512">
<mml:math display="block" id="math119-0037549712473512">
<mml:mrow>
<mml:mi>S</mml:mi>
<mml:mi>V</mml:mi>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> and action variable of <inline-formula id="inline-formula109-0037549712473512">
<mml:math display="block" id="math120-0037549712473512">
<mml:mrow>
<mml:mi>Var</mml:mi>
<mml:mi>s</mml:mi>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> (which will be defined later) in a model; in other words,</p>
<p><disp-formula id="disp-formula12-0037549712473512">
<mml:math display="block" id="math121-0037549712473512">
<mml:mrow>
<mml:mi>S</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo>:</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>S</mml:mi>
<mml:mi>V</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo>⋃</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>Var</mml:mi>
<mml:mi>s</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>→</mml:mo>
<mml:mi>δ</mml:mi>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula12-0037549712473512" xlink:href="10.1177_0037549712473512-eq12.tif"/>
</disp-formula></p>
<p>where <inline-formula id="inline-formula110-0037549712473512">
<mml:math display="block" id="math122-0037549712473512">
<mml:mrow>
<mml:mi>δ</mml:mi>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> denotes the set of all possible sorts. Each state-variable <inline-formula id="inline-formula111-0037549712473512">
<mml:math display="block" id="math123-0037549712473512">
<mml:mrow>
<mml:mi>sv</mml:mi>
<mml:mo>∈</mml:mo>
<mml:mi>S</mml:mi>
<mml:mi>V</mml:mi>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> has the attribute <inline-formula id="inline-formula112-0037549712473512">
<mml:math display="block" id="math124-0037549712473512">
<mml:mrow>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>Con</mml:mi>
<mml:mi>d</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>Val</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>*</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula>. Sometimes there are cases in which not all values that belong to a particular sort of a state-variable are actually allowed. The state condition <inline-formula id="inline-formula113-0037549712473512">
<mml:math display="block" id="math125-0037549712473512">
<mml:mrow>
<mml:mi>Con</mml:mi>
<mml:mi>d</mml:mi>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> is a boolean function which returns for a state-variable in a specific model state whether or not it is allowed such that</p>
<p><disp-formula id="disp-formula13-0037549712473512">
<mml:math display="block" id="math126-0037549712473512">
<mml:mrow>
<mml:mi>Con</mml:mi>
<mml:mi>d</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo>:</mml:mo>
<mml:mi>S</mml:mi>
<mml:mi>V</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo>×</mml:mo>
<mml:mi>Σ</mml:mi>
<mml:mo>→</mml:mo>
<mml:mi>B</mml:mi>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula13-0037549712473512" xlink:href="10.1177_0037549712473512-eq13.tif"/>
</disp-formula></p>
<p>where <inline-formula id="inline-formula114-0037549712473512">
<mml:math display="block" id="math127-0037549712473512">
<mml:mrow>
<mml:mi>Σ</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula> is the set of all theoretically possible states of a certain SDES and is defined as</p>
<p><disp-formula id="disp-formula14-0037549712473512">
<mml:math display="block" id="math128-0037549712473512">
<mml:mrow>
<mml:mo>∑</mml:mo>
<mml:mo>=</mml:mo>
<mml:munder>
<mml:mo>Π</mml:mo>
<mml:mrow>
<mml:mi>sv</mml:mi>
<mml:mo>∈</mml:mo>
<mml:mi>S</mml:mi>
<mml:mi>V</mml:mi>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:munder>
<mml:mi>S</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>sv</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula14-0037549712473512" xlink:href="10.1177_0037549712473512-eq14.tif"/>
</disp-formula></p>
<p><inline-formula id="inline-formula115-0037549712473512">
<mml:math display="block" id="math129-0037549712473512">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>Val</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> is a function that specifies the initial value of each state-variable, which is necessary as a starting point for an evaluation of the model behavior that satisfies the following requirement:</p>
<p><disp-formula id="disp-formula15-0037549712473512">
<mml:math display="block" id="math130-0037549712473512">
<mml:mrow>
<mml:mo>∀</mml:mo>
<mml:mi>sv</mml:mi>
<mml:mo>∈</mml:mo>
<mml:mi>S</mml:mi>
<mml:mi>V</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo>:</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>Val</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>*</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>sv</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∈</mml:mo>
<mml:mi>S</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>sv</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula15-0037549712473512" xlink:href="10.1177_0037549712473512-eq15.tif"/>
</disp-formula></p>
<p><inline-formula id="inline-formula116-0037549712473512">
<mml:math display="block" id="math131-0037549712473512">
<mml:mrow>
<mml:mi>A</mml:mi>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula>, which denotes the set of actions of an SDES model, describes possible state changes of the modeled system. An action <inline-formula id="inline-formula117-0037549712473512">
<mml:math display="block" id="math132-0037549712473512">
<mml:mrow>
<mml:mi>a</mml:mi>
<mml:mo>∈</mml:mo>
<mml:mi>A</mml:mi>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> may be composed of several internal actions with different attributes in some SDES model classes, or may contain individual variants or modes in other examples. To capture this, the action variables <inline-formula id="inline-formula118-0037549712473512">
<mml:math display="block" id="math133-0037549712473512">
<mml:mrow>
<mml:mi>Var</mml:mi>
<mml:mi>s</mml:mi>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> define a model-dependent set of variables <inline-formula id="inline-formula119-0037549712473512">
<mml:math display="block" id="math134-0037549712473512">
<mml:mrow>
<mml:mi>Var</mml:mi>
<mml:mi>s</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>a</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> of an action <inline-formula id="inline-formula120-0037549712473512">
<mml:math display="block" id="math135-0037549712473512">
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula> with individual sorts. One setting of values for these variables corresponds to an action mode <italic>mode</italic>. This is, for example, equivalent to a binding in a colored Petri net. Many attributes depend on an action <inline-formula id="inline-formula121-0037549712473512">
<mml:math display="block" id="math136-0037549712473512">
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula> together with one of its corresponding modes, <inline-formula id="inline-formula122-0037549712473512">
<mml:math display="block" id="math137-0037549712473512">
<mml:mrow>
<mml:mi>mode</mml:mi>
<mml:mo>∈</mml:mo>
<mml:mi>Mode</mml:mi>
<mml:mi>s</mml:mi>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula>. Any possible pair of an action and an action mode is called an action variant, written as <inline-formula id="inline-formula123-0037549712473512">
<mml:math display="block" id="math138-0037549712473512">
<mml:mrow>
<mml:mi>v</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula>. The set of all possible action variants <inline-formula id="inline-formula124-0037549712473512">
<mml:math display="block" id="math139-0037549712473512">
<mml:mrow>
<mml:mi>AV</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula> is defined as</p>
<p><disp-formula id="disp-formula16-0037549712473512">
<mml:math display="block" id="math140-0037549712473512">
<mml:mrow>
<mml:mi>AV</mml:mi>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">{</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>a</mml:mi>
<mml:mo>,</mml:mo>
<mml:mi>mode</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">|</mml:mo>
<mml:mi>a</mml:mi>
<mml:mo>∈</mml:mo>
<mml:mi>A</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo>,</mml:mo>
<mml:mi>mode</mml:mi>
<mml:mo>∈</mml:mo>
<mml:mi>Mode</mml:mi>
<mml:mi>s</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>a</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">}</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula16-0037549712473512" xlink:href="10.1177_0037549712473512-eq16.tif"/>
</disp-formula></p>
<p>Each action <inline-formula id="inline-formula125-0037549712473512">
<mml:math display="block" id="math141-0037549712473512">
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula>, <inline-formula id="inline-formula126-0037549712473512">
<mml:math display="block" id="math142-0037549712473512">
<mml:mrow>
<mml:mi>a</mml:mi>
<mml:mo>∈</mml:mo>
<mml:mi>A</mml:mi>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula>, is</p>
<p><disp-formula id="disp-formula17-0037549712473512">
<mml:math display="block" id="math143-0037549712473512">
<mml:mrow>
<mml:mi>a</mml:mi>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>Pr</mml:mi>
<mml:mi>i</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo>,</mml:mo>
<mml:mi>De</mml:mi>
<mml:mi>g</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo>,</mml:mo>
<mml:mi>Va</mml:mi>
<mml:mi>r</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo>,</mml:mo>
<mml:mi>En</mml:mi>
<mml:mi>a</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo>,</mml:mo>
<mml:mi>Dela</mml:mi>
<mml:mi>y</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo>,</mml:mo>
<mml:mi>Weigh</mml:mi>
<mml:mi>t</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo>,</mml:mo>
<mml:mi>Exe</mml:mi>
<mml:mi>c</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula17-0037549712473512" xlink:href="10.1177_0037549712473512-eq17.tif"/>
</disp-formula></p>
<p>where:</p>
<list id="list4-0037549712473512" list-type="bullet">
<list-item>
<p><inline-formula id="inline-formula127-0037549712473512">
<mml:math display="block" id="math144-0037549712473512">
<mml:mrow>
<mml:mi>Pr</mml:mi>
<mml:mi>i</mml:mi>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> associates a global priority to every action. The priority is used to decide which action is executed first if there are several activities that are scheduled to finish at the same point in time.</p>
<p><disp-formula id="disp-formula18-0037549712473512">
<mml:math display="block" id="math145-0037549712473512">
<mml:mrow>
<mml:mi>Pr</mml:mi>
<mml:mi>i</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo>:</mml:mo>
<mml:mi>A</mml:mi>
<mml:mo>→</mml:mo>
<mml:mi>N</mml:mi>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula18-0037549712473512" xlink:href="10.1177_0037549712473512-eq18.tif"/>
</disp-formula></p>
</list-item>
<list-item>
<p>The enabling degree <inline-formula id="inline-formula128-0037549712473512">
<mml:math display="block" id="math146-0037549712473512">
<mml:mrow>
<mml:mi>De</mml:mi>
<mml:mi>g</mml:mi>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> of an action specifies the number of activities of it that are permitted to run concurrently in any state. This is for instance used to capture the difference between infinite-server and single-server semantics.</p>
<p><disp-formula id="disp-formula19-0037549712473512">
<mml:math display="block" id="math147-0037549712473512">
<mml:mrow>
<mml:mi>De</mml:mi>
<mml:mi>g</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo>:</mml:mo>
<mml:mi>A</mml:mi>
<mml:mo>→</mml:mo>
<mml:mo stretchy="false">{</mml:mo>
<mml:mi>N</mml:mi>
<mml:mo>⋃</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>∞</mml:mi>
<mml:mo stretchy="false">}</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula19-0037549712473512" xlink:href="10.1177_0037549712473512-eq19.tif"/>
</disp-formula></p>
</list-item>
<list-item>
<p>Action variants may only start and proceed over their delay under certain conditions until execution. If these conditions hold in a state, we say the action variant is enabled in it. The value of the boolean enabling function <inline-formula id="inline-formula129-0037549712473512">
<mml:math display="block" id="math148-0037549712473512">
<mml:mrow>
<mml:mi>En</mml:mi>
<mml:mi>a</mml:mi>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> of an action variant returns for a model state whether or not it is enabled.</p>
<p><disp-formula id="disp-formula20-0037549712473512">
<mml:math display="block" id="math149-0037549712473512">
<mml:mrow>
<mml:mi>En</mml:mi>
<mml:mi>a</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo>:</mml:mo>
<mml:mi>AV</mml:mi>
<mml:mo>×</mml:mo>
<mml:mi>Σ</mml:mi>
<mml:mo>→</mml:mo>
<mml:mi>B</mml:mi>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula20-0037549712473512" xlink:href="10.1177_0037549712473512-eq20.tif"/>
</disp-formula></p>
</list-item>
<list-item>
<p><inline-formula id="inline-formula130-0037549712473512">
<mml:math display="block" id="math150-0037549712473512">
<mml:mrow>
<mml:mi>Dela</mml:mi>
<mml:mi>y</mml:mi>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> describes the time that must elapse while an action variant is enabled in an activity until it finishes. This time is in most cases not a fixed number, but a random variable with positive real values.</p>
<p><disp-formula id="disp-formula21-0037549712473512">
<mml:math display="block" id="math151-0037549712473512">
<mml:mrow>
<mml:mi>Dela</mml:mi>
<mml:mi>y</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo>:</mml:mo>
<mml:mi>AV</mml:mi>
<mml:mo>→</mml:mo>
<mml:msup>
<mml:mrow>
<mml:mi>F</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>+</mml:mo>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula21-0037549712473512" xlink:href="10.1177_0037549712473512-eq21.tif"/>
</disp-formula></p>
</list-item>
<list-item>
<p>The weight <inline-formula id="inline-formula131-0037549712473512">
<mml:math display="block" id="math152-0037549712473512">
<mml:mrow>
<mml:mi>Weigh</mml:mi>
<mml:mi>t</mml:mi>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> of an action variant is a positive real number that defines the probability of selecting it for execution in relation to other weights. This applies only to cases in which activities with equal priorities are scheduled for execution at the same instant of time (e.g. firing weights of immediate transitions in Petri nets).</p>
<p><disp-formula id="disp-formula22-0037549712473512">
<mml:math display="block" id="math153-0037549712473512">
<mml:mrow>
<mml:mi>Weigh</mml:mi>
<mml:mi>t</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo>:</mml:mo>
<mml:mi>AV</mml:mi>
<mml:mo>→</mml:mo>
<mml:msup>
<mml:mrow>
<mml:mi>R</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>+</mml:mo>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula22-0037549712473512" xlink:href="10.1177_0037549712473512-eq22.tif"/>
</disp-formula></p>
</list-item>
<list-item>
<p><inline-formula id="inline-formula132-0037549712473512">
<mml:math display="block" id="math154-0037549712473512">
<mml:mrow>
<mml:mi>Exe</mml:mi>
<mml:mi>c</mml:mi>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> defines the state change that happens as a result of an action variant execution (i.e. the finishing and execution of the activity) and is called the execution function. As actions change the state, <inline-formula id="inline-formula133-0037549712473512">
<mml:math display="block" id="math155-0037549712473512">
<mml:mrow>
<mml:mi>Exe</mml:mi>
<mml:mi>c</mml:mi>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:math>
</inline-formula> is a function that associates a destination state to a source state for each action variant. This function does not need to be defined or have a useful value for pairs containing a variant that is not enabled in the respective state.</p>
<p><disp-formula id="disp-formula23-0037549712473512">
<mml:math display="block" id="math156-0037549712473512">
<mml:mrow>
<mml:mi>Exe</mml:mi>
<mml:mi>c</mml:mi>
<mml:mo>*</mml:mo>
<mml:mo>:</mml:mo>
<mml:mi>AV</mml:mi>
<mml:mo>×</mml:mo>
<mml:mi>Σ</mml:mi>
<mml:mo>→</mml:mo>
<mml:mi>Σ</mml:mi>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula23-0037549712473512" xlink:href="10.1177_0037549712473512-eq23.tif"/>
</disp-formula></p>
</list-item>
</list>
</app>
</app-group>
<bio>
<title>Author biographies</title>
<p><bold>Ali Khalili</bold> received his BSc degree in software engineering from Ferdowsi University of Mashhad, Iran, 2005. In 2009, he received an MSc degree in computer engineering (software) from Iran University of Science and Technology (IUST). Currently, he is a PhD student at the Italian Institute of Technology (IIT), Genova, Italy. His research topics are modelling and simulation, formal verification, and model-based testing.</p>
<p><bold>Mohammad Abdollahi Azgomi</bold> received his BS, MS, and PhD in computer engineering (software) in 1991, 1996, and 2005, respectively, from Sharif University of Technology, Tehran, Iran. His research interests include dependable systems and software, performance and dependability modelling, and network security. He has published several papers in international journals and conferences. Dr. Abdollahi Azgomi is currently a faculty member at the School of Computer Engineering, Iran University of Science and Technology, Tehran, Iran.</p>
<p><bold>Amir Jalaly Bidgoly</bold> received his BSc degree in computer engineering (software) from the Department of Computer Engineering, Kashan University, in 2005. He received an MSc degree in computer engineering (software) from Iran University of Science and Technology (IUST) in 2009. He is currently a PhD student at the Department of Computer Engineering, Isfahan University, Isfahan, Iran. His research interests include modelling and simulation, rare-event simulation, and fault-tolerant computing. He has published several papers at national and international conferences.</p>
</bio>
<ref-list>
<title>References</title>
<ref id="bibr1-0037549712473512">
<label>1.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Zimmermann</surname><given-names>A</given-names></name>
</person-group>. <source>Stochastic discrete event systems: Modeling, evaluation, applications</source>. <publisher-loc>Berlin</publisher-loc>: <publisher-name>Springer-Verlag</publisher-name>, <year>2007</year>.</citation>
</ref>
<ref id="bibr2-0037549712473512">
<label>2.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Zimmermann</surname><given-names>A</given-names></name>
<name><surname>Knoke</surname><given-names>M</given-names></name>
<name><surname>Huck</surname><given-names>A</given-names></name><etal/>
</person-group>. <article-title>Towards version 4.0 of TimeNET</article-title>. In: <conf-name>Proceedings of the 13th GI/ITG conference on measuring, modelling and evaluation of computer and communication systems (MMB’06)</conf-name>, <conf-date>2006</conf-date>, pp. <fpage>1</fpage>–<lpage>4</lpage>.</citation>
</ref>
<ref id="bibr3-0037549712473512">
<label>3.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Sanders</surname><given-names>WH</given-names></name>
<name><surname>Obal</surname><given-names>WD</given-names></name>
<name><surname>Qureshi</surname><given-names>MA</given-names></name><etal/>
</person-group>. <article-title>The UltraSAN modeling environment</article-title>. <source>Perform Eval</source> <year>1995</year>; <volume>24</volume>(<issue>1–2</issue>): <fpage>89</fpage>–<lpage>115</lpage>.</citation>
</ref>
<ref id="bibr4-0037549712473512">
<label>4.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Vittorini</surname><given-names>V</given-names></name>
<name><surname>Iacono</surname><given-names>M</given-names></name>
<name><surname>Mazzocca</surname><given-names>N</given-names></name><etal/>
</person-group>. <article-title>The OsMoSys approach to multi-formalism modeling of systems</article-title>. <source>Softw Syst Model</source> <year>2004</year>; <volume>3</volume>(<issue>1</issue>): <fpage>68</fpage>–<lpage>81</lpage>.</citation>
</ref>
<ref id="bibr5-0037549712473512">
<label>5.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Hirel</surname><given-names>C</given-names></name>
<name><surname>Sahner</surname><given-names>R</given-names></name>
<name><surname>Zang</surname><given-names>X</given-names></name><etal/>
</person-group>. <article-title>Reliability and performability modeling using SHARPE 2000</article-title>. In: <conf-name>Proceedings of the 11th international conference on computer performance evaluation: Modelling techniques and tools</conf-name>, <conf-date>2000</conf-date>, pp. <fpage>345</fpage>–<lpage>349</lpage>.</citation>
</ref>
<ref id="bibr6-0037549712473512">
<label>6.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Ciardo</surname><given-names>G</given-names></name>
<name><surname>Miner</surname><given-names>AS</given-names></name>
</person-group>. <article-title>SMART: Simulation and Markovian analyzer for reliability and timing</article-title>. In: <conf-name>Proceedings of the 1996 IEEE international computer performance and dependability symposium</conf-name>, <conf-date>1996</conf-date>, p. <fpage>60</fpage>.</citation>
</ref>
<ref id="bibr7-0037549712473512">
<label>7.</label>
<citation citation-type="thesis">
<person-group person-group-type="author">
<name><surname>Deavours</surname><given-names>DD</given-names></name><etal/>
</person-group>. <source>Formal specification of the Möbius modeling framework</source>. PhD Thesis, <publisher-name>University of Illinois at Urbana-Champaign, IL</publisher-name>, <year>2001</year>.</citation>
</ref>
<ref id="bibr8-0037549712473512">
<label>8.</label>
<citation citation-type="thesis">
<person-group person-group-type="author">
<name><surname>Williamson</surname><given-names>AL</given-names></name>
</person-group>. <source>Discrete event simulation in the Möbius modeling framework</source>. Master’s Thesis, <publisher-name>University of Arizona, AZ</publisher-name>, <year>1998</year>.</citation>
</ref>
<ref id="bibr9-0037549712473512">
<label>9.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Bolch</surname><given-names>G</given-names></name>
<name><surname>Herold</surname><given-names>H</given-names></name>
</person-group>. <article-title>MOSEL – MOdeling Specification and Evaluation Language</article-title>. In: <conf-name>Proceedings of the2001 Aachen international multiconference on measurement, modelling and evaluation of computer and communication systems</conf-name>, <conf-loc>Aachen, Germany</conf-loc>, <conf-date>1995</conf-date>.</citation>
</ref>
<ref id="bibr10-0037549712473512">
<label>10.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Wiichner</surname><given-names>P</given-names></name>
<name><surname>De Meer</surname><given-names>H</given-names></name>
<name><surname>Barner</surname><given-names>J</given-names></name><etal/>
</person-group>. <article-title>MOSEL-2 – A compact but versatile model description language and its evaluation environment</article-title>. In: <conf-name>Proceedings of the MMBnet workshop</conf-name>, <conf-date>2005</conf-date>, pp. <fpage>51</fpage>–<lpage>59</lpage>.</citation>
</ref>
<ref id="bibr11-0037549712473512">
<label>11.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Zeigler</surname><given-names>BP</given-names></name>
<name><surname>Praehofer</surname><given-names>H</given-names></name>
<name><surname>Kim</surname><given-names>TG</given-names></name>
</person-group>. <source>Theory of modeling and simulation: Integrating discrete event and continuous complex dynamic systems</source>. <publisher-loc>San Diego, CA</publisher-loc>: <publisher-name>Academic Press</publisher-name>, <year>2000</year>.</citation>
</ref>
<ref id="bibr12-0037549712473512">
<label>12.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Sarjoughian</surname><given-names>HS</given-names></name>
<name><surname>Elamvazhuthi</surname><given-names>V</given-names></name>
</person-group>. <article-title>CoSMoS: A visual environment for component-based modeling, experimental design, and simulation</article-title>. In: <conf-name>Proceedings of the 2nd international conference on simulation tools and techniques</conf-name>, <conf-date>2009</conf-date>, p. <fpage>59</fpage>.</citation>
</ref>
<ref id="bibr13-0037549712473512">
<label>13.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Kim</surname><given-names>S</given-names></name>
<name><surname>Sarjoughian</surname><given-names>HS</given-names></name>
<name><surname>Elamvazhuthi</surname><given-names>V</given-names></name>
</person-group>. <article-title>DEVS-Suite: A component-based simulation tool for rapid experimentation and evaluation</article-title>. In: <conf-name>Spring simulation multi-conference</conf-name>, <conf-loc>San Diego, CA</conf-loc>, <conf-date>2009</conf-date>.</citation>
</ref>
<ref id="bibr14-0037549712473512">
<label>14.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Castro</surname><given-names>R</given-names></name>
<name><surname>Kofman</surname><given-names>E</given-names></name>
<name><surname>Wainer</surname><given-names>G</given-names></name>
</person-group>. <article-title>A formal framework for stochastic discrete event system specification modeling and simulation</article-title>. <source>Simul</source> <year>2010</year>; <volume>86</volume>(<issue>10</issue>): <fpage>587</fpage>–<lpage>611</lpage>.</citation>
</ref>
<ref id="bibr15-0037549712473512">
<label>15.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Molloy</surname><given-names>MK</given-names></name>
</person-group>. <article-title>Performance analysis using stochastic Petri nets</article-title>. <source>IEEE T Comput</source> <year>1982</year>; <volume>C-31</volume>(<issue>9</issue>): <fpage>913</fpage>–<lpage>917</lpage>.</citation>
</ref>
<ref id="bibr16-0037549712473512">
<label>16.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Marsan</surname><given-names>MA</given-names></name>
<name><surname>Balbo</surname><given-names>G</given-names></name>
<name><surname>Conte</surname><given-names>G</given-names></name>
</person-group>. <source>Performance models of multiprocessor systems</source>. <publisher-loc>Cambridge, MA</publisher-loc>: <publisher-name>The MIT Press</publisher-name>, <year>1986</year>.</citation>
</ref>
<ref id="bibr17-0037549712473512">
<label>17.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Movaghar</surname><given-names>A</given-names></name>
<name><surname>Meyer</surname><given-names>JF</given-names></name>
</person-group>. <article-title>Performability modeling with stochastic activity networks</article-title>. In: <conf-name>Proceedings of the real-time systems symposium</conf-name>, <conf-loc>Austin, TX</conf-loc>, <conf-date>1985</conf-date>, pp. <fpage>215</fpage>–<lpage>224</lpage>.</citation>
</ref>
<ref id="bibr18-0037549712473512">
<label>18.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Meyer</surname><given-names>JF</given-names></name>
<name><surname>Movaghar</surname><given-names>A</given-names></name>
<name><surname>Sanders</surname><given-names>WH</given-names></name>
</person-group>. <article-title>Stochastic activity networks: Structure, behavior, and application</article-title>. In: <source>Proceedings of the international workshop on timed petri nets</source>, <year>1985</year>, pp. <fpage>106</fpage>–<lpage>115</lpage>.</citation>
</ref>
<ref id="bibr19-0037549712473512">
<label>19.</label>
<citation citation-type="web">
<collab>PDELab</collab>. <article-title>SimGine homepage</article-title>, <ext-link ext-link-type="uri" xlink:href="http://pdel.iust.ac.ir/projects/SimGine.html">http://pdel.iust.ac.ir/projects/SimGine.html</ext-link>.</citation>
</ref>
<ref id="bibr20-0037549712473512">
<label>20.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Sanders</surname><given-names>WH</given-names></name>
<name><surname>Meyer</surname><given-names>JF</given-names></name>
</person-group>. <article-title>A unified approach for specifying measures of performance, dependability, and performability</article-title>. <source>Depend Comput Fault-Tolerant Syst</source> <year>1991</year>; <volume>4</volume>: <fpage>215</fpage>–<lpage>237</lpage>.</citation>
</ref>
<ref id="bibr21-0037549712473512">
<label>21.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Khalili</surname><given-names>A</given-names></name>
<name><surname>Jalaly Bidgoly</surname><given-names>A</given-names></name>
<name><surname>Abdollahi Azgomi</surname><given-names>M</given-names></name>
</person-group>. <article-title>PDETool: A multi-formalism modeling tool for discrete-event systems based on SDES description</article-title>. In: <conf-name>Proceedings of the 30th international conference on application and theory of petri nets and other models of concurrency (ICATPN’09)</conf-name>, <conf-loc>Paris, France</conf-loc>, <conf-date>22–26 June 2009</conf-date>, pp. <fpage>343</fpage>–<lpage>352</lpage>.</citation>
</ref>
<ref id="bibr22-0037549712473512">
<label>22.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Khalili</surname><given-names>A</given-names></name>
<name><surname>Abdollahi Azgomi</surname><given-names>M</given-names></name>
</person-group>. <article-title>RayLang: A modeling language for performance evaluation of stochastic discrete-event systems</article-title>. In: <conf-name>Proceedings of the 2009 international middle eastern simulation multiconference (MESM’09)</conf-name>, <conf-loc>2009</conf-loc>, pp. <fpage>119</fpage>–<lpage>130</lpage>.</citation>
</ref>
<ref id="bibr23-0037549712473512">
<label>23.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Juneja</surname><given-names>S</given-names></name>
<name><surname>Shahabuddin</surname><given-names>P</given-names></name>
</person-group>. <article-title>Rare event simulation techniques: An introduction and recent advances</article-title>. In: <person-group person-group-type="editor">
<name><surname>Henderson</surname><given-names>SG</given-names></name>
<name><surname>Nelson</surname><given-names>BL</given-names></name>
</person-group> (eds) <source>Simulation</source> (<source>Handbooks in Operations Research and Management Science</source>, <volume>13</volume>). <publisher-loc>Amsterdam</publisher-loc>: <publisher-name>Elsevier</publisher-name>, <year>2006</year>, pp. <fpage>291</fpage>–<lpage>350</lpage>.</citation>
</ref>
<ref id="bibr24-0037549712473512">
<label>24.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Shahabuddin</surname><given-names>P</given-names></name>
</person-group>. <article-title>Importance sampling for the simulation of highly reliable Markovian systems</article-title>. <source>Manage Sci</source> <year>1994</year>; <volume>40</volume>(<issue>3</issue>): <fpage>333</fpage>–<lpage>352</lpage>.</citation>
</ref>
<ref id="bibr25-0037549712473512">
<label>25.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Glynn</surname><given-names>PW</given-names></name>
<name><surname>Iglehart</surname><given-names>DL</given-names></name>
</person-group>. <article-title>Importance sampling for stochastic simulations</article-title>. <source>Manage Sci</source> <year>1989</year>; <volume>35</volume>(<issue>11</issue>): <fpage>1367</fpage>–<lpage>1392</lpage>.</citation>
</ref>
<ref id="bibr26-0037549712473512">
<label>26.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Heidelberger</surname><given-names>P</given-names></name>
<name><surname>Shahabuddin</surname><given-names>P</given-names></name><etal/>
</person-group>. <article-title>Splitting for rare event simulation: Analysis of simple cases</article-title>. In: <conf-name>Proceedings of the 28th conference on winter simulation</conf-name>, <conf-date>1996</conf-date>, pp. <fpage>302</fpage>–<lpage>308</lpage>.</citation>
</ref>
<ref id="bibr27-0037549712473512">
<label>27.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>L’Ecuyer</surname><given-names>P</given-names></name>
<name><surname>Demers</surname><given-names>V</given-names></name>
<name><surname>Tuffin</surname><given-names>B</given-names></name>
</person-group>. <article-title>Splitting for rare-event simulation</article-title>. In: <conf-name>Proceedings of the 2006 winter simulation conference (WSC’06)</conf-name>, <conf-date>2006</conf-date>, pp. <fpage>137</fpage>–<lpage>148</lpage>.</citation>
</ref>
<ref id="bibr28-0037549712473512">
<label>28.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Kahn</surname><given-names>H</given-names></name>
<name><surname>Harris</surname><given-names>TE</given-names></name>
</person-group>. <article-title>Estimation of particle transmission by random sampling</article-title>. <source>Natl Bureau Stand Appl Math Ser</source> <year>1951</year>; <volume>12</volume>: <fpage>27</fpage>–<lpage>30</lpage>.</citation>
</ref>
<ref id="bibr29-0037549712473512">
<label>29.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Villén-Altamirano</surname><given-names>M</given-names></name>
<name><surname>Villén-Altamirano</surname><given-names>J</given-names></name>
<name><surname>de Madrid</surname><given-names>UP</given-names></name>
</person-group>. <article-title>RESTART: A method for accelerating rare-event simulations</article-title>. In: <conf-name>Proceedings of the 13th international teletraffic congress</conf-name>, <conf-loc>Copenhagen, Denmark</conf-loc>, <conf-date>19–26 June 1991</conf-date>, pp. <fpage>71</fpage>–<lpage>76</lpage>.</citation>
</ref>
<ref id="bibr30-0037549712473512">
<label>30.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Villén-Altamirano</surname><given-names>M</given-names></name>
<name><surname>Villén-Altamirano</surname><given-names>J</given-names></name>
</person-group>. <article-title>RESTART: A straightforward method for fast simulation of rare events</article-title>. In: <conf-name>Proceedings of the 1994 winter simulation conference</conf-name>, <conf-date>1994</conf-date>, pp. <fpage>282</fpage>–<lpage>289</lpage>.</citation>
</ref>
<ref id="bibr31-0037549712473512">
<label>31.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Villén-Altamirano</surname><given-names>M</given-names></name>
<name><surname>Villén-Altamirano</surname><given-names>J</given-names></name>
</person-group>. <article-title>On the efficiency of RESTART for multidimensional state systems</article-title>. <source>ACM Trans Model Comput Simul (TOMACS)</source> <year>2006</year>; <volume>16</volume>(<issue>3</issue>): <fpage>251</fpage>–<lpage>279</lpage>.</citation>
</ref>
<ref id="bibr32-0037549712473512">
<label>32.</label>
<citation citation-type="thesis">
<person-group person-group-type="author">
<name><surname>Obal</surname><given-names>WD</given-names><suffix>II</suffix></name>
</person-group>. <source>Importance sampling simulation of SPN-based reward models</source>. Master’s Thesis, <publisher-name>University of Arizona, AZ</publisher-name>, <year>1993</year>.</citation>
</ref>
<ref id="bibr33-0037549712473512">
<label>33.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Nicola</surname><given-names>VF</given-names></name>
<name><surname>Nakayama</surname><given-names>MK</given-names></name>
<name><surname>Heidelberger</surname><given-names>P</given-names></name><etal/>
</person-group>. <article-title>Fast simulation of highly dependable systems with general failure and repair processes</article-title>. <source>IEEE T Comput</source> <year>1993</year>; <volume>42</volume>(<issue>12</issue>): <fpage>1440</fpage>–<lpage>1452</lpage>.</citation>
</ref>
</ref-list>
</back>
</article>