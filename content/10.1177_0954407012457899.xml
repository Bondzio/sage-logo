<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD Journal Publishing DTD v2.3 20070202//EN" "journalpublishing.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" xml:lang="en">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">PID</journal-id>
<journal-id journal-id-type="hwp">sppid</journal-id>
<journal-title>Proceedings of the Institution of Mechanical Engineers, Part D: Journal of Automobile Engineering</journal-title>
<issn pub-type="ppub">0954-4070</issn>
<issn pub-type="epub">2041-2991</issn>
<publisher>
<publisher-name>SAGE Publications</publisher-name>
<publisher-loc>Sage UK: London, England</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1177/0954407012457899</article-id>
<article-id pub-id-type="publisher-id">10.1177_0954407012457899</article-id>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Original Articles</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>Engine fault diagnosis based on a morphological neural network using a morphological filter as a preprocessor</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" corresp="yes">
<name><surname>Li</surname><given-names>Bing</given-names></name>
<xref ref-type="aff" rid="aff1-0954407012457899">1</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Hu</surname><given-names>Ren-Xi</given-names></name>
<xref ref-type="aff" rid="aff2-0954407012457899">2</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Ren</surname><given-names>Guo-Quan</given-names></name>
<xref ref-type="aff" rid="aff3-0954407012457899">3</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Fu</surname><given-names>Jian-Ping</given-names></name>
<xref ref-type="aff" rid="aff3-0954407012457899">3</xref>
</contrib>
</contrib-group>
<aff id="aff1-0954407012457899"><label>1</label>Fourth Department, Ordnance Engineering College, Shi Jia-zhuang, People’s Republic of China</aff>
<aff id="aff2-0954407012457899"><label>2</label>Department of Basic Courses, Ordnance Engineering College, Shi Jia-zhuang, People’s Republic of China</aff>
<aff id="aff3-0954407012457899"><label>3</label>First Department, Ordnance Engineering College, Shi Jia-zhuang, People’s Republic of China</aff>
<author-notes>
<corresp id="corresp1-0954407012457899">Bing Li, Fourth Department, Ordnance Engineering College, 97 He-ping West Road, Shi Jia-zhuang, He Bei Province 050003, People’s Republic of China. Email: <email>rommandy@163.com</email></corresp>
</author-notes>
<pub-date pub-type="epub-ppub">
<month>4</month>
<year>2013</year>
</pub-date>
<volume>227</volume>
<issue>4</issue>
<fpage>490</fpage>
<lpage>505</lpage>
<history>
<date date-type="received">
<day>16</day>
<month>2</month>
<year>2012</year>
</date>
<date date-type="accepted">
<day>7</day>
<month>6</month>
<year>2012</year>
</date>
</history>
<permissions>
<copyright-statement>© IMechE 2013</copyright-statement>
<copyright-year>2013</copyright-year>
<copyright-holder content-type="society">Institution of Mechanical Engineers</copyright-holder>
</permissions>
<abstract>
<p>Feature extraction and faults classification are the two most significant issues involved in the field of mechanical fault diagnosis problems. In this work, we address these two problems using mathematical morphology and non-negative matrix factorization. In particular, we present a novel engine fault diagnosis scheme utilizing the averaged multi-scale morphological filter to enhance the vibration signals, non-negative matrix factorization to characterize the signals, and a constructive morphological neural network to classify the engine operating states. Eight engine running states including the healthy state and seven defective states are tested in an engine experiment rig to evaluate the presented fault diagnosis scheme. Conventional feature extraction methods as well as classifiers popularly used in the literature are also employed as a comparison. The experimental results indicate the proposed approach to be an effective and efficient scheme for detection of the intelligent faults of engines.</p>
</abstract>
<kwd-group>
<kwd>Mathematical morphology</kwd>
<kwd>averaged multi-scale morphological gradient filter</kwd>
<kwd>non-negative matrix factorization</kwd>
<kwd>constructive morphological neural network</kwd>
<kwd>engine</kwd>
<kwd>fault diagnosis</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="section1-0954407012457899" sec-type="intro">
<title>Introduction</title>
<p>In the aim to reduce the loss and downtime in industrial procedures, there is a growing demand for condition-monitoring and fault detection schemes to prevent failure occurring in mechanical systems in an early stage. Vibration signal analysis, which contains rich information on the machine and can be collected conveniently without breakdown of the machine, has been the most widely employed technique in the field of condition monitoring.<sup><xref ref-type="bibr" rid="bibr1-0954407012457899">1</xref>,<xref ref-type="bibr" rid="bibr2-0954407012457899">2</xref></sup></p>
<p>The most two important issues involved in the vibration-based condition-monitoring system are extracting informative features and making accurate decisions on the machine status. Several useful feature extraction methods such as spectral analysis,<sup><xref ref-type="bibr" rid="bibr3-0954407012457899">3</xref>,<xref ref-type="bibr" rid="bibr4-0954407012457899">4</xref></sup> wavelet transform<sup><xref ref-type="bibr" rid="bibr2-0954407012457899">2</xref>,<xref ref-type="bibr" rid="bibr5-0954407012457899">5</xref><xref ref-type="bibr" rid="bibr6-0954407012457899"/><xref ref-type="bibr" rid="bibr7-0954407012457899"/>–<xref ref-type="bibr" rid="bibr8-0954407012457899">8</xref></sup> and empirical mode decomposition<sup><xref ref-type="bibr" rid="bibr9-0954407012457899">9</xref>,<xref ref-type="bibr" rid="bibr10-0954407012457899">10</xref></sup> have been applied and established in practice for engine fault diagnosis in recent years. Furthermore, with the aim to allow relatively unskilled operators to make more reliable and fast decisions on the running status of the machine, various artificial intelligence techniques such as an artificial neural networks (ANN), a support vector machine (SVM) and a decision tree (DT) have been intensively employed in the field of fault diagnosis over the past few years.<sup><xref ref-type="bibr" rid="bibr11-0954407012457899">11</xref><xref ref-type="bibr" rid="bibr12-0954407012457899"/><xref ref-type="bibr" rid="bibr13-0954407012457899"/><xref ref-type="bibr" rid="bibr14-0954407012457899"/><xref ref-type="bibr" rid="bibr15-0954407012457899"/>–<xref ref-type="bibr" rid="bibr16-0954407012457899">16</xref></sup> The applications of these techniques have significantly improved the automation and performance of fault diagnosis in practice.</p>
<p>In this paper, we present a novel engine fault diagnosis scheme based on the framework of mathematical morphology theory. In particular, we investigate the application of an averaged multi-scale morphological gradient (AMMG) filter and a constructive morphological neural network (CMNN) to vibration signal processing and intelligent classification for engine fault diagnosis. Morphological filters have been the most widely employed tools in image-processing areas during the last few decades.<sup><xref ref-type="bibr" rid="bibr17-0954407012457899">17</xref><xref ref-type="bibr" rid="bibr18-0954407012457899"/><xref ref-type="bibr" rid="bibr19-0954407012457899"/>–<xref ref-type="bibr" rid="bibr20-0954407012457899">20</xref></sup> However, this method applied to a one-dimensional signal is still limited, especially in mechanical fault diagnosis areas. The morphological neural network (MNN) model is an entirely new type of neural network, which was derived from a merger of ideas from an ANN and mathematical morphology. The MNN has been successfully applied to a variety of problems such as radar target recognition,<sup><xref ref-type="bibr" rid="bibr21-0954407012457899">21</xref></sup> handwritten character recognition,<sup><xref ref-type="bibr" rid="bibr22-0954407012457899">22</xref></sup> face recognition,<sup><xref ref-type="bibr" rid="bibr23-0954407012457899">23</xref></sup> blood cell detection and pattern classification<sup><xref ref-type="bibr" rid="bibr24-0954407012457899">24</xref></sup> and image reconstruction<sup><xref ref-type="bibr" rid="bibr25-0954407012457899">25</xref></sup> problems in recent years. However, to our knowledge, this new type of neural network has never been utilized in the field of fault diagnosis in the literature.</p>
<p>The presented engine fault diagnosis scheme based on the mathematical morphology theory involves three steps. First, the vibration signals collected from engine are enhanced by the AMMG filter, which can enhance the impulsive features and depress the noise simultaneously. Then the non-negative matrix factorization (NMF) technique is used to extract informative features as the input to classifiers. Finally, the CMNN is utilized to classify the different engine states. <xref ref-type="fig" rid="fig1-0954407012457899">Figure 1</xref> shows the flow chart of our presented feature extraction and faults classification scheme. We evaluate and compare the performance of the proposed scheme on the engine data set with the conventional feature extraction methods and classifiers. Experimental results indicated the superiority of the proposed approach model with respect to computation cost and classification accuracies.</p>
<fig id="fig1-0954407012457899" position="float">
<label>Figure 1.</label>
<caption>
<p>Flow chart of the feature extraction and classification scheme for engine fault diagnosis proposed in this work.</p>
</caption>
<graphic xlink:href="10.1177_0954407012457899-fig1.tif"/>
</fig>
<p>The remainder of this paper is organized as follows. The second section gives a brief review of the basic theories of mathematical morphology and the averaged multi-scale morphological filters. The third section introduces the concepts of NMF. In the fourth section, the architecture and the training algorithm of the CMNN are detailed. Some illustrations are also given. In the fifth section, the presented feature extraction and classification approach is applied to engine fault diagnosis. Some comparisons with traditional feature extraction methods and classifiers are also conducted. The conclusions of this investigation are summarized in the sixth section.</p>
</sec>
<sec id="section2-0954407012457899">
<title>Morphological filter</title>
<sec id="section3-0954407012457899">
<title>Basic theories on a morphological filter</title>
<p>A morphological filter is a non-linear signal-processing method stemming from the mathematical morphology theory, which was originally put forward by Matheron and Serra as an image-processing methodology based on set theory.<sup><xref ref-type="bibr" rid="bibr26-0954407012457899">26</xref>,<xref ref-type="bibr" rid="bibr27-0954407012457899">27</xref></sup> The main idea of a morphological filter is to modify the shape of a signal with another object called the structure element (SE). The basic morphological filters include the dilation filter, the erosion filter, the opening filter and the closing filter.<sup><xref ref-type="bibr" rid="bibr28-0954407012457899">28</xref>,<xref ref-type="bibr" rid="bibr29-0954407012457899">29</xref></sup></p>
<p>Let <inline-formula id="inline-formula1-0954407012457899"><mml:math display="inline" id="math1-0954407012457899"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be the discrete one-dimensional signal over a domain <inline-formula id="inline-formula2-0954407012457899"><mml:math display="inline" id="math2-0954407012457899"><mml:mrow><mml:mi>F</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math></inline-formula> and let <inline-formula id="inline-formula3-0954407012457899"><mml:math display="inline" id="math3-0954407012457899"><mml:mrow><mml:mi>g</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be the structure element over a domain <inline-formula id="inline-formula4-0954407012457899"><mml:math display="inline" id="math4-0954407012457899"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math></inline-formula>; the dilation filter and erosion filter are defined as</p>
<p>
<disp-formula id="disp-formula1-0954407012457899">
<label>(1)</label>
<mml:math display="block" id="math5-0954407012457899">
<mml:mrow>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>f</mml:mi>
<mml:mo>⊕</mml:mo>
<mml:mi>g</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:munder>
<mml:mrow>
<mml:mo>max</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mo>∈</mml:mo>
<mml:mi>G</mml:mi>
</mml:mrow>
</mml:munder>
<mml:mo stretchy="false">[</mml:mo>
<mml:mi>f</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo>−</mml:mo>
<mml:mi>m</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>+</mml:mo>
<mml:mi>g</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>m</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">]</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula1-0954407012457899" xlink:href="10.1177_0954407012457899-eq1.tif"/>
</disp-formula>
</p>
<p>and</p>
<p>
<disp-formula id="disp-formula2-0954407012457899">
<label>(2)</label>
<mml:math display="block" id="math6-0954407012457899">
<mml:mrow>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>f</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mi>Θ</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mi>g</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:munder>
<mml:mrow>
<mml:mo>min</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mo>∈</mml:mo>
<mml:mi>G</mml:mi>
</mml:mrow>
</mml:munder>
<mml:mo stretchy="false">[</mml:mo>
<mml:mi>f</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo>+</mml:mo>
<mml:mi>m</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>−</mml:mo>
<mml:mi>g</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>m</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">]</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula2-0954407012457899" xlink:href="10.1177_0954407012457899-eq2.tif"/>
</disp-formula>
</p>
<p>respectively where<inline-formula id="inline-formula5-0954407012457899"><mml:math display="inline" id="math7-0954407012457899"><mml:mrow><mml:mo>⊕</mml:mo></mml:mrow></mml:math></inline-formula>represents the dilation operator and <inline-formula id="inline-formula6-0954407012457899"><mml:math display="inline" id="math8-0954407012457899"><mml:mrow><mml:mi>Θ</mml:mi></mml:mrow></mml:math></inline-formula> represents the erosion operator.</p>
<p>The opening filter is constructed on the basis of the dilation operator, and the closing filter is constructed on the basis of the erosion operator; these filters are defined as</p>
<p>
<disp-formula id="disp-formula3-0954407012457899">
<label>(3)</label>
<mml:math display="block" id="math9-0954407012457899">
<mml:mrow>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>f</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo>∘</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>g</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>f</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mi>Θ</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mi>g</mml:mi>
<mml:mo>⊕</mml:mo>
<mml:mi>g</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula3-0954407012457899" xlink:href="10.1177_0954407012457899-eq3.tif"/>
</disp-formula>
</p>
<p>and</p>
<p>
<disp-formula id="disp-formula4-0954407012457899">
<label>(4)</label>
<mml:math display="block" id="math10-0954407012457899">
<mml:mrow>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>f</mml:mi>
<mml:mo>•</mml:mo>
<mml:mi>g</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>f</mml:mi>
<mml:mo>⊕</mml:mo>
<mml:mi>g</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mi>Θ</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mi>g</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula4-0954407012457899" xlink:href="10.1177_0954407012457899-eq4.tif"/>
</disp-formula>
</p>
<p>respectively, where <inline-formula id="inline-formula7-0954407012457899"><mml:math display="inline" id="math11-0954407012457899"><mml:mrow><mml:mo>∘</mml:mo></mml:mrow></mml:math></inline-formula> means the opening operator and <inline-formula id="inline-formula8-0954407012457899"><mml:math display="inline" id="math12-0954407012457899"><mml:mrow><mml:mo>•</mml:mo></mml:mrow></mml:math></inline-formula> means the closing operator.</p>
<p>Two types of morphological gradient (MG) filter, called the morphological dilation–erosion gradient (MG<sub>DE</sub>) filter and the morphological closing–opening gradient (MG<sub>CO</sub>) filter, can be defined on basis of the above four morphological filters according to</p>
<p>
<disp-formula id="disp-formula5-0954407012457899">
<label>(5)</label>
<mml:math display="block" id="math13-0954407012457899">
<mml:mrow>
<mml:mtext>M</mml:mtext>
<mml:msub>
<mml:mrow>
<mml:mtext>G</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mtext>DE</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>f</mml:mi>
<mml:mo>⊕</mml:mo>
<mml:mi>g</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>−</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>f</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mi>Θ</mml:mi>
<mml:mi>g</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula5-0954407012457899" xlink:href="10.1177_0954407012457899-eq5.tif"/>
</disp-formula>
</p>
<p>and</p>
<p>
<disp-formula id="disp-formula6-0954407012457899">
<label>(6)</label>
<mml:math display="block" id="math14-0954407012457899">
<mml:mrow>
<mml:mtext>M</mml:mtext>
<mml:msub>
<mml:mrow>
<mml:mtext>G</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mtext>CO</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>f</mml:mi>
<mml:mo>•</mml:mo>
<mml:mi>g</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>−</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>f</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo>∘</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>g</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula6-0954407012457899" xlink:href="10.1177_0954407012457899-eq6.tif"/>
</disp-formula>
</p>
<p>More details about morphological filters and SEs have been given by Maragos and Schafer,<sup><xref ref-type="bibr" rid="bibr29-0954407012457899">29</xref></sup> Serra and Vincent<sup><xref ref-type="bibr" rid="bibr30-0954407012457899">30</xref></sup> and Heijmans.<sup><xref ref-type="bibr" rid="bibr31-0954407012457899">31</xref></sup></p>
<p><xref ref-type="fig" rid="fig2-0954407012457899">Figure 2</xref> gives an illustration of the four basic morphological operators and two MG operators on a signal. It can be found that both the dilation operator and the closing operator seem to give the upper envelope of the signal, while the erosion operator and the opening operator seem to give the lower envelope of the signal. The two MG operators can enhance the impulsive feature in the signal very effectively. Therefore it is very desirable to utilize the morphological filter to detect the impulsive components in vibration signals for engine fault diagnosis.</p>
<fig id="fig2-0954407012457899" position="float">
<label>Figure 2.</label>
<caption>
<p>Filtered results of a signal using the following: (a) morphological dilation; (b) morphological erosion; (c) morphological opening; (d) morphological closing; (e) morphological dilation–erosion gradient; (f) morphological closing–opening gradient.</p>
</caption>
<graphic xlink:href="10.1177_0954407012457899-fig2.tif"/>
</fig>
</sec>
<sec id="section4-0954407012457899">
<title>Multi-scale morphological filters</title>
<p>A classical morphological filter performs single-scale analysis, in which a fixed SE is utilized by prior knowledge. This is simple and easy to implement. However, prior knowledge is not always available for some applications. Therefore, multi-scale morphology analysis on signals seems to be more promising than single-scale morphology analysis does.</p>
<p>In the phase of morphological filtering, multi-scale analysis can be implemented by using SEs with different scales. Let <inline-formula id="inline-formula9-0954407012457899"><mml:math display="inline" id="math15-0954407012457899"><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> (<inline-formula id="inline-formula10-0954407012457899"><mml:math display="inline" id="math16-0954407012457899"><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>max</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>) be the scale, and <inline-formula id="inline-formula11-0954407012457899"><mml:math display="inline" id="math17-0954407012457899"><mml:mrow><mml:mi>g</mml:mi></mml:mrow></mml:math></inline-formula> be the unit SE; the SE used on scale <inline-formula id="inline-formula12-0954407012457899"><mml:math display="inline" id="math18-0954407012457899"><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> can be defined as<sup><xref ref-type="bibr" rid="bibr32-0954407012457899">32</xref></sup></p>
<p>
<disp-formula id="disp-formula7-0954407012457899">
<label>(7)</label>
<mml:math display="block" id="math19-0954407012457899">
<mml:mrow>
<mml:mi>sg</mml:mi>
<mml:mo>=</mml:mo>
<mml:munder>
<mml:mrow>
<mml:munder>
<mml:mrow>
<mml:mi>g</mml:mi>
<mml:mo>⊕</mml:mo>
<mml:mi>g</mml:mi>
<mml:mo>⊕</mml:mo>
<mml:mo>⋯</mml:mo>
<mml:mo>⊕</mml:mo>
<mml:mi>g</mml:mi>
</mml:mrow>
<mml:mo stretchy="true">︸</mml:mo>
</mml:munder>
</mml:mrow>
<mml:mrow>
<mml:mi>s</mml:mi>
<mml:mo>−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mspace width="0.25em"/>
<mml:mtext>times</mml:mtext>
</mml:mrow>
</mml:munder>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula7-0954407012457899" xlink:href="10.1177_0954407012457899-eq7.tif"/>
</disp-formula>
</p>
<p>Then the dilation and erosion of the signal <inline-formula id="inline-formula13-0954407012457899"><mml:math display="inline" id="math20-0954407012457899"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> on scale <inline-formula id="inline-formula14-0954407012457899"><mml:math display="inline" id="math21-0954407012457899"><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> can be obtained as</p>
<p>
<disp-formula id="disp-formula8-0954407012457899">
<label>(8)</label>
<mml:math display="block" id="math22-0954407012457899">
<mml:mrow>
<mml:mi>f</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo>⊕</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>sg</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:munder>
<mml:mrow>
<mml:munder>
<mml:mrow>
<mml:mi>f</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo>⊕</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>g</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo>⊕</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>g</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo>⊕</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mo>⋯</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mo>⊕</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>g</mml:mi>
</mml:mrow>
<mml:mo stretchy="true">︸</mml:mo>
</mml:munder>
</mml:mrow>
<mml:mrow>
<mml:mi>s</mml:mi>
<mml:mo>−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mspace width="0.25em"/>
<mml:mtext>times</mml:mtext>
</mml:mrow>
</mml:munder>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula8-0954407012457899" xlink:href="10.1177_0954407012457899-eq8.tif"/>
</disp-formula>
</p>
<p>and</p>
<p>
<disp-formula id="disp-formula9-0954407012457899">
<label>(9)</label>
<mml:math display="block" id="math23-0954407012457899">
<mml:mrow>
<mml:mi>f</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mi>Θ</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mi>sg</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:munder>
<mml:mrow>
<mml:munder>
<mml:mrow>
<mml:mi>f</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mi>Θ</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mi>g</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mi>Θ</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mi>g</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mi>Θ</mml:mi>
<mml:mo>⋯</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>Θ</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mi>g</mml:mi>
</mml:mrow>
<mml:mo stretchy="true">︸</mml:mo>
</mml:munder>
</mml:mrow>
<mml:mrow>
<mml:mi>s</mml:mi>
<mml:mo>−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mspace width="0.25em"/>
<mml:mtext>times</mml:mtext>
</mml:mrow>
</mml:munder>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula9-0954407012457899" xlink:href="10.1177_0954407012457899-eq9.tif"/>
</disp-formula>
</p>
<p>respectively.</p>
<p>Correspondingly, the opening and closing of the signal <inline-formula id="inline-formula15-0954407012457899"><mml:math display="inline" id="math24-0954407012457899"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> on the scale <inline-formula id="inline-formula16-0954407012457899"><mml:math display="inline" id="math25-0954407012457899"><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> can be defined as</p>
<p>
<disp-formula id="disp-formula10-0954407012457899">
<label>(10)</label>
<mml:math display="block" id="math26-0954407012457899">
<mml:mrow>
<mml:mi>f</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo>∘</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>sg</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>f</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mi>Θ</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mi>sg</mml:mi>
<mml:mo>⊕</mml:mo>
<mml:mi>sg</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula10-0954407012457899" xlink:href="10.1177_0954407012457899-eq10.tif"/>
</disp-formula>
</p>
<p>and</p>
<p>
<disp-formula id="disp-formula11-0954407012457899">
<label>(11)</label>
<mml:math display="block" id="math27-0954407012457899">
<mml:mrow>
<mml:mi>f</mml:mi>
<mml:mo>•</mml:mo>
<mml:mi>sg</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>f</mml:mi>
<mml:mo>⊕</mml:mo>
<mml:mi>sg</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mi>Θ</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mi>sg</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula11-0954407012457899" xlink:href="10.1177_0954407012457899-eq11.tif"/>
</disp-formula>
</p>
<p>respectively.</p>
<p>Therefore the multi-scale morphological gradient (MMG) operators on scale <inline-formula id="inline-formula17-0954407012457899"><mml:math display="inline" id="math28-0954407012457899"><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> can be defined as</p>
<p>
<disp-formula id="disp-formula12-0954407012457899">
<label>(12)</label>
<mml:math display="block" id="math29-0954407012457899">
<mml:mrow>
<mml:msubsup>
<mml:mrow>
<mml:mtext>MMG</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mtext>DE</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
</mml:msubsup>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mi>f</mml:mi>
<mml:mo>⊕</mml:mo>
<mml:mi>sg</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>−</mml:mo>
<mml:mi>f</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mi>Θ</mml:mi>
<mml:mi>sg</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula12-0954407012457899" xlink:href="10.1177_0954407012457899-eq12.tif"/>
</disp-formula>
</p>
<p>and</p>
<p>
<disp-formula id="disp-formula13-0954407012457899">
<label>(13)</label>
<mml:math display="block" id="math30-0954407012457899">
<mml:mrow>
<mml:msubsup>
<mml:mrow>
<mml:mtext>MMG</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mtext>CO</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
</mml:msubsup>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mi>f</mml:mi>
<mml:mo>•</mml:mo>
<mml:mi>sg</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>−</mml:mo>
<mml:mi>f</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo>∘</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>sg</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula13-0954407012457899" xlink:href="10.1177_0954407012457899-eq13.tif"/>
</disp-formula>
</p>
</sec>
<sec id="section5-0954407012457899">
<title>The averaged multi-scale morphological gradient filter</title>
<p>A large-scale SE can depress the noise effectively but also can blur the impulse details, while a small-scale SE will preserve the impulse details but will fail to suppress the noise. In order to overcome this problem, two AMMG filters are developed in this work. They make use of averaging a sequence of morphologically filtered signals on different scales; thus the impulsive features can be preserved and the noise can be depressed simultaneously. The two AMMGs are defined as</p>
<p>
<disp-formula id="disp-formula14-0954407012457899">
<label>(14)</label>
<mml:math display="block" id="math31-0954407012457899">
<mml:mrow>
<mml:mtext>AMM</mml:mtext>
<mml:msub>
<mml:mrow>
<mml:mtext>G</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mtext>DE</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mfrac>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>max</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfrac>
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>s</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>max</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:msubsup>
<mml:mrow>
<mml:mtext>MMG</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mtext>DE</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
</mml:msubsup>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula14-0954407012457899" xlink:href="10.1177_0954407012457899-eq14.tif"/>
</disp-formula>
</p>
<p>and</p>
<p>
<disp-formula id="disp-formula15-0954407012457899">
<label>(15)</label>
<mml:math display="block" id="math32-0954407012457899">
<mml:mrow>
<mml:mtext>AMM</mml:mtext>
<mml:msub>
<mml:mrow>
<mml:mtext>G</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mtext>CO</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mfrac>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>max</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfrac>
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>s</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>max</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:msubsup>
<mml:mrow>
<mml:mtext>MMG</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mtext>CO</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
</mml:msubsup>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>n</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula15-0954407012457899" xlink:href="10.1177_0954407012457899-eq15.tif"/>
</disp-formula>
</p>
<p>In this work, we select MG<sub>DE</sub> to construct the AMMG filter. The reason for selecting MG<sub>DE</sub> is its capacity to maintain the shape of the signal, and its computation cost is only half that of MG<sub>CO</sub>.</p>
</sec>
</sec>
<sec id="section6-0954407012457899">
<title>Non-negative matrix factorization</title>
<p>The NMF algorithm is a technique that compresses a matrix into a smaller number of basis functions and their encodings. It is shown that NMF offers dimension reduction and produces useful representations by converting a data matrix to multiplication of two smaller matrices. Because of its superior properties, NMF has been adopted for various applications such as face expression and recognition,<sup><xref ref-type="bibr" rid="bibr33-0954407012457899">33</xref></sup> object detection,<sup><xref ref-type="bibr" rid="bibr34-0954407012457899">34</xref></sup> image compression and classification<sup><xref ref-type="bibr" rid="bibr35-0954407012457899">35</xref></sup> and sound classification.<sup><xref ref-type="bibr" rid="bibr36-0954407012457899">36</xref></sup> In this work, NMF is employed to characterize the vibration signals for engine fault diagnosis.</p>
<p>Different from other similar methods, NMF imposes a non-negativity constraint on factorization which leads to the formation of intuitive and parts-based representations of data for its factors. The factorization can be expressed as</p>
<p>
<disp-formula id="disp-formula16-0954407012457899">
<label>(16)</label>
<mml:math display="block" id="math33-0954407012457899">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">V</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo>×</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>m</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>≈</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">W</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo>×</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">H</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>r</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo>×</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>m</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula16-0954407012457899" xlink:href="10.1177_0954407012457899-eq16.tif"/>
</disp-formula>
</p>
<p>where <inline-formula id="inline-formula18-0954407012457899"><mml:math display="inline" id="math34-0954407012457899"><mml:mrow><mml:mtext mathvariant="bold">V</mml:mtext></mml:mrow></mml:math></inline-formula> denotes an <inline-formula id="inline-formula19-0954407012457899"><mml:math display="inline" id="math35-0954407012457899"><mml:mrow><mml:mi>n</mml:mi><mml:mspace width="0.25em"/><mml:mo>×</mml:mo><mml:mspace width="0.25em"/><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula> matrix and <inline-formula id="inline-formula20-0954407012457899"><mml:math display="inline" id="math36-0954407012457899"><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula> is the number of examples in the data set, each column of which contains an <italic>n</italic>-dimensional observed data vector with non-negative values. This matrix then approximately factorizes into an <inline-formula id="inline-formula21-0954407012457899"><mml:math display="inline" id="math37-0954407012457899"><mml:mrow><mml:mi>n</mml:mi><mml:mspace width="0.25em"/><mml:mo>×</mml:mo><mml:mspace width="0.25em"/><mml:mi>r</mml:mi></mml:mrow></mml:math></inline-formula> matrix <inline-formula id="inline-formula22-0954407012457899"><mml:math display="inline" id="math38-0954407012457899"><mml:mrow><mml:mtext mathvariant="bold">W</mml:mtext></mml:mrow></mml:math></inline-formula> and an <inline-formula id="inline-formula23-0954407012457899"><mml:math display="inline" id="math39-0954407012457899"><mml:mrow><mml:mi>r</mml:mi><mml:mspace width="0.25em"/><mml:mo>×</mml:mo><mml:mspace width="0.25em"/><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula> matrix <inline-formula id="inline-formula24-0954407012457899"><mml:math display="inline" id="math40-0954407012457899"><mml:mrow><mml:mtext mathvariant="bold">H</mml:mtext></mml:mrow></mml:math></inline-formula>. The rank <inline-formula id="inline-formula25-0954407012457899"><mml:math display="inline" id="math41-0954407012457899"><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:math></inline-formula> of the factorization is usually chosen such that <inline-formula id="inline-formula26-0954407012457899"><mml:math display="inline" id="math42-0954407012457899"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>r</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>nm</mml:mi></mml:mrow></mml:math></inline-formula>, and hence compression or dimensionality reduction is achieved. This results in a compressed version of the original data matrix. In other words, each data vector <inline-formula id="inline-formula27-0954407012457899"><mml:math display="inline" id="math43-0954407012457899"><mml:mrow><mml:mtext mathvariant="bold">V</mml:mtext></mml:mrow></mml:math></inline-formula> is approximated by a linear combination of the columns of <inline-formula id="inline-formula28-0954407012457899"><mml:math display="inline" id="math44-0954407012457899"><mml:mrow><mml:mtext mathvariant="bold">W</mml:mtext></mml:mrow></mml:math></inline-formula>, weighted by the components of <inline-formula id="inline-formula29-0954407012457899"><mml:math display="inline" id="math45-0954407012457899"><mml:mrow><mml:mtext mathvariant="bold">H</mml:mtext></mml:mrow></mml:math></inline-formula>. Therefore,<inline-formula id="inline-formula30-0954407012457899"><mml:math display="inline" id="math46-0954407012457899"><mml:mrow><mml:mtext mathvariant="bold">W</mml:mtext></mml:mrow></mml:math></inline-formula>can be regarded as the basis matrix and <inline-formula id="inline-formula31-0954407012457899"><mml:math display="inline" id="math47-0954407012457899"><mml:mrow><mml:mtext mathvariant="bold">H</mml:mtext></mml:mrow></mml:math></inline-formula> as the coefficient matrix.</p>
<p>The key characteristic of NMF is the non-negativity constraints imposed on the two factors, and the non-negativity constraints are compatible with the intuitive notion of combining parts to form a whole.</p>
<p>In order to complete approximate factorization in <xref ref-type="disp-formula" rid="disp-formula16-0954407012457899">equation (16)</xref>, a cost function is needed to quantify the quality of the approximation. NMF uses the divergence measure as the objective function</p>
<p>
<disp-formula id="disp-formula17-0954407012457899">
<label>(17)</label>
<mml:math display="block" id="math48-0954407012457899">
<mml:mrow>
<mml:mi>F</mml:mi>
<mml:mo>=</mml:mo>
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:munderover>
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mo>[</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">V</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>ij</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mi>log</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="bold">WH</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>ij</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="bold">WH</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>ij</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>]</mml:mo>
</mml:mrow>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula17-0954407012457899" xlink:href="10.1177_0954407012457899-eq17.tif"/>
</disp-formula>
</p>
<p>which is subject to the non-negative constraints as described above.</p>
<p>In order to obtain <bold>W</bold> and <bold>H</bold>, a multiplicative update rule has been given by Lee and Seung<sup><xref ref-type="bibr" rid="bibr37-0954407012457899">37</xref></sup> as</p>
<p>
<disp-formula id="disp-formula18-0954407012457899">
<label>(18)</label>
<mml:math display="block" id="math49-0954407012457899">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">W</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>ia</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">W</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>ia</mml:mi>
</mml:mrow>
</mml:msub>
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
</mml:munderover>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">V</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>ij</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="bold">WH</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>ij</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfrac>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">H</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>aj</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula18-0954407012457899" xlink:href="10.1177_0954407012457899-eq18.tif"/>
</disp-formula>
</p>
<p>
<disp-formula id="disp-formula19-0954407012457899">
<label>(19)</label>
<mml:math display="block" id="math50-0954407012457899">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">W</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>ia</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">W</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>ia</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
</mml:munderover>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">W</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>ia</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula19-0954407012457899" xlink:href="10.1177_0954407012457899-eq19.tif"/>
</disp-formula>
</p>
<p>
<disp-formula id="disp-formula20-0954407012457899">
<label>(20)</label>
<mml:math display="block" id="math51-0954407012457899">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">H</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>aj</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">H</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>aj</mml:mi>
</mml:mrow>
</mml:msub>
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:munderover>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">W</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>ia</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">V</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>ij</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="bold">WH</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>ij</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula20-0954407012457899" xlink:href="10.1177_0954407012457899-eq20.tif"/>
</disp-formula>
</p>
<p>More details about NMF theories and algorithms have been given by Lee and Seung.<sup><xref ref-type="bibr" rid="bibr37-0954407012457899">37</xref>,<xref ref-type="bibr" rid="bibr38-0954407012457899">38</xref></sup></p>
</sec>
<sec id="section7-0954407012457899">
<title>Morphological neural network</title>
<p>The MNN model is an entirely new type of neural network, which was derived from a merger of ideas from an ANN and mathematical morphology.<sup><xref ref-type="bibr" rid="bibr39-0954407012457899">39</xref><xref ref-type="bibr" rid="bibr40-0954407012457899"/>–<xref ref-type="bibr" rid="bibr41-0954407012457899">41</xref></sup> In this section, first we give a brief review of the computational basis of an MNN, which means the lattice-based mathematical morphology theory. Then the details of the MNN architecture and training algorithm are described. A simple illustration using a simulated data set is also given.</p>
<sec id="section8-0954407012457899">
<title>Mathematical morphology based on lattice theory</title>
<p>Let <inline-formula id="inline-formula32-0954407012457899"><mml:math display="inline" id="math52-0954407012457899"><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:math></inline-formula> be a partial-order set, if and only if every subset <inline-formula id="inline-formula33-0954407012457899"><mml:math display="inline" id="math53-0954407012457899"><mml:mrow><mml:mi>X</mml:mi></mml:mrow></mml:math></inline-formula> of <inline-formula id="inline-formula34-0954407012457899"><mml:math display="inline" id="math54-0954407012457899"><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:math></inline-formula> has a minimum supremem denoted as <inline-formula id="inline-formula35-0954407012457899"><mml:math display="inline" id="math55-0954407012457899"><mml:mrow><mml:mo>∨</mml:mo><mml:mi>X</mml:mi></mml:mrow></mml:math></inline-formula> and a maximum infimum denoted as <inline-formula id="inline-formula36-0954407012457899"><mml:math display="inline" id="math56-0954407012457899"><mml:mrow><mml:mo>∧</mml:mo><mml:mi>X</mml:mi></mml:mrow></mml:math></inline-formula>; we call <italic>L</italic> a complete lattice. If <inline-formula id="inline-formula37-0954407012457899"><mml:math display="inline" id="math57-0954407012457899"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> are lattices, we call <inline-formula id="inline-formula38-0954407012457899"><mml:math display="inline" id="math58-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mspace width="0.25em"/><mml:mo>×</mml:mo><mml:mspace width="0.25em"/><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mspace width="0.25em"/><mml:mo>×</mml:mo><mml:mspace width="0.25em"/><mml:mo>⋯</mml:mo><mml:mspace width="0.25em"/><mml:mo>×</mml:mo><mml:mspace width="0.25em"/><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> a product lattice, in which the partial order can be defined as</p>
<p>
<disp-formula id="disp-formula21-0954407012457899">
<label>(21)</label>
<mml:math display="block" id="math59-0954407012457899">
<mml:mrow>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mo>…</mml:mo>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>N</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>≤</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>y</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mo>…</mml:mo>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>y</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>N</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>⇔</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>≤</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>y</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mo>⋯</mml:mo>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>N</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>≤</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>y</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>N</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula21-0954407012457899" xlink:href="10.1177_0954407012457899-eq21.tif"/>
</disp-formula>
</p>
<p>If <inline-formula id="inline-formula39-0954407012457899"><mml:math display="inline" id="math60-0954407012457899"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> are complete lattices, <inline-formula id="inline-formula40-0954407012457899"><mml:math display="inline" id="math61-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> is also a complete lattice.</p>
<p>A fundamental theorem of mathematical morphology states that every mapping between complete lattices can be written in terms of these elementary operators and infimum and supreme operators. Four basic morphological operators, namely the erosion operator, the dilation operator, the anti-erosion operator and the anti-dilation operator, are defined as<sup><xref ref-type="bibr" rid="bibr31-0954407012457899">31</xref>,<xref ref-type="bibr" rid="bibr41-0954407012457899">41</xref>,<xref ref-type="bibr" rid="bibr42-0954407012457899">42</xref></sup></p>
<p>
<disp-formula id="disp-formula22-0954407012457899">
<label>(22)</label>
<mml:math display="block" id="math62-0954407012457899">
<mml:mrow>
<mml:mi>ε</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mtext>the</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>erosion</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>operator</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>if</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>and</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>only</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>if</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mo>⇔</mml:mo>
<mml:mi>ε</mml:mi>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:munderover>
<mml:mrow>
<mml:mo>∧</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>J</mml:mi>
</mml:mrow>
</mml:munderover>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>=</mml:mo>
<mml:munderover>
<mml:mrow>
<mml:mo>∧</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>J</mml:mi>
</mml:mrow>
</mml:munderover>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>ε</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula22-0954407012457899" xlink:href="10.1177_0954407012457899-eq22.tif"/>
</disp-formula>
</p>
<p>
<disp-formula id="disp-formula23-0954407012457899">
<label>(23)</label>
<mml:math display="block" id="math63-0954407012457899">
<mml:mrow>
<mml:mi>δ</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mtext>the</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>dilation</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>operator</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>if</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>and</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>only</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>if</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mo>⇔</mml:mo>
<mml:mi>δ</mml:mi>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:munderover>
<mml:mrow>
<mml:mo>∨</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>J</mml:mi>
</mml:mrow>
</mml:munderover>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>=</mml:mo>
<mml:munderover>
<mml:mrow>
<mml:mo>∨</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>J</mml:mi>
</mml:mrow>
</mml:munderover>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>δ</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula23-0954407012457899" xlink:href="10.1177_0954407012457899-eq23.tif"/>
</disp-formula>
</p>
<p>
<disp-formula id="disp-formula24-0954407012457899">
<label>(24)</label>
<mml:math display="block" id="math64-0954407012457899">
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>ε</mml:mi>
</mml:mrow>
<mml:mo>¯</mml:mo>
</mml:mover>
<mml:mspace width="0.25em"/>
<mml:mtext>is</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>the</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>anti-erosion</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>operator</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>if</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>and</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>only</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>if</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mo>⇔</mml:mo>
<mml:mover>
<mml:mrow>
<mml:mi>ε</mml:mi>
</mml:mrow>
<mml:mo>¯</mml:mo>
</mml:mover>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:munderover>
<mml:mrow>
<mml:mo>∧</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>J</mml:mi>
</mml:mrow>
</mml:munderover>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>=</mml:mo>
<mml:munderover>
<mml:mrow>
<mml:mo>∨</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>J</mml:mi>
</mml:mrow>
</mml:munderover>
<mml:mo stretchy="false">(</mml:mo>
<mml:mover>
<mml:mrow>
<mml:mi>ε</mml:mi>
</mml:mrow>
<mml:mo>¯</mml:mo>
</mml:mover>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula24-0954407012457899" xlink:href="10.1177_0954407012457899-eq24.tif"/>
</disp-formula>
</p>
<p>
<disp-formula id="disp-formula25-0954407012457899">
<label>(25)</label>
<mml:math display="block" id="math65-0954407012457899">
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>δ</mml:mi>
</mml:mrow>
<mml:mo>¯</mml:mo>
</mml:mover>
<mml:mspace width="0.25em"/>
<mml:mtext>is</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>the</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>anti-dilation</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>operator</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>if</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>and</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>only</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>if</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mo>⇔</mml:mo>
<mml:mover>
<mml:mrow>
<mml:mi>δ</mml:mi>
</mml:mrow>
<mml:mo>¯</mml:mo>
</mml:mover>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:munderover>
<mml:mrow>
<mml:mo>∨</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>J</mml:mi>
</mml:mrow>
</mml:munderover>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>=</mml:mo>
<mml:munderover>
<mml:mrow>
<mml:mo>∧</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>J</mml:mi>
</mml:mrow>
</mml:munderover>
<mml:mo stretchy="false">(</mml:mo>
<mml:mover>
<mml:mrow>
<mml:mi>δ</mml:mi>
</mml:mrow>
<mml:mo>¯</mml:mo>
</mml:mover>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula25-0954407012457899" xlink:href="10.1177_0954407012457899-eq25.tif"/>
</disp-formula>
</p>
<p>These four elementary morphological operators combined with the infimum and supremem operators lie at the core of the training algorithms of MNN models.</p>
</sec>
<sec id="section9-0954407012457899">
<title>Architecture of the morphological neural network</title>
<p>The basic idea for the MNN is to replace semilinear operations used in a conventional ANN by morphological operations. Morphological perceptrons (MPs) arguably represent the simplest MNN model. The basic idea for the development of MPs was to mimic conventional perceptrons using morphological operations.<sup><xref ref-type="bibr" rid="bibr43-0954407012457899">43</xref></sup></p>
<p>Given an input vector <inline-formula id="inline-formula41-0954407012457899"><mml:math display="inline" id="math66-0954407012457899"><mml:mrow><mml:mtext mathvariant="bold">x</mml:mtext><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, a synaptic weight vector <inline-formula id="inline-formula42-0954407012457899"><mml:math display="inline" id="math67-0954407012457899"><mml:mrow><mml:mtext mathvariant="bold">w</mml:mtext><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> and an active function <inline-formula id="inline-formula43-0954407012457899"><mml:math display="inline" id="math68-0954407012457899"><mml:mrow><mml:mi>f</mml:mi></mml:mrow></mml:math></inline-formula>, the output of an MP can be computed on the basis of the following rules. First</p>
<p>
<disp-formula id="disp-formula26-0954407012457899">
<label>(26)</label>
<mml:math display="block" id="math69-0954407012457899">
<mml:mrow>
<mml:mi>y</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi>f</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>ε</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext mathvariant="bold">w</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mtext mathvariant="bold">x</mml:mtext>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula26-0954407012457899" xlink:href="10.1177_0954407012457899-eq26.tif"/>
</disp-formula>
</p>
<p>where</p>
<p>
<disp-formula id="disp-formula27-0954407012457899">
<mml:math display="block" id="math70-0954407012457899">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>ε</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext mathvariant="bold">w</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mtext mathvariant="bold">x</mml:mtext>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:munderover>
<mml:mrow>
<mml:mo>∧</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:munderover>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula27-0954407012457899" xlink:href="10.1177_0954407012457899-eq27.tif"/>
</disp-formula>
</p>
<p>Second</p>
<p>
<disp-formula id="disp-formula28-0954407012457899">
<label>(27)</label>
<mml:math display="block" id="math71-0954407012457899">
<mml:mrow>
<mml:mi>y</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi>f</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext mathvariant="bold">w</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mtext mathvariant="bold">x</mml:mtext>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula28-0954407012457899" xlink:href="10.1177_0954407012457899-eq28.tif"/>
</disp-formula>
</p>
<p>where</p>
<p>
<disp-formula id="disp-formula29-0954407012457899">
<mml:math display="block" id="math72-0954407012457899">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext mathvariant="bold">w</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mtext mathvariant="bold">x</mml:mtext>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:munderover>
<mml:mrow>
<mml:mo>∨</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:munderover>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula29-0954407012457899" xlink:href="10.1177_0954407012457899-eq29.tif"/>
</disp-formula>
</p>
<p>Third</p>
<p>
<disp-formula id="disp-formula30-0954407012457899">
<label>(28)</label>
<mml:math display="block" id="math73-0954407012457899">
<mml:mrow>
<mml:mi>y</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi>f</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>ε</mml:mi>
</mml:mrow>
<mml:mo>¯</mml:mo>
</mml:mover>
</mml:mrow>
<mml:mrow>
<mml:mtext mathvariant="bold">w</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mtext mathvariant="bold">x</mml:mtext>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula30-0954407012457899" xlink:href="10.1177_0954407012457899-eq30.tif"/>
</disp-formula>
</p>
<p>where</p>
<p>
<disp-formula id="disp-formula31-0954407012457899">
<mml:math display="block" id="math74-0954407012457899">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>ε</mml:mi>
</mml:mrow>
<mml:mo>¯</mml:mo>
</mml:mover>
</mml:mrow>
<mml:mrow>
<mml:mtext mathvariant="bold">w</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mtext mathvariant="bold">x</mml:mtext>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:munderover>
<mml:mrow>
<mml:mo>∨</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:munderover>
<mml:mo stretchy="false">(</mml:mo>
<mml:msubsup>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msubsup>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula31-0954407012457899" xlink:href="10.1177_0954407012457899-eq31.tif"/>
</disp-formula>
</p>
<p>Fourth</p>
<p>
<disp-formula id="disp-formula32-0954407012457899">
<label>(29)</label>
<mml:math display="block" id="math75-0954407012457899">
<mml:mrow>
<mml:mi>y</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi>f</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>δ</mml:mi>
</mml:mrow>
<mml:mo>¯</mml:mo>
</mml:mover>
</mml:mrow>
<mml:mrow>
<mml:mtext mathvariant="bold">w</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mtext mathvariant="bold">x</mml:mtext>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula32-0954407012457899" xlink:href="10.1177_0954407012457899-eq32.tif"/>
</disp-formula>
</p>
<p>where</p>
<p>
<disp-formula id="disp-formula33-0954407012457899">
<mml:math display="block" id="math76-0954407012457899">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>δ</mml:mi>
</mml:mrow>
<mml:mo>¯</mml:mo>
</mml:mover>
</mml:mrow>
<mml:mrow>
<mml:mtext mathvariant="bold">w</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mtext mathvariant="bold">x</mml:mtext>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:munderover>
<mml:mrow>
<mml:mo>∧</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:munderover>
<mml:mo stretchy="false">(</mml:mo>
<mml:msubsup>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msubsup>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula33-0954407012457899" xlink:href="10.1177_0954407012457899-eq33.tif"/>
</disp-formula>
</p>
<p>It should be noted that the operators <inline-formula id="inline-formula44-0954407012457899"><mml:math display="inline" id="math77-0954407012457899"><mml:mrow><mml:msub><mml:mrow><mml:mi>ε</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="bold">w</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="bold">w</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>ε</mml:mi></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mtext mathvariant="bold">w</mml:mtext></mml:mrow></mml:msub><mml:mspace width="0.25em"/><mml:mtext>and</mml:mtext><mml:mspace width="0.25em"/><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mtext mathvariant="bold">w</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> represent the erosion operator, the dilation operator, the anti-erosion operator and the anti-dilation operator respectively from the complete lattice <inline-formula id="inline-formula45-0954407012457899"><mml:math display="inline" id="math78-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> to the complete lattice <inline-formula id="inline-formula46-0954407012457899"><mml:math display="inline" id="math79-0954407012457899"><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
<p>Because the function of the MNN is not differentiable, Sussner and Esmi<sup><xref ref-type="bibr" rid="bibr40-0954407012457899">40</xref>,<xref ref-type="bibr" rid="bibr41-0954407012457899">41</xref>,<xref ref-type="bibr" rid="bibr43-0954407012457899">43</xref></sup> and Sussner<sup><xref ref-type="bibr" rid="bibr44-0954407012457899">44</xref></sup> have developed a supervised learning algorithm for an MP and modified it for multi-class tasks in recent years. This new MP training algorithm does not merely generate the weights for a neural net having a fixed architecture but incrementally grows new neurons together with their associated weights, resulting in a feedforward architecture. Thus we can regard this new MP model as a CMNN.</p>
<p>The architecture of the CMNN is illustrated in <xref ref-type="fig" rid="fig3-0954407012457899">Figure 3</xref>, where the symbols <inline-formula id="inline-formula47-0954407012457899"><mml:math display="inline" id="math80-0954407012457899"><mml:mrow><mml:msub><mml:mrow><mml:mi>ε</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="bold">u</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="inline-formula48-0954407012457899"><mml:math display="inline" id="math81-0954407012457899"><mml:mrow><mml:mspace width="0.25em"/><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mtext mathvariant="bold">w</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mtext mathvariant="bold">x</mml:mtext><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> represent the morphological erosion operator and the anti-dilation operator respectively which were defined previously, <bold>u</bold> and <bold>w</bold> are the weights of hidden neurons and <bold>x</bold> is an input vector. Note that the output neuron performs a morphological dilation from the complete lattice <inline-formula id="inline-formula49-0954407012457899"><mml:math display="inline" id="math82-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> to the complete lattice <inline-formula id="inline-formula50-0954407012457899"><mml:math display="inline" id="math83-0954407012457899"><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
<fig id="fig3-0954407012457899" position="float">
<label>Figure 3.</label>
<caption>
<p>Architecture of the CMNN.</p>
</caption>
<graphic xlink:href="10.1177_0954407012457899-fig3.tif"/>
</fig>
<p>The values of the CMNN’s weights <bold>u</bold> and <bold>w</bold> must be determined before it can act as a classifier. More precisely, the weights are determined using a supervised learning algorithm that constructs <italic>n</italic>-dimensional hyper-boxes around sets of points which share the same class value. Note that a hyper-box in <inline-formula id="inline-formula51-0954407012457899"><mml:math display="inline" id="math84-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> can be completely determined by its lower vertex <bold>a</bold> and its upper vertex <bold>b.</bold> We say that an element <inline-formula id="inline-formula52-0954407012457899"><mml:math display="inline" id="math85-0954407012457899"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> is contained in a hyper-box [<bold>a</bold>, <bold>b</bold>] if and only if <bold>a</bold> ≤ <bold>x</bold> ≤ <bold>b</bold> is satisfied. Let <bold>u</bold> = <bold>a</bold><sup>*</sup> and <bold>w</bold> = <bold>b;</bold> we can equivalently transfer the above condition as</p>
<p>
<disp-formula id="disp-formula34-0954407012457899">
<label>(30)</label>
<mml:math display="block" id="math86-0954407012457899">
<mml:mrow>
<mml:mtext mathvariant="bold">x</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>is</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>contained</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>in</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mrow>
<mml:mo>[</mml:mo>
<mml:mtext mathvariant="bold">a</mml:mtext>
<mml:mo>,</mml:mo>
<mml:mtext mathvariant="bold">b</mml:mtext>
<mml:mo>]</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mo>⇔</mml:mo>
<mml:msub>
<mml:mi>ε</mml:mi>
<mml:mtext mathvariant="bold">u</mml:mtext>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>x</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∧</mml:mo>
<mml:msub>
<mml:mover accent="true">
<mml:mi>δ</mml:mi>
<mml:mo>¯</mml:mo>
</mml:mover>
<mml:mtext mathvariant="bold">w</mml:mtext>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mtext mathvariant="bold">x</mml:mtext>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>≥</mml:mo>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula34-0954407012457899" xlink:href="10.1177_0954407012457899-eq34.tif"/>
</disp-formula>
</p>
<p>where <bold>u</bold> = <bold>a</bold><sup>*</sup> and <bold>w</bold> = <bold>b</bold>.</p>
<p>During the process of training, the CMNN automatically generates a series of hyper-boxes [<bold>a</bold><sub>j</sub>, <bold>b</bold><sub>j</sub>] (<inline-formula id="inline-formula53-0954407012457899"><mml:math display="inline" id="math87-0954407012457899"><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>12</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula>), which contain all the points belonging to the first class.</p>
<p>In the testing phase, an input pattern <bold>x</bold> is classified as belonging to the first class if and only if it is contained in one of the hyper-boxes [<bold>a</bold><sub>j</sub>, <bold>b</bold><sub>j</sub>]. In other words, the output of the CMNN is determined by the equation</p>
<p>
<disp-formula id="disp-formula35-0954407012457899">
<label>(31)</label>
<mml:math display="block" id="math88-0954407012457899">
<mml:mrow>
<mml:mi>y</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi>f</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>ε</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">u</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mtext mathvariant="bold">x</mml:mtext>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∧</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>δ</mml:mi>
</mml:mrow>
<mml:mo>¯</mml:mo>
</mml:mover>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">w</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mtext mathvariant="bold">x</mml:mtext>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>j</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>12</mml:mn>
<mml:mo>,</mml:mo>
<mml:mo>…</mml:mo>
<mml:mo>,</mml:mo>
<mml:mi>m</mml:mi>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula35-0954407012457899" xlink:href="10.1177_0954407012457899-eq35.tif"/>
</disp-formula>
</p>
<p>where</p>
<p>
<disp-formula id="disp-formula36-0954407012457899">
<mml:math display="block" id="math89-0954407012457899">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">u</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:msubsup>
<mml:mrow>
<mml:mtext mathvariant="bold">a</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>*</mml:mo>
</mml:mrow>
</mml:msubsup>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mspace width="0.25em"/>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">w</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">b</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>f</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>x</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mrow>
<mml:mo>{</mml:mo>
<mml:mtable align="left">
<mml:mtr>
<mml:mtd columnalign="center">
<mml:mrow>
<mml:mn>1</mml:mn>
<mml:mo>,</mml:mo>
</mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mi>x</mml:mi>
<mml:mo>≥</mml:mo>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="center" columnspan="1">
<mml:mrow>
<mml:mn>0</mml:mn>
<mml:mo>,</mml:mo>
</mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mi>x</mml:mi>
<mml:mo>&lt;</mml:mo>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mrow>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula36-0954407012457899" xlink:href="10.1177_0954407012457899-eq36.tif"/>
</disp-formula>
</p>
</sec>
<sec id="section10-0954407012457899">
<title>Training algorithm of the constructive morphological neural network</title>
<p>Considering a given training data set <inline-formula id="inline-formula54-0954407012457899"><mml:math display="inline" id="math90-0954407012457899"><mml:mrow><mml:mtext mathvariant="bold">X</mml:mtext><mml:mo>=</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:msup><mml:mrow><mml:mtext mathvariant="bold">x</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mtext mathvariant="bold">x</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mtext mathvariant="bold">x</mml:mtext></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">}</mml:mo><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, let <inline-formula id="inline-formula55-0954407012457899"><mml:math display="inline" id="math91-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mtext mathvariant="bold">C</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>and <inline-formula id="inline-formula56-0954407012457899"><mml:math display="inline" id="math92-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mtext mathvariant="bold">C</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> denote the samples belonging to the first class and the second class respectively. In the training process, we intend to construct two families of hyper-boxes <inline-formula id="inline-formula57-0954407012457899"><mml:math display="inline" id="math93-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mtext mathvariant="bold">B</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">b</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">b</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mspace width="0.25em"/><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mspace width="0.25em"/><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">b</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="inline-formula58-0954407012457899"><mml:math display="inline" id="math94-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mtext mathvariant="bold">B</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">b</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mspace width="0.25em"/><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">b</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mspace width="0.25em"/><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">b</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math></inline-formula> in <inline-formula id="inline-formula59-0954407012457899"><mml:math display="inline" id="math95-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, such that <inline-formula id="inline-formula60-0954407012457899"><mml:math display="inline" id="math96-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mtext mathvariant="bold">B</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> contains all the samples belonging to the first class and <inline-formula id="inline-formula61-0954407012457899"><mml:math display="inline" id="math97-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mtext mathvariant="bold">B</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> contains all the samples belonging to the second class. In this work, we shall find first the hyper-box <inline-formula id="inline-formula62-0954407012457899"><mml:math display="inline" id="math98-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mtext mathvariant="bold">B</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> and then the hyper-box <inline-formula id="inline-formula63-0954407012457899"><mml:math display="inline" id="math99-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mtext mathvariant="bold">B</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>.</p>
<p>A practical training algorithm has been developed by Sussner and Esmi<sup><xref ref-type="bibr" rid="bibr40-0954407012457899">40</xref>,<xref ref-type="bibr" rid="bibr41-0954407012457899">41</xref>,<xref ref-type="bibr" rid="bibr43-0954407012457899">43</xref></sup> and Sussner.<sup><xref ref-type="bibr" rid="bibr44-0954407012457899">44</xref></sup> Our algorithm is derived from their work, but it is a little different from their method. The procedures of the training algorithm for CMNN presented in this work are given as follows.</p>
<p>In the beginning, we initialize the set <inline-formula id="inline-formula64-0954407012457899"><mml:math display="inline" id="math100-0954407012457899"><mml:mrow><mml:mtext mathvariant="bold">C</mml:mtext><mml:mo>=</mml:mo><mml:mi>X</mml:mi></mml:mrow></mml:math></inline-formula>, <inline-formula id="inline-formula65-0954407012457899"><mml:math display="inline" id="math101-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mtext mathvariant="bold">B</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mi>Φ</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
<p>When <inline-formula id="inline-formula66-0954407012457899"><mml:math display="inline" id="math102-0954407012457899"><mml:mrow><mml:mtext mathvariant="bold">C</mml:mtext><mml:mo>≠</mml:mo><mml:mi>Φ</mml:mi></mml:mrow></mml:math></inline-formula>, we proceed as follows.</p>
<list id="list1-0954407012457899" list-type="order">
<list-item><p>Find all the samples belonging to the first class in <inline-formula id="inline-formula67-0954407012457899"><mml:math display="inline" id="math103-0954407012457899"><mml:mrow><mml:mtext mathvariant="bold">C</mml:mtext></mml:mrow></mml:math></inline-formula>; denote it as <inline-formula id="inline-formula68-0954407012457899"><mml:math display="inline" id="math104-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">C</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mtext mathvariant="bold">C</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>∩</mml:mo><mml:mtext mathvariant="bold">C</mml:mtext></mml:mrow></mml:math></inline-formula>. Compute the smallest hyper-box <inline-formula id="inline-formula69-0954407012457899"><mml:math display="inline" id="math105-0954407012457899"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mspace width="0.25em"/><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mspace width="0.25em"/><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">b</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mo>∧</mml:mo><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">C</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mspace width="0.25em"/><mml:mo>∨</mml:mo><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">C</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> containing all the samples belonging to the first class.</p></list-item>
<list-item><p>Find all the samples belonging to the second class contained in <inline-formula id="inline-formula70-0954407012457899"><mml:math display="inline" id="math106-0954407012457899"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mspace width="0.25em"/><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mspace width="0.25em"/><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">b</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>; denote as <inline-formula id="inline-formula71-0954407012457899"><mml:math display="inline" id="math107-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">C</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>.</p></list-item>
<list-item><p>If <inline-formula id="inline-formula72-0954407012457899"><mml:math display="inline" id="math108-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">C</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mi>Φ</mml:mi></mml:mrow></mml:math></inline-formula>, then add <inline-formula id="inline-formula73-0954407012457899"><mml:math display="inline" id="math109-0954407012457899"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mspace width="0.25em"/><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mspace width="0.25em"/><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">b</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula id="inline-formula74-0954407012457899"><mml:math display="inline" id="math110-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mtext mathvariant="bold">B</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>.</p></list-item>
<list-item><p>If <inline-formula id="inline-formula75-0954407012457899"><mml:math display="inline" id="math111-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">C</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>≠</mml:mo><mml:mi>Φ</mml:mi></mml:mrow></mml:math></inline-formula>, compute the smallest hyper-box <inline-formula id="inline-formula76-0954407012457899"><mml:math display="inline" id="math112-0954407012457899"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mspace width="0.25em"/><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">b</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mspace width="0.25em"/><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mo>∧</mml:mo><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">C</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mspace width="0.25em"/><mml:mo>∨</mml:mo><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">C</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>.</p></list-item>
<list-item><p>Compute the half-space of <inline-formula id="inline-formula77-0954407012457899"><mml:math display="inline" id="math113-0954407012457899"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mspace width="0.25em"/><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">b</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mspace width="0.25em"/><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> according to</p>
<p>
<disp-formula id="disp-formula37-0954407012457899">
<label>(32)</label>
<mml:math display="block" id="math114-0954407012457899">
<mml:mrow>
<mml:msubsup>
<mml:mrow>
<mml:mtext mathvariant="bold">H</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>−</mml:mo>
</mml:mrow>
</mml:msubsup>
<mml:mo stretchy="false">(</mml:mo>
<mml:msup>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mtext mathvariant="bold">a</mml:mtext>
</mml:mrow>
<mml:mo>¯</mml:mo>
</mml:mover>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msup>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">{</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext mathvariant="bold">x</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mrow>
<mml:mo>|</mml:mo>
<mml:mspace width="0.25em"/>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">x</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mo>&lt;</mml:mo>
<mml:msubsup>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mtext mathvariant="bold">a</mml:mtext>
</mml:mrow>
<mml:mo>¯</mml:mo>
</mml:mover>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msubsup>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">}</mml:mo>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mspace width="0.25em"/>
<mml:mtext mathvariant="bold">x</mml:mtext>
<mml:mo>∈</mml:mo>
<mml:msup>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mtext mathvariant="bold">C</mml:mtext>
</mml:mrow>
<mml:mo>¯</mml:mo>
</mml:mover>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msup>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mspace width="0.25em"/>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>,</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo>,</mml:mo>
<mml:mo>…</mml:mo>
<mml:mo>,</mml:mo>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula37-0954407012457899" xlink:href="10.1177_0954407012457899-eq37.tif"/>
</disp-formula>
</p>
<p>
<disp-formula id="disp-formula38-0954407012457899">
<label>(33)</label>
<mml:math display="block" id="math115-0954407012457899">
<mml:mrow>
<mml:msubsup>
<mml:mrow>
<mml:mtext mathvariant="bold">H</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>+</mml:mo>
</mml:mrow>
</mml:msubsup>
<mml:mo stretchy="false">(</mml:mo>
<mml:msup>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mtext mathvariant="bold">b</mml:mtext>
</mml:mrow>
<mml:mo>¯</mml:mo>
</mml:mover>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msup>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">{</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mtext mathvariant="bold">x</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mrow>
<mml:mo>|</mml:mo>
<mml:mspace width="0.25em"/>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">x</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mo>&gt;</mml:mo>
<mml:msubsup>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mtext mathvariant="bold">b</mml:mtext>
</mml:mrow>
<mml:mo>¯</mml:mo>
</mml:mover>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msubsup>
<mml:mspace width="0.25em"/>
<mml:mo stretchy="false">}</mml:mo>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mspace width="0.25em"/>
<mml:mtext mathvariant="bold">x</mml:mtext>
<mml:mo>∈</mml:mo>
<mml:msup>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mtext mathvariant="bold">C</mml:mtext>
</mml:mrow>
<mml:mo>¯</mml:mo>
</mml:mover>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msup>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mspace width="0.25em"/>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>,</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo>,</mml:mo>
<mml:mo>…</mml:mo>
<mml:mo>,</mml:mo>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula38-0954407012457899" xlink:href="10.1177_0954407012457899-eq38.tif"/>
</disp-formula>
</p>
<p>In this way, we can obtain 2<italic>n</italic> subsets containing only samples belonging to the first class; denote as <inline-formula id="inline-formula78-0954407012457899"><mml:math display="inline" id="math116-0954407012457899"><mml:mrow><mml:mtext mathvariant="bold">H</mml:mtext><mml:mo>=</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mrow><mml:mtext mathvariant="bold">H</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mtext mathvariant="bold">H</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mtext mathvariant="bold">H</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math></inline-formula>.</p></list-item>
<list-item><p>If <inline-formula id="inline-formula79-0954407012457899"><mml:math display="inline" id="math117-0954407012457899"><mml:mrow><mml:msub><mml:mrow><mml:mtext mathvariant="bold">H</mml:mtext></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>≠</mml:mo><mml:mi>Φ</mml:mi><mml:mo>,</mml:mo><mml:mspace width="0.25em"/><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>, compute the smallest hyper-box containing <inline-formula id="inline-formula80-0954407012457899"><mml:math display="inline" id="math118-0954407012457899"><mml:mrow><mml:msub><mml:mrow><mml:mtext mathvariant="bold">H</mml:mtext></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> according to</p>
<p>
<disp-formula id="disp-formula39-0954407012457899">
<label>(34)</label>
<mml:math display="block" id="math119-0954407012457899">
<mml:mrow>
<mml:mo stretchy="false">[</mml:mo>
<mml:msubsup>
<mml:mrow>
<mml:mtext mathvariant="bold">a</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msubsup>
<mml:mo>,</mml:mo>
<mml:msubsup>
<mml:mrow>
<mml:mtext mathvariant="bold">b</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msubsup>
<mml:mo stretchy="false">]</mml:mo>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">[</mml:mo>
<mml:mo>∧</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">H</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mo>∨</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">H</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">]</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula39-0954407012457899" xlink:href="10.1177_0954407012457899-eq39.tif"/>
</disp-formula>
</p></list-item>
<list-item><p>Add the hyper-boxes <inline-formula id="inline-formula81-0954407012457899"><mml:math display="inline" id="math120-0954407012457899"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">b</mml:mtext></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula id="inline-formula82-0954407012457899"><mml:math display="inline" id="math121-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mtext mathvariant="bold">B</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>.</p></list-item>
<list-item><p>Then set <inline-formula id="inline-formula83-0954407012457899"><mml:math display="inline" id="math122-0954407012457899"><mml:mrow><mml:mtext mathvariant="bold">C</mml:mtext><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">C</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>.</p></list-item>
</list>
<p>End.</p>
<p>In <xref ref-type="fig" rid="fig4-0954407012457899">Figure 4</xref> the first iteration of the training procedure in <inline-formula id="inline-formula84-0954407012457899"><mml:math display="inline" id="math123-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> is visualized. The first-class patterns are represented using open circles. The second-class 2 patterns are repesented using plus symbols. The two rectangular solid boxes represents the hyper-boxes <inline-formula id="inline-formula85-0954407012457899"><mml:math display="inline" id="math124-0954407012457899"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mspace width="0.25em"/><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mspace width="0.25em"/><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">b</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="inline-formula86-0954407012457899"><mml:math display="inline" id="math125-0954407012457899"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mspace width="0.25em"/><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">b</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mspace width="0.25em"/><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> respectively, and the two rectangular dashed boxes are two hyper-boxes which lie in the half-space <inline-formula id="inline-formula87-0954407012457899"><mml:math display="inline" id="math126-0954407012457899"><mml:mrow><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">H</mml:mtext></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mspace width="0.25em"/><mml:mspace width="0.25em"/><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>.</p>
<fig id="fig4-0954407012457899" position="float">
<label>Figure 4.</label>
<caption>
<p>Illustration of the training process, where the open circles and the plus symbols represent the patterns belonging to the first class and the second class respectively, <inline-formula id="inline-formula88-0954407012457899"><mml:math display="inline" id="math127-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mspace width="0.25em"/><mml:mtext>and</mml:mtext><mml:mspace width="0.25em"/><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">b</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>denote the lower vertex and the upper vertex respectively of the hyper-box containing all the patterns belonging to the first class, <inline-formula id="inline-formula89-0954407012457899"><mml:math display="inline" id="math128-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mtext>and</mml:mtext><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">b</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>denote the lower vertex and upper vertex respectively of the hyper-box containing all the patterns belong to the second class, <inline-formula id="inline-formula90-0954407012457899"><mml:math display="inline" id="math129-0954407012457899"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">b</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> denotes the hyper-box containing all the patterns belonging to the first class in the half-space <inline-formula id="inline-formula91-0954407012457899"><mml:math display="inline" id="math130-0954407012457899"><mml:mrow><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">H</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>, and <inline-formula id="inline-formula92-0954407012457899"><mml:math display="inline" id="math131-0954407012457899"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">b</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> denotes the hyper-box containing all the patterns belonging to the first class in the half-space <inline-formula id="inline-formula93-0954407012457899"><mml:math display="inline" id="math132-0954407012457899"><mml:mrow><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">H</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>.</p>
</caption>
<graphic xlink:href="10.1177_0954407012457899-fig4.tif"/>
</fig>
<p>After the convergence of the above training procedure, we can obtain a family of hyper-boxes <inline-formula id="inline-formula94-0954407012457899"><mml:math display="inline" id="math133-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mtext mathvariant="bold">B</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">b</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mspace width="0.25em"/><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">b</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mspace width="0.25em"/><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mspace width="0.25em"/><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">b</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math></inline-formula>, which contains all the samples belonging to the first class. By simply reversing the class labels of the first class and the second class, we can also obtain a family of hyper-boxes <inline-formula id="inline-formula95-0954407012457899"><mml:math display="inline" id="math134-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mtext mathvariant="bold">B</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">b</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mspace width="0.25em"/><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">b</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mspace width="0.25em"/><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mspace width="0.25em"/><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">b</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math></inline-formula> containing all the samples belonging to the second class, by repeating the above training procedure.</p>
<p>This training procedure can be extended easily to multi-class classification problems. Suppose that there are <italic>S</italic> classes in the training data set <bold>X</bold>, denoted as <inline-formula id="inline-formula96-0954407012457899"><mml:math display="inline" id="math135-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mtext mathvariant="bold">C</mml:mtext></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mspace width="0.25em"/><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula>. We intend to construct <italic>S</italic> families of hyper-boxes <inline-formula id="inline-formula97-0954407012457899"><mml:math display="inline" id="math136-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mtext mathvariant="bold">B</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mtext mathvariant="bold">B</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mtext mathvariant="bold">B</mml:mtext></mml:mrow><mml:mrow><mml:mi>S</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, in which <inline-formula id="inline-formula98-0954407012457899"><mml:math display="inline" id="math137-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mtext mathvariant="bold">B</mml:mtext></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">b</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mspace width="0.25em"/><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">b</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mspace width="0.25em"/><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mspace width="0.25em"/><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">b</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math></inline-formula> contains only all samples of the <italic>s</italic>th class. When constructing hyper-boxes for the <italic>s</italic>th class, we simply set <inline-formula id="inline-formula99-0954407012457899"><mml:math display="inline" id="math138-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mtext mathvariant="bold">C</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mtext mathvariant="bold">C</mml:mtext></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="inline-formula100-0954407012457899"><mml:math display="inline" id="math139-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mtext mathvariant="bold">C</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:msup><mml:mrow><mml:mtext mathvariant="bold">C</mml:mtext></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mrow><mml:mo>|</mml:mo><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mo>;</mml:mo></mml:mrow><mml:mspace width="0.25em"/><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math></inline-formula>. Then we just repeat the training procedure for <italic>S</italic> times to obtain the <italic>S</italic> families of hyper-boxes.</p>
<p>In the testing phase, given a testing vector <inline-formula id="inline-formula101-0954407012457899"><mml:math display="inline" id="math140-0954407012457899"><mml:mrow><mml:mtext mathvariant="bold">x</mml:mtext><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, we compute the output of the <italic>s</italic>th module, as shown in <xref ref-type="fig" rid="fig5-0954407012457899">Figure 5</xref>, ccording to</p>
<fig id="fig5-0954407012457899" position="float">
<label>Figure 5.</label>
<caption>
<p>The architecture of the CMNN module corresponding to the <italic>s</italic>th class.</p>
</caption>
<graphic xlink:href="10.1177_0954407012457899-fig5.tif"/>
</fig>
<p>
<disp-formula id="disp-formula40-0954407012457899">
<label>(35)</label>
<mml:math display="block" id="math141-0954407012457899">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>y</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>ε</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:msubsup>
<mml:mrow>
<mml:mtext mathvariant="bold">u</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mtext mathvariant="bold">x</mml:mtext>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>∧</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>δ</mml:mi>
</mml:mrow>
<mml:mo>¯</mml:mo>
</mml:mover>
</mml:mrow>
<mml:mrow>
<mml:msubsup>
<mml:mrow>
<mml:mtext mathvariant="bold">w</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mtext mathvariant="bold">x</mml:mtext>
<mml:mo stretchy="false">)</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>j</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>,</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo>,</mml:mo>
<mml:mo>…</mml:mo>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>s</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>,</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo>,</mml:mo>
<mml:mo>…</mml:mo>
<mml:mo>,</mml:mo>
<mml:mi>S</mml:mi>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula40-0954407012457899" xlink:href="10.1177_0954407012457899-eq40.tif"/>
</disp-formula>
</p>
<p>where <inline-formula id="inline-formula102-0954407012457899"><mml:math display="inline" id="math142-0954407012457899"><mml:mrow><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">u</mml:mtext></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">a</mml:mtext></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="inline-formula103-0954407012457899"><mml:math display="inline" id="math143-0954407012457899"><mml:mrow><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">w</mml:mtext></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="bold">b</mml:mtext></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>.</p>
<p>Then we can assign <inline-formula id="inline-formula104-0954407012457899"><mml:math display="inline" id="math144-0954407012457899"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:math></inline-formula> to the class <italic>s</italic> according to the rule (as shown in <xref ref-type="fig" rid="fig6-0954407012457899">Figure 6</xref>)</p>
<fig id="fig6-0954407012457899" position="float">
<label>Figure 6.</label>
<caption>
<p>The architecture of CMNN for multi-class tasks.</p>
</caption>
<graphic xlink:href="10.1177_0954407012457899-fig6.tif"/>
</fig>
<p>
<disp-formula id="disp-formula41-0954407012457899">
<label>(36)</label>
<mml:math display="block" id="math145-0954407012457899">
<mml:mrow>
<mml:mi>y</mml:mi>
<mml:mo>=</mml:mo>
<mml:munder>
<mml:mrow>
<mml:mtext>argmax</mml:mtext>
<mml:mspace width="0.25em"/>
</mml:mrow>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
</mml:munder>
<mml:msub>
<mml:mrow>
<mml:mi>y</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>s</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>,</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo>,</mml:mo>
<mml:mo>…</mml:mo>
<mml:mo>,</mml:mo>
<mml:mi>S</mml:mi>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula41-0954407012457899" xlink:href="10.1177_0954407012457899-eq41.tif"/>
</disp-formula>
</p>
</sec>
<sec id="section11-0954407012457899">
<title>A simple illustration of a CMNN for a simulated data set</title>
<p><xref ref-type="fig" rid="fig7-0954407012457899">Figure 7</xref> shows a three-class problem in two dimensions solved by the CMNN model. The dots denote the first class, the asterisks the second class and the plus symbols the third class. In the training phase, for each class, the CMNN generates a series of hyper-boxes which cover all the patterns belonging to the same class. The number of convergence steps of the CMNN model for generating the three families of hyper-boxes are three, seven and four respectively. Consequently, five, 24 and13 hyper-boxes are constructed by the CMNN for the first class, the second class and the third class respectively.</p>
<fig id="fig7-0954407012457899" position="float">
<label>Figure 7.</label>
<caption>
<p>Illustration of a CMNN for a three-class problem in two-dimensional space.</p>
</caption>
<graphic xlink:href="10.1177_0954407012457899-fig7.tif"/>
</fig>
<p>The three families of hyper-boxes for the three classes are displayed in <xref ref-type="fig" rid="fig7-0954407012457899">Figure 7</xref> with differently shaded areas. It can be observed that all the training patterns belonging to the same class are covered by the same family of hyper-boxes. In the testing phase, for a given pattern <bold>x</bold>, we can classify <bold>x</bold> as a certain class according to <xref ref-type="disp-formula" rid="disp-formula40-0954407012457899">equation (35)</xref> and <xref ref-type="disp-formula" rid="disp-formula41-0954407012457899">equation (36)</xref>.</p>
</sec>
</sec>
<sec id="section12-0954407012457899">
<title>Experimental results</title>
<sec id="section13-0954407012457899">
<title>Experimental system of the engine</title>
<p>To evaluate the performance of the presented feature extraction scheme, we conduct experiments on an F3L912 engine with three cylinders. Eight engine running conditions (an engine with no faults; first cylinder misfire; second cylinder misfire; first and second cylinders misfire; too large a clearance of the intake valve; too large a clearance of the exhaust valve; air leakage of intake valve; air leakage of an exhaust valve) are tested in the experiment. All the valve defects are set on the first cylinder. The running speed is set at 1200 r/min.</p>
<p>Vibration data are collected using accelerometers, which are attached to the cylinder head near the first cylinder with magnetic bases. The sample frequency is 40,000. A working cycle is recorded as a sample, which includes 4096 sample points. 40 samples are recorded for every condition of the engine, giving in total 320 samples. <xref ref-type="fig" rid="fig8-0954407012457899">Figure 8</xref> demonstrates the waveform of the vibration signal from the eight engine conditions. The main components including the engine ignition signal of the first cylinder and the second cylinder, the impact signals of the intake valve and exhaust valve sites are shown in <xref ref-type="fig" rid="fig8-0954407012457899">Figure 8</xref>.</p>
<fig id="fig8-0954407012457899" position="float">
<label>Figure 8.</label>
<caption>
<p>Original vibration signals acquired from the engine under eight operating states: (a) an engine with no faults; (b) first cylinder misfire; (c) second cylinder misfire; (d) first and second cylinders misfire; (e) too large a clearance of the intake valve; (f) too large a clearance of the exhaust valve; (g) air leakage of the intake valve; (h) air leakage of the exhaust valve.</p>
</caption>
<graphic xlink:href="10.1177_0954407012457899-fig8.tif"/>
</fig>
</sec>
<sec id="section14-0954407012457899">
<title>Feature extraction using the AMMG filter and NMF</title>
<p>In this section, the vibration signals acquired from the engine were first processed by the AMMG filter described in the second section. The unit SE used in this work is the flat structure element <inline-formula id="inline-formula105-0954407012457899"><mml:math display="inline" id="math146-0954407012457899"><mml:mrow><mml:mi>g</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math></inline-formula>. The analysed scale of the AMMG filter is set to 1–25 based on a series of tests.</p>
<p>In order to demonstrate the superiority of AMMG filters over traditional MMG filters, a comparison is made in <xref ref-type="fig" rid="fig9-0954407012457899">Figure 9</xref>. The original vibration signal from engine with no faults is given in <xref ref-type="fig" rid="fig9-0954407012457899">Figure 9(a)</xref>. The signals processed by an MG filter with SEs on scale 5 and scale 25 are shown in <xref ref-type="fig" rid="fig9-0954407012457899">Figure 9(b)</xref> and <xref ref-type="fig" rid="fig9-0954407012457899">(c)</xref> respectively. The signal processed by an AMMG filter is displayed in <xref ref-type="fig" rid="fig9-0954407012457899">Figure 9(d)</xref>. It can be found that the impulsive details can be maintained but the noise cannot be depressed effectively when using small-scale SEs for the MG filter, as shown in <xref ref-type="fig" rid="fig9-0954407012457899">Figure 9(b)</xref>. On the contrary, when the scale is too large, the MG filter can depress the noise effectively but it will blur the impulsive details, as shown in <xref ref-type="fig" rid="fig9-0954407012457899">Figure 9(c)</xref>. The AMMG filter is designed to combine the signals processed by the MG filter with SEs of different scales; thus the impulsive features can be preserved and the noise can be depressed simultaneously, as shown in <xref ref-type="fig" rid="fig9-0954407012457899">Figure 9(d)</xref>.</p>
<fig id="fig9-0954407012457899" position="float">
<label>Figure 9.</label>
<caption>
<p>Vibration signals acquired from an engine with no faults processed by traditional MMG filters and AMMG: (a) original vibration signal; (b) results processed by an MG filter with an SE on scale 5; (c) results processed by an MG filter with an SE on scale 25; (d) results processed by an AMMG filter.</p>
</caption>
<graphic xlink:href="10.1177_0954407012457899-fig9.tif"/>
</fig>
<p><xref ref-type="fig" rid="fig10-0954407012457899">Figure 10</xref> displays the signals from eight engine states processed by an AMMG filter. It can be observed obviously that the impulsive components in the original vibration signals are enhanced, while the noise is depressed effectively. Consequently, the characteristics of the different engine states are indicated more clearly.</p>
<fig id="fig10-0954407012457899" position="float">
<label>Figure 10.</label>
<caption>
<p>AMMG-processed vibration signals from an engine in eight operating states: (a) an engine with no faults; (b) first cylinder misfire; (c) second cylinder misfire; (d) first and second cylinders misfire; (e) too large a clearance of the intake valve; (f) too large a clearance of the exhaust valve; (g) air leakage of the intake valve; (h) air leakage of the exhaust valve.</p>
</caption>
<graphic xlink:href="10.1177_0954407012457899-fig10.tif"/>
</fig>
<p>Then the NMF method is employed for feature extraction from the signals processed by the AMMG filter. Five samples of each engine state (in total, 40 samples) are selected to form the training matrix <bold>V</bold>. The training samples selected are shown in <xref ref-type="fig" rid="fig11-0954407012457899">Figure 11</xref>, in which each row represents one engine state.</p>
<fig id="fig11-0954407012457899" position="float">
<label>Figure 11.</label>
<caption>
<p>The training samples of engine for NMF, each row containing five samples from one engine state: (a) an engine with no faults; (b) first cylinder misfire; (c) second cylinder misfire; (d) first and second cylinders misfire; (e) too large a clearance of the intake valve; (f) too large a clearance of the exhaust valve; (g) air leakage of the intake valve; (h) air leakage of the exhaust valve.</p>
</caption>
<graphic xlink:href="10.1177_0954407012457899-fig11.tif"/>
</fig>
<p>According to the NMF scheme, the training matrix <inline-formula id="inline-formula106-0954407012457899"><mml:math display="inline" id="math147-0954407012457899"><mml:mrow><mml:mtext mathvariant="bold">V</mml:mtext></mml:mrow></mml:math></inline-formula> can be decomposed to two smaller matrices according to</p>
<p>
<disp-formula id="disp-formula42-0954407012457899">
<label>(37)</label>
<mml:math display="block" id="math148-0954407012457899">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">V</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mn>4096</mml:mn>
<mml:mspace width="0.25em"/>
<mml:mo>×</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mn>40</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">W</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mn>4096</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:mspace width="0.25em"/>
<mml:mo>×</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">H</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>r</mml:mi>
<mml:mspace width="0.25em"/>
<mml:mo>×</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mn>40</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula42-0954407012457899" xlink:href="10.1177_0954407012457899-eq42.tif"/>
</disp-formula>
</p>
<p>The matrix <inline-formula id="inline-formula107-0954407012457899"><mml:math display="inline" id="math149-0954407012457899"><mml:mrow><mml:msub><mml:mrow><mml:mtext mathvariant="bold">W</mml:mtext></mml:mrow><mml:mrow><mml:mn>4096</mml:mn><mml:mspace width="0.25em"/><mml:mo>×</mml:mo><mml:mspace width="0.25em"/><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> can be regarded as the basis matrix and <inline-formula id="inline-formula108-0954407012457899"><mml:math display="inline" id="math150-0954407012457899"><mml:mrow><mml:msub><mml:mrow><mml:mtext mathvariant="bold">H</mml:mtext></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mspace width="0.25em"/><mml:mo>×</mml:mo><mml:mspace width="0.25em"/><mml:mn>40</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> as the coefficient matrix.</p>
<p>It should be noted that there is still no criterion to determine the dimensional parameter <italic>r</italic> in the literature. One possible solution is setting <italic>r</italic> to be a variable and selecting the value yielding the best performance. In this work, we set the dimensional parameter <inline-formula id="inline-formula109-0954407012457899"><mml:math display="inline" id="math151-0954407012457899"><mml:mrow><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mn>8</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>32</mml:mn><mml:mo>,</mml:mo><mml:mn>36</mml:mn><mml:mo>,</mml:mo><mml:mn>40</mml:mn></mml:mrow></mml:math></inline-formula>. In this way, 10 feature subsets with different dimension can be obtained by NMF and we should select one feature subset yielding the highest classification accuracy. Taking <italic>r</italic> = 32 for example, each sample can be represented by a 32-dimensional feature vector, which can be used as inputs for classifiers. <xref ref-type="fig" rid="fig12-0954407012457899">Figure 12</xref> gives the 32 basic vectors obtained by NMF, and the coefficient vectors of each training sample are demonstrated in <xref ref-type="fig" rid="fig13-0954407012457899">Figure 13</xref>.</p>
<fig id="fig12-0954407012457899" position="float">
<label>Figure 12.</label>
<caption>
<p>The basic vectors obtained by NMF.</p>
</caption>
<graphic xlink:href="10.1177_0954407012457899-fig12.tif"/>
</fig>
<fig id="fig13-0954407012457899" position="float">
<label>Figure 13.</label>
<caption>
<p>The coefficient vectors obtained by NMF, each row containing five samples from one engine state: (a) an engine with no faults; (b) first cylinder misfire; (c) second cylinder misfire; (d) first and second cylinders misfire; (e) too large a clearance of the intake valve; (f) too large a clearance of the exhaust valve; (g) air leakage of the intake valve; (h) air leakage of the exhaust valve.</p>
</caption>
<graphic xlink:href="10.1177_0954407012457899-fig13.tif"/>
</fig>
<p>For training samples, every column vector in <bold>H</bold> can be regarded as extracted features for every sample. For the test sample data set <inline-formula id="inline-formula110-0954407012457899"><mml:math display="inline" id="math152-0954407012457899"><mml:mrow><mml:msub><mml:mrow><mml:mtext mathvariant="bold">S</mml:mtext></mml:mrow><mml:mrow><mml:mi>test</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, the extracted features can be obtained from</p>
<p>
<disp-formula id="disp-formula43-0954407012457899">
<label>(38)</label>
<mml:math display="block" id="math153-0954407012457899">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">H</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>test</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:msup>
<mml:mtext mathvariant="bold">W</mml:mtext>
<mml:mrow>
<mml:mo>+</mml:mo>
</mml:mrow>
</mml:msup>
<mml:msub>
<mml:mrow>
<mml:mtext mathvariant="bold">S</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mi>test</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula43-0954407012457899" xlink:href="10.1177_0954407012457899-eq43.tif"/>
</disp-formula>
</p>
<p>where <inline-formula id="inline-formula111-0954407012457899"><mml:math display="inline" id="math154-0954407012457899"><mml:mrow><mml:msup><mml:mrow><mml:mtext mathvariant="bold">W</mml:mtext></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> denotes the pseudo-inverse of the basis matrix <inline-formula id="inline-formula112-0954407012457899"><mml:math display="inline" id="math155-0954407012457899"><mml:mrow><mml:mtext mathvariant="bold">W</mml:mtext></mml:mrow></mml:math></inline-formula>. Thus every column vector in <inline-formula id="inline-formula113-0954407012457899"><mml:math display="inline" id="math156-0954407012457899"><mml:mrow><mml:msub><mml:mrow><mml:mtext mathvariant="bold">H</mml:mtext></mml:mrow><mml:mrow><mml:mi>test</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> can be regarded as extracted features for every sample. We denote the feature subset extracted by the AMMG filter and NMF as <inline-formula id="inline-formula114-0954407012457899"><mml:math display="inline" id="math157-0954407012457899"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>AMMG</mml:mi><mml:mo>−</mml:mo><mml:mi>NMF</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
<p>Moreover, some traditional feature extraction approaches are employed for comparison with the proposed method. It is not realistic to compare all the feature extraction methods in the literature. The statistical parameters and the wavelet transform have been the most popularly used techniques for mechanical fault diagnosis over the past few years.<sup><xref ref-type="bibr" rid="bibr8-0954407012457899">8</xref>,<xref ref-type="bibr" rid="bibr13-0954407012457899">13</xref>,<xref ref-type="bibr" rid="bibr45-0954407012457899">45</xref><xref ref-type="bibr" rid="bibr46-0954407012457899"/>–<xref ref-type="bibr" rid="bibr47-0954407012457899">47</xref></sup> Therefore we just incorporated the statistical analysis and wavelet transform to generate another feature subset for comparison. The details of these two techniques can be found in the above-mentioned studies. In this work, the db5 wavelet was utilized to decompose the original signal into a series of coefficients and the classical Mallat algorithm was used to implement the decomposition. The decomposition level was set to 3 and thus four coefficients can be obtained for each sample. Then 10 statistical parameters (the mean, standard derivation, r.m.s. value, maximum, skewness, kurtosis, crest factor, impulse factor, shape factor and clearance factor) were calculated for each coefficient. In this way, 40 features can be calculated for each sample. We denoted the feature subset extracted by wavelet transform and statistical analysis as <inline-formula id="inline-formula115-0954407012457899"><mml:math display="inline" id="math158-0954407012457899"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>wavelet</mml:mi><mml:mo>−</mml:mo><mml:mi>statistical</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
</sec>
<sec id="section15-0954407012457899">
<title>Classification performance of the CMNN in detecting engine defects</title>
<p>In this section, we evaluate the classification performance and computation cost of the CMNN model in detecting engine faults using the feature subsets <inline-formula id="inline-formula116-0954407012457899"><mml:math display="inline" id="math159-0954407012457899"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>AMMG</mml:mi><mml:mo>−</mml:mo><mml:mi>NMF</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="inline-formula117-0954407012457899"><mml:math display="inline" id="math160-0954407012457899"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>wavelet</mml:mi><mml:mo>−</mml:mo><mml:mi>statistical</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. We also conduct a comparison of the CMNN with a conventional ANN, an SVM and a DT. The CMNN was implemented by us with MATLAB software. All the other classifiers are implemented by utilizing PRTools 4.1.<sup><xref ref-type="bibr" rid="bibr48-0954407012457899">48</xref></sup></p>
<p>In all experiments, we considered an ANN with a single hidden layer with 20 neurons and a back-propagation training algorithm. We use the SVM with a radial basis function kernel, and the parameters of the SVM were optimized by a quadratic programming procedure. When using a DT, we select the purity splitting criterion and the pessimistic pruning rule. All other parameters of the above three classifiers were set to the default values.</p>
<p>As mentioned in the section on the experimental system of the engine, 320 samples were in the experiment. The data set was segmented into two parts: 160 samples (20 samples of each state) are employed as the training data set and the other 160 samples are used as the testing data set. We carried out this segmentation randomly 20 times to obtain more robust evaluation results. The computation costs of the CMNN, ANN, SVM and DT were also evaluated and compared. The experiments were conducted on a personal computer with a 2.93G Hz central processing unit (CPU) and 512 Mb memory. The computing software employed is MATLAB version 7.4.1.</p>
<p><xref ref-type="fig" rid="fig14-0954407012457899">Figure 14</xref> shows the classification accuracies of the ANN, SVM, DT and CMNN on the 10 feature subsets with different dimensions obtained by NMF in the section on feature extracion using the AMMG filter and NMF. It can be observed that the classification accuracies of all the classifiers do not always increase with increasing dimension parameter <italic>r</italic>. As can be seen in <xref ref-type="fig" rid="fig14-0954407012457899">Figure 14</xref>, the optimal feature subsets <inline-formula id="inline-formula118-0954407012457899"><mml:math display="inline" id="math161-0954407012457899"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>AMMG</mml:mi><mml:mo>−</mml:mo><mml:mi>NMF</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> for the ANN, SVM, DT and CMNN are obtained by NMF with the dimensional parameter <italic>r</italic> equal to 28, 40, 32 and 32 respectively.</p>
<fig id="fig14-0954407012457899" position="float">
<label>Figure 14.</label>
<caption>
<p>Classification accuracies of the ANN, SVM, DT and CMNN on feature subsets with different dimensions extracted by NMF.</p>
<p>ANN: artificial neural network; SVM: support vector machine; DT: decision tree; CMNN: constructive morphological neural network; NMF: non-negative matrix factorization.</p>
</caption>
<graphic xlink:href="10.1177_0954407012457899-fig14.tif"/>
</fig>
<p>The classification accuracies as well as the training and testing CPU times of the four classifiers for the two feature subsets <inline-formula id="inline-formula119-0954407012457899"><mml:math display="inline" id="math162-0954407012457899"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>AMMG</mml:mi><mml:mo>−</mml:mo><mml:mi>NMF</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="inline-formula120-0954407012457899"><mml:math display="inline" id="math163-0954407012457899"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>wavelet</mml:mi><mml:mo>−</mml:mo><mml:mi>statistical</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> are summarized in <xref ref-type="table" rid="table1-0954407012457899">Table 1</xref> and <xref ref-type="table" rid="table2-0954407012457899">Table 2</xref> respectively.</p>
<table-wrap id="table1-0954407012457899" position="float">
<label>Table 1.</label>
<caption>
<p>Classification results of the ANN, SVM, DT and CMNN using the feature subset <italic>F</italic><sub><italic>wavelet</italic><italic>–statistical</italic></sub> for engine fault diagnosis.</p>
</caption>
<graphic alternate-form-of="table1-0954407012457899" xlink:href="10.1177_0954407012457899-table1.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="left"/>
<col align="left"/>
<col align="left"/>
<col align="left"/>
</colgroup>
<thead>
<tr>
<th align="left">Classifier</th>
<th align="left">Training time (s)</th>
<th align="left">Testing time (s)</th>
<th align="left" colspan="2">Classification accuracy (%)<hr/></th>
</tr>
<tr>
<th/>
<th/>
<th/>
<th align="left">Training set</th>
<th align="left">Testing set</th>
</tr>
</thead>
<tbody>
<tr>
<td>ANN</td>
<td>1.3170</td>
<td>0.0152</td>
<td>88.8</td>
<td>77.2</td>
</tr>
<tr>
<td>SVM</td>
<td>0.4327</td>
<td>0.2641</td>
<td>90.27</td>
<td>86.1</td>
</tr>
<tr>
<td>DT</td>
<td>0.0151</td>
<td>0.0576</td>
<td>100</td>
<td>77.6</td>
</tr>
<tr>
<td>CMNN</td>
<td>0.0144</td>
<td>0.1197</td>
<td>100</td>
<td>85.4</td>
</tr>
</tbody>
</table>
<table-wrap-foot>
<fn id="table-fn1-0954407012457899">
<p>ANN: artificial neural network; SVM: support vector machine; DT: decision tree; CMNN: constructive morphological neural network.</p>
</fn>
</table-wrap-foot>
</table-wrap>
<table-wrap id="table2-0954407012457899" position="float">
<label>Table 2.</label>
<caption>
<p>Classification results of the ANN, SVM, DT and CMNN using feature subset the <italic>F</italic><sub><italic>AMMG–NMF</italic></sub> for engine fault diagnosis.</p>
</caption>
<graphic alternate-form-of="table2-0954407012457899" xlink:href="10.1177_0954407012457899-table2.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="left"/>
<col align="left"/>
<col align="left"/>
<col align="left"/>
</colgroup>
<thead>
<tr>
<th align="left">Classifier</th>
<th align="left">Training time (s)</th>
<th align="left">Testing time (s)</th>
<th align="left" colspan="2">Classification accuracy (%)<hr/></th>
</tr>
<tr>
<th/>
<th/>
<th/>
<th align="left">Training set</th>
<th align="left">Testing set</th>
</tr>
</thead>
<tbody>
<tr>
<td>ANN</td>
<td>0.7453</td>
<td>0.0137</td>
<td>95.2</td>
<td>90.2</td>
</tr>
<tr>
<td>SVM</td>
<td>0.5234</td>
<td>0.2678</td>
<td>96.4</td>
<td>93.2</td>
</tr>
<tr>
<td>DT</td>
<td>0.0245</td>
<td>0.0705</td>
<td>100</td>
<td>87.25</td>
</tr>
<tr>
<td>CMNN</td>
<td>0.0056</td>
<td>0.0708</td>
<td>100</td>
<td>92</td>
</tr>
</tbody>
</table>
<table-wrap-foot>
<fn id="table-fn2-0954407012457899">
<p>ANN: artificial neural network; SVM: support vector machine; DT: decision tree; CMNN: constructive morphological neural network.</p>
</fn>
</table-wrap-foot>
</table-wrap>
<p>It should be noted that the performances of the four classifiers based on <inline-formula id="inline-formula121-0954407012457899"><mml:math display="inline" id="math164-0954407012457899"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>AMMG</mml:mi><mml:mo>−</mml:mo><mml:mi>NMF</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> outperform those based on <inline-formula id="inline-formula122-0954407012457899"><mml:math display="inline" id="math165-0954407012457899"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>wavelet</mml:mi><mml:mo>−</mml:mo><mml:mi>statistical</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> clearly. The highest classification rates obtained using <inline-formula id="inline-formula123-0954407012457899"><mml:math display="inline" id="math166-0954407012457899"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>AMMG</mml:mi><mml:mo>−</mml:mo><mml:mi>NMF</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is 93.2%, which is higher than 86.1% which is obtained using <inline-formula id="inline-formula124-0954407012457899"><mml:math display="inline" id="math167-0954407012457899"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>wavelet</mml:mi><mml:mo>−</mml:mo><mml:mi>statistical</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. It indicates that the presented feature extraction scheme combining the AMMG filter and NMF has a superior capacity to represent and distinguish between the different engine operating states.</p>
<p>Furthermore, we can find that the CMNN exhibits satisfactory classification results over all the two feature subsets. The training patterns can be perfectly separated by CMNN with 100% classification accuracy and the testing patterns are also well classified. Similar performances are achieved by the conventional ANN model and SVM. The DT gives the worst results of the four classifiers in our experiments, but it requires much less training time than do the ANN and SVM.</p>
</sec>
<sec id="section16-0954407012457899">
<title>Discussion</title>
<p>According to our experimental results, some attractive properties of the presented engine fault diagnosis scheme can be summarized as follows.</p>
<list id="list2-0954407012457899" list-type="order">
<list-item><p>The feature subset extracted by combining the AMMG filter and NMF yields a better performance than do traditional methods. There are two main reasons for this result. First, the AMMG filter can enhance the impulsive components and depress noise in the original engine vibration signals simultaneously. Second, NMF has a satisfactory capacity to characterize the signal for identifying the different engine states.</p></list-item>
<list-item><p>One problem of the presented feature extraction scheme is the selection of the dimensional parameter <italic>r</italic> for NMF. As mentioned in the section on feature extracion using the AMMG filter and NMF, there is no criterion to determine this parameter. Therefore we have to make more experiments on evaluating the performances of the preset parameters and select one parameter corresponding to the best performance. Future work should be focused on selecting the dimensional parameter <italic>r</italic> for NMF more efficiently.</p></list-item>
<list-item><p>The CMNN yields a perfect classification of training patterns, as well as a satisfactory performance of testing samples. It indicates that the CMNN has a superior learning and generalizing capacity for classifying patterns, which means the engine faults in this work.</p></list-item>
<list-item><p>The computation cost of the CMNN is significantly lower than those of the ANN and SVM. One reason is that the main operators involved in the CMNN is the minimax algebra operators (i.e. the minimum, maximum, addition and subtraction operators), which require much less calculation cost than do the semilinear operators involved in a conventional ANN and SVM. Another reason is that the CMNN can converge in a few steps by using the presented training algorithm.</p></list-item>
<list-item><p>No parameters need to be tuned for CMNN, in which the hidden neurons are constructed automatically during the training procedure. This makes the CMNN a very simple approach, which requires much less expertise knowledge than do ANN and SVM in application.</p></list-item>
</list>
</sec>
</sec>
<sec id="section17-0954407012457899" sec-type="conclusions">
<title>Conclusion</title>
<p>The main contribution of this work develops a new feature extraction and classification scheme for engine fault diagnosis based on mathematical morphology and NMF. In particular, the AMMG filter, which can enhance the impulsive features and depress the noise simultaneously, is proposed to enhance the impulsive components in engine vibration signals. Then a new feature extraction technique (i.e. the NMF technique), which has been widely used in the pattern recognition area, is utilized to characterize the vibration signals processed by the AMMG filter. Finally, an entirely new type of neural network, the CMNN, is employed to classify the different engine operating states based on the feature subsets obtained by the AMMG filter and NMF.</p>
<p>We conducted experiments on an engine test rig, in which eight engine states were tested, to evaluate and compare the proposed feature extraction and classification scheme with the conventional approaches. Experimental results showed that the AMMG filter combined with the NMF technique to be an effective feature extraction approach to characterize and distinguish between the vibration signals acquired from the engine with various operating conditions. It also demonstrated the excellent classification accuracy and fast computation capacity of the presented CMNN over conventional classifiers in engine fault diagnosis problems.</p>
<p>Our study has demonstrated clearly that the presented fault diagnosis scheme is an efficient and effective technique for engine fault diagnosis. Therefore, the proposed method has a great potential to be an effective online condition-monitoring and diagnostic tool for engine and other mechanical components in industry applications.</p>
</sec>
</body>
<back>
<fn-group>
<fn fn-type="financial-disclosure">
<label>Funding</label>
<p>This research is supported by the National Natural Science Foundation of China (grant number 50705097) and the Natural Science Foundation of He-bei Province (grant number E2007001048).</p>
</fn>
</fn-group>
<ref-list>
<title>References</title>
<ref id="bibr1-0954407012457899">
<label>1.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Jones</surname><given-names>NB</given-names></name>
<name><surname>Li</surname><given-names>YH</given-names></name>
</person-group>. <article-title>A review of condition monitoring and fault diagnosis for diesel engines</article-title>. <source>Tribotest</source> <year>2000</year>; <volume>6</volume>(<issue>3</issue>): <fpage>267</fpage>–<lpage>291</lpage>.</citation>
</ref>
<ref id="bibr2-0954407012457899">
<label>2.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Chang</surname><given-names>J</given-names></name>
<name><surname>Kim</surname><given-names>M</given-names></name>
<name><surname>Min</surname><given-names>K</given-names></name>
</person-group>. <article-title>Detection of misfire and knock in spark ignition engines by wavelet transform of engine block vibration signals</article-title>. <source>Measmt Sci Technol</source> <year>2002</year>; <volume>13</volume>(<issue>7</issue>): <fpage>1108</fpage>–<lpage>1114</lpage>.</citation>
</ref>
<ref id="bibr3-0954407012457899">
<label>3.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Hong</surname><given-names>D</given-names></name>
<name><surname>Xiuwen</surname><given-names>G</given-names></name>
<name><surname>Shuzi</surname><given-names>Y</given-names></name>
</person-group>. <article-title>An approach to state recognition and knowledge-based diagnosis for engines</article-title>. <source>Mech Systems Signal Processing</source> <year>1991</year>; <volume>5</volume>(<issue>4</issue>): <fpage>257</fpage>–<lpage>266</lpage>.</citation>
</ref>
<ref id="bibr4-0954407012457899">
<label>4.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Botton</surname><given-names>G</given-names></name>
<name><surname>Ben-Ari</surname><given-names>J</given-names></name>
<name><surname>Sher</surname><given-names>E</given-names></name>
</person-group>. <article-title>Vibration monitoring as a predictive maintenance tool for reciprocating engines</article-title>. <source>Proc IMechE Part D: J Automobile Engineering</source> <year>2000</year>; <volume>214</volume>(<issue>8</issue>): <fpage>895</fpage>–<lpage>903</lpage>.</citation>
</ref>
<ref id="bibr5-0954407012457899">
<label>5.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Zhou</surname><given-names>P</given-names></name>
<name><surname>Li</surname><given-names>H</given-names></name>
<name><surname>Clelland</surname><given-names>D</given-names></name>
</person-group>. <article-title>Pattern recognition on diesel engine working conditions by wavelet Kullback-Leibler distance method</article-title>. <source>Proc IMechE Part C: J Mechanical Engineering Science</source> <year>2005</year>; <volume>219</volume>(<issue>9</issue>): <fpage>879</fpage>–<lpage>887</lpage>.</citation>
</ref>
<ref id="bibr6-0954407012457899">
<label>6.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Wu</surname><given-names>JD</given-names></name>
<name><surname>Chen</surname><given-names>JC</given-names></name>
</person-group>. <article-title>Continuous wavelet transform technique for fault signal diagnosis of internal combustion engines</article-title>. <source>NDT E Int</source> <year>2006</year>; <volume>39</volume>(<issue>4</issue>): <fpage>304</fpage>–<lpage>311</lpage>.</citation>
</ref>
<ref id="bibr7-0954407012457899">
<label>7.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Wu</surname><given-names>JD</given-names></name>
<name><surname>Kuo</surname><given-names>JM</given-names></name>
</person-group>. <article-title>An automotive generator fault diagnosis system using discrete wavelet transform and artificial neural network</article-title>. <source>Expert Systems Applic</source> <year>2009</year>; <volume>36</volume>(<issue>6</issue>): <fpage>9776</fpage>–<lpage>9783</lpage>.</citation>
</ref>
<ref id="bibr8-0954407012457899">
<label>8.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Zhou</surname><given-names>R</given-names></name>
<name><surname>Bao</surname><given-names>W</given-names></name>
<name><surname>Li</surname><given-names>N</given-names></name><etal/>
</person-group>. <article-title>Mechanical equipment fault diagnosis based on redundant second generation wavelet packet transform</article-title>. <source>Digital Signal Processing</source> <year>2010</year>; <volume>20</volume>(<issue>1</issue>): <fpage>276</fpage>–<lpage>288</lpage>.</citation>
</ref>
<ref id="bibr9-0954407012457899">
<label>9.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Li</surname><given-names>Y</given-names></name>
<name><surname>Tse</surname><given-names>PW</given-names></name>
<name><surname>Yang</surname><given-names>X</given-names></name>
<name><surname>Yang</surname><given-names>J</given-names></name>
</person-group>. <article-title>EMD-based fault diagnosis for abnormal clearance between contacting components in a diesel engine</article-title>. <source>Mech Systems Signal Processing</source> <year>2010</year>; <volume>24</volume>(<issue>1</issue>): <fpage>193</fpage>–<lpage>210</lpage>.</citation>
</ref>
<ref id="bibr10-0954407012457899">
<label>10.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Yadav</surname><given-names>SK</given-names></name>
<name><surname>Kalra</surname><given-names>PK</given-names></name>
</person-group>. <article-title>Condition monitoring of internal combustion engine using EMD and HMM</article-title>. In: <source>Intelligent autonomous systems</source>, <series>Studies in Computational Intelligence</series>, vol. <volume>275</volume>. <publisher-loc>Berlin</publisher-loc>: <publisher-name>Springer</publisher-name>, <year>2010</year>, pp. <fpage>167</fpage>–<lpage>185</lpage>.</citation>
</ref>
<ref id="bibr11-0954407012457899">
<label>11.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Filippetti</surname><given-names>F</given-names></name>
<name><surname>Franceschini</surname><given-names>G</given-names></name>
<name><surname>Tassoni</surname><given-names>C</given-names></name>
<name><surname>Vas</surname><given-names>P</given-names></name>
</person-group>. <article-title>Recent developments of induction motor drives fault diagnosis using AI techniques</article-title>. <source>IEEE Trans Ind Electron</source> <year>2000</year>; <volume>47</volume>(<issue>5</issue>): <fpage>994</fpage>–<lpage>1004</lpage>.</citation>
</ref>
<ref id="bibr12-0954407012457899">
<label>12.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Lu</surname><given-names>PJ</given-names></name>
<name><surname>Zhang</surname><given-names>MC</given-names></name>
<name><surname>Hsu</surname><given-names>TC</given-names></name>
<name><surname>Zhang</surname><given-names>J</given-names></name>
</person-group>. <article-title>An evaluation of engine faults diagnostics using artificial neural networks</article-title>. <source>Trans ASME, J Engng Gas Turbines Power</source> <year>2001</year>; <volume>123</volume>(<issue>2</issue>): <fpage>340</fpage>–<lpage>346</lpage>.</citation>
</ref>
<ref id="bibr13-0954407012457899">
<label>13.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Wu</surname><given-names>JD</given-names></name>
<name><surname>Liu</surname><given-names>CH</given-names></name>
</person-group>. <article-title>Investigation of engine fault diagnosis using discrete wavelet transform and neural network</article-title>. <source>Expert Systems Applic</source> <year>2008</year>; <volume>35</volume>(<issue>3</issue>): <fpage>1200</fpage>–<lpage>1213</lpage>.</citation>
</ref>
<ref id="bibr14-0954407012457899">
<label>14.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Wu</surname><given-names>JD</given-names></name>
<name><surname>Chiang</surname><given-names>PH</given-names></name>
</person-group>. <article-title>Application of Wigner–Ville distribution and probability neural network for scooter engine fault diagnosis</article-title>. <source>Expert Systems Applic</source> <year>2009</year>; <volume>36</volume>(<issue>2, Part 1</issue>): <fpage>2187</fpage>–<lpage>2199</lpage>.</citation>
</ref>
<ref id="bibr15-0954407012457899">
<label>15.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Saravanan</surname><given-names>N</given-names></name>
<name><surname>Ramachandran</surname><given-names>KI</given-names></name>
</person-group>. <article-title>Fault diagnosis of spur bevel gear box using discrete wavelet features and decision tree classification</article-title>. <source>Expert Systems Applic</source> <year>2009</year>; <volume>36</volume>(<issue>5</issue>): <fpage>9564</fpage>–<lpage>9573</lpage>.</citation>
</ref>
<ref id="bibr16-0954407012457899">
<label>16.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Saravanan</surname><given-names>N</given-names></name>
<name><surname>Ramachandran</surname><given-names>KI</given-names></name>
</person-group>. <article-title>A case study on classification of features by fast single-shot multiclass PSVM using Morlet wavelet for fault diagnosis of spur bevel gear box</article-title>. <source>Expert Systems Applic</source> <year>2009</year>; <volume>36</volume>(<issue>3</issue>): <fpage>10 854</fpage>–<lpage>10 862</lpage>.</citation>
</ref>
<ref id="bibr17-0954407012457899">
<label>17.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Serra</surname><given-names>J</given-names></name>
</person-group>. <article-title>Morphological filtering: an overview</article-title>. <source>Signal Processing</source> <year>1994</year>; <volume>38</volume>(<issue>1</issue>): <fpage>3</fpage>–<lpage>11</lpage>.</citation>
</ref>
<ref id="bibr18-0954407012457899">
<label>18.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Chen</surname><given-names>CS</given-names></name>
<name><surname>Wu</surname><given-names>JL</given-names></name>
<name><surname>Hung</surname><given-names>YP</given-names></name>
</person-group>. <article-title>Theoretical aspects of vertically invariant gray-level morphological operators and their application on adaptive signal and image filtering</article-title>. <source>IEEE Trans Signal Processing</source> <year>1999</year>; <volume>47</volume>(<issue>4</issue>): <fpage>1049</fpage>–<lpage>1060</lpage>.</citation>
</ref>
<ref id="bibr19-0954407012457899">
<label>19.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Soille</surname><given-names>P</given-names></name>
</person-group>. <article-title>On morphological operators based on rank filters</article-title>. <source>Pattern Recognition</source> <year>2002</year>; <volume>35</volume>(<issue>2</issue>): <fpage>527</fpage>–<lpage>535</lpage>.</citation>
</ref>
<ref id="bibr20-0954407012457899">
<label>20.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Mak</surname><given-names>KL</given-names></name>
<name><surname>Peng</surname><given-names>P</given-names></name>
<name><surname>Yiu</surname><given-names>KFC</given-names></name>
</person-group>. <article-title>Fabric defect detection using morphological filters</article-title>. <source>Image Vision Comput</source> <year>2009</year>; <volume>27</volume>(<issue>10</issue>): <fpage>1585</fpage>–<lpage>1592</lpage>.</citation>
</ref>
<ref id="bibr21-0954407012457899">
<label>21.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Khabou</surname><given-names>MA</given-names></name>
<name><surname>Gader</surname><given-names>PD</given-names></name>
<name><surname>Keller</surname><given-names>JM</given-names></name>
</person-group>. <article-title>LADAR target detection using morphological shared-weight neural networks</article-title>. <source>Mach Vision Applic</source> <year>2000</year>; <volume>11</volume>(<issue>6</issue>): <fpage>300</fpage>–<lpage>305</lpage>.</citation>
</ref>
<ref id="bibr22-0954407012457899">
<label>22.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Pessoa</surname><given-names>LFC</given-names></name>
<name><surname>Maragos</surname><given-names>P</given-names></name>
</person-group>. <article-title>Neural networks with hybrid morphological/rank/linear nodes: a unifying framework with applications to handwritten character recognition</article-title>. <source>Pattern Recognition</source> <year>2000</year>; <volume>33</volume>(<issue>6</issue>): <fpage>945</fpage>–<lpage>960</lpage>.</citation>
</ref>
<ref id="bibr23-0954407012457899">
<label>23.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Han</surname><given-names>CW</given-names></name>
</person-group>. <article-title>Range facial recognition with the aid of eigenface and morphological neural networks</article-title>. In: <conf-name>9th international conference on intelligent data engineering and automated learning, Lecture Notes in Computer Science</conf-name>, vol. <volume>5326</volume>, <conf-loc>Daejeon, Republic of Korea</conf-loc>, <conf-date>2–5 November 2008</conf-date>, pp. <fpage>217</fpage>–<lpage>224</lpage>. <publisher-loc>Berlin</publisher-loc>: <publisher-name>Springer.</publisher-name></citation>
</ref>
<ref id="bibr24-0954407012457899">
<label>24.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Ke</surname><given-names>C</given-names></name>
</person-group>. <article-title>White blood cell detection using a novel fuzzy morphological shared-weight neural network</article-title>. In: <conf-name>International symposium on computer science and computational technology</conf-name>, <conf-loc>Shanghai, People’s Republic of China</conf-loc>, <conf-date>20–22 December 2008</conf-date>, vol. <volume>2</volume>, pp. <fpage>532</fpage>–<lpage>535</lpage>. <publisher-loc>New York</publisher-loc>: <publisher-name>IEEE</publisher-name>.</citation>
</ref>
<ref id="bibr25-0954407012457899">
<label>25.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Vazquez</surname><given-names>RA</given-names></name>
<name><surname>Sossa</surname><given-names>H</given-names></name>
</person-group>. <article-title>Morphological hetero-associative memories appliedto restore true-color patterns</article-title>. In: <conf-name>6th international symposium on neural networks, Lecture Notes in Computer Science</conf-name>, vol. <volume>5553</volume>, <conf-loc>Wuhan, People’s Republic of China</conf-loc>, <conf-date>26–29 May 2009</conf-date>, pp. <fpage>520</fpage>–<lpage>529</lpage>. <publisher-loc>Berlin</publisher-loc>: <publisher-name>Springer</publisher-name>.</citation>
</ref>
<ref id="bibr26-0954407012457899">
<label>26.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Serra</surname><given-names>J</given-names></name>
</person-group>. <source>Image analysis and mathematical morphology</source>. <publisher-loc>London</publisher-loc>: <publisher-name>Academic Press</publisher-name>, <year>1982</year>.</citation>
</ref>
<ref id="bibr27-0954407012457899">
<label>27.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Serra</surname><given-names>J</given-names></name>
</person-group>. <source>Image analysis and mathematical morphology, vol. 2: theoretical advances</source>. <publisher-loc>Londom</publisher-loc>: <publisher-name>Academic Press</publisher-name>, <year>1988</year>.</citation>
</ref>
<ref id="bibr28-0954407012457899">
<label>28.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Maragos</surname><given-names>P</given-names></name>
<name><surname>Schafer</surname><given-names>RW</given-names></name>
</person-group>. <article-title>Morphological filters – Part I: their set-theoretic analysis and relations to linear shift-invariant filters</article-title>. <source>IEEE Trans Acoustics, Speech, Signal Processing</source> <year>1987</year>; <volume>35</volume>(<issue>8</issue>): <fpage>1153</fpage>–<lpage>1169</lpage>.</citation>
</ref>
<ref id="bibr29-0954407012457899">
<label>29.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Maragos</surname><given-names>P</given-names></name>
<name><surname>Schafer</surname><given-names>RW</given-names></name>
</person-group>. <article-title>Morphological filters – Part II: their relations to median, order-statistic, and stack filters</article-title>. <source>IEEE Trans Acoustics, Speech, Signal Processing</source> <year>1987</year>; <volume>35</volume>(<issue>8</issue>): <fpage>1170</fpage>–<lpage>1184</lpage>.</citation>
</ref>
<ref id="bibr30-0954407012457899">
<label>30.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Serra</surname><given-names>J</given-names></name>
<name><surname>Vincent</surname><given-names>L</given-names></name>
</person-group>. <article-title>An overview of morphological filtering</article-title>. <source>Circuits, Systems Signal Processing</source> <year>1992</year>; <volume>11</volume>(<issue>1</issue>): <fpage>47</fpage>–<lpage>108</lpage>.</citation>
</ref>
<ref id="bibr31-0954407012457899">
<label>31.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Heijmans</surname><given-names>HJAM</given-names></name>
</person-group>. <article-title>Mathematical morphology: a modern approach in image processing based on algebra and geometry</article-title>. <source>SIAM Rev</source> <year>1995</year>; <volume>37</volume>(<issue>1</issue>): <fpage>1</fpage>–<lpage>36</lpage>.</citation>
</ref>
<ref id="bibr32-0954407012457899">
<label>32.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Maragos</surname><given-names>P</given-names></name>
</person-group>. <article-title>Pattern spectrum and multiscale shape representation</article-title>. <source>IEEE Trans Pattern Analysis Mach Intell</source> <year>1989</year>; <volume>11</volume>(<issue>7</issue>): <fpage>701</fpage>–<lpage>716</lpage>.</citation>
</ref>
<ref id="bibr33-0954407012457899">
<label>33.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Pu</surname><given-names>X</given-names></name>
<name><surname>Yi</surname><given-names>Z</given-names></name>
<name><surname>Zheng</surname><given-names>Z</given-names></name><etal/>
</person-group>. <article-title>Face recognition using fisher non-negative matrix factorization with sparseness constraints</article-title>. In: <conf-name>2nd international symposium on neural networks</conf-name>, <series>Lecture Notes in Computer Science</series>, <volume>vol. 3497</volume>, <conf-loc>Chongqing, People’s Republic of China</conf-loc>, <conf-date>30 May–1 June 2005</conf-date>, pp. <fpage>821</fpage>–<lpage>822</lpage>. <publisher-loc>Berlin</publisher-loc>: <publisher-name>Springer</publisher-name>.</citation>
</ref>
<ref id="bibr34-0954407012457899">
<label>34.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Liu</surname><given-names>W</given-names></name>
<name><surname>Zheng</surname><given-names>N</given-names></name>
</person-group>. <article-title>Non-negative matrix factorization based methods for object recognition</article-title>. <source>Pattern Recognition Lett</source> <year>2004</year>; <volume>25</volume>(<issue>8</issue>): <fpage>893</fpage>–<lpage>897</lpage>.</citation>
</ref>
<ref id="bibr35-0954407012457899">
<label>35.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Yuan</surname><given-names>Z</given-names></name>
<name><surname>Oja</surname><given-names>E</given-names></name>
</person-group>. <article-title>Projective nonnegative matrix factorization for image compression and feature extraction</article-title>. In: <conf-name>14th Scandinavian conference</conf-name>, <series>Lecture Notes in Computer Science</series>, <volume>vol. 3540</volume>, <conf-loc>Joensuu, Finland</conf-loc>, <conf-date>19–22 June 2005</conf-date>, pp. <fpage>333</fpage>–<lpage>342</lpage>. <publisher-loc>Berlin</publisher-loc>: <publisher-name>Springer</publisher-name>.</citation>
</ref>
<ref id="bibr36-0954407012457899">
<label>36.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Cho</surname><given-names>YC</given-names></name>
<name><surname>Choi</surname><given-names>S</given-names></name>
</person-group>. <article-title>Nonnegative features of spectro-temporal sounds for classification</article-title>. <source>Pattern Recognition Lett</source> <year>2005</year>; <volume>26</volume>(<issue>9</issue>): <fpage>1327</fpage>–<lpage>1336</lpage>.</citation>
</ref>
<ref id="bibr37-0954407012457899">
<label>37.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Lee</surname><given-names>DD</given-names></name>
<name><surname>Seung</surname><given-names>HS</given-names></name>
</person-group>. <article-title>Learning the parts of objects by non-negative matrix factorization</article-title>. <source>Nature</source> <year>1999</year>; <volume>401</volume>(<issue>6755</issue>): <fpage>788</fpage>–<lpage>791</lpage>.</citation>
</ref>
<ref id="bibr38-0954407012457899">
<label>38.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Lee</surname><given-names>DD</given-names></name>
<name><surname>Seung</surname><given-names>HS</given-names></name>
</person-group>. <article-title>Algorithms for non-negative matrix factorization</article-title>. <source>Adv Neural Inf Processing Systems</source> <year>2001</year>; <volume>13</volume>(<issue>3</issue>): <fpage>556</fpage>–<lpage>562</lpage>.</citation>
</ref>
<ref id="bibr39-0954407012457899">
<label>39.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Ritter</surname><given-names>GX</given-names></name>
<name><surname>Sussner</surname><given-names>P</given-names></name>
</person-group>.<article-title>An introduction to morphological neural networks</article-title>. In: <conf-name>13th international conference on pattern recognition</conf-name>, <conf-loc>Vienna, Austria</conf-loc>, <conf-date>25–29 August 1996</conf-date>, <volume>vol. 4</volume>, pp. <fpage>709</fpage>–<lpage>717</lpage>. <publisher-loc>New York</publisher-loc>: <publisher-name>IEEE</publisher-name>.</citation>
</ref>
<ref id="bibr40-0954407012457899">
<label>40.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Sussner</surname><given-names>P</given-names></name>
<name><surname>Esmi</surname><given-names>EL</given-names></name>
</person-group>. <article-title>Constructive morphological neural networks: some theoretical aspects and experimental results in classification</article-title>. In: <conf-name>Constructive neural networks</conf-name>, <series>Studies in Computational Intelligence</series>, <volume>vol. 258</volume>, pp. <fpage>123</fpage>–<lpage>144</lpage>. <publisher-loc>Berlin</publisher-loc>: <publisher-name>Springer</publisher-name>.</citation>
</ref>
<ref id="bibr41-0954407012457899">
<label>41.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Sussner</surname><given-names>P</given-names></name>
<name><surname>Esmi</surname><given-names>EL</given-names></name>
</person-group>. <article-title>Morphological perceptrons with competitive learning: lattice-theoretical framework and constructive learning algorithm</article-title>. <source>Inf Sci</source> <year>2011</year>; <volume>181</volume>(<issue>10</issue>): <fpage>1929</fpage>–<lpage>1950</lpage>.</citation>
</ref>
<ref id="bibr42-0954407012457899">
<label>42.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Maragos</surname><given-names>P</given-names></name>
</person-group>. <article-title>Lattice image processing: a unification of morphological and fuzzy algebraic systems</article-title>. <source>J Mathl Imaging Vision</source> <year>2005</year>; <volume>22</volume>(<issue>2</issue>): <fpage>333</fpage>–<lpage>353</lpage>.</citation>
</ref>
<ref id="bibr43-0954407012457899">
<label>43.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Sussner</surname><given-names>P</given-names></name>
<name><surname>Esmi</surname><given-names>EL</given-names></name>
</person-group>. <article-title>An introduction to morphological perceptrons with competitive learning</article-title>. In: <conf-name>International joint conference on neural networks</conf-name>, <conf-loc>Atlanta, GA, USA</conf-loc>, <conf-date>14–19 June 2009</conf-date>, pp. <fpage>3024</fpage>–<lpage>3031</lpage>. <publisher-loc>New York</publisher-loc>: <publisher-name>IEEE</publisher-name>.</citation>
</ref>
<ref id="bibr44-0954407012457899">
<label>44.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Sussner</surname><given-names>P</given-names></name>
</person-group>. <article-title>Morphological perceptron learning</article-title>. In: <conf-name>IEEE international symposium on intelligent control</conf-name>, <conf-loc>Gaithersburg, MD, USA</conf-loc>, <conf-date>14–17 September 1998</conf-date>, pp. <fpage>477</fpage>–<lpage>482</lpage>. <publisher-loc>New York</publisher-loc>: <publisher-name>IEEE</publisher-name>.</citation>
</ref>
<ref id="bibr45-0954407012457899">
<label>45.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Sun</surname><given-names>Q</given-names></name>
<name><surname>Chen</surname><given-names>P</given-names></name>
<name><surname>Zhang</surname><given-names>D</given-names></name>
<name><surname>Xi</surname><given-names>F</given-names></name>
</person-group>. <article-title>Pattern recognition for automatic machinery fault diagnosis</article-title>. <source>Trans ASME, J Vibr Acoust</source> <year>2004</year>; <volume>126</volume>(<issue>2</issue>): <fpage>307</fpage>–<lpage>316</lpage>.</citation>
</ref>
<ref id="bibr46-0954407012457899">
<label>46.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Hu</surname><given-names>Q</given-names></name>
<name><surname>He</surname><given-names>Z</given-names></name>
<name><surname>Zhang</surname><given-names>Z</given-names></name>
<name><surname>Zi</surname><given-names>Y</given-names></name>
</person-group>. <article-title>Fault diagnosis of rotating machinery based on improved wavelet package transform and SVMs ensemble</article-title>. <source>Mech Systems Signal Processing</source> <year>2007</year>; <volume>21</volume>(<issue>2</issue>): <fpage>688</fpage>–<lpage>705</lpage>.</citation>
</ref>
<ref id="bibr47-0954407012457899">
<label>47.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Lei</surname><given-names>Y</given-names></name>
<name><surname>He</surname><given-names>Z</given-names></name>
<name><surname>Zi</surname><given-names>Y</given-names></name>
</person-group>. <article-title>Application of an intelligent classification method to mechanical fault diagnosis</article-title>. <source>Expert Systems Applic</source> <year>2009</year>; <volume>36</volume>(<issue>6</issue>): <fpage>9941</fpage>–<lpage>9948</lpage>.</citation>
</ref>
<ref id="bibr48-0954407012457899">
<label>48.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Duin</surname><given-names>RPW</given-names></name>
<name><surname>Juszczak</surname><given-names>P</given-names></name>
<name><surname>Paclik</surname><given-names>P</given-names></name><etal/>
</person-group>. <source>PRTools 4.1, a Matlab toolbox for pattern recognition</source>. <publisher-loc>Delft</publisher-loc>: <publisher-name>Delft University of Technology</publisher-name>, <year>2007</year>.</citation>
</ref>
</ref-list>
</back>
</article>