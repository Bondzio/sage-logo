<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD Journal Publishing DTD v2.3 20070202//EN" "journalpublishing.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">HPC</journal-id>
<journal-id journal-id-type="hwp">sphpc</journal-id>
<journal-title>The International Journal of High Performance Computing Applications</journal-title>
<issn pub-type="ppub">1094-3420</issn>
<issn pub-type="epub">1741-2846</issn>
<publisher>
<publisher-name>SAGE Publications</publisher-name>
<publisher-loc>Sage UK: London, England</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1177/1094342012457191</article-id>
<article-id pub-id-type="publisher-id">10.1177_1094342012457191</article-id>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Regular Articles</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>Parallel Monte Carlo radiosity using scene partitioning</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" corresp="yes">
<name>
<surname>Sanjurjo</surname>
<given-names>José R.</given-names>
</name>
<xref ref-type="aff" rid="aff1-1094342012457191">1</xref>
<xref ref-type="corresp" rid="corresp1-1094342012457191"/>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Amor</surname>
<given-names>Margarita</given-names>
</name>
<xref ref-type="aff" rid="aff1-1094342012457191">1</xref>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Bóo</surname>
<given-names>Montserrat</given-names>
</name>
<xref ref-type="aff" rid="aff2-1094342012457191">2</xref>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Doallo</surname>
<given-names>Ramón</given-names>
</name>
<xref ref-type="aff" rid="aff1-1094342012457191">1</xref>
</contrib>
<bio>
<title>Author biographies</title>
<p>
<italic>José R. Sanjurjo</italic> received his B.S. degree in Physics from the University of Santiago de Compostela (Spain) in 1990, and his Ph.D. degree in Computer Science from the University of A Coruña (Spain) in 2012. In 1990 he joined the Department of Electronics and Systems of the University of A Coruña (Spain) as Associate Professor of Computer Engineering. He teaches undergraduate courses on computer architecture. His research interests are computer graphics and parallel and distributed computing.</p>
<p>
<italic>Margarita Amor</italic> is currently an associate professor at Department of Electronic and Systems of the University of A Coruña (Spain). She received the B.S. and Ph.D. degrees in Physics from the University of Santiago de Compostela (Spain) in 1993 and 1997, respectively. Her research interest is mainly focused in the areas of computer graphics and parallel computing.</p>
<p>
<italic>Montserrat Bóo</italic> received the B.S. and Ph.D. degrees in Physics from the University of Santiago de Compostela (Spain) in 1993 and 1997, respectively. Currently she is Associate Professor in the Department of Electronics and Computer Engineering at the University of Santiago de Compostela. Her interests are in the areas of VLSI digital signal and image processing, computer graphics, GPGPU and computer arithmetic.</p>
<p>
<italic>Ramón Doallo</italic> received a Ph.D. in Physics from University of Santiago de Compostela (Spain), is a Full Professor and the Head of the Computer Architecture Research Group at University of A Coruña (Spain). He has 22 years of experience in research and development in the area of high-performance computing (HPC), covering a wide range of topics such as compilers and programming languages for HPC, parallel and distributed algorithms and applications, management of HPC infrastructures, cluster and Grid computing, processor architecture, computer graphics, and distributed geographic information systems. He has published more than 120 technical papers on these topics.</p>
</bio>
</contrib-group>
<aff id="aff1-1094342012457191">
<label>1</label>Computer Architecture Group, University of A Coruña, A Coruña, Spain</aff>
<aff id="aff2-1094342012457191">
<label>2</label>Computer Architecture Group, University of Santiago de Compostela, Santiago de Compostela, Spain</aff>
<author-notes>
<corresp id="corresp1-1094342012457191">José R. Sanjurjo, Facultad de Informática, Campus de Elviña, Universidade da Coruña, 15071 - A Coruña, Spain. Email: <email>jose.sanjurjo@udc.es</email>
</corresp>
</author-notes>
<pub-date pub-type="epub-ppub">
<month>8</month>
<year>2013</year>
</pub-date>
<volume>27</volume>
<issue>3</issue>
<issue-title>Special Issue section on CCDSC 2012 Workshop</issue-title>
<fpage>318</fpage>
<lpage>334</lpage>
<permissions>
<copyright-statement>© The Author(s) 2012</copyright-statement>
<copyright-year>2012</copyright-year>
<copyright-holder content-type="sage">SAGE Publications</copyright-holder>
</permissions>
<abstract>
<p>Global illumination provides realistic image synthesis but its high computational requirements limit its use in practice. In this paper we present a parallel method of the Monte Carlo radiosity method. Our proposal is based on the utilization of a convex partition to divide the whole scene into a set of disjoint sub-scenes which are allocated among processors of a distributed memory system. We have used two partitioning strategies: uniform and non-uniform. The convex partition employed permits the exploitation of data locality, and the optimization of the ray shooting procedure by minimizing the number of objects to be tested in the intersection calculation. We present three different techniques to increase the performance of parallel implementation and to solve the challenges that the distribution of the data among processors implies: minimization of communications, load balancing, and a distributed test for determining the end of each iteration. The obtained results are good in terms of quality and execution times, increasing the flexibility of previous solutions.</p>
</abstract>
<kwd-group>
<kwd>distributed memory system</kwd>
<kwd>parallelization</kwd>
<kwd>radiosity</kwd>
<kwd>Monte Carlo methods</kwd>
<kwd>convex partition</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="section1-1094342012457191">
<title>1. Introduction</title>
<p>Global illumination simulation is employed for realistic image synthesis with applications in product design, architecture, interior design, computer games and computer animation, among others. In general, the global illumination methods attempt to solve the rendering equation (<xref ref-type="bibr" rid="bibr7-1094342012457191">Dutre et al., 2006</xref>) that describes the light propagation in closed scenes. More specifically the radiosity method (<xref ref-type="bibr" rid="bibr6-1094342012457191">Cohen and Wallace, 1993</xref>) simplifies the rendering equation by considering only ideal diffuse surfaces. This method is particularly suited to applications such as lighting design or walkthroughs of architectural models.</p>
<p>One possible approach for the radiosity computation is the Monte Carlo algorithm. The Monte Carlo methods are stochastic and randomly sample the space associated with the problem to arrive at approximate solutions; they are used to solve a variety of complex problems arising in numerous areas such as computational physics, finance, and economics (<xref ref-type="bibr" rid="bibr12-1094342012457191">Kalos and Whitlock, 1986</xref>). Monte Carlo radiosity (MCR) methods (<xref ref-type="bibr" rid="bibr3-1094342012457191">Bekaert et al., 1998</xref>; <xref ref-type="bibr" rid="bibr7-1094342012457191">Dutre et al., 2006</xref>) can handle complex and large scenes; however, the associated high computational requirements make the development of optimizations to reduce the resulting execution times desirable.</p>
<p>In the MCR algorithm a large number of independent rays are chosen stochastically by a weighted sampling of the objects according to their power after previous iterations. Once a ray is shot, the procedure follows by searching the nearest object intersected by this ray. This procedure, called ‘ray shooting’, is the main computational core of the algorithm. This is due to the large number of surfaces of the scene and, as a consequence, the large number of ray–object intersections to be computed.</p>
<p>Several parallel implementations for solving global illumination algorithms on different architectures have been proposed (<xref ref-type="bibr" rid="bibr8-1094342012457191">Gibson and Hubbold, 2000</xref>; <xref ref-type="bibr" rid="bibr20-1094342012457191">Sanjurjo et al., 2005</xref>; <xref ref-type="bibr" rid="bibr19-1094342012457191">Ritschel et al., 2008</xref>; <xref ref-type="bibr" rid="bibr28-1094342012457191">Wang et al., 2009</xref>; <xref ref-type="bibr" rid="bibr13-1094342012457191">Kaplanyan and Dachsbacher, 2010</xref>). Although the MCR is widely used in many fields owing to its accuracy, there are in fact very few publications on distributed memory systems, this scheme being the main objective of our work. <xref ref-type="bibr" rid="bibr30-1094342012457191">Zareski et al. (1995</xref>) used a master–slave paradigm on a distributed memory system, where each slave calculates the ray shooting for a given set of independent rays. The main drawback of this implementation is the storage requirements, as the whole scene has to be replicated in the local memory of each processor. This limits the size of the scene that can be processed. Moreover, as the master processor is responsible for combining the results calculated by all slave processors, the communication requirements can become a bottleneck for the system.</p>
<p>In the search for other parallel implementations based on the Monte Carlo algorithm we find other proposals, for example in the computational physics context. Specifically, the Monte Carlo method is used to solve many different issues for example the thermal radiation transport problem. In this context there are several parallel implementations (<xref ref-type="bibr" rid="bibr1-1094342012457191">Alme et al., 2001</xref>; <xref ref-type="bibr" rid="bibr5-1094342012457191">Brunner and Brantley, 2009</xref>). <xref ref-type="bibr" rid="bibr1-1094342012457191">Alme et al. (2001</xref>) proposed a hybrid parallel strategy combining replication and non-convex domain decomposition. In this parallelization the domain is divided into fewer sub-domains than the number of available processors. The sub-domains are then replicated across the processors according to a work estimation in order to balance the load. <xref ref-type="bibr" rid="bibr5-1094342012457191">Brunner and Brantley (2009</xref>) outlined a proposal with domain decomposition to solve the time-dependent transport equation for photons coupled with matter. The main drawback of these implementations is the resulting load imbalance.</p>
<p>Another global illumination approach based on the ray shooting procedure is the ray tracing algorithm. Ray tracing has been performed on a variety of platforms such as field-programmable gate arrays (FPGAs) (<xref ref-type="bibr" rid="bibr29-1094342012457191">Woop et al., 2005</xref>), graphics processing units (GPUs) (<xref ref-type="bibr" rid="bibr18-1094342012457191">Popov et al., 2007</xref>), cell processor (<xref ref-type="bibr" rid="bibr4-1094342012457191">Benthin et al., 2006</xref>), multicore (<xref ref-type="bibr" rid="bibr24-1094342012457191">Shevtsov et al., 2007</xref>) and multiple CPU systems (<xref ref-type="bibr" rid="bibr14-1094342012457191">Kato, 2003</xref>; <xref ref-type="bibr" rid="bibr25-1094342012457191">Wald et al., 2003</xref>). While in the MCR context the rays are traced among surfaces, in the ray tracing algorithms they are traced from screen pixels to the objects in the scene. Therefore, for ray tracing there are basically two approaches for the parallelization on a multiple CPU system: screen and scene sub-division. Screen sub-division usually requires a local copy of the whole scene on each processor (<xref ref-type="bibr" rid="bibr25-1094342012457191">Wald et al., 2003</xref>). This limits the size of the scene that can be processed. Among the scene sub-division approaches the proposal by <xref ref-type="bibr" rid="bibr14-1094342012457191">Kato (2003</xref>) distributes the scene randomly into chunks of triangles. In this proposal each ray created by a given processor is sent to the remaining processors and the intersection results are sent back to the original processor. This parallelization scheme does not exploit the data locality and requires a larger number of communications among processors. A different strategy was employed by <xref ref-type="bibr" rid="bibr10-1094342012457191">Ize et al. (2011</xref>) and <xref ref-type="bibr" rid="bibr27-1094342012457191">Wald et al. (2005</xref>), where systems for rendering massive models were developed. The first proposal is based on the efficient management of the system’s memory hierarchy. However, when the data for a particular acceleration structure node is not readily available the stand-in for the current node is used in place of the actual geometry. Consequently, this implies a quality loss as jagged silhouettes are generated. In the second proposal, massive models, that cannot reside inside the physical memory of any individual compute node, are ray traced on a cluster.</p>
<p>In this paper, we propose a parallel implementation of the MCR on a distributed memory system. The scene is partitioned into sub-scenes according to a convex partitioning procedure. A similar strategy was employed by <xref ref-type="bibr" rid="bibr2-1094342012457191">Amor et al. (2004</xref>) in the context of the progressive radiosity algorithm parallelization on distributed memory systems. The sub-scenes are distributed among processors so that each processor calculates the radiosity for the set of data assigned to its sub-scene. In this work we have employed two scene partitioning methods: a uniform partition, which divides the scene into equal-sized sub-scenes adhering to purely geometric criteria, and a non-uniform partition, that persecutes the homogeneous distribution of the workload so that a similar number of rays is processed by all processors. In terms of execution times, good results are obtained with our proposals, even for complex models. In addition, as the data is efficiently communicated among processors, no approximations have to be performed and high-quality images are obtained.</p>
<p>Our parallel method is based on a coarse-grained parallel strategy and uses the message-passing paradigm. Each processor calculates the radiosity for its sub-scenes according to the local rays and the exchanged rays from neighbour processors. Rays are sent to processors depending on the next sub-scene pierced by the ray. This communication among processors is critical due to the large number of rays exchanged. We have proposed a technique based on the generation and transmission of ray packets that reduces the communication requirements.</p>
<p>The remainder of the paper is organized as follows: in Section 2 we briefly describe the incremental stochastic Jacobi iterative method and in Section 3 we describe our parallel implementation on a distributed memory system. Next, in Section 4 we detail the convex decomposition algorithms for scene partitioning. In Section 5 we explain the ray packing strategy for minimizing communications among processors. The procedure for testing the end of each iteration we have employed is described in Section 6. Finally, experimental results are analysed in Section 7, while Section 8 presents the main conclusions of the work.</p>
</sec>
<sec id="section2-1094342012457191">
<title>2. The Monte Carlo radiosity algorithm</title>
<p>The radiosity method (<xref ref-type="bibr" rid="bibr7-1094342012457191">Dutre et al., 2006</xref>) solves the global illumination problem considering only ideal diffuse surfaces. The resulting discrete radiosity equation is<disp-formula id="disp-formula1-1094342012457191">
<label>1</label>
<mml:math id="mml-disp1-1094342012457191">
<mml:msub>
<mml:mi>B</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo stretchy="false">=</mml:mo>
<mml:msub>
<mml:mi>E</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo stretchy="false">+</mml:mo>
<mml:msub>
<mml:mi mathvariant="italic">ρ</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mrow>
<mml:munderover>
<mml:mo movablelimits="false" stretchy="false">∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>N</mml:mi>
<mml:mi>s</mml:mi>
</mml:mrow>
</mml:munderover>
</mml:mrow>
<mml:msub>
<mml:mi>B</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:msub>
<mml:mi>F</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
</mml:math>
<graphic alternate-form-of="disp-formula1-1094342012457191" xlink:href="10.1177_1094342012457191-eq1.tif"/>
</disp-formula>
</p>
<p>where <inline-formula id="inline-formula1-1094342012457191">
<mml:math id="mml-inline1-1094342012457191">
<mml:msub>
<mml:mi>B</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> is the radiosity of surface <inline-formula id="inline-formula2-1094342012457191">
<mml:math id="mml-inline2-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula>, <inline-formula id="inline-formula3-1094342012457191">
<mml:math id="mml-inline3-1094342012457191">
<mml:msub>
<mml:mi>E</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> is the emittance, <inline-formula id="inline-formula4-1094342012457191">
<mml:math id="mml-inline4-1094342012457191">
<mml:msub>
<mml:mi mathvariant="italic">ρ</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> the diffuse reflectivity, and <inline-formula id="inline-formula5-1094342012457191">
<mml:math id="mml-inline5-1094342012457191">
<mml:mi>N</mml:mi>
<mml:mi>s</mml:mi>
</mml:math>
</inline-formula> is the number of objects of the scene. The summation represents the contribution of the other surfaces in the scene to the radiosity of surface <inline-formula id="inline-formula6-1094342012457191">
<mml:math id="mml-inline6-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula>, and <inline-formula id="inline-formula7-1094342012457191">
<mml:math id="mml-inline7-1094342012457191">
<mml:msub>
<mml:mi>F</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula> is the form factor between surfaces <inline-formula id="inline-formula8-1094342012457191">
<mml:math id="mml-inline8-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> and <inline-formula id="inline-formula9-1094342012457191">
<mml:math id="mml-inline9-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:math>
</inline-formula>. Here <inline-formula id="inline-formula10-1094342012457191">
<mml:math id="mml-inline10-1094342012457191">
<mml:msub>
<mml:mi>F</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula> is an adimensional constant that only depends on the geometry of the scene and represents the proportion of the radiosity leaving surface <inline-formula id="inline-formula11-1094342012457191">
<mml:math id="mml-inline11-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> that is received by <inline-formula id="inline-formula12-1094342012457191">
<mml:math id="mml-inline12-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:math>
</inline-formula>. There is one radiosity equation per surface and one form factor among all pairs of surfaces.</p>
<p>MCR (<xref ref-type="bibr" rid="bibr3-1094342012457191">Bekaert et al., 1998</xref>; <xref ref-type="bibr" rid="bibr7-1094342012457191">Dutre et al., 2006</xref>) provides a reliable form factor computation while explicit form factor storage is avoided. The basic idea is to compute the geometry relation between two surfaces <inline-formula id="inline-formula13-1094342012457191">
<mml:math id="mml-inline13-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> and <inline-formula id="inline-formula14-1094342012457191">
<mml:math id="mml-inline14-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> by casting a set of <inline-formula id="inline-formula15-1094342012457191">
<mml:math id="mml-inline15-1094342012457191">
<mml:mi>N</mml:mi>
<mml:msub>
<mml:mi>r</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> rays from <inline-formula id="inline-formula16-1094342012457191">
<mml:math id="mml-inline16-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula>. The amount of rays that finally intersect with surface <inline-formula id="inline-formula17-1094342012457191">
<mml:math id="mml-inline17-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> enables us to estimate the form factor between <inline-formula id="inline-formula18-1094342012457191">
<mml:math id="mml-inline18-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> and <inline-formula id="inline-formula19-1094342012457191">
<mml:math id="mml-inline19-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:math>
</inline-formula>.</p>
<p>There are basically three approaches to solve the radiosity system of linear equations by means of Monte Carlo methods (<xref ref-type="bibr" rid="bibr7-1094342012457191">Dutre et al., 2006</xref>): stochastic relaxation methods (<xref ref-type="bibr" rid="bibr16-1094342012457191">Neumann et al., 1995</xref>), discrete random walk methods (<xref ref-type="bibr" rid="bibr22-1094342012457191">Sbert, 1997</xref>) and photon density estimation methods (<xref ref-type="bibr" rid="bibr11-1094342012457191">Jensen, 2001</xref>; <xref ref-type="bibr" rid="bibr15-1094342012457191">Larsen and Christensen, 2004</xref>). The stochastic relaxation methods are based on stochastic adaptations of iterative schemes to solve the radiosity system, such as, the Jacobi, Gauss–Seidel, or Southwell methods. The discrete random walk methods are based on a shooting random walk estimator for solving an adjoint system of equations. The photon density estimation methods are very similar to the random walk methods for linear systems, but solve the radiosity integral equation directly.</p>
<p>In this work we focus on a stochastic relaxation method that uses the Jacobi iteration to solve the set of radiosity equations. The main structure of the procedure is summarized in the following section.</p>
<sec id="section3-1094342012457191">
<title>2.1. Incremental stochastic Jacobi iterative method</title>
<p>The stochastic radiosity method (<xref ref-type="bibr" rid="bibr16-1094342012457191">Neumann et al., 1995</xref>) is based on the stochastic shooting technique. This method works with radiant power values <inline-formula id="inline-formula20-1094342012457191">
<mml:math id="mml-inline20-1094342012457191">
<mml:msub>
<mml:mi>P</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo stretchy="false">=</mml:mo>
<mml:msub>
<mml:mi>B</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo stretchy="false">⋅</mml:mo>
<mml:msub>
<mml:mi>A</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> rather than with radiosity values <inline-formula id="inline-formula21-1094342012457191">
<mml:math id="mml-inline21-1094342012457191">
<mml:msub>
<mml:mi>B</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> (where <inline-formula id="inline-formula22-1094342012457191">
<mml:math id="mml-inline22-1094342012457191">
<mml:msub>
<mml:mi>A</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> is the area of surface <inline-formula id="inline-formula23-1094342012457191">
<mml:math id="mml-inline23-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula>). The radiosity equation can easily be expressed in terms of power:<disp-formula id="disp-formula2-1094342012457191">
<label>2</label>
<mml:math id="mml-disp2-1094342012457191">
<mml:msub>
<mml:mi>P</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo stretchy="false">=</mml:mo>
<mml:msub>
<mml:mi>P</mml:mi>
<mml:mrow>
<mml:mi>e</mml:mi>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">+</mml:mo>
<mml:msub>
<mml:mi mathvariant="italic">ρ</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mrow>
<mml:munderover>
<mml:mo movablelimits="false" stretchy="false">∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>N</mml:mi>
<mml:mi>s</mml:mi>
</mml:mrow>
</mml:munderover>
</mml:mrow>
<mml:msub>
<mml:mi>P</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo stretchy="false">⋅</mml:mo>
<mml:msub>
<mml:mi>F</mml:mi>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
</mml:math>
<graphic alternate-form-of="disp-formula2-1094342012457191" xlink:href="10.1177_1094342012457191-eq2.tif"/>
</disp-formula>
</p>
<p>where <inline-formula id="inline-formula24-1094342012457191">
<mml:math id="mml-inline24-1094342012457191">
<mml:msub>
<mml:mi>P</mml:mi>
<mml:mrow>
<mml:mi>e</mml:mi>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula> is the self-emitted power of surface <inline-formula id="inline-formula25-1094342012457191">
<mml:math id="mml-inline25-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula>. At each iteration of the incremental stochastic Jacobi method the unshot power is propagated rather than the total power. An approximation for the total power is then obtained as the sum of increments <inline-formula id="inline-formula26-1094342012457191">
<mml:math id="mml-inline26-1094342012457191">
<mml:mi mathvariant="normal">Δ</mml:mi>
<mml:msup>
<mml:mi>P</mml:mi>
<mml:mi>k</mml:mi>
</mml:msup>
</mml:math>
</inline-formula> computed in each iteration:<disp-formula id="disp-formula3-1094342012457191">
<label>3</label>
<mml:math id="mml-disp3-1094342012457191">
<mml:mtable columnalign="right left" columnspacing="thickmathspace" displaystyle="true" rowspacing=".5em">
<mml:mtr>
<mml:mtd>
<mml:mi mathvariant="normal">Δ</mml:mi>
<mml:msubsup>
<mml:mi>P</mml:mi>
<mml:mi>i</mml:mi>
<mml:mrow>
<mml:mi>k</mml:mi>
<mml:mo stretchy="false">+</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msubsup>
<mml:mo stretchy="false">=</mml:mo>
<mml:mtext> </mml:mtext>
<mml:mrow>
<mml:msub>
<mml:mi mathvariant="italic">ρ</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mrow>
<mml:munderover>
<mml:mo movablelimits="false" stretchy="false">∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>N</mml:mi>
<mml:mi>s</mml:mi>
</mml:mrow>
</mml:munderover>
</mml:mrow>
<mml:mi mathvariant="normal">Δ</mml:mi>
<mml:msubsup>
<mml:mi>P</mml:mi>
<mml:mi>j</mml:mi>
<mml:mi>k</mml:mi>
</mml:msubsup>
<mml:mo stretchy="false">⋅</mml:mo>
<mml:msub>
<mml:mi>F</mml:mi>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:msubsup>
<mml:mi>P</mml:mi>
<mml:mi>i</mml:mi>
<mml:mi>k</mml:mi>
</mml:msubsup>
<mml:mo stretchy="false">=</mml:mo>
<mml:mtext> </mml:mtext>
<mml:mrow>
<mml:mrow>
<mml:munderover>
<mml:mo movablelimits="false" stretchy="false">∑</mml:mo>
<mml:mrow>
<mml:mi>l</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>0</mml:mn>
</mml:mrow>
<mml:mi>k</mml:mi>
</mml:munderover>
</mml:mrow>
<mml:mi mathvariant="normal">Δ</mml:mi>
<mml:msubsup>
<mml:mi>P</mml:mi>
<mml:mi>i</mml:mi>
<mml:mi>l</mml:mi>
</mml:msubsup>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:math>
<graphic alternate-form-of="disp-formula3-1094342012457191" xlink:href="10.1177_1094342012457191-eq3.tif"/>
</disp-formula>
</p>
<p>where <inline-formula id="inline-formula27-1094342012457191">
<mml:math id="mml-inline27-1094342012457191">
<mml:mi mathvariant="normal">Δ</mml:mi>
<mml:msubsup>
<mml:mi>P</mml:mi>
<mml:mi>i</mml:mi>
<mml:mn>0</mml:mn>
</mml:msubsup>
<mml:mo stretchy="false">=</mml:mo>
<mml:msub>
<mml:mi>P</mml:mi>
<mml:mrow>
<mml:mi>e</mml:mi>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula>. Sums can be estimated stochastically by randomly picking terms from the sum up according to some probability. There are approaches based on global lines and based on local lines. The global procedures work with lines randomly casted along the scene. The main limitation of the global lines is that their construction can not easily be adapted to increase or decrease the number of assigned rays of a surface (<xref ref-type="bibr" rid="bibr7-1094342012457191">Dutre et al., 2006</xref>). In the local line approach the lines are cast by randomly selecting the source surface <inline-formula id="inline-formula28-1094342012457191">
<mml:math id="mml-inline28-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> or the destination surface <inline-formula id="inline-formula29-1094342012457191">
<mml:math id="mml-inline29-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:math>
</inline-formula>. In case of the origin surface, a set of origin surfaces <inline-formula id="inline-formula30-1094342012457191">
<mml:math id="mml-inline30-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> are randomly selected and lines are cast from them. In case of the destination surface, for each surface <inline-formula id="inline-formula31-1094342012457191">
<mml:math id="mml-inline31-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> a set of rays are cast following a random cosine distribution direction and, consequently, the destination surface <inline-formula id="inline-formula32-1094342012457191">
<mml:math id="mml-inline32-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> is also randomly selected. This permits a finer discretization of the total power in the shooting step, as in this case only a fraction of all surfaces are chosen in each iteration (<xref ref-type="bibr" rid="bibr16-1094342012457191">Neumann et al., 1995</xref>).</p>
<p>In our proposal we use a local line approach with the selection of the destination surface <inline-formula id="inline-formula33-1094342012457191">
<mml:math id="mml-inline33-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:math>
</inline-formula>. Given a surface <inline-formula id="inline-formula34-1094342012457191">
<mml:math id="mml-inline34-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula>, this surface emits a number of random rays proportional to its fraction of unshot power. For each shot ray, the closest surface <inline-formula id="inline-formula35-1094342012457191">
<mml:math id="mml-inline35-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> intersected by the ray is chosen. The result is that the destination surface <inline-formula id="inline-formula36-1094342012457191">
<mml:math id="mml-inline36-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> is randomly selected with probability:<disp-formula id="disp-formula4-1094342012457191">
<label>4</label>
<mml:math id="mml-disp4-1094342012457191">
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mrow>
<mml:mo>|</mml:mo>
</mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">=</mml:mo>
<mml:msub>
<mml:mi>F</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
</mml:math>
<graphic alternate-form-of="disp-formula4-1094342012457191" xlink:href="10.1177_1094342012457191-eq4.tif"/>
</disp-formula>
</p>
<p>Therefore, the form factor can be computed by means of the equation:<disp-formula id="disp-formula5-1094342012457191">
<label>5</label>
<mml:math id="mml-disp5-1094342012457191">
<mml:msub>
<mml:mi>F</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">≃</mml:mo>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:mi>N</mml:mi>
<mml:msub>
<mml:mi>r</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:mi>N</mml:mi>
<mml:msub>
<mml:mi>r</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula5-1094342012457191" xlink:href="10.1177_1094342012457191-eq5.tif"/>
</disp-formula>
</p>
<p>where <inline-formula id="inline-formula37-1094342012457191">
<mml:math id="mml-inline37-1094342012457191">
<mml:mi>N</mml:mi>
<mml:msub>
<mml:mi>r</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> is the number of rays cast from <inline-formula id="inline-formula38-1094342012457191">
<mml:math id="mml-inline38-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula>, while <inline-formula id="inline-formula39-1094342012457191">
<mml:math id="mml-inline39-1094342012457191">
<mml:mi>N</mml:mi>
<mml:msub>
<mml:mi>r</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula> are the number of these rays that finally intersect <inline-formula id="inline-formula40-1094342012457191">
<mml:math id="mml-inline40-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:math>
</inline-formula>. In this way, we implicitly calculate a stochastic approximation of the form factor matrix.</p>
<p>Globally, a number of <inline-formula id="inline-formula41-1094342012457191">
<mml:math id="mml-inline41-1094342012457191">
<mml:mi>N</mml:mi>
<mml:mi>r</mml:mi>
</mml:math>
</inline-formula> rays are randomly cast in the scene. The number of rays at each iteration is proportional to the amount of power <inline-formula id="inline-formula42-1094342012457191">
<mml:math id="mml-inline42-1094342012457191">
<mml:mi mathvariant="normal">Δ</mml:mi>
<mml:msubsup>
<mml:mi>P</mml:mi>
<mml:mi>T</mml:mi>
<mml:mi>k</mml:mi>
</mml:msubsup>
</mml:math>
</inline-formula> to be propagated. A heuristic often used to select the total number of rays, <inline-formula id="inline-formula43-1094342012457191">
<mml:math id="mml-inline43-1094342012457191">
<mml:mi>N</mml:mi>
<mml:mi>r</mml:mi>
</mml:math>
</inline-formula>, aims for the convergence of the complete sequence of incremental shooting iterations (<xref ref-type="bibr" rid="bibr7-1094342012457191">Dutre et al., 2006</xref>):<disp-formula id="disp-formula6-1094342012457191">
<label>6</label>
<mml:math id="mml-disp6-1094342012457191">
<mml:mi>N</mml:mi>
<mml:mi>r</mml:mi>
<mml:mo stretchy="false">≃</mml:mo>
<mml:mn>9</mml:mn>
<mml:mo stretchy="false">⋅</mml:mo>
<mml:munder>
<mml:mrow>
<mml:mo form="prefix" movablelimits="true">max</mml:mo>
</mml:mrow>
<mml:mi>i</mml:mi>
</mml:munder>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi mathvariant="italic">ρ</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:msub>
<mml:mi>A</mml:mi>
<mml:mi>T</mml:mi>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>A</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula6-1094342012457191" xlink:href="10.1177_1094342012457191-eq6.tif"/>
</disp-formula>
</p>
<p>where <inline-formula id="inline-formula44-1094342012457191">
<mml:math id="mml-inline44-1094342012457191">
<mml:msub>
<mml:mi>A</mml:mi>
<mml:mi>T</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> is the total area of the surfaces in the scene. The time complexity of the stochastic Jacobi iterative algorithms for radiosity is roughly log-linear. The power is uniformly distributed among all rays so that the fraction of power per ray <inline-formula id="inline-formula45-1094342012457191">
<mml:math id="mml-inline45-1094342012457191">
<mml:msub>
<mml:mi>P</mml:mi>
<mml:mi>r</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> is<disp-formula id="disp-formula7-1094342012457191">
<label>7</label>
<mml:math id="mml-disp7-1094342012457191">
<mml:msub>
<mml:mi>P</mml:mi>
<mml:mi>r</mml:mi>
</mml:msub>
<mml:mo stretchy="false">=</mml:mo>
<mml:mrow>
<mml:mfrac>
<mml:mn>1</mml:mn>
<mml:mrow>
<mml:mi>N</mml:mi>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
<mml:mrow>
<mml:munderover>
<mml:mo movablelimits="false" stretchy="false">∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>N</mml:mi>
<mml:mi>s</mml:mi>
</mml:mrow>
</mml:munderover>
</mml:mrow>
<mml:msub>
<mml:mi>P</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo stretchy="false">=</mml:mo>
<mml:mrow>
<mml:mfrac>
<mml:mn>1</mml:mn>
<mml:mrow>
<mml:mi>N</mml:mi>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
<mml:mo stretchy="false">⋅</mml:mo>
<mml:msub>
<mml:mi>P</mml:mi>
<mml:mi>T</mml:mi>
</mml:msub>
</mml:math>
<graphic alternate-form-of="disp-formula7-1094342012457191" xlink:href="10.1177_1094342012457191-eq7.tif"/>
</disp-formula>
</p>
<p>where <inline-formula id="inline-formula46-1094342012457191">
<mml:math id="mml-inline46-1094342012457191">
<mml:msub>
<mml:mi>P</mml:mi>
<mml:mi>T</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> is the total available power in the environment.</p>
<p>The structure of the incremental stochastic Jacobi iterative radiosity algorithm is outlined in <xref ref-type="fig" rid="fig1-1094342012457191">Figure 1</xref>. First, total unshot power, <inline-formula id="inline-formula47-1094342012457191">
<mml:math id="mml-inline47-1094342012457191">
<mml:mi mathvariant="normal">Δ</mml:mi>
<mml:msubsup>
<mml:mi>P</mml:mi>
<mml:mi>T</mml:mi>
<mml:mn>0</mml:mn>
</mml:msubsup>
</mml:math>
</inline-formula>, and unshot power of each surface, <inline-formula id="inline-formula48-1094342012457191">
<mml:math id="mml-inline48-1094342012457191">
<mml:mi mathvariant="normal">Δ</mml:mi>
<mml:msubsup>
<mml:mi>P</mml:mi>
<mml:mi>i</mml:mi>
<mml:mn>0</mml:mn>
</mml:msubsup>
</mml:math>
</inline-formula>, are initialized (lines 1–5). In line 6 the power per ray is calculated; this value is constant during the process. While not converged, the process is repeated iteratively (line 7). In line 8 the number of samples, <inline-formula id="inline-formula49-1094342012457191">
<mml:math id="mml-inline49-1094342012457191">
<mml:mi>N</mml:mi>
<mml:mi>r</mml:mi>
</mml:math>
</inline-formula>, is calculated; this number is proportional to the amount of power <inline-formula id="inline-formula50-1094342012457191">
<mml:math id="mml-inline50-1094342012457191">
<mml:mi mathvariant="normal">Δ</mml:mi>
<mml:msubsup>
<mml:mi>P</mml:mi>
<mml:mi>T</mml:mi>
<mml:mi>k</mml:mi>
</mml:msubsup>
</mml:math>
</inline-formula> to be propagated in each iteration, and all rays carry the same amount of power. Then, the number of rays, <inline-formula id="inline-formula51-1094342012457191">
<mml:math id="mml-inline51-1094342012457191">
<mml:mi>N</mml:mi>
<mml:msub>
<mml:mi>r</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula>, to be shot from each surface <inline-formula id="inline-formula52-1094342012457191">
<mml:math id="mml-inline52-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> is computed (lines 11 and 12). To shoot a ray <inline-formula id="inline-formula53-1094342012457191">
<mml:math id="mml-inline53-1094342012457191">
<mml:mi>l</mml:mi>
</mml:math>
</inline-formula> from a surface <inline-formula id="inline-formula54-1094342012457191">
<mml:math id="mml-inline54-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula>, a point <inline-formula id="inline-formula55-1094342012457191">
<mml:math id="mml-inline55-1094342012457191">
<mml:msub>
<mml:mi>x</mml:mi>
<mml:mi>l</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> on the surface is selected and the ray is finally shot in a cosine-distributed direction <inline-formula id="inline-formula56-1094342012457191">
<mml:math id="mml-inline56-1094342012457191">
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mi>l</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> at <inline-formula id="inline-formula57-1094342012457191">
<mml:math id="mml-inline57-1094342012457191">
<mml:msub>
<mml:mi>x</mml:mi>
<mml:mi>l</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> (lines 15 and 16). For each shot ray, the closest surface <inline-formula id="inline-formula58-1094342012457191">
<mml:math id="mml-inline58-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> intersected by the ray is determined (line 17). To accelerate the ray shooting procedure a <inline-formula id="inline-formula59-1094342012457191">
<mml:math id="mml-inline59-1094342012457191">
<mml:mi>k</mml:mi>
<mml:mi>d</mml:mi>
</mml:math>
</inline-formula>-tree (<xref ref-type="bibr" rid="bibr9-1094342012457191">Havran, 2000</xref>) was used in our implementation. Specifically, we have used the implementation presented in <xref ref-type="bibr" rid="bibr17-1094342012457191">Pharr and Humphreys (2004</xref>). After this, <inline-formula id="inline-formula60-1094342012457191">
<mml:math id="mml-inline60-1094342012457191">
<mml:mi mathvariant="normal">Δ</mml:mi>
<mml:msubsup>
<mml:mi>P</mml:mi>
<mml:mi>j</mml:mi>
<mml:mrow>
<mml:mi>k</mml:mi>
<mml:mo stretchy="false">+</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msubsup>
</mml:math>
</inline-formula> is calculated (line 18). Finally, for each surface, its total power <inline-formula id="inline-formula61-1094342012457191">
<mml:math id="mml-inline61-1094342012457191">
<mml:msub>
<mml:mi>P</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> is incremented and the new total unshot power is updated (lines 21–25).</p>
<fig id="fig1-1094342012457191" position="float">
<label>Figure 1.</label>
<caption>
<p>Incremental stochastic Jacobi iterative algorithm.</p>
</caption>
<graphic xlink:href="10.1177_1094342012457191-fig1.tif"/>
</fig>
</sec>
</sec>
<sec id="section4-1094342012457191">
<title>3. Distributed Monte Carlo radiosity method</title>
<p>Our parallel implementation is based on a coarse-grained parallel strategy in which every processor computes the radiosity for the sub-scene assigned to it. The message-passing library MPI is used to manage interprocessor communication.</p>
<p>The parallel incremental stochastic Jacobi iterative method we propose is based on three techniques: convex partitioning of the scene to increase the capabilities of our method (larger scene sizes can be processed) and also to simplify the ray shooting procedure; utilization of ray packets to reduce the communications among processors; and a distributed procedure to test the end of each iteration to handle the iterative process on a distributed system. In addition, non-blocking communications to allow overlapping among computations and communications were used to increase the application’s performance. The three techniques we propose have entailed stiff challenges, from the algorithmic and computational point of view, when considering a message passing programming context and the non-blocking communications.</p>
<p>
<xref ref-type="fig" rid="fig2-1094342012457191">Figure 2</xref> shows the detailed structure of our parallel algorithm. First, the unshot power <inline-formula id="inline-formula62-1094342012457191">
<mml:math id="mml-inline62-1094342012457191">
<mml:mi mathvariant="normal">Δ</mml:mi>
<mml:msubsup>
<mml:mi>P</mml:mi>
<mml:mrow>
<mml:mi>T</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mi>d</mml:mi>
</mml:mrow>
<mml:mn>0</mml:mn>
</mml:msubsup>
</mml:math>
</inline-formula> of each sub-scene <inline-formula id="inline-formula63-1094342012457191">
<mml:math id="mml-inline63-1094342012457191">
<mml:mi>d</mml:mi>
</mml:math>
</inline-formula>, <inline-formula id="inline-formula64-1094342012457191">
<mml:math id="mml-inline64-1094342012457191">
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">≤</mml:mo>
<mml:mi>d</mml:mi>
<mml:mo stretchy="false">≤</mml:mo>
<mml:mi>N</mml:mi>
<mml:mi>d</mml:mi>
</mml:math>
</inline-formula>, is computed (line 1), where <inline-formula id="inline-formula65-1094342012457191">
<mml:math id="mml-inline65-1094342012457191">
<mml:mi>N</mml:mi>
<mml:mi>d</mml:mi>
</mml:math>
</inline-formula> is the number of sub-scenes in which the original scene was partitioned. The unshot power <inline-formula id="inline-formula66-1094342012457191">
<mml:math id="mml-inline66-1094342012457191">
<mml:mi mathvariant="normal">Δ</mml:mi>
<mml:msubsup>
<mml:mi>P</mml:mi>
<mml:mi>T</mml:mi>
<mml:mn>0</mml:mn>
</mml:msubsup>
</mml:math>
</inline-formula> of the whole scene is obtained by a reduction operation, i.e. results from all processors are collected and combined in a sum operation (line 2). The power per ray <inline-formula id="inline-formula67-1094342012457191">
<mml:math id="mml-inline67-1094342012457191">
<mml:msub>
<mml:mi>P</mml:mi>
<mml:mi>r</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> is also calculated according to a reduction operation (line 2).</p>
<fig id="fig2-1094342012457191" position="float">
<label>Figure 2.</label>
<caption>
<p>Distributed incremental stochastic Jacobi iterative pseudocode.</p>
</caption>
<graphic xlink:href="10.1177_1094342012457191-fig2.tif"/>
</fig>
<p>After this, the iterative process starts and is repeated until the convergence test is verified (line 3). The number of rays <inline-formula id="inline-formula68-1094342012457191">
<mml:math id="mml-inline68-1094342012457191">
<mml:mi>N</mml:mi>
<mml:msub>
<mml:mi>r</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> to be shot from each surface <inline-formula id="inline-formula69-1094342012457191">
<mml:math id="mml-inline69-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> is computed (line 6). These rays are shot from a random selected point of <inline-formula id="inline-formula70-1094342012457191">
<mml:math id="mml-inline70-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> in a cosine-distributed direction (lines 8 and 9). The surface intersected by each ray is searched. First, the objects of the local sub-scene <inline-formula id="inline-formula71-1094342012457191">
<mml:math id="mml-inline71-1094342012457191">
<mml:mi>d</mml:mi>
</mml:math>
</inline-formula> are analysed. A local <inline-formula id="inline-formula72-1094342012457191">
<mml:math id="mml-inline72-1094342012457191">
<mml:mi>k</mml:mi>
<mml:mi>d</mml:mi>
</mml:math>
</inline-formula>-tree for the acceleration of the ray shooting procedure is used. Each processor has a <inline-formula id="inline-formula73-1094342012457191">
<mml:math id="mml-inline73-1094342012457191">
<mml:mi>k</mml:mi>
<mml:mi>d</mml:mi>
</mml:math>
</inline-formula>-tree for the surfaces belonging to the assigned sub-scene (line 10). In case of a local intersection, the closest surface <inline-formula id="inline-formula74-1094342012457191">
<mml:math id="mml-inline74-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> intersected by the ray is determined and the associated power incremented <inline-formula id="inline-formula75-1094342012457191">
<mml:math id="mml-inline75-1094342012457191">
<mml:mi mathvariant="normal">Δ</mml:mi>
<mml:msubsup>
<mml:mi>P</mml:mi>
<mml:mi>j</mml:mi>
<mml:mrow>
<mml:mi>k</mml:mi>
<mml:mo stretchy="false">+</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msubsup>
</mml:math>
</inline-formula> (line 17). In other case (lines 11–15), the ray intersects a frontier which is a shared face of two neighbouring sub-scenes. Once the neighbouring processor <italic>υ</italic> is determined, the ray is attached to the ray packet associated with that frontier Buffer<italic>
<sub>d</sub>
</italic>
<sub>,<italic>υ</italic>
</sub>. As pointed out above, in order to optimize the communication performance a maximum ray packet size, <inline-formula id="inline-formula76-1094342012457191">
<mml:math id="mml-inline76-1094342012457191">
<mml:mi>N</mml:mi>
<mml:mi>b</mml:mi>
</mml:math>
</inline-formula>, is established. When the ray packet size reaches this threshold, the packet Buffer<italic>
<sub>d</sub>
</italic>
<sub>,<italic>υ</italic>
</sub> is sent to neighbour processor <italic>υ</italic> (line 14). In addition to the processing of local rays, the processor must check whether other rays are coming from neighbouring processors. If incoming rays have arrived, they are put into the local active ray queue Ray<inline-formula id="inline-formula77-1094342012457191">
<mml:math id="mml-inline77-1094342012457191">
<mml:msub>
<mml:mi>
</mml:mi>
<mml:mi>d</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> (line 19).</p>
<p>After all rays assigned to a sub-scene are processed, the corresponding processor must check whether all of the sent rays in the system have intersected any object (line 21). In the event that there are still rays to be processed, the assigned processor must detect whether the nearest object belongs to its sub-scene or, otherwise, re-send the ray to a neighbouring processor (line 22). Then, <inline-formula id="inline-formula78-1094342012457191">
<mml:math id="mml-inline78-1094342012457191">
<mml:mi mathvariant="normal">Δ</mml:mi>
<mml:msubsup>
<mml:mi>P</mml:mi>
<mml:mrow>
<mml:mi>T</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mi>d</mml:mi>
</mml:mrow>
<mml:mi>k</mml:mi>
</mml:msubsup>
</mml:math>
</inline-formula> is calculated (line 24) for each sub-scene <italic>d</italic>. Finally, the unshot power <inline-formula id="inline-formula79-1094342012457191">
<mml:math id="mml-inline79-1094342012457191">
<mml:mi mathvariant="normal">Δ</mml:mi>
<mml:msubsup>
<mml:mi>P</mml:mi>
<mml:mi>T</mml:mi>
<mml:mi>k</mml:mi>
</mml:msubsup>
</mml:math>
</inline-formula> of the whole scene is updated by a reduction operation (line 25).</p>
</sec>
<sec id="section5-1094342012457191">
<title>4. Convex partitioning methods</title>
<p>In this section we present the two methods we have employed to split the scene. The objective is to prevent the replication of the scene in the local memory of each processor and, at the same time, to reduce communications among processors through the exploitation of the data locality. Furthermore, this optimizes the ray shooting procedure due to the data locality exploitation and the reduction of the computational requirements (<xref ref-type="bibr" rid="bibr21-1094342012457191">Sanjurjo et al., 2007</xref>). The uniform partition method splits the scene into a regular grid of equal-sized sub-scenes. The non-uniform partition is based on the minimization of a distribution function with the objective of load balancing. Both methods generate convex sub-scenes enabling the computations associated with the ray shooting procedure to be simplified.</p>
<p>Within the wide range of existing partitioning techniques and due to the large number of data transfers associated with the dynamic algorithms, we have focused on parallel static graph partitioning algorithms. Among the partitioning techniques we have chosen geometric techniques, as we are dealing with geometric scenes and these techniques obtain extremely fast partitioning, based mainly on geometric information. Specifically, the algorithms we use are variants of the <italic>coordinate nested dissection</italic> (CND) algorithm (<xref ref-type="bibr" rid="bibr23-1094342012457191">Schloegel et al., 2003</xref>), a geometric technique that attempts to minimize the boundary between the sub-spaces (and, thus, the inter-processor communications) by splitting the mesh into two halves across its longest dimension.</p>
<p>The partitioning strategies we have employed generate convex sub-scenes enabling the ray shooting procedure which searches the closest intersected object by a given ray to be simplified. With a convex partition, if the ray intersects an object located in the same partition as the ray source, there is no need to check the remaining partitions and the communications are performed between neighbouring processors, i.e. processors in charge of neighbouring sub-scenes. With a non-convex partition all partitions have to be checked to ensure that the closest object has indeed been selected.</p>
<sec id="section6-1094342012457191">
<title>4.1. Uniform partitioning</title>
<p>The first partitioning technique we have employed makes a geometric uniform partition of the input scene. It splits the scene domain into a set of disjoint sub-spaces of the same shape and size, and it assigns all of the objects contained in a sub-space to the same processing element. This kind of partition is computed quickly and straightforwardly, and also provides high data locality.</p>
<p>A simple partitioning scheme would split the scene into two halves and then, recursively, split each sub-scene again. However, this would not generate equal-sized sub-spaces when the objective is an odd number of sub-scenes. By way of example the partitioning of <xref ref-type="fig" rid="fig3-1094342012457191">Figure 3</xref>(a). The algorithm we have employed does not employ this recursive structure. In our case, the number of splitting planes that are needed to split the scene along each coordinate axis is computed <italic>a priori</italic>. In this case, equal-sized sub-spaces can be obtained, as indicated in the example of <xref ref-type="fig" rid="fig3-1094342012457191">Figure 3</xref>(b). As an example, <xref ref-type="fig" rid="fig4-1094342012457191">Figure 4</xref> shows the result of the utilization of our uniform partitioning on a scene with <inline-formula id="inline-formula80-1094342012457191">
<mml:math id="mml-inline80-1094342012457191">
<mml:mi>N</mml:mi>
<mml:mi>d</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>4</mml:mn>
</mml:math>
</inline-formula>, where <inline-formula id="inline-formula81-1094342012457191">
<mml:math id="mml-inline81-1094342012457191">
<mml:mi>N</mml:mi>
<mml:mi>d</mml:mi>
</mml:math>
</inline-formula> is the number of sub-scenes. The original scene is partitioned into four sub-scenes with one partition along the <inline-formula id="inline-formula82-1094342012457191">
<mml:math id="mml-inline82-1094342012457191">
<mml:mi>x</mml:mi>
</mml:math>
</inline-formula>-axis and another along the <inline-formula id="inline-formula83-1094342012457191">
<mml:math id="mml-inline83-1094342012457191">
<mml:mi>y</mml:mi>
</mml:math>
</inline-formula>-axis.</p>
<fig id="fig3-1094342012457191" position="float">
<label>Figure 3.</label>
<caption>
<p>Recursive versus <italic>a priori</italic> partition: (a) Recursive partition in three sub-spaces; (b) <italic>a priori</italic> partition in three sub-spaces.</p>
</caption>
<graphic xlink:href="10.1177_1094342012457191-fig3.tif"/>
</fig>
<fig id="fig4-1094342012457191" position="float">
<label>Figure 4.</label>
<caption>
<p>Example of uniform partitioning into four sub-scenes.</p>
</caption>
<graphic xlink:href="10.1177_1094342012457191-fig4.tif"/>
</fig>
<p>The algorithm we have employed to partition and to distribute the sub-scenes among the processors is based on the prime factor decomposition of the number of sub-scenes <inline-formula id="inline-formula84-1094342012457191">
<mml:math id="mml-inline84-1094342012457191">
<mml:mi>N</mml:mi>
<mml:mi>d</mml:mi>
</mml:math>
</inline-formula> (<xref ref-type="bibr" rid="bibr2-1094342012457191">Amor et al., 2004</xref>). Let us denote <inline-formula id="inline-formula85-1094342012457191">
<mml:math id="mml-inline85-1094342012457191">
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>N</mml:mi>
<mml:msup>
<mml:mi>d</mml:mi>
<mml:mi>x</mml:mi>
</mml:msup>
<mml:mo stretchy="false">,</mml:mo>
<mml:mi>N</mml:mi>
<mml:msup>
<mml:mi>d</mml:mi>
<mml:mi>y</mml:mi>
</mml:msup>
<mml:mo stretchy="false">,</mml:mo>
<mml:mi>N</mml:mi>
<mml:msup>
<mml:mi>d</mml:mi>
<mml:mi>z</mml:mi>
</mml:msup>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula> as the number of sub-scenes in the <inline-formula id="inline-formula86-1094342012457191">
<mml:math id="mml-inline86-1094342012457191">
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>x</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mi>y</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mi>z</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula> directions. The number of partitions <inline-formula id="inline-formula87-1094342012457191">
<mml:math id="mml-inline87-1094342012457191">
<mml:mi>N</mml:mi>
<mml:mi>d</mml:mi>
</mml:math>
</inline-formula> is decomposed into prime factors <inline-formula id="inline-formula88-1094342012457191">
<mml:math id="mml-inline88-1094342012457191">
<mml:msub>
<mml:mi>d</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> such that <inline-formula id="inline-formula89-1094342012457191">
<mml:math id="mml-inline89-1094342012457191">
<mml:mi>N</mml:mi>
<mml:mi>d</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:msub>
<mml:mi>d</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo stretchy="false">⋅</mml:mo>
<mml:msub>
<mml:mi>d</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
<mml:mo stretchy="false">⋯</mml:mo>
<mml:msub>
<mml:mi>d</mml:mi>
<mml:mi>n</mml:mi>
</mml:msub>
</mml:math>
</inline-formula>. To compute the partitions in each direction, these prime factors are sorted in decreasing order. Then, each <inline-formula id="inline-formula90-1094342012457191">
<mml:math id="mml-inline90-1094342012457191">
<mml:msub>
<mml:mi>d</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> prime factor is employed to update the partition value associated with the dimension with minimum value <inline-formula id="inline-formula91-1094342012457191">
<mml:math id="mml-inline91-1094342012457191">
<mml:mi>N</mml:mi>
<mml:msup>
<mml:mi>d</mml:mi>
<mml:mi>j</mml:mi>
</mml:msup>
</mml:math>
</inline-formula> (<inline-formula id="inline-formula92-1094342012457191">
<mml:math id="mml-inline92-1094342012457191">
<mml:mi>N</mml:mi>
<mml:msup>
<mml:mi>d</mml:mi>
<mml:mi>j</mml:mi>
</mml:msup>
<mml:mo stretchy="false">=</mml:mo>
<mml:mo form="prefix" movablelimits="true">min</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>N</mml:mi>
<mml:msup>
<mml:mi>d</mml:mi>
<mml:mi>x</mml:mi>
</mml:msup>
<mml:mo stretchy="false">,</mml:mo>
<mml:mi>N</mml:mi>
<mml:msup>
<mml:mi>d</mml:mi>
<mml:mi>y</mml:mi>
</mml:msup>
<mml:mo stretchy="false">,</mml:mo>
<mml:mi>N</mml:mi>
<mml:msup>
<mml:mi>d</mml:mi>
<mml:mi>z</mml:mi>
</mml:msup>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula>) through a multiplication operation <inline-formula id="inline-formula93-1094342012457191">
<mml:math id="mml-inline93-1094342012457191">
<mml:mi>N</mml:mi>
<mml:msup>
<mml:mi>d</mml:mi>
<mml:mi>j</mml:mi>
</mml:msup>
<mml:mo stretchy="false">=</mml:mo>
<mml:mi>N</mml:mi>
<mml:msup>
<mml:mi>d</mml:mi>
<mml:mi>j</mml:mi>
</mml:msup>
<mml:msub>
<mml:mi>d</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula>.</p>
<p>By way of example let us consider the partitioning of a scene in <inline-formula id="inline-formula94-1094342012457191">
<mml:math id="mml-inline94-1094342012457191">
<mml:mi>N</mml:mi>
<mml:mi>d</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>36</mml:mn>
</mml:math>
</inline-formula> sub-scenes to be processed in a system with <inline-formula id="inline-formula95-1094342012457191">
<mml:math id="mml-inline95-1094342012457191">
<mml:mn>36</mml:mn>
</mml:math>
</inline-formula> processors. The number of sub-scenes is decomposed into prime factors: <inline-formula id="inline-formula96-1094342012457191">
<mml:math id="mml-inline96-1094342012457191">
<mml:mo fence="false" stretchy="false">{</mml:mo>
<mml:mn>3</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>3</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo fence="false" stretchy="false">}</mml:mo>
</mml:math>
</inline-formula>. The first three factors are initially assigned to <inline-formula id="inline-formula97-1094342012457191">
<mml:math id="mml-inline97-1094342012457191">
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>N</mml:mi>
<mml:msup>
<mml:mi>d</mml:mi>
<mml:mi>x</mml:mi>
</mml:msup>
<mml:mo stretchy="false">,</mml:mo>
<mml:mi>N</mml:mi>
<mml:msup>
<mml:mi>d</mml:mi>
<mml:mi>y</mml:mi>
</mml:msup>
<mml:mo stretchy="false">,</mml:mo>
<mml:mi>N</mml:mi>
<mml:msup>
<mml:mi>d</mml:mi>
<mml:mi>z</mml:mi>
</mml:msup>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">=</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mn>3</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>3</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula>. The last prime factor, <inline-formula id="inline-formula98-1094342012457191">
<mml:math id="mml-inline98-1094342012457191">
<mml:msub>
<mml:mi>d</mml:mi>
<mml:mn>4</mml:mn>
</mml:msub>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>2</mml:mn>
</mml:math>
</inline-formula>, is then employed to update <inline-formula id="inline-formula99-1094342012457191">
<mml:math id="mml-inline99-1094342012457191">
<mml:mi>N</mml:mi>
<mml:msup>
<mml:mi>d</mml:mi>
<mml:mi>z</mml:mi>
</mml:msup>
</mml:math>
</inline-formula>. The resulting partition configuration is <inline-formula id="inline-formula100-1094342012457191">
<mml:math id="mml-inline100-1094342012457191">
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>N</mml:mi>
<mml:msup>
<mml:mi>d</mml:mi>
<mml:mi>x</mml:mi>
</mml:msup>
<mml:mo stretchy="false">,</mml:mo>
<mml:mi>N</mml:mi>
<mml:msup>
<mml:mi>d</mml:mi>
<mml:mi>y</mml:mi>
</mml:msup>
<mml:mo stretchy="false">,</mml:mo>
<mml:mi>N</mml:mi>
<mml:msup>
<mml:mi>d</mml:mi>
<mml:mi>z</mml:mi>
</mml:msup>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">=</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mn>3</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>3</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>4</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula>.</p>
</sec>
<sec id="section7-1094342012457191">
<title>4.2. Non-uniform partitioning</title>
<p>Non-uniform partitioning is proposed to solve load balancing problems. The main drawback of the previous partitioning algorithm is the non-uniform load distribution among processors. This is due to the nature of the partitioning procedure because the splitting is performed in terms of geometric coordinates instead of the scene content. This can result in an important load imbalance problem in those scenes with very irregular objects distribution, such as scenes with very complex objects on a zone of the scene.</p>
<p>Our method is based on the minimization of a distribution function associated with the partition operation. Therefore, the objective is to select the partition which minimizes the distribution function. To guide the partition operation we define a distribution function which describes the load imbalance in terms of a given factor <inline-formula id="inline-formula101-1094342012457191">
<mml:math id="mml-inline101-1094342012457191">
<mml:mi>X</mml:mi>
</mml:math>
</inline-formula>. This factor is a specific property of each surface which can be employed to characterize the resulting partitions. The objective of the partitioning method is to obtain a set of sub-scenes with similar contribution to the <inline-formula id="inline-formula102-1094342012457191">
<mml:math id="mml-inline102-1094342012457191">
<mml:mi>X</mml:mi>
</mml:math>
</inline-formula> factor. There are different options to select a <inline-formula id="inline-formula103-1094342012457191">
<mml:math id="mml-inline103-1094342012457191">
<mml:mi>X</mml:mi>
</mml:math>
</inline-formula> factor (area, initial power, etc.) to guide the partitioning procedure. In Section 7 we evaluate the resulting performance and its behaviour in terms of the factor employed. Thus, the distribution function is defined by<disp-formula id="disp-formula8-1094342012457191">
<label>8</label>
<mml:math id="mml-disp8-1094342012457191">
<mml:mi mathvariant="italic">σ</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>X</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mi>N</mml:mi>
<mml:mi>d</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">=</mml:mo>
<mml:mrow>
<mml:mfrac>
<mml:mn>1</mml:mn>
<mml:mrow>
<mml:mover accent="true">
<mml:mi>X</mml:mi>
<mml:mo accent="true" stretchy="false">ˉ</mml:mo>
</mml:mover>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
<mml:msqrt>
<mml:mrow>
<mml:munderover>
<mml:mo movablelimits="false" stretchy="false">∑</mml:mo>
<mml:mrow>
<mml:mi>d</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>N</mml:mi>
<mml:mi>d</mml:mi>
</mml:mrow>
</mml:munderover>
</mml:mrow>
<mml:mo stretchy="false">(</mml:mo>
<mml:mover accent="true">
<mml:mi>X</mml:mi>
<mml:mo accent="true" stretchy="false">ˉ</mml:mo>
</mml:mover>
<mml:mo stretchy="false">−</mml:mo>
<mml:msup>
<mml:mi>X</mml:mi>
<mml:mi>d</mml:mi>
</mml:msup>
<mml:mrow>
<mml:msup>
<mml:mo stretchy="false">)</mml:mo>
<mml:mn>2</mml:mn>
</mml:msup>
</mml:mrow>
<mml:mrow>
<mml:mo>/</mml:mo>
</mml:mrow>
<mml:mi>N</mml:mi>
<mml:mi>d</mml:mi>
</mml:msqrt>
<mml:mo stretchy="false">,</mml:mo>
</mml:math>
<graphic alternate-form-of="disp-formula8-1094342012457191" xlink:href="10.1177_1094342012457191-eq8.tif"/>
</disp-formula>
</p>
<p>where <inline-formula id="inline-formula104-1094342012457191">
<mml:math id="mml-inline104-1094342012457191">
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>X</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mi>N</mml:mi>
<mml:mi>d</mml:mi>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula> is the partition of the scene into <inline-formula id="inline-formula105-1094342012457191">
<mml:math id="mml-inline105-1094342012457191">
<mml:mi>N</mml:mi>
<mml:mi>d</mml:mi>
</mml:math>
</inline-formula> sub-scenes and <inline-formula id="inline-formula106-1094342012457191">
<mml:math id="mml-inline106-1094342012457191">
<mml:mi>X</mml:mi>
</mml:math>
</inline-formula> is the factor employed to guide the partitioning. Here <inline-formula id="inline-formula107-1094342012457191">
<mml:math id="mml-inline107-1094342012457191">
<mml:mover accent="true">
<mml:mi>X</mml:mi>
<mml:mo accent="true" stretchy="false">ˉ</mml:mo>
</mml:mover>
</mml:math>
</inline-formula> is the average value of factor <inline-formula id="inline-formula108-1094342012457191">
<mml:math id="mml-inline108-1094342012457191">
<mml:mi>X</mml:mi>
</mml:math>
</inline-formula> for the scene and is defined by<disp-formula id="disp-formula9-1094342012457191">
<label>9</label>
<mml:math id="mml-disp9-1094342012457191">
<mml:mover accent="true">
<mml:mi>X</mml:mi>
<mml:mo accent="true" stretchy="false">ˉ</mml:mo>
</mml:mover>
<mml:mo stretchy="false">=</mml:mo>
<mml:mrow>
<mml:mfrac>
<mml:mn>1</mml:mn>
<mml:mrow>
<mml:mi>N</mml:mi>
<mml:mi>d</mml:mi>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
<mml:mrow>
<mml:munderover>
<mml:mo movablelimits="false" stretchy="false">∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>N</mml:mi>
<mml:mi>s</mml:mi>
</mml:mrow>
</mml:munderover>
</mml:mrow>
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo stretchy="false">,</mml:mo>
</mml:math>
<graphic alternate-form-of="disp-formula9-1094342012457191" xlink:href="10.1177_1094342012457191-eq9.tif"/>
</disp-formula>
</p>
<p>where <inline-formula id="inline-formula109-1094342012457191">
<mml:math id="mml-inline109-1094342012457191">
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> is the factor <inline-formula id="inline-formula110-1094342012457191">
<mml:math id="mml-inline110-1094342012457191">
<mml:mi>X</mml:mi>
</mml:math>
</inline-formula> for surface <inline-formula id="inline-formula111-1094342012457191">
<mml:math id="mml-inline111-1094342012457191">
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
</inline-formula>. In addition, for each sub-scene we define<disp-formula id="disp-formula10-1094342012457191">
<label>10</label>
<mml:math id="mml-disp10-1094342012457191">
<mml:msup>
<mml:mi>X</mml:mi>
<mml:mi>d</mml:mi>
</mml:msup>
<mml:mo stretchy="false">=</mml:mo>
<mml:mrow>
<mml:munderover>
<mml:mo movablelimits="false" stretchy="false">∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>N</mml:mi>
<mml:msup>
<mml:mi>s</mml:mi>
<mml:mi>d</mml:mi>
</mml:msup>
</mml:mrow>
</mml:munderover>
</mml:mrow>
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo stretchy="false">,</mml:mo>
<mml:mtext> </mml:mtext>
<mml:msub>
<mml:mi>S</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo stretchy="false">∈</mml:mo>
<mml:msup>
<mml:mrow>
<mml:mrow>
<mml:mi mathvariant="normal">S</mml:mi>
<mml:mi mathvariant="normal">u</mml:mi>
<mml:mi mathvariant="normal">b</mml:mi>
<mml:mi mathvariant="normal">_</mml:mi>
<mml:mi mathvariant="normal">S</mml:mi>
<mml:mi mathvariant="normal">c</mml:mi>
<mml:mi mathvariant="normal">e</mml:mi>
<mml:mi mathvariant="normal">n</mml:mi>
<mml:mi mathvariant="normal">e</mml:mi>
</mml:mrow>
</mml:mrow>
<mml:mi>d</mml:mi>
</mml:msup>
<mml:mo stretchy="false">,</mml:mo>
</mml:math>
<graphic alternate-form-of="disp-formula10-1094342012457191" xlink:href="10.1177_1094342012457191-eq10.tif"/>
</disp-formula>
</p>
<p>where <inline-formula id="inline-formula112-1094342012457191">
<mml:math id="mml-inline112-1094342012457191">
<mml:mi>N</mml:mi>
<mml:msup>
<mml:mi>s</mml:mi>
<mml:mi>d</mml:mi>
</mml:msup>
</mml:math>
</inline-formula> is the number of surfaces of the Sub_Scene<inline-formula id="inline-formula113-1094342012457191">
<mml:math id="mml-inline113-1094342012457191">
<mml:msup>
<mml:mi>
</mml:mi>
<mml:mi>d</mml:mi>
</mml:msup>
</mml:math>
</inline-formula>.</p>
<p>To obtain a good load balancing, the partition <inline-formula id="inline-formula114-1094342012457191">
<mml:math id="mml-inline114-1094342012457191">
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>X</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mi>N</mml:mi>
<mml:mi>d</mml:mi>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula> that minimizes <xref ref-type="disp-formula" rid="disp-formula8-1094342012457191">Equation 8</xref> has to be identified. We have employed a divide and conquer strategy to solve this NP-complete problem. This strategy consists in dividing the problem into several operations of smaller size, solving each basic operation independently and combining the results obtained to construct a solution to the original problem. In our proposal we work with the smaller optimization problem which searches for the optimum partitioning of a space into two sub-scenes <inline-formula id="inline-formula115-1094342012457191">
<mml:math id="mml-inline115-1094342012457191">
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>X</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula>. Hence, the objective is to find the partitioning into two sub-scenes <inline-formula id="inline-formula116-1094342012457191">
<mml:math id="mml-inline116-1094342012457191">
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>X</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula> that minimizes the function <inline-formula id="inline-formula117-1094342012457191">
<mml:math id="mml-inline117-1094342012457191">
<mml:mi mathvariant="italic">σ</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>X</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula>:<disp-formula id="disp-formula11-1094342012457191">
<label>11</label>
<mml:math id="mml-disp11-1094342012457191">
<mml:mi mathvariant="italic">σ</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>X</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">=</mml:mo>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:mrow>
<mml:mo>|</mml:mo>
</mml:mrow>
<mml:msup>
<mml:mi>X</mml:mi>
<mml:mn>1</mml:mn>
</mml:msup>
<mml:mo stretchy="false">−</mml:mo>
<mml:msup>
<mml:mi>X</mml:mi>
<mml:mn>2</mml:mn>
</mml:msup>
<mml:mrow>
<mml:mo>|</mml:mo>
</mml:mrow>
</mml:mrow>
<mml:mrow>
<mml:msup>
<mml:mi>X</mml:mi>
<mml:mn>1</mml:mn>
</mml:msup>
<mml:mo stretchy="false">+</mml:mo>
<mml:msup>
<mml:mi>X</mml:mi>
<mml:mn>2</mml:mn>
</mml:msup>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
<mml:mo stretchy="false">,</mml:mo>
</mml:math>
<graphic alternate-form-of="disp-formula11-1094342012457191" xlink:href="10.1177_1094342012457191-eq11.tif"/>
</disp-formula>
</p>
<p>where <inline-formula id="inline-formula118-1094342012457191">
<mml:math id="mml-inline118-1094342012457191">
<mml:msup>
<mml:mi>X</mml:mi>
<mml:mn>1</mml:mn>
</mml:msup>
</mml:math>
</inline-formula> and <inline-formula id="inline-formula119-1094342012457191">
<mml:math id="mml-inline119-1094342012457191">
<mml:msup>
<mml:mi>X</mml:mi>
<mml:mn>2</mml:mn>
</mml:msup>
</mml:math>
</inline-formula> are the factors of the two candidate sub-scenes. <inline-formula id="inline-formula120-1094342012457191">
<mml:math id="mml-inline120-1094342012457191">
<mml:mi mathvariant="italic">σ</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>X</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>0</mml:mn>
</mml:math>
</inline-formula> is equivalent to a perfect load balancing. In fact, the minimization finished when <inline-formula id="inline-formula121-1094342012457191">
<mml:math id="mml-inline121-1094342012457191">
<mml:mi mathvariant="italic">σ</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>X</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">&lt;</mml:mo>
<mml:mi>t</mml:mi>
<mml:mi>h</mml:mi>
<mml:mi>r</mml:mi>
</mml:math>
</inline-formula>, where <italic>thr</italic> is a user-specified threshold. Therefore, the search for an optimum partition <inline-formula id="inline-formula122-1094342012457191">
<mml:math id="mml-inline122-1094342012457191">
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>X</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mi>N</mml:mi>
<mml:mi>d</mml:mi>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula> can be decomposed into <inline-formula id="inline-formula123-1094342012457191">
<mml:math id="mml-inline123-1094342012457191">
<mml:mi>l</mml:mi>
<mml:mi>o</mml:mi>
<mml:msub>
<mml:mi>g</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>N</mml:mi>
<mml:mi>d</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula> simple stages that split each scene/sub-scene into two.</p>
<p>
<xref ref-type="fig" rid="fig5-1094342012457191">Figure 5</xref> shows an example where the scene is partitioned into four sub-scenes, <inline-formula id="inline-formula124-1094342012457191">
<mml:math id="mml-inline124-1094342012457191">
<mml:mi>N</mml:mi>
<mml:mi>d</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>4</mml:mn>
</mml:math>
</inline-formula>. In this example the <inline-formula id="inline-formula125-1094342012457191">
<mml:math id="mml-inline125-1094342012457191">
<mml:mi>X</mml:mi>
</mml:math>
</inline-formula> factor employed to guide the partition was the area of the surfaces in each sub-scene. In the first step the scene is partitioned into two partitions with the lower value of <inline-formula id="inline-formula126-1094342012457191">
<mml:math id="mml-inline126-1094342012457191">
<mml:mi mathvariant="italic">σ</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>A</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula>, corresponding in this example to <inline-formula id="inline-formula127-1094342012457191">
<mml:math id="mml-inline127-1094342012457191">
<mml:msubsup>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>A</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>2</mml:mn>
</mml:mrow>
<mml:mi>x</mml:mi>
</mml:msubsup>
</mml:math>
</inline-formula>. In the second step each sub-scene is once again sub-divided into two partitions, with <inline-formula id="inline-formula128-1094342012457191">
<mml:math id="mml-inline128-1094342012457191">
<mml:msubsup>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>A</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>2</mml:mn>
</mml:mrow>
<mml:mi>x</mml:mi>
</mml:msubsup>
</mml:math>
</inline-formula> again being the best partition for both sub-scenes.</p>
<fig id="fig5-1094342012457191" position="float">
<label>Figure 5.</label>
<caption>
<p>Example of non-uniform partitioning into four sub-scenes.</p>
</caption>
<graphic xlink:href="10.1177_1094342012457191-fig5.tif"/>
</fig>
<p>In our proposal a specific set of locations for each splitting plane are analysed and the optimum position identified. Specifically, and for each coordinate, a total of <inline-formula id="inline-formula129-1094342012457191">
<mml:math id="mml-inline129-1094342012457191">
<mml:msup>
<mml:mn>2</mml:mn>
<mml:mi>C</mml:mi>
</mml:msup>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>1</mml:mn>
</mml:math>
</inline-formula> uniformly distributed candidate positions are potentially analysed. This means that the split plane can be at locations <inline-formula id="inline-formula130-1094342012457191">
<mml:math id="mml-inline130-1094342012457191">
<mml:mo fence="false" stretchy="false">{</mml:mo>
<mml:mn>1</mml:mn>
<mml:mrow>
<mml:mo>/</mml:mo>
</mml:mrow>
<mml:msup>
<mml:mn>2</mml:mn>
<mml:mi>C</mml:mi>
</mml:msup>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>2</mml:mn>
<mml:mrow>
<mml:mo>/</mml:mo>
</mml:mrow>
<mml:msup>
<mml:mn>2</mml:mn>
<mml:mi>C</mml:mi>
</mml:msup>
<mml:mo stretchy="false">,</mml:mo>
<mml:mo stretchy="false">…</mml:mo>
<mml:mo stretchy="false">,</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:msup>
<mml:mn>2</mml:mn>
<mml:mi>C</mml:mi>
</mml:msup>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
<mml:mrow>
<mml:mo>/</mml:mo>
</mml:mrow>
<mml:msup>
<mml:mn>2</mml:mn>
<mml:mi>C</mml:mi>
</mml:msup>
<mml:mo fence="false" stretchy="false">}</mml:mo>
</mml:math>
</inline-formula> along the dimension of the scene. As will be shown below, the value of <inline-formula id="inline-formula131-1094342012457191">
<mml:math id="mml-inline131-1094342012457191">
<mml:mi>C</mml:mi>
</mml:math>
</inline-formula> is dynamically determined as being the minimum value that assures the minimization of the <inline-formula id="inline-formula132-1094342012457191">
<mml:math id="mml-inline132-1094342012457191">
<mml:mi mathvariant="italic">σ</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>X</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula> function with the lowest number of searching steps.</p>
<p>The search of the optimum location is performed with the assistance of a binary search tree. This permits the optimization of the searching procedure as not all of the candidate positions have to be analysed. By way of example <xref ref-type="fig" rid="fig6-1094342012457191">Figure 6</xref> shows a binary search tree for <inline-formula id="inline-formula133-1094342012457191">
<mml:math id="mml-inline133-1094342012457191">
<mml:mi>C</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>4</mml:mn>
</mml:math>
</inline-formula>. Each node represents a splitting plane where the root (labelled as 1/2) is the plane that divides the scene into two equal parts. Each node has two children that divide the corresponding space into two parts of the same size:<disp-formula id="disp-formula12-1094342012457191">
<label>12</label>
<mml:math id="mml-disp12-1094342012457191">
<mml:mtable columnspacing="1em" rowspacing="4pt">
<mml:mtr>
<mml:mtd>
<mml:mrow>
</mml:mrow>
</mml:mtd>
<mml:mtd>
<mml:mrow>
</mml:mrow>
</mml:mtd>
<mml:mtd>
<mml:mrow>
<mml:mi>S</mml:mi>
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mo stretchy="false">(</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>i</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo stretchy="false">+</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
<mml:mrow>
<mml:mo>/</mml:mo>
</mml:mrow>
<mml:mo stretchy="false">(</mml:mo>
<mml:mn>2</mml:mn>
<mml:mi>j</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mrow>
</mml:mrow>
</mml:mtd>
<mml:mtd>
<mml:mo stretchy="false">↗</mml:mo>
</mml:mtd>
<mml:mtd>
<mml:mrow>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mrow>
<mml:mi>S</mml:mi>
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mrow>
<mml:mo>/</mml:mo>
</mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mtd>
<mml:mtd>
<mml:mrow>
</mml:mrow>
</mml:mtd>
<mml:mtd>
<mml:mrow>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mrow>
</mml:mrow>
</mml:mtd>
<mml:mtd>
<mml:mo stretchy="false">↘</mml:mo>
</mml:mtd>
<mml:mtd>
<mml:mrow>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mrow>
</mml:mrow>
</mml:mtd>
<mml:mtd>
<mml:mrow>
</mml:mrow>
</mml:mtd>
<mml:mtd>
<mml:mrow>
<mml:mi>S</mml:mi>
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mo stretchy="false">(</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>i</mml:mi>
<mml:mo stretchy="false">−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo stretchy="false">+</mml:mo>
<mml:mn>3</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
<mml:mrow>
<mml:mo>/</mml:mo>
</mml:mrow>
<mml:mo stretchy="false">(</mml:mo>
<mml:mn>2</mml:mn>
<mml:mi>j</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mrow>
</mml:mrow>
</mml:mtd>
<mml:mtd>
<mml:mrow>
</mml:mrow>
</mml:mtd>
<mml:mtd>
<mml:mrow>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:math>
<graphic alternate-form-of="disp-formula12-1094342012457191" xlink:href="10.1177_1094342012457191-eq12.tif"/>
</disp-formula>
</p>
<fig id="fig6-1094342012457191" position="float">
<label>Figure 6.</label>
<caption>
<p>Example of binary search tree employed for the determination of the splitting plane position with <inline-formula id="inline-formula134-1094342012457191">
<mml:math id="mml-inline134-1094342012457191">
<mml:mi>C</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>4</mml:mn>
</mml:math>
</inline-formula>.</p>
</caption>
<graphic xlink:href="10.1177_1094342012457191-fig6.tif"/>
</fig>
<p>The resulting binary tree is employed for the best location identification. First the root location is analysed. If the resulting <inline-formula id="inline-formula135-1094342012457191">
<mml:math id="mml-inline135-1094342012457191">
<mml:mi mathvariant="italic">σ</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>X</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula> value is higher than a user-specified limit (see <xref ref-type="disp-formula" rid="disp-formula11-1094342012457191">Equation 11</xref>), the procedure continues with the children nodes. Specifically and assuming that the Sub_Scene<inline-formula id="inline-formula136-1094342012457191">
<mml:math id="mml-inline136-1094342012457191">
<mml:msup>
<mml:mi>
</mml:mi>
<mml:mn>1</mml:mn>
</mml:msup>
</mml:math>
</inline-formula> is the sub-scene with lower coordinate values, if <inline-formula id="inline-formula137-1094342012457191">
<mml:math id="mml-inline137-1094342012457191">
<mml:msup>
<mml:mi>X</mml:mi>
<mml:mn>1</mml:mn>
</mml:msup>
<mml:mo stretchy="false">&gt;</mml:mo>
<mml:msup>
<mml:mi>X</mml:mi>
<mml:mn>2</mml:mn>
</mml:msup>
</mml:math>
</inline-formula> the left node is analysed and otherwise the right node. The required nodes of the binary search tree are computed in run-time and the procedure ends when the <inline-formula id="inline-formula138-1094342012457191">
<mml:math id="mml-inline138-1094342012457191">
<mml:mi mathvariant="italic">σ</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>X</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula> value is lower than a user-specified threshold. <xref ref-type="fig" rid="fig7-1094342012457191">Figure 7</xref> illustrates this method. First, <inline-formula id="inline-formula139-1094342012457191">
<mml:math id="mml-inline139-1094342012457191">
<mml:mi>S</mml:mi>
<mml:msubsup>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mn>1</mml:mn>
<mml:mrow>
<mml:mo>/</mml:mo>
</mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
<mml:mi>x</mml:mi>
</mml:msubsup>
</mml:math>
</inline-formula> divides the space into two halves. As <inline-formula id="inline-formula140-1094342012457191">
<mml:math id="mml-inline140-1094342012457191">
<mml:msup>
<mml:mi>X</mml:mi>
<mml:mn>1</mml:mn>
</mml:msup>
<mml:mo stretchy="false">&gt;</mml:mo>
<mml:msup>
<mml:mi>X</mml:mi>
<mml:mn>2</mml:mn>
</mml:msup>
</mml:math>
</inline-formula>, the child node <inline-formula id="inline-formula141-1094342012457191">
<mml:math id="mml-inline141-1094342012457191">
<mml:mi>S</mml:mi>
<mml:msubsup>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mn>1</mml:mn>
<mml:mrow>
<mml:mo>/</mml:mo>
</mml:mrow>
<mml:mn>4</mml:mn>
</mml:mrow>
<mml:mi>x</mml:mi>
</mml:msubsup>
</mml:math>
</inline-formula> is chosen. The process continues by selecting <inline-formula id="inline-formula142-1094342012457191">
<mml:math id="mml-inline142-1094342012457191">
<mml:mi>S</mml:mi>
<mml:msubsup>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mn>3</mml:mn>
<mml:mrow>
<mml:mo>/</mml:mo>
</mml:mrow>
<mml:mn>8</mml:mn>
</mml:mrow>
<mml:mi>x</mml:mi>
</mml:msubsup>
</mml:math>
</inline-formula> and finally <inline-formula id="inline-formula143-1094342012457191">
<mml:math id="mml-inline143-1094342012457191">
<mml:mi>S</mml:mi>
<mml:msubsup>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mn>7</mml:mn>
<mml:mrow>
<mml:mo>/</mml:mo>
</mml:mrow>
<mml:mn>16</mml:mn>
</mml:mrow>
<mml:mi>x</mml:mi>
</mml:msubsup>
</mml:math>
</inline-formula>. Consequently, the binary search tree depth is <inline-formula id="inline-formula144-1094342012457191">
<mml:math id="mml-inline144-1094342012457191">
<mml:mi>C</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>4</mml:mn>
</mml:math>
</inline-formula>.</p>
<fig id="fig7-1094342012457191" position="float">
<label>Figure 7.</label>
<caption>
<p>Search of the splitting plane position (coordinate <inline-formula id="inline-formula145-1094342012457191">
<mml:math id="mml-inline145-1094342012457191">
<mml:mi>x</mml:mi>
</mml:math>
</inline-formula>).</p>
</caption>
<graphic xlink:href="10.1177_1094342012457191-fig7.tif"/>
</fig>
<p>In our approach, first the best splitting plane for each coordinate <inline-formula id="inline-formula146-1094342012457191">
<mml:math id="mml-inline146-1094342012457191">
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>S</mml:mi>
<mml:msup>
<mml:mi>D</mml:mi>
<mml:mi>x</mml:mi>
</mml:msup>
<mml:mo stretchy="false">,</mml:mo>
<mml:mi>S</mml:mi>
<mml:msup>
<mml:mi>D</mml:mi>
<mml:mi>y</mml:mi>
</mml:msup>
<mml:mo stretchy="false">,</mml:mo>
<mml:mi>S</mml:mi>
<mml:msup>
<mml:mi>D</mml:mi>
<mml:mi>z</mml:mi>
</mml:msup>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula> is determined, and then the final splitting plane has to be selected from them. To do so, the resulting sub-scene volumes are analysed. Specifically, and to improve the partitioning in the following stages, the final splitting plane <inline-formula id="inline-formula147-1094342012457191">
<mml:math id="mml-inline147-1094342012457191">
<mml:mi>S</mml:mi>
<mml:mi>D</mml:mi>
</mml:math>
</inline-formula> is the one that generates more balanced volumes, i.e. sub-scenes with a similar volume are preferred. This selection aims to minimize the number of rays to be communicated among processors.</p>
</sec>
</sec>
<sec id="section8-1094342012457191">
<title>5. Ray packing strategy</title>
<p>Any parallel implementation of the radiosity method is characterized by the large amount of information to be transmitted among processors. In the event that a ray from a surface does not intersect any other surface belonging to the same sub-scene, this ray is propagated to the neighbouring sub-scene. Regarding the parallel implementation, this implies communication between processors. Owing to the large number of rays to be processed and propagated among processors, the cost associated with communications is not negligible. This section describes a strategy used for minimizing and optimizing communications among sub-scenes (in our case equivalent to among processors).</p>
<p>As described in the previous section, partitioning methods are based on the generation of convex sub-scenes. This property allows the inherent simplification of the communication procedure as the sub-scene to be analysed can be directly identified for each one of the rays originated from a specific sub-scene. Thus, for each ray <inline-formula id="inline-formula148-1094342012457191">
<mml:math id="mml-inline148-1094342012457191">
<mml:mi>l</mml:mi>
</mml:math>
</inline-formula> originated in a sub-scene to be propagated to another one, the processor responsible for the source sub-scene must identify both the receiving sub-scene involved and the processor that has to process it. A message is then sent including the following information:<disp-formula id="disp-formula13-1094342012457191">
<label>13</label>
<mml:math id="mml-disp13-1094342012457191">
<mml:mi>M</mml:mi>
<mml:mi>e</mml:mi>
<mml:mi>s</mml:mi>
<mml:msub>
<mml:mi>s</mml:mi>
<mml:mi>l</mml:mi>
</mml:msub>
<mml:mo stretchy="false">=</mml:mo>
<mml:mo fence="false" stretchy="false">{</mml:mo>
<mml:msub>
<mml:mi>x</mml:mi>
<mml:mi>l</mml:mi>
</mml:msub>
<mml:mo stretchy="false">,</mml:mo>
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mi>l</mml:mi>
</mml:msub>
<mml:mo stretchy="false">,</mml:mo>
<mml:mi>r</mml:mi>
<mml:mi>g</mml:mi>
<mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>l</mml:mi>
</mml:msub>
<mml:mo fence="false" stretchy="false">}</mml:mo>
</mml:math>
<graphic alternate-form-of="disp-formula13-1094342012457191" xlink:href="10.1177_1094342012457191-eq13.tif"/>
</disp-formula>
</p>
<p>where <inline-formula id="inline-formula149-1094342012457191">
<mml:math id="mml-inline149-1094342012457191">
<mml:msub>
<mml:mi>x</mml:mi>
<mml:mi>l</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> are the coordinates of the ray source point, <inline-formula id="inline-formula150-1094342012457191">
<mml:math id="mml-inline150-1094342012457191">
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mi>l</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> are the values of the ray direction vector, and <inline-formula id="inline-formula151-1094342012457191">
<mml:math id="mml-inline151-1094342012457191">
<mml:mi>r</mml:mi>
<mml:mi>g</mml:mi>
<mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>l</mml:mi>
</mml:msub>
</mml:math>
</inline-formula> is the contribution per colour of ray <inline-formula id="inline-formula152-1094342012457191">
<mml:math id="mml-inline152-1094342012457191">
<mml:mi>l</mml:mi>
</mml:math>
</inline-formula> to the power in RGB format. Thus, a ray contributing only to the colour red has the following value on the field <italic>rgb</italic>, <inline-formula id="inline-formula153-1094342012457191">
<mml:math id="mml-inline153-1094342012457191">
<mml:mi>M</mml:mi>
<mml:mi>e</mml:mi>
<mml:mi>s</mml:mi>
<mml:msub>
<mml:mi>s</mml:mi>
<mml:mi>l</mml:mi>
</mml:msub>
<mml:mo stretchy="false">→</mml:mo>
<mml:mi>r</mml:mi>
<mml:mi>g</mml:mi>
<mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>l</mml:mi>
</mml:msub>
<mml:mo stretchy="false">=</mml:mo>
<mml:mo fence="false" stretchy="false">{</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>0</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>0</mml:mn>
<mml:mo fence="false" stretchy="false">}</mml:mo>
</mml:math>
</inline-formula>.</p>
<p>Once a processor receives this message, it then proceeds to process the ray and to identify the local element that intersects with that ray. In the event that no intersection occurs for that sub-scene, the ray is propagated to the neighbouring sub-scene. Once again the processor responsible for the source sub-scene must identify the new sub-scene to which the ray will be propagated and the processor assigned to the processing of that destination sub-scene; the ray is then sent to the destination sub-scene. Although the amount of rays not locally processed in a sub-scene is totally dependent on the nature of the scene and the partitioning method chosen, test results always indicate a large amount of communications among processors. In order to provide a view of the magnitude of the communications involved in the processing of a standard scene, for the <italic>Study</italic> scene (see Section 7) considering 32 processors and a non-uniform partitioning, 739,000 rays were generated and 1,200,000 messages were sent.</p>
<p>Following a similar strategy to the one used for ray tracing algorithms, our proposal for minimizing communications among processors relies on ray packing. Traditionally for these type of algorithms speedups were obtained by means of accelerating the processing of individual rays; spatial or hierarchical index structures were used for reducing the number of traversal steps and primitive intersections that need to be done for each ray. Recently, speedup strategies have focused on processing groups of rays. With these types of strategies memory accesses are minimized, common operations are shared, and also efficient exploitation of single instruction multiple data (SIMD) units is achieved (<xref ref-type="bibr" rid="bibr26-1094342012457191">Wald et al., 2001</xref>). One key aspect if this approach to be profitable is the grouping together of rays with the same origin and similar direction. Our approach creates a ray packet Buffer<italic>
<sub>d</sub>
</italic>
<sub>,<italic>υ</italic>
</sub> for each processor <inline-formula id="inline-formula154-1094342012457191">
<mml:math id="mml-inline154-1094342012457191">
<mml:mi>d</mml:mi>
</mml:math>
</inline-formula> and each one of the boundaries <italic>υ</italic> with neighbouring sub-scenes. This packet, to be sent to the processor in charge of that sub-scene, includes all of the messages from the source sub-scene propagated through the boundary <italic>υ</italic>.</p>
<p>The number of rays per packet, <inline-formula id="inline-formula155-1094342012457191">
<mml:math id="mml-inline155-1094342012457191">
<mml:mi>N</mml:mi>
<mml:mi>b</mml:mi>
</mml:math>
</inline-formula>, is constant for the scene to be processed. This number is determinant as a packet is not sent until it is complete, i.e. until <inline-formula id="inline-formula156-1094342012457191">
<mml:math id="mml-inline156-1094342012457191">
<mml:mi>N</mml:mi>
<mml:mi>b</mml:mi>
</mml:math>
</inline-formula> rays to be propagated through that boundary have been detected. Once all of the rays assigned to a processor have been processed, the incomplete packets are sent to the neighbouring processors and the procedure enters into the end of iteration checking stage, to be described in the next section. Incomplete packets are marked in order to be identified correctly by the receiving processors.</p>
<p>Packet size is crucial for application performance. Small packets can imply too many packets giving rise to excessive communications. The larger the packet size the larger the number of rays involved in incomplete packets is, hence the waiting time at each receiving processor also increases. Furthermore, larger packet sizes might paradoxically result in larger numbers of packets to be processed. This situation can occur when the processors enter into the end of iteration checking stage, so they send their own messages with incomplete packets and then they could receive incomplete packets from the neighbouring processors. Larger packet sizes imply larger timing requirements for the generation and communication of ray packets. Then the communications of packets among processors slows down and, as consequence, the processor waiting times for incoming ray packets also increase.</p>
<p>Following the same previous example (<italic>Study</italic> scene, 32 processors, and non-uniform partitioning), choosing <inline-formula id="inline-formula157-1094342012457191">
<mml:math id="mml-inline157-1094342012457191">
<mml:mi>N</mml:mi>
<mml:mi>b</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>100</mml:mn>
</mml:math>
</inline-formula> as packet size, 22,000 packets were generated while 11,000 were complete packets. Nevertheless, when <inline-formula id="inline-formula158-1094342012457191">
<mml:math id="mml-inline158-1094342012457191">
<mml:mi>N</mml:mi>
<mml:mi>b</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>1000</mml:mn>
</mml:math>
</inline-formula> was chosen as packet size, 36,000 packets were generated while only 586 were complete packets. A detailed analysis of packet size and the resulting performance is included in Section 7.</p>
</sec>
<sec id="section9-1094342012457191">
<title>6. Procedure to test the end of each iteration</title>
<p>Checking the end of each algorithm iteration is a challenge in a distributed memory system, as it has to be assured not only for each processor but for the whole system. To solve this problem, our distributed algorithm is based on two stages: one local (to each processor) and one distributed (among all processors). Our procedure avoids the inefficient blocking one-to-all communications and only requires the utilization of non-blocking communications.</p>
<p>In the first stage, each processor checks a local criterion. This test evaluates whether the processor has incoming unshot rays and whether there are incomplete ray packets that have not been sent. If the criterion is verified, the processor starts the second stage; otherwise incoming rays are processed and packets are sent.</p>
<p>In the second stage, each processor <inline-formula id="inline-formula159-1094342012457191">
<mml:math id="mml-inline159-1094342012457191">
<mml:mi>i</mml:mi>
</mml:math>
</inline-formula> sends non-blocking messages to all processors with the following information:</p>
<disp-formula id="disp-formula14-1094342012457191">
<mml:math id="mml-disp14-1094342012457191">
<mml:mi>I</mml:mi>
<mml:msup>
<mml:mi>F</mml:mi>
<mml:mi>i</mml:mi>
</mml:msup>
<mml:mo stretchy="false">=</mml:mo>
<mml:mo fence="false" stretchy="false">{</mml:mo>
<mml:msub>
<mml:mi>N</mml:mi>
<mml:mrow>
<mml:mi>S</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">,</mml:mo>
<mml:msub>
<mml:mi>N</mml:mi>
<mml:mrow>
<mml:mi>R</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">,</mml:mo>
<mml:msubsup>
<mml:mi>N</mml:mi>
<mml:mi>S</mml:mi>
<mml:mi>i</mml:mi>
</mml:msubsup>
<mml:mo stretchy="false">,</mml:mo>
<mml:msubsup>
<mml:mi>N</mml:mi>
<mml:mi>R</mml:mi>
<mml:mi>i</mml:mi>
</mml:msubsup>
<mml:mo fence="false" stretchy="false">}</mml:mo>
<mml:mo stretchy="false">,</mml:mo>
</mml:math>
<graphic alternate-form-of="disp-formula14-1094342012457191" xlink:href="10.1177_1094342012457191-eq14.tif"/>
</disp-formula>
<p>where <inline-formula id="inline-formula160-1094342012457191">
<mml:math id="mml-inline160-1094342012457191">
<mml:msub>
<mml:mi>N</mml:mi>
<mml:mrow>
<mml:mi>S</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">,</mml:mo>
<mml:msub>
<mml:mi>N</mml:mi>
<mml:mrow>
<mml:mi>R</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
</mml:math>
</inline-formula> are the total number of sent and received ray packets managed by processor <inline-formula id="inline-formula161-1094342012457191">
<mml:math id="mml-inline161-1094342012457191">
<mml:mi>i</mml:mi>
</mml:math>
</inline-formula>, respectively, and <inline-formula id="inline-formula162-1094342012457191">
<mml:math id="mml-inline162-1094342012457191">
<mml:msubsup>
<mml:mi>N</mml:mi>
<mml:mi>S</mml:mi>
<mml:mi>i</mml:mi>
</mml:msubsup>
<mml:mo stretchy="false">,</mml:mo>
<mml:msubsup>
<mml:mi>N</mml:mi>
<mml:mi>R</mml:mi>
<mml:mi>i</mml:mi>
</mml:msubsup>
</mml:math>
</inline-formula> are the total number of sent and received ray packets handled by all processors of the system according to the updated information available in processor <inline-formula id="inline-formula163-1094342012457191">
<mml:math id="mml-inline163-1094342012457191">
<mml:mi>i</mml:mi>
</mml:math>
</inline-formula>. The end of each iteration is detected when <inline-formula id="inline-formula164-1094342012457191">
<mml:math id="mml-inline164-1094342012457191">
<mml:msubsup>
<mml:mi>N</mml:mi>
<mml:mi>S</mml:mi>
<mml:mi>i</mml:mi>
</mml:msubsup>
<mml:mo stretchy="false">=</mml:mo>
<mml:msubsup>
<mml:mi>N</mml:mi>
<mml:mi>R</mml:mi>
<mml:mi>j</mml:mi>
</mml:msubsup>
</mml:math>
</inline-formula>, for <inline-formula id="inline-formula165-1094342012457191">
<mml:math id="mml-inline165-1094342012457191">
<mml:mn>1</mml:mn>
<mml:mo stretchy="false">≤</mml:mo>
<mml:mi>i</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mi>j</mml:mi>
<mml:mo stretchy="false">≤</mml:mo>
<mml:mi>N</mml:mi>
<mml:mi>d</mml:mi>
</mml:math>
</inline-formula>; i.e. when all processors have detected that the total number of sent ray packets in the system is equal to the total number of received ray packets, and this amount is the same for all processors.</p>
<p>Let us consider the example of <xref ref-type="table" rid="table1-1094342012457191">Table 1</xref>, where the total number of ray packets interchanged among each processor with its neighbours is indicated. For example Processor <inline-formula id="inline-formula166-1094342012457191">
<mml:math id="mml-inline166-1094342012457191">
<mml:mn>1</mml:mn>
</mml:math>
</inline-formula> sends 3 ray packets to Processor <inline-formula id="inline-formula167-1094342012457191">
<mml:math id="mml-inline167-1094342012457191">
<mml:mn>2</mml:mn>
</mml:math>
</inline-formula>, and 2 to Processor <inline-formula id="inline-formula168-1094342012457191">
<mml:math id="mml-inline168-1094342012457191">
<mml:mn>3</mml:mn>
</mml:math>
</inline-formula>, while it receives 2 from Processor <inline-formula id="inline-formula169-1094342012457191">
<mml:math id="mml-inline169-1094342012457191">
<mml:mn>2</mml:mn>
</mml:math>
</inline-formula>, and 4 from Processor <inline-formula id="inline-formula170-1094342012457191">
<mml:math id="mml-inline170-1094342012457191">
<mml:mn>3</mml:mn>
</mml:math>
</inline-formula>. Taking into account this information, let us now analyse the status of the iteration for a specific computational step where the following conditions are verified: Processor <inline-formula id="inline-formula171-1094342012457191">
<mml:math id="mml-inline171-1094342012457191">
<mml:mn>1</mml:mn>
</mml:math>
</inline-formula> is in the second stage of the test algorithm, it has not received any information from other processors, and has sent its <inline-formula id="inline-formula172-1094342012457191">
<mml:math id="mml-inline172-1094342012457191">
<mml:mi>I</mml:mi>
<mml:msup>
<mml:mi>F</mml:mi>
<mml:mn>1</mml:mn>
</mml:msup>
</mml:math>
</inline-formula> to the other processors; Processor <inline-formula id="inline-formula173-1094342012457191">
<mml:math id="mml-inline173-1094342012457191">
<mml:mn>2</mml:mn>
</mml:math>
</inline-formula> has not finished the first stage of the test algorithm; Processors <inline-formula id="inline-formula174-1094342012457191">
<mml:math id="mml-inline174-1094342012457191">
<mml:mn>3</mml:mn>
</mml:math>
</inline-formula> and <inline-formula id="inline-formula175-1094342012457191">
<mml:math id="mml-inline175-1094342012457191">
<mml:mn>4</mml:mn>
</mml:math>
</inline-formula> have finished the first stage of the test and have just started the second stage, but they still have not send their <inline-formula id="inline-formula176-1094342012457191">
<mml:math id="mml-inline176-1094342012457191">
<mml:mi>I</mml:mi>
<mml:mi>F</mml:mi>
</mml:math>
</inline-formula> to the other processors. Taking into account these conditions, the information to be communicated is<disp-formula id="disp-formula15-1094342012457191">
<mml:math id="mml-disp15-1094342012457191">
<mml:mtable columnspacing="1em" rowspacing="4pt">
<mml:mtr>
<mml:mtd>
<mml:mrow>
<mml:mi>I</mml:mi>
<mml:msup>
<mml:mi>F</mml:mi>
<mml:mn>1</mml:mn>
</mml:msup>
<mml:mo stretchy="false">=</mml:mo>
</mml:mrow>
</mml:mtd>
<mml:mtd>
<mml:mrow>
<mml:mo fence="false" stretchy="false">{</mml:mo>
<mml:mn>5</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>6</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>5</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>6</mml:mn>
<mml:mo fence="false" stretchy="false">}</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mrow>
<mml:mi>I</mml:mi>
<mml:msup>
<mml:mi>F</mml:mi>
<mml:mn>2</mml:mn>
</mml:msup>
<mml:mo stretchy="false">=</mml:mo>
</mml:mrow>
</mml:mtd>
<mml:mtd>
<mml:mrow>
<mml:mo fence="false" stretchy="false">{</mml:mo>
<mml:mo stretchy="false">−</mml:mo>
<mml:mo stretchy="false">,</mml:mo>
<mml:mo stretchy="false">−</mml:mo>
<mml:mo stretchy="false">,</mml:mo>
<mml:mo stretchy="false">−</mml:mo>
<mml:mo stretchy="false">,</mml:mo>
<mml:mo stretchy="false">−</mml:mo>
<mml:mo fence="false" stretchy="false">}</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mrow>
<mml:mi>I</mml:mi>
<mml:msup>
<mml:mi>F</mml:mi>
<mml:mn>3</mml:mn>
</mml:msup>
<mml:mo stretchy="false">=</mml:mo>
</mml:mrow>
</mml:mtd>
<mml:mtd>
<mml:mrow>
<mml:mo fence="false" stretchy="false">{</mml:mo>
<mml:mn>7</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>3</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>12</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>9</mml:mn>
<mml:mo fence="false" stretchy="false">}</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mrow>
<mml:mi>I</mml:mi>
<mml:msup>
<mml:mi>F</mml:mi>
<mml:mn>4</mml:mn>
</mml:msup>
<mml:mo stretchy="false">=</mml:mo>
</mml:mrow>
</mml:mtd>
<mml:mtd>
<mml:mrow>
<mml:mo fence="false" stretchy="false">{</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>4</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>7</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>10</mml:mn>
<mml:mo fence="false" stretchy="false">}</mml:mo>
<mml:mo>.</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:math>
<graphic alternate-form-of="disp-formula15-1094342012457191" xlink:href="10.1177_1094342012457191-eq15.tif"/>
</disp-formula>
</p>
<table-wrap id="table1-1094342012457191" position="float">
<label>Table 1.</label>
<caption>
<p>Example of ray packets interchanged among processors.</p>
</caption>
<graphic alternate-form-of="table1-1094342012457191" xlink:href="10.1177_1094342012457191-table1.tif"/>
<table>
<thead>
<tr>
<th colspan="2">
</th>
<th colspan="4">Sender</th>
</tr>
<tr>
<th>
</th>
<th>Processors</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>Receiver</td>
<td>1</td>
<td align="center">–</td>
<td>2</td>
<td>4</td>
<td align="center">–</td>
</tr>
<tr>
<td>
</td>
<td>2</td>
<td>3</td>
<td align="center">–</td>
<td align="center">–</td>
<td>1</td>
</tr>
<tr>
<td>
</td>
<td>3</td>
<td>2</td>
<td align="center">–</td>
<td align="center">–</td>
<td>1</td>
</tr>
<tr>
<td>
</td>
<td>4</td>
<td align="center">–</td>
<td>1</td>
<td>3</td>
<td align="center">–</td>
</tr>
</tbody>
</table>
</table-wrap>
<p>That is, <inline-formula id="inline-formula177-1094342012457191">
<mml:math id="mml-inline177-1094342012457191">
<mml:mi>I</mml:mi>
<mml:msup>
<mml:mi>F</mml:mi>
<mml:mn>1</mml:mn>
</mml:msup>
</mml:math>
</inline-formula> indicates that Processor <inline-formula id="inline-formula178-1094342012457191">
<mml:math id="mml-inline178-1094342012457191">
<mml:mn>1</mml:mn>
</mml:math>
</inline-formula> only has local information and it has sent 5 ray packets and received 6 ray packets. Processors <inline-formula id="inline-formula179-1094342012457191">
<mml:math id="mml-inline179-1094342012457191">
<mml:mn>3</mml:mn>
</mml:math>
</inline-formula> and <inline-formula id="inline-formula180-1094342012457191">
<mml:math id="mml-inline180-1094342012457191">
<mml:mn>4</mml:mn>
</mml:math>
</inline-formula> have their local information together with the information received from Processor <inline-formula id="inline-formula181-1094342012457191">
<mml:math id="mml-inline181-1094342012457191">
<mml:mn>1</mml:mn>
</mml:math>
</inline-formula>, that is, <inline-formula id="inline-formula182-1094342012457191">
<mml:math id="mml-inline182-1094342012457191">
<mml:mi>I</mml:mi>
<mml:msup>
<mml:mi>F</mml:mi>
<mml:mn>1</mml:mn>
</mml:msup>
</mml:math>
</inline-formula>. For example, Processor <inline-formula id="inline-formula183-1094342012457191">
<mml:math id="mml-inline183-1094342012457191">
<mml:mn>3</mml:mn>
</mml:math>
</inline-formula> has sent 7 ray packets and received 3 ray packets, but it has been notified that another processor has sent 5 ray packets and received 6 ray packets. In consequence, the total number of interchanged ray packets according to the information available in Processor <inline-formula id="inline-formula184-1094342012457191">
<mml:math id="mml-inline184-1094342012457191">
<mml:mn>3</mml:mn>
</mml:math>
</inline-formula> is that 12 ray packets have been sent, and 9 have been received in the whole system. The end of the iteration is determined when these total number of sent/received ray packets is the same for all processors.</p>
</sec>
<sec id="section10-1094342012457191">
<title>7. Experimental results</title>
<p>In this section, we present the performance results and analysis of our proposal. The parallel incremental stochastic Jacobi iterative method has been implemented using the message–passing paradigm. Specifically, we have used the MPI programming environment.</p>
<p>To evaluate our proposal we have used the <italic>Finis Terrae</italic> supercomputer<sup>
<xref ref-type="fn" rid="fn1-1094342012457191">1</xref>
</sup> that provides nodes with 16 Itanium 2 Montvale 1.6 GHz physical cores, with access to a shared memory of 128 GB. Nodes are connected through an Infiniband Network with 16 Gbps interconnection bandwidth and a very low latency, which for the user is 6 <inline-formula id="inline-formula185-1094342012457191">
<mml:math id="mml-inline185-1094342012457191">
<mml:mi mathvariant="italic">μ</mml:mi>
</mml:math>
</inline-formula>s. The policy of occupation for the <italic>Finis Terrae</italic> is based on the maximization of the number of MPI processes per node. As consequence, MPI processes of one application can finally be mapped to the same node or to different nodes. In addition, the system allows a load of up to 32 MPI processes per application. This system is a DSM (distributed shared memory) but we use it as a distributed memory system.</p>
<p>A set of test scenes to demonstrate the performance of our parallel algorithm were rendered: <italic>Building</italic> scene (see <xref ref-type="fig" rid="fig8-1094342012457191">Figure 8</xref>(a)), <italic>LivingRoom</italic> (see <xref ref-type="fig" rid="fig8-1094342012457191">Figure 8</xref>(b)), <italic>Study</italic> scene (see <xref ref-type="fig" rid="fig8-1094342012457191">Figure 8</xref>(c)), and <italic>PowerPlant</italic> scene (see <xref ref-type="fig" rid="fig8-1094342012457191">Figure 8</xref>(d)). With the objective of obtaining speedups with respect to the sequential version, the scenes employed fit into the memory of a single processor. These scenes were selected due to their specific characteristics in terms of regularity, objects and light conditions, allowing the performance of our algorithm and its dependence on the nature of the scene to be characterized. The <italic>Building</italic> scene was built by replicating a room <inline-formula id="inline-formula186-1094342012457191">
<mml:math id="mml-inline186-1094342012457191">
<mml:mn>4</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
<mml:mn>4</mml:mn>
<mml:mo stretchy="false">×</mml:mo>
<mml:mn>4</mml:mn>
</mml:math>
</inline-formula> times, locating open doors between rooms. Consequently, this scene presents a very regular distribution of objects and lights. The <italic>LivingRoom</italic> scene has an irregular distribution of objects with non-illuminated areas (a corridor without lights). The <italic>Study</italic> scene has an irregular distribution of objects and regular light distribution. Finally, the <italic>PowerPlant</italic> scene consists of 1,174,550 triangles, and it is based on the Power Plant Model available from UNC WWW site,<sup>
<xref ref-type="fn" rid="fn2-1094342012457191">2</xref>
</sup>, a model of an actual coal fired power plant used also frequently as reference test in Computer Graphics.</p>
<fig id="fig8-1094342012457191" position="float">
<label>Figure 8.</label>
<caption>
<p>Test scenes: (a) <italic>Building</italic>; (b) <italic>LivingRoom</italic>; (c) <italic>Study</italic>; (d) <italic>PowerPlant</italic>.</p>
</caption>
<graphic xlink:href="10.1177_1094342012457191-fig8.tif"/>
</fig>
<p>The performance of our proposal and the influence of different factors <inline-formula id="inline-formula187-1094342012457191">
<mml:math id="mml-inline187-1094342012457191">
<mml:mi>X</mml:mi>
</mml:math>
</inline-formula> on the results were analysed. First, in terms of speedup and quality, it was verified that the convex partition algorithm is a good solution for the partitioning and distribution of the scene among processors on a distributed memory system. Furthermore, two approaches were compared: uniform and non-uniform partitioning. To simplify, we have considered that each sub-scene is assigned to a processor, that is, <italic>Nd</italic> is the number of processors. After testing the benefits of the non-uniform partitioning strategy the influence of the factors that can be employed to guide the partitioning procedure was analysed. The timing costs associated with the partitioning techniques were also analysed. Once the best partitioning procedure was selected, the influence of the maximum ray packet size, <inline-formula id="inline-formula188-1094342012457191">
<mml:math id="mml-inline188-1094342012457191">
<mml:mi>N</mml:mi>
<mml:mi>b</mml:mi>
</mml:math>
</inline-formula>, was tested.</p>
<p>First of all, an analysis of our partitioning method was performed. <xref ref-type="fig" rid="fig9-1094342012457191">Figure 9</xref> shows the speedup for our parallel algorithm with the uniform partitioning method (see Section 4.1) for different number of processors. These data have been measured with respect to the results obtained with the purely sequential algorithm without scene partitioning. The execution times for the sequential algorithm were 19.21, 23.48, 12.50 and 848.72 seconds for the <italic>Building</italic>, <italic>LivingRoom</italic>, <italic>Study</italic> and <italic>PowerPlant</italic> scenes, respectively. In terms of speedup, good performance was obtained with our proposal for the <italic>Building</italic> scene. For example for 32 processors, the execution time was 0.96 seconds for this scene, corresponding to a speedup of 19.93. For the other scenes and 32 processors, the execution times were 2.28 seconds for the <italic>LivingRoom</italic> scene, 1.26 seconds for the <italic>Study</italic> scene, and 114.65 seconds for the <italic>PowerPlant</italic> scene, corresponding to speedups of 10.32, 9.96 and 7.40, respectively. The good result for the <italic>Building</italic> scene is associated with its regularity characterized by the uniform distribution of objects and lights, ideal characteristics for a uniform partitioning method, as it balances the load and reduces target patch searching time and cache misses (<xref ref-type="bibr" rid="bibr21-1094342012457191">Sanjurjo et al., 2007</xref>). Lower speedups were obtained for the other three scenes with non-uniform distributions of objects and lights that imply a lack of load balancing.</p>
<fig id="fig9-1094342012457191" position="float">
<label>Figure 9.</label>
<caption>
<p>Speedup using uniform partitioning.</p>
</caption>
<graphic xlink:href="10.1177_1094342012457191-fig9.tif"/>
</fig>
<p>Hence, the non-uniform partition explained in Section 4.2 was analysed. As explained above, our method is based on the selection of an adequate <inline-formula id="inline-formula189-1094342012457191">
<mml:math id="mml-inline189-1094342012457191">
<mml:mi>X</mml:mi>
</mml:math>
</inline-formula> factor to guide the partitioning and the minimization of a distribution function (see <xref ref-type="disp-formula" rid="disp-formula8-1094342012457191">Equation 8</xref>). As result of our analysis the following factor was finally selected:<disp-formula id="disp-formula16-1094342012457191">
<label>14</label>
<mml:math id="mml-disp16-1094342012457191">
<mml:mi>X</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mi>k</mml:mi>
<mml:mo stretchy="false">⋅</mml:mo>
<mml:mi>P</mml:mi>
<mml:mo stretchy="false">+</mml:mo>
<mml:mi>A</mml:mi>
<mml:mo stretchy="false">;</mml:mo>
<mml:mn>0.0</mml:mn>
<mml:mo stretchy="false">≤</mml:mo>
<mml:mi>k</mml:mi>
<mml:mo stretchy="false">≤</mml:mo>
<mml:mn>15.0</mml:mn>
<mml:mo stretchy="false">,</mml:mo>
</mml:math>
<graphic alternate-form-of="disp-formula16-1094342012457191" xlink:href="10.1177_1094342012457191-eq16.tif"/>
</disp-formula>
</p>
<p>where <inline-formula id="inline-formula190-1094342012457191">
<mml:math id="mml-inline190-1094342012457191">
<mml:mi>P</mml:mi>
</mml:math>
</inline-formula> and <inline-formula id="inline-formula191-1094342012457191">
<mml:math id="mml-inline191-1094342012457191">
<mml:mi>A</mml:mi>
</mml:math>
</inline-formula> are the normalized values of the radiant power and the area of a sub-scene, respectively. With <inline-formula id="inline-formula192-1094342012457191">
<mml:math id="mml-inline192-1094342012457191">
<mml:mi>k</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>0</mml:mn>
</mml:math>
</inline-formula>, the partitioning is guided by area parameters, whereas <inline-formula id="inline-formula193-1094342012457191">
<mml:math id="mml-inline193-1094342012457191">
<mml:mi>k</mml:mi>
<mml:mo stretchy="false">&gt;</mml:mo>
<mml:mn>0</mml:mn>
</mml:math>
</inline-formula> improves the partitioning methodology by including the radiant power as guidance on the procedure. <xref ref-type="fig" rid="fig10-1094342012457191">Figure 10</xref> displays the speedup obtained for all of the scenes under test for the non-uniform partitioning method and with <inline-formula id="inline-formula194-1094342012457191">
<mml:math id="mml-inline194-1094342012457191">
<mml:mi>N</mml:mi>
<mml:mi>d</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>32</mml:mn>
</mml:math>
</inline-formula> for different values of <inline-formula id="inline-formula195-1094342012457191">
<mml:math id="mml-inline195-1094342012457191">
<mml:mi>k</mml:mi>
</mml:math>
</inline-formula>. As can be observed in the figure, the execution time for each scene varies with <inline-formula id="inline-formula196-1094342012457191">
<mml:math id="mml-inline196-1094342012457191">
<mml:mi>k</mml:mi>
</mml:math>
</inline-formula> for low <inline-formula id="inline-formula197-1094342012457191">
<mml:math id="mml-inline197-1094342012457191">
<mml:mi>k</mml:mi>
</mml:math>
</inline-formula> values (<inline-formula id="inline-formula198-1094342012457191">
<mml:math id="mml-inline198-1094342012457191">
<mml:mi>k</mml:mi>
<mml:mo stretchy="false">&lt;</mml:mo>
<mml:mn>1</mml:mn>
</mml:math>
</inline-formula> for the <italic>Building</italic> scene, <inline-formula id="inline-formula199-1094342012457191">
<mml:math id="mml-inline199-1094342012457191">
<mml:mi>k</mml:mi>
<mml:mo stretchy="false">&lt;</mml:mo>
<mml:mn>4</mml:mn>
</mml:math>
</inline-formula> for the <italic>LivingRoom</italic> scene, <inline-formula id="inline-formula200-1094342012457191">
<mml:math id="mml-inline200-1094342012457191">
<mml:mi>k</mml:mi>
<mml:mo stretchy="false">&lt;</mml:mo>
<mml:mn>9</mml:mn>
</mml:math>
</inline-formula> for the <italic>Study</italic> scene, and <inline-formula id="inline-formula201-1094342012457191">
<mml:math id="mml-inline201-1094342012457191">
<mml:mi>k</mml:mi>
<mml:mo stretchy="false">&lt;</mml:mo>
<mml:mn>1.5</mml:mn>
</mml:math>
</inline-formula> for the <italic>PowerPlant</italic> scene), and is almost independent on <inline-formula id="inline-formula202-1094342012457191">
<mml:math id="mml-inline202-1094342012457191">
<mml:mi>k</mml:mi>
</mml:math>
</inline-formula> for larger <inline-formula id="inline-formula203-1094342012457191">
<mml:math id="mml-inline203-1094342012457191">
<mml:mi>k</mml:mi>
</mml:math>
</inline-formula> values. Employing the area as the unique parameter to guide the partitioning procedure (i.e. <inline-formula id="inline-formula204-1094342012457191">
<mml:math id="mml-inline204-1094342012457191">
<mml:mi>k</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>0</mml:mn>
</mml:math>
</inline-formula>) can generate partitions with non-illuminated zones with the consequent degradation of the load balance, as these non-illuminated sub-scenes involve poor workload or none at all. Note that this lack of computational load in some of the nodes can be solved after some initial iterations, when incoming power from other sub-scenes is detected and processed. For this reason, it seems reasonable that larger <inline-formula id="inline-formula205-1094342012457191">
<mml:math id="mml-inline205-1094342012457191">
<mml:mi>k</mml:mi>
</mml:math>
</inline-formula> values would result in equal or larger speedups as the utilization of the power as a guide would solve the situations associated with sub-scenes without light sources.</p>
<fig id="fig10-1094342012457191" position="float">
<label>Figure 10.</label>
<caption>
<p>Speedup using non-uniform partitioning with different <inline-formula id="inline-formula206-1094342012457191">
<mml:math id="mml-inline206-1094342012457191">
<mml:mi>k</mml:mi>
</mml:math>
</inline-formula> values and <inline-formula id="inline-formula207-1094342012457191">
<mml:math id="mml-inline207-1094342012457191">
<mml:mi>N</mml:mi>
<mml:mi>d</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>32</mml:mn>
</mml:math>
</inline-formula>: (a) <italic>Building</italic>; (b) <italic>LivingRoom</italic>; (c) <italic>Study</italic>; (d) <italic>PowerPlant</italic>.</p>
</caption>
<graphic xlink:href="10.1177_1094342012457191-fig10.tif"/>
</fig>
<p>Taking this into account, <inline-formula id="inline-formula208-1094342012457191">
<mml:math id="mml-inline208-1094342012457191">
<mml:mi>k</mml:mi>
<mml:mo stretchy="false">≠</mml:mo>
<mml:mn>0</mml:mn>
</mml:math>
</inline-formula> would seem to be desirable for the first iterations in order to avoid partitions with non-illuminated zones. However, for the following iterations a different partition prioritizing area parameters could result in better results. As can be observed in the figure, there are specific <inline-formula id="inline-formula209-1094342012457191">
<mml:math id="mml-inline209-1094342012457191">
<mml:mi>k</mml:mi>
</mml:math>
</inline-formula> values that result in very high speedups for the <italic>LivingRoom</italic>, <italic>Study</italic>, and <italic>PowerPlant</italic> scenes. Note that these scenes are characterized by non uniform distribution of the geometry and light sources. These specific <inline-formula id="inline-formula210-1094342012457191">
<mml:math id="mml-inline210-1094342012457191">
<mml:mi>k</mml:mi>
</mml:math>
</inline-formula> values combine the advantages of the use of the power as a parameter for the first iterations, and the inclusion of the area as factor to guide the partitioning procedure for the following iterations. Note also that for <italic>Study</italic> and <italic>PowerPlant</italic> scenes (see <xref ref-type="fig" rid="fig10-1094342012457191">Figure 10</xref>(c) and (d)) a strong degradation in performance is obtained for large values of <inline-formula id="inline-formula211-1094342012457191">
<mml:math id="mml-inline211-1094342012457191">
<mml:mi>k</mml:mi>
</mml:math>
</inline-formula>, as in this case almost empty sub-scenes are generated.</p>
<p>The next step in the analysis was to compare the results of the uniform partitioning with the best results obtained with the non-uniform partitionings. <xref ref-type="fig" rid="fig11-1094342012457191">Figures 11</xref> and <xref ref-type="fig" rid="fig12-1094342012457191">12</xref> show the results in terms of speedup and efficiency obtained for the uniform and non-uniform partitioning methods of the algorithm for all of the scenes. Specifically, the results obtained with <inline-formula id="inline-formula212-1094342012457191">
<mml:math id="mml-inline212-1094342012457191">
<mml:mi>k</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>0</mml:mn>
</mml:math>
</inline-formula> (labelled in the figure as ‘area’) and the best results obtained with <inline-formula id="inline-formula213-1094342012457191">
<mml:math id="mml-inline213-1094342012457191">
<mml:mi>k</mml:mi>
<mml:mo stretchy="false">≠</mml:mo>
<mml:mn>0</mml:mn>
</mml:math>
</inline-formula> (labelled in the figure as ‘power’) are included. For very regular scenes, the best results correspond to the uniform partitioning being slightly superior to the non-uniform ‘power’ version. However, for scenes with an irregular distribution of objects and light sources, the best results are obtained with the non-uniform ‘power’ version, resulting in super-linear speedups in some cases. For example, for the <italic>Study</italic> scene the speedups were 2.21, 5.46 and 11.01 for 2, 4 and 8 processors, respectively. Therefore, these results prove that the techniques we have proposed for the parallelization of the MCR algorithm provide an excellent performance on distributed memory systems.</p>
<fig id="fig11-1094342012457191" position="float">
<label>Figure 11.</label>
<caption>
<p>Speedups for the uniform partitioning and for non-uniform partitioning using area and power: (a) <italic>Building</italic>; (b) <italic>LivingRoom</italic>; (c) <italic>Study</italic>; (d) <italic>PowerPlant</italic>.</p>
</caption>
<graphic xlink:href="10.1177_1094342012457191-fig11.tif"/>
</fig>
<fig id="fig12-1094342012457191" position="float">
<label>Figure 12.</label>
<caption>
<p>Efficiencies for the uniform partitioning and for non-uniform partitioning using area and power: (a) <italic>Building</italic>; (b) <italic>LivingRoom</italic>; (c) <italic>Study</italic>; (d) <italic>PowerPlant</italic>.</p>
</caption>
<graphic xlink:href="10.1177_1094342012457191-fig12.tif"/>
</fig>
<p>To further show the benefits of the non-uniform partitioning, the load balance was also checked by measuring the distribution function of each method (see <xref ref-type="disp-formula" rid="disp-formula8-1094342012457191">Equation 8</xref>). Specifically, <xref ref-type="table" rid="table2-1094342012457191">Table 2</xref> shows the values for <inline-formula id="inline-formula214-1094342012457191">
<mml:math id="mml-inline214-1094342012457191">
<mml:mi mathvariant="italic">σ</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>X</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>32</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula> for a configuration of 32 processors for the uniform and non-uniform strategies, where we have used for <inline-formula id="inline-formula215-1094342012457191">
<mml:math id="mml-inline215-1094342012457191">
<mml:mi>X</mml:mi>
</mml:math>
</inline-formula> factor the <inline-formula id="inline-formula216-1094342012457191">
<mml:math id="mml-inline216-1094342012457191">
<mml:mi>k</mml:mi>
</mml:math>
</inline-formula> values corresponding to the best results obtained for the non-uniform version. As can be observed, lower values and, as a consequence, more balanced applications are obtained for the non-uniform version. Note that for the <italic>Building</italic> scene greater speedups are obtained for the uniform partition although the <inline-formula id="inline-formula217-1094342012457191">
<mml:math id="mml-inline217-1094342012457191">
<mml:mi mathvariant="italic">σ</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>X</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>32</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula> value is higher. This is due to the special characteristics of the scene and processor configuration. For this special situation, precisely two complete rooms of the scene are assigned to each processor, resulting in an optimal locality exploitation and lower number of communications.</p>
<table-wrap id="table2-1094342012457191" position="float">
<label>Table 2.</label>
<caption>
<p>Distribution of the load for a configuration of 32 processors.</p>
</caption>
<graphic alternate-form-of="table2-1094342012457191" xlink:href="10.1177_1094342012457191-table2.tif"/>
<table>
<thead>
<tr>
<th>
</th>
<th colspan="2">
<inline-formula id="inline-formula218-1094342012457191">
<mml:math id="mml-inline218-1094342012457191">
<mml:mi mathvariant="italic">σ</mml:mi>
<mml:mtext> </mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>X</mml:mi>
<mml:mo stretchy="false">,</mml:mo>
<mml:mn>32</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
</inline-formula>
</th>
</tr>
<tr>
<th>
</th>
<th>Uniform</th>
<th>Non-uniform </th>
</tr>
</thead>
<tbody>
<tr>
<td>
<italic>Building</italic>
</td>
<td>0.0084</td>
<td>0.0065</td>
</tr>
<tr>
<td>
<italic>LivingRoom</italic>
</td>
<td>1.8684</td>
<td>0.0640</td>
</tr>
<tr>
<td>
<italic>Study</italic>
</td>
<td>1.4109</td>
<td>0.1770</td>
</tr>
<tr>
<td>
<italic>PowerPlant</italic>
</td>
<td>0.7942</td>
<td>0.0256</td>
</tr>
</tbody>
</table>
</table-wrap>
<p>On the other hand, a comparison of the computational time required for every stage of parallel algorithm with respect to the total computational time was performed. <xref ref-type="table" rid="table3-1094342012457191">Table 3</xref> shows the resulting measures obtained for the <italic>LivingRoom</italic> scene for each one of the partitioning techniques, uniform and non-uniform. The first value for each technique represents the initialization time, the second value is the time required for the partitioning, the third value is the time necessary to calculate the <inline-formula id="inline-formula219-1094342012457191">
<mml:math id="mml-inline219-1094342012457191">
<mml:mi>k</mml:mi>
<mml:mi>d</mml:mi>
</mml:math>
</inline-formula>-tree and the iterations, and the fourth value is the total execution time. Note that time required for the partitioning in both techniques is reasonable in relation with the total computational time. By way of example, for <inline-formula id="inline-formula220-1094342012457191">
<mml:math id="mml-inline220-1094342012457191">
<mml:mi>N</mml:mi>
<mml:mi>d</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>16</mml:mn>
</mml:math>
</inline-formula> and for the non-uniform version, the partitioning requires 4.6% of the total computational time.</p>
<table-wrap id="table3-1094342012457191" position="float">
<label>Table 3.</label>
<caption>
<p>Comparison of total execution time with the time of every stage of the distributed algorithm for <italic>LivingRoom</italic> scene.</p>
</caption>
<graphic alternate-form-of="table3-1094342012457191" xlink:href="10.1177_1094342012457191-table3.tif"/>
<table>
<thead>
<tr>
<th rowspan="2">
<italic>Nd</italic>
</th>
<th colspan="4">Uniform</th>
<th colspan="4">Non-uniform</th>
</tr>
<tr>
<th>Init</th>
<th>Partition</th>
<th>kd+iter</th>
<th>Total</th>
<th>Init</th>
<th>Partition</th>
<th>kd+iter</th>
<th>Total</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>0.0214</td>
<td>0.0109</td>
<td>15.273</td>
<td>15.305</td>
<td>0.0389</td>
<td>0.0517</td>
<td>12.010</td>
<td>12.101</td>
</tr>
<tr>
<td>4</td>
<td>0.0097</td>
<td>0.0120</td>
<td>8.981</td>
<td>9.003</td>
<td>0.0098</td>
<td>0.0777</td>
<td>5.043</td>
<td>5.130</td>
</tr>
<tr>
<td>8</td>
<td>0.0033</td>
<td>0.0113</td>
<td>6.150</td>
<td>6.165</td>
<td>0.0103</td>
<td>0.1136</td>
<td>2.857</td>
<td>2.981</td>
</tr>
<tr>
<td>16</td>
<td>0.0022</td>
<td>0.0116</td>
<td>3.753</td>
<td>3.767</td>
<td>0.0022</td>
<td>0.1061</td>
<td>2.188</td>
<td>2.296</td>
</tr>
<tr>
<td>32</td>
<td>0.0031</td>
<td>0.0172</td>
<td>2.256</td>
<td>2.276</td>
<td>0.0018</td>
<td>0.1744</td>
<td>1.553</td>
<td>1.729</td>
</tr>
</tbody>
</table>
</table-wrap>
<p>The optimal maximum ray packet size was also experimentally analysed. The results obtained are summarized in <xref ref-type="fig" rid="fig13-1094342012457191">Figure 13</xref>. This figure shows the speedup dependence with the packet size, <inline-formula id="inline-formula221-1094342012457191">
<mml:math id="mml-inline221-1094342012457191">
<mml:mi>N</mml:mi>
<mml:mi>b</mml:mi>
</mml:math>
</inline-formula>, for a configuration of 32 processors. As can be observed, the best performance is obtained for a maximum ray packet size between approximately 0.71 and 14.1 Kib, that corresponds to <inline-formula id="inline-formula222-1094342012457191">
<mml:math id="mml-inline222-1094342012457191">
<mml:mn>20</mml:mn>
<mml:mo stretchy="false">&lt;</mml:mo>
<mml:mi>N</mml:mi>
<mml:mi>b</mml:mi>
<mml:mo stretchy="false">≤</mml:mo>
<mml:mn>400</mml:mn>
</mml:math>
</inline-formula>, for the <italic>LivingRoom</italic> and <italic>Study</italic> scenes, and between 0.71 and 351.6 Kib, that corresponds to <inline-formula id="inline-formula223-1094342012457191">
<mml:math id="mml-inline223-1094342012457191">
<mml:mn>20</mml:mn>
<mml:mo stretchy="false">&lt;</mml:mo>
<mml:mi>N</mml:mi>
<mml:mi>b</mml:mi>
<mml:mo stretchy="false">≤</mml:mo>
<mml:mn>10000</mml:mn>
</mml:math>
</inline-formula>, for the <italic>Building</italic> and <italic>PowerPlant</italic> scenes. In these ranges, there is a lower number of communications, an efficient exploitation of the high interconnection bandwidth, and a more efficient computation scheduling as processor waiting cycles are reduced. The larger range for the Building scene is due to the different nature of this scene. In this case and for <inline-formula id="inline-formula224-1094342012457191">
<mml:math id="mml-inline224-1094342012457191">
<mml:mi>N</mml:mi>
<mml:mi>d</mml:mi>
<mml:mo stretchy="false">=</mml:mo>
<mml:mn>32</mml:mn>
</mml:math>
</inline-formula> a very convenient situation is generated as two rooms, each one with two open doors, are assigned to each processor. In the case of <italic>PowerPlant</italic> scene the wide range observed depends on the large number of shot rays.</p>
<fig id="fig13-1094342012457191" position="float">
<label>Figure 13.</label>
<caption>
<p>Speedup dependence on the ray packet size for 32 processors: (a) <italic>Building</italic>; (b) <italic>LivingRoom</italic>; (c) <italic>Study</italic>; (d) <italic>PowerPlant</italic>.</p>
</caption>
<graphic xlink:href="10.1177_1094342012457191-fig13.tif"/>
</fig>
<p>Note that for a given processor, the incomplete packets coming from neighbouring processors can generate more communications if the rays do not intersect any object in the associated sub-scene. In this case the corresponding rays have to be resent to other processors. For <inline-formula id="inline-formula225-1094342012457191">
<mml:math id="mml-inline225-1094342012457191">
<mml:mi>N</mml:mi>
<mml:mi>b</mml:mi>
</mml:math>
</inline-formula> inside the specified ranges, these rays can be handled efficiently and grouped together with the local ray packets under construction, thus reducing the global number of communications. For larger <inline-formula id="inline-formula226-1094342012457191">
<mml:math id="mml-inline226-1094342012457191">
<mml:mi>N</mml:mi>
<mml:mi>b</mml:mi>
</mml:math>
</inline-formula> values this trend changes: Processor waiting periods increase due to the need to pack a higher number of rays per packet. Moreover, the communication of the final incomplete ray packets is costly due to, on average, larger number of incomplete packets to be sent with the consequent increment in the communication requirements.</p>
</sec>
<sec id="section11-1094342012457191">
<title>8. Conclusions</title>
<p>In this paper we have presented a parallel implementation of the MCR algorithm. Our proposal is based on three strategies that solve the main challenges associated with the algorithm and its parallelization on a distributed memory system.</p>
<p>The first key step in our proposal is the partitioning method to split the scenes into sub-scenes to prevent data replication in the memory and simplify the ray shooting procedure. We have proposed and analysed a uniform partitioning strategy with very good results for regular scenes with uniform distribution of objects and lights. To improve the performance for scenes with other characteristics, we have proposed a non-uniform partitioning guided by area and power factors. The results of our analysis indicate that very good results can be obtained with this methodology for scenes with very different natures. Note that super-linear speedup was achieved for some configurations, and a speedup above 12 for 32 processors was obtained even for complex scenes.</p>
<p>We have also presented two other key features for solving and optimizing the problems associated with the distribution of the scene among processors: a ray packing strategy to minimize the number of communications, and a methodology to test the end of each iteration on a distributed system. In both cases our proposals solve the challenges associated with the distributed strategy.</p>
<p>In summary, good results in terms of execution times are obtained even for complex models. These results also indicate the low overhead associated with the techniques employed for the implementation. Furthermore, as in our proposal the data is efficiently communicated among processors, no approximations need to be performed and high-quality images are obtained.</p>
</sec>
</body>
<back>
<fn-group>
<fn fn-type="financial-disclosure" id="fn3-1094342012457191">
<label>Funding</label>
<p>This work was partially supported by the Ministry of Education and Science of Spain (grant number MEC TIN 2010-16735) and the Xunta de Galicia (grant numbers 08TIC001206PR and INCITE08PXIB105161PR).</p>
</fn>
</fn-group>
<notes>
<title>Notes</title>
<fn-group>
<fn fn-type="other" id="fn1-1094342012457191">
<label>1.</label>
<p>See <ext-link ext-link-type="uri" xlink:href="http://www.cesga.es">http://www.cesga.es</ext-link>
</p>
</fn>
<fn fn-type="other" id="fn2-1094342012457191">
<label>2.</label>
<p>See <ext-link ext-link-type="uri" xlink:href="http://gamma.cs.unc.edu/POWERPLANT/">http://gamma.cs.unc.edu/POWERPLANT/</ext-link>
</p>
</fn>
</fn-group>
</notes>
<ref-list>
<title>References</title>
<ref id="bibr1-1094342012457191">
<citation citation-type="journal">
<person-group person-group-type="author">
<name>
<surname>Alme</surname>
<given-names>H</given-names>
</name>
<name>
<surname>Rodriguez</surname>
<given-names>G</given-names>
</name>
<name>
<surname>Zimmerman</surname>
<given-names>G</given-names>
</name>
</person-group> (<year>2001</year>) <article-title>Domain decomposition models for parallel monte carlo transport</article-title>. <source>The Journal of Supercomputing</source> <volume>18</volume>: <fpage>5</fpage>–<lpage>23</lpage>.</citation>
</ref>
<ref id="bibr2-1094342012457191">
<citation citation-type="journal">
<person-group person-group-type="author">
<name>
<surname>Amor</surname>
<given-names>M</given-names>
</name>
<name>
<surname>Sanjurjo</surname>
<given-names>JR</given-names>
</name>
<name>
<surname>Padrón</surname>
<given-names>EJ</given-names>
</name>
<name>
<surname>Doallo</surname>
<given-names>R</given-names>
</name>
</person-group> (<year>2004</year>) <article-title>Progressive radiosity method on clusters using a new clipping algorithm</article-title>. <source>International Journal of High Performance Computing and Networking</source> <volume>1</volume>: <fpage>55</fpage>–<lpage>63</lpage>.</citation>
</ref>
<ref id="bibr3-1094342012457191">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Bekaert</surname>
<given-names>P</given-names>
</name>
<name>
<surname>Neumann</surname>
<given-names>L</given-names>
</name>
<name>
<surname>Neumann</surname>
<given-names>A</given-names>
</name>
<name>
<surname>Sbert</surname>
<given-names>M</given-names>
</name>
<name>
<surname>Willems</surname>
<given-names>YD</given-names>
</name>
</person-group> (<year>1998</year>) <article-title>Hierarchical Monte Carlo radiosity</article-title>. In: <source>Rendering Techniques’98, Proceedings of the Eurographics Workshop</source>. <publisher-loc>New York</publisher-loc>: <publisher-name>Springer</publisher-name>, pp. <fpage>259</fpage>–<lpage>268</lpage>.</citation>
</ref>
<ref id="bibr4-1094342012457191">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Benthin</surname>
<given-names>C</given-names>
</name>
<name>
<surname>Wald</surname>
<given-names>I</given-names>
</name>
<name>
<surname>Scherbaum</surname>
<given-names>M</given-names>
</name>
<name>
<surname>Friedrich</surname>
<given-names>H</given-names>
</name>
</person-group> (<year>2006</year>) <article-title>Ray tracing on the Cell processor</article-title>. In: <source>Proceedings of the 2006 IEEE Symposium on Interactive Ray Tracing</source>, pp. <fpage>15</fpage>–<lpage>23</lpage>.</citation>
</ref>
<ref id="bibr5-1094342012457191">
<citation citation-type="journal">
<person-group person-group-type="author">
<name>
<surname>Brunner</surname>
<given-names>T</given-names>
</name>
<name>
<surname>Brantley</surname>
<given-names>PS</given-names>
</name>
</person-group> (<year>2009</year>) <article-title>An efficient, robust, domain-decomposition algorithm for Monte Carlo</article-title>. <source>Journal of Computational Physics</source> <volume>228</volume>: <fpage>3882</fpage>–<lpage>3890</lpage>.</citation>
</ref>
<ref id="bibr6-1094342012457191">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Cohen</surname>
<given-names>MF</given-names>
</name>
<name>
<surname>Wallace</surname>
<given-names>JR</given-names>
</name>
</person-group> (<year>1993</year>) <source>Radiosity and Realistic Image Synthesis</source>. <publisher-loc>Boston, MA</publisher-loc>: <publisher-name>Academic Press Professional</publisher-name>.</citation>
</ref>
<ref id="bibr7-1094342012457191">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Dutre</surname>
<given-names>P</given-names>
</name>
<name>
<surname>Bekaert</surname>
<given-names>P</given-names>
</name>
<name>
<surname>Bala</surname>
<given-names>K</given-names>
</name>
</person-group> (<year>2006</year>) <source>Advanced Global Illumination</source>, <edition>2nd edn</edition>. <publisher-loc>Wellesley, MA</publisher-loc>: <publisher-name>A.K. Peters Limited</publisher-name>.</citation>
</ref>
<ref id="bibr8-1094342012457191">
<citation citation-type="journal">
<person-group person-group-type="author">
<name>
<surname>Gibson</surname>
<given-names>S</given-names>
</name>
<name>
<surname>Hubbold</surname>
<given-names>RJ</given-names>
</name>
</person-group> (<year>2000</year>) <article-title>A perceptually-driven parallel algorithm for efficient radiosity simulation</article-title>. <source>IEEE Transactions on Visualization and Computer Graphics</source> <volume>6</volume>: <fpage>220</fpage>–<lpage>235</lpage>.</citation>
</ref>
<ref id="bibr9-1094342012457191">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Havran</surname>
<given-names>V</given-names>
</name>
</person-group> (<year>2000</year>) <source>Heuristic Ray Shooting Algorithms</source>. <comment>Ph.D. thesis</comment>, <publisher-name>Department of Computer Science and Engineering, Faculty of Electrical Engineering</publisher-name>, <publisher-loc>Czech Technical University in Prague</publisher-loc>.</citation>
</ref>
<ref id="bibr10-1094342012457191">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Ize</surname>
<given-names>T</given-names>
</name>
<name>
<surname>Brownlee</surname>
<given-names>C</given-names>
</name>
<name>
<surname>Hansen</surname>
<given-names>CD</given-names>
</name>
</person-group> (<year>2011</year>) <article-title>Real-time ray tracer for visualizing massive models on a cluster</article-title>. In: <source>Proceedings of Eurographics Symposium on Parallel Graphics and Visualization, EGPGV 2011</source>, pp. <fpage>61</fpage>–<lpage>69</lpage>.</citation>
</ref>
<ref id="bibr11-1094342012457191">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Jensen</surname>
<given-names>HW</given-names>
</name>
</person-group> (<year>2001</year>) <source>Realistic Image Synthesis Using Photon Mapping</source>. <publisher-loc>Wellesly, MA</publisher-loc>: <publisher-name>A.K. Peters Limited</publisher-name>.</citation>
</ref>
<ref id="bibr12-1094342012457191">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Kalos</surname>
<given-names>MH</given-names>
</name>
<name>
<surname>Whitlock</surname>
<given-names>PA</given-names>
</name>
</person-group> (<year>1986</year>) <source>Monte Carlo Methods</source>. <publisher-loc>New York</publisher-loc>: <publisher-name>Wiley-Interscience</publisher-name>.</citation>
</ref>
<ref id="bibr13-1094342012457191">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Kaplanyan</surname>
<given-names>A</given-names>
</name>
<name>
<surname>Dachsbacher</surname>
<given-names>C</given-names>
</name>
</person-group> (<year>2010</year>) <article-title>Cascaded light propagation volumes for real-time indirect illumination</article-title>. In: <source>Proceedings of the 2010 ACM SIGGRAPH Symposium on Interactive 3D Graphics and Games (I3D’10)</source>. <publisher-loc>New York</publisher-loc>: <publisher-name>ACM Press</publisher-name>, pp. <fpage>99</fpage>–<lpage>107</lpage>.</citation>
</ref>
<ref id="bibr14-1094342012457191">
<citation citation-type="journal">
<person-group person-group-type="author">
<name>
<surname>Kato</surname>
<given-names>T</given-names>
</name>
</person-group> (<year>2003</year>) <article-title>‘Kilauea’: parallel global illumination renderer</article-title>. <source>Parallel Computing</source> <volume>29</volume>: <fpage>289</fpage>–<lpage>310</lpage>.</citation>
</ref>
<ref id="bibr15-1094342012457191">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Larsen</surname>
<given-names>BD</given-names>
</name>
<name>
<surname>Christensen</surname>
<given-names>NJ</given-names>
</name>
</person-group> (<year>2004</year>) <article-title>Simulating photon mapping for real-time applications</article-title>. In <source>Rendering Techniques ‘04</source>, pp. <fpage>123</fpage>–<lpage>132</lpage>.</citation>
</ref>
<ref id="bibr16-1094342012457191">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Neumann</surname>
<given-names>L</given-names>
</name>
<name>
<surname>Purgathofer</surname>
<given-names>W</given-names>
</name>
<name>
<surname>Tobler</surname>
<given-names>RF</given-names>
</name>
<etal/>
</person-group>. (<year>1995</year>) <article-title>The stochastic ray method for radiosity</article-title>. In: <source>Rendering Techniques ‘95</source>, pp. <fpage>206</fpage>–<lpage>218</lpage>.</citation>
</ref>
<ref id="bibr17-1094342012457191">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Pharr</surname>
<given-names>M</given-names>
</name>
<name>
<surname>Humphreys</surname>
<given-names>G</given-names>
</name>
</person-group> (<year>2004</year>) <source>Physically Based Rendering: From Theory to Implementation</source>. <publisher-loc>San Mateo, CA</publisher-loc>: <publisher-name>Morgan Kaufmann Publishers Inc</publisher-name>.</citation>
</ref>
<ref id="bibr18-1094342012457191">
<citation citation-type="journal">
<person-group person-group-type="author">
<name>
<surname>Popov</surname>
<given-names>S</given-names>
</name>
<name>
<surname>Günther</surname>
<given-names>J</given-names>
</name>
<name>
<surname>Seidel</surname>
<given-names>H-P</given-names>
</name>
<name>
<surname>Slusallek</surname>
<given-names>P</given-names>
</name>
</person-group> (<year>2007</year>) <article-title>Stackless <inline-formula id="inline-formula227-1094342012457191">
<mml:math id="mml-inline227-1094342012457191">
<mml:mi>k</mml:mi>
<mml:mi>d</mml:mi>
</mml:math>
</inline-formula>-tree traversal for high performance GPU ray tracing</article-title>. <source>Computer Graphics Forum</source> <volume>26</volume>: <fpage>415</fpage>–<lpage>424</lpage>.</citation>
</ref>
<ref id="bibr19-1094342012457191">
<citation citation-type="journal">
<person-group person-group-type="author">
<name>
<surname>Ritschel</surname>
<given-names>T</given-names>
</name>
<name>
<surname>Grosch</surname>
<given-names>T</given-names>
</name>
<name>
<surname>Kim</surname>
<given-names>MH</given-names>
</name>
<name>
<surname>Seidel</surname>
<given-names>H-P</given-names>
</name>
<name>
<surname>Dachsbacher</surname>
<given-names>C</given-names>
</name>
<name>
<surname>Kautz</surname>
<given-names>J</given-names>
</name>
</person-group> (<year>2008</year>) <article-title>Imperfect shadow maps for efficient computation of indirect illumination</article-title>. <source>ACM Transaction on Graphics</source> <volume>27</volume>: <issue>129</issue>:<fpage>1</fpage>–<lpage>129</lpage>:8.</citation>
</ref>
<ref id="bibr20-1094342012457191">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Sanjurjo</surname>
<given-names>JR</given-names>
</name>
<name>
<surname>Amor</surname>
<given-names>M</given-names>
</name>
<name>
<surname>Bóo</surname>
<given-names>M</given-names>
</name>
<name>
<surname>Doallo</surname>
<given-names>R</given-names>
</name>
</person-group> (<year>2005</year>) <article-title>Parallel global illumination method based on a non-uniform partitioning of the scene</article-title>. In: <source>Proceedings of the 13th Euromicro Conference on Parallel, Distributed and Network-based Processing (PDP’05)</source>, pp. <fpage>251</fpage>–<lpage>257</lpage>.</citation>
</ref>
<ref id="bibr21-1094342012457191">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Sanjurjo</surname>
<given-names>JR</given-names>
</name>
<name>
<surname>Amor</surname>
<given-names>M</given-names>
</name>
<name>
<surname>Bóo</surname>
<given-names>M</given-names>
</name>
<name>
<surname>Doallo</surname>
<given-names>R</given-names>
</name>
</person-group> (<year>2007</year>) <article-title>Improving locality for progressive radiosity algorithm: a study based on the blocking transformation of the scene</article-title>. In: <source>Proceedings of the 15th International Conference in Central Europe on Computer Graphics, Visualization, and Computer Vision’2007 (WSCG07)</source>, pp. <fpage>113</fpage>–<lpage>120</lpage>.</citation>
</ref>
<ref id="bibr22-1094342012457191">
<citation citation-type="journal">
<person-group person-group-type="author">
<name>
<surname>Sbert</surname>
<given-names>M</given-names>
</name>
</person-group> (<year>1997</year>) <article-title>Error and complexity of random walk Monte Carlo radiosity</article-title>. <source>IEEE Transactions on Visualization and Computer Graphics</source> <volume>3</volume>: <fpage>23</fpage>–<lpage>38</lpage>.</citation>
</ref>
<ref id="bibr23-1094342012457191">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Schloegel</surname>
<given-names>K</given-names>
</name>
<name>
<surname>Karypis</surname>
<given-names>G</given-names>
</name>
<name>
<surname>Kumar</surname>
<given-names>V</given-names>
</name>
</person-group> (<year>2003</year>) <article-title>Graph partitioning for high-performance scientific simulations</article-title>. <source>Sourcebook of Parallel Computing</source>. <publisher-loc>San Francisco, CA</publisher-loc>: <publisher-name>Morgan Kaufmann Publishers Inc</publisher-name>., pp. <fpage>491</fpage>–<lpage>541</lpage>.</citation>
</ref>
<ref id="bibr24-1094342012457191">
<citation citation-type="journal">
<person-group person-group-type="author">
<name>
<surname>Shevtsov</surname>
<given-names>M</given-names>
</name>
<name>
<surname>Soupikov</surname>
<given-names>A</given-names>
</name>
<name>
<surname>Kapustin</surname>
<given-names>A</given-names>
</name>
</person-group> (<year>2007</year>) <article-title>Highly parallel fast <inline-formula id="inline-formula228-1094342012457191">
<mml:math id="mml-inline228-1094342012457191">
<mml:mi>k</mml:mi>
<mml:mi>d</mml:mi>
</mml:math>
</inline-formula>-tree construction for interactive ray tracing of dynamic scenes</article-title>. <source>Computer Graphics Forum</source> <volume>26</volume>: <fpage>395</fpage>–<lpage>404</lpage>.</citation>
</ref>
<ref id="bibr25-1094342012457191">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Wald</surname>
<given-names>I</given-names>
</name>
<name>
<surname>Benthin</surname>
<given-names>C</given-names>
</name>
<name>
<surname>Dietrich</surname>
<given-names>A</given-names>
</name>
<name>
<surname>Slusallek</surname>
<given-names>P</given-names>
</name>
</person-group> (<year>2003</year>) <source>Interactive Distributed Ray Tracing on Commodity PC Clusters – State of the Art and Practical Applications (Lecture Notes on Computer Science</source>, <comment>vol. 2790)</comment>. <publisher-loc>Berlin</publisher-loc>: <publisher-name>Springer</publisher-name>, pp. <fpage>499</fpage>–<lpage>508</lpage>.</citation>
</ref>
<ref id="bibr26-1094342012457191">
<citation citation-type="journal">
<person-group person-group-type="author">
<name>
<surname>Wald</surname>
<given-names>I</given-names>
</name>
<name>
<surname>Benthin</surname>
<given-names>C</given-names>
</name>
<name>
<surname>Wagner</surname>
<given-names>M</given-names>
</name>
<name>
<surname>Slusallek</surname>
<given-names>P</given-names>
</name>
</person-group> (<year>2001</year>) <article-title>Interactive rendering with coherent ray tracing</article-title>. <source>Computer Graphics Forum (Proceedings of EUROGRAPHICS 2001)</source> <volume>20</volume>: <fpage>153</fpage>–<lpage>164</lpage>.</citation>
</ref>
<ref id="bibr27-1094342012457191">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Wald</surname>
<given-names>I</given-names>
</name>
<name>
<surname>Dietrich</surname>
<given-names>A</given-names>
</name>
<name>
<surname>Slusallek</surname>
<given-names>P</given-names>
</name>
</person-group> (<year>2005</year>) <article-title>An interactive out-of-core rendering framework for visualizing massively complex models</article-title>. In: <source>ACM SIGGRAPH 2005 Courses</source>.</citation>
</ref>
<ref id="bibr28-1094342012457191">
<citation citation-type="journal">
<person-group person-group-type="author">
<name>
<surname>Wang</surname>
<given-names>R</given-names>
</name>
<name>
<surname>Wang</surname>
<given-names>R</given-names>
</name>
<name>
<surname>Zhou</surname>
<given-names>K</given-names>
</name>
<name>
<surname>Pan</surname>
<given-names>M</given-names>
</name>
<name>
<surname>Bao</surname>
<given-names>H</given-names>
</name>
</person-group> (<year>2009</year>) <article-title>An efficient GPU-based approach for interactive global illumination</article-title>. <source>ACM Transactions on Graphics</source> <volume>28</volume>(<issue>3</issue>): 91:<fpage>1</fpage>–<lpage>91</lpage>:8.</citation>
</ref>
<ref id="bibr29-1094342012457191">
<citation citation-type="journal">
<person-group person-group-type="author">
<name>
<surname>Woop</surname>
<given-names>S</given-names>
</name>
<name>
<surname>Schmitter</surname>
<given-names>J</given-names>
</name>
<name>
<surname>Slusallek</surname>
<given-names>P</given-names>
</name>
</person-group> (<year>2005</year>) <article-title>RPU: a programmable ray processing unit for realtime ray tracing</article-title>. <source>ACM Transactions on Graphics</source> <volume>24</volume>: <fpage>434</fpage>–<lpage>444</lpage>.</citation>
</ref>
<ref id="bibr30-1094342012457191">
<citation citation-type="book">
<person-group person-group-type="author">
<name>
<surname>Zareski</surname>
<given-names>D</given-names>
</name>
<name>
<surname>Wade</surname>
<given-names>B</given-names>
</name>
<name>
<surname>Hubbard</surname>
<given-names>P</given-names>
</name>
<name>
<surname>Shirley</surname>
<given-names>P</given-names>
</name>
</person-group> (<year>1995</year>) <article-title>Efficient parallel global illumination using density estimation</article-title>. In: <source>Proceedings of the IEEE Symposium on Parallel Rendering (PRS’95)</source>, pp. <fpage>47</fpage>–<lpage>54</lpage>.</citation>
</ref>
</ref-list>
</back>
</article>