<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD Journal Publishing DTD v2.3 20070202//EN" "journalpublishing.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">JVC</journal-id>
<journal-id journal-id-type="hwp">spjvc</journal-id>
<journal-title>Journal of Vibration and Control</journal-title>
<issn pub-type="ppub">1077-5463</issn>
<issn pub-type="epub">1741-2986</issn>
<publisher>
<publisher-name>SAGE Publications</publisher-name>
<publisher-loc>Sage UK: London, England</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1177/1077546311419177</article-id>
<article-id pub-id-type="publisher-id">10.1177_1077546311419177</article-id>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Articles</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>A self-tuning fuzzy inference sliding mode control scheme for a class of nonlinear systems</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" corresp="yes">
<name><surname>Chaouch</surname> <given-names>Djamel Eddine</given-names></name>
<xref ref-type="aff" rid="aff1-1077546311419177">1</xref>
<xref ref-type="corresp" rid="corresp1-1077546311419177"/>
</contrib>
<contrib contrib-type="author">
<name><surname>Ahmed-Foitih</surname> <given-names>Zoubir</given-names></name>
<xref ref-type="aff" rid="aff2-1077546311419177">2</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Khelfi</surname> <given-names>Med Fayçal</given-names></name>
<xref ref-type="aff" rid="aff3-1077546311419177">3</xref>
</contrib>
</contrib-group>
<aff id="aff1-1077546311419177"><label>1</label>Laboratory of Sciences and Technology of Water (LSTE), University of Mascara, Algeria</aff>
<aff id="aff2-1077546311419177"><label>2</label>Faculty of Electrical Engineering, University of Sciences and Technology of Oran, Algeria</aff>
<aff id="aff3-1077546311419177"><label>3</label>Laboratory of Research in Industrial Computing and Networks, Faculty of Sciences, University of Oran Es-Sénia, Algeria</aff>
<author-notes>
<corresp id="corresp1-1077546311419177">Djamel Eddine Chaouch, Laboratory of Sciences and Technology of Water (LSTE), University of Mascara BP 276, Mascara, Algeria Email: <email>dj_chaouch@yahoo.fr</email></corresp>
</author-notes>
<pub-date pub-type="epub-ppub">
<month>9</month>
<year>2012</year>
</pub-date>
<volume>18</volume>
<issue>10</issue>
<fpage>1494</fpage>
<lpage>1505</lpage>
<history>
<date date-type="received"><day>28</day><month>3</month><year>2011</year></date>
<date date-type="accepted"><day>6</day><month>7</month><year>2011</year></date>
</history>
<permissions>
<copyright-statement>© The Author(s) 2011 Reprints and permissions: sagepub.co.uk/journalsPermissions.nav</copyright-statement>
<copyright-year>2011</copyright-year>
<copyright-holder content-type="sage">SAGE Publications</copyright-holder>
</permissions>
<abstract>
<p>A self-tuning fuzzy inference sliding mode control method is presented for single inverted pendulum position tracking control. Sliding mode control is a special nonlinear control method which has a quick response, is insensitive to parameters’ variation and disturbance; and is very suitable for nonlinear system control. Neuro-fuzzy logic systems are used to directly generate the "equivalent control term". In this case, a neuro-fuzzy system was described as a self-tuning fuzzy inference system optimized online using Takagi-Sygeno type of rules and a back-propagation algorithm to minimize a cost function. The cost function is made up of a quadratic error term and a weight decay term that prevents an excessive growth of parameters. The definition of sliding mode control was presented, and on the basis of the inverted pendulum system the sliding mode controller was designed. Stability of the proposed control scheme is proved by the Lyapunov theorem and the control scheme is applied to an inverted pendulum system. Simulation studies show that the method is effective and can be applied to a nonlinear control system.</p>
</abstract>
<kwd-group>
<kwd>Adaptive control</kwd>
<kwd>neuro-fuzzy system</kwd>
<kwd>nonlinear system</kwd>
<kwd>self-tuning fuzzy inference system</kwd>
<kwd>sliding mode control</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="sec1-1077546311419177"><title>1. Introduction</title>
<p>Variable structure control with sliding mode was introduced by <xref ref-type="bibr" rid="bibr22-1077546311419177">Utkin (1977)</xref>. The sliding mode control (SMC) was originally developed for variable structure systems in continuous domain. SMC systems exhibit a good control performance which can be designed and have no relationship with controlled plant parameters and disturbance (<xref ref-type="bibr" rid="bibr14-1077546311419177">Lin et al., 2002</xref>; <xref ref-type="bibr" rid="bibr21-1077546311419177">Tan et al. 2000</xref>). This method has some advantages such as quick response and is insensitive to parameters’ variation and disturbance, but chattering reduction and elimination is a key problem in SMC (<xref ref-type="bibr" rid="bibr20-1077546311419177">Slotine and Li, 1991</xref>). In basic SMC, a big switching gain was needed to eliminate the uncertainties and external disturbance, which was the main source of chattering.</p>
<p>Fuzzy control has many advantages such as control with mathematical models being unnecessary, using expert information and knowledge, and with a strong robustness (<xref ref-type="bibr" rid="bibr16-1077546311419177">MacVicar-Whelan, 1976</xref>). Recently, the resurgence of interest in the field of artificial neural networks has injected a new driving force into the fuzzy literature. The back-propagation learning rule, which drew little attention until its applications to artificial neural networks was discovered, is actually a universal learning paradigm for any smooth parameterized models, including fuzzy inference systems. As a result, a fuzzy inference system can now not only take linguistic information from human experts, but also adapt itself using numerical data (input/output pairs) to achieve a better performance (<xref ref-type="bibr" rid="bibr15-1077546311419177">Maaref and Barret, 2001</xref>). This gives fuzzy inference systems an edge over neural networks, which cannot take linguistic information directly. In an autonomous wheeled robot, many developed learning techniques have arisen in order to generate or to tune fuzzy rules. Most of them are based on the so-called “neuro-fuzzy learning algorithms” as proposed in <xref ref-type="bibr" rid="bibr25-1077546311419177">Zemalache and Maaref (2009)</xref> and <xref ref-type="bibr" rid="bibr26-1077546311419177">Zemalache et al. (2008)</xref>. These methods are suitable for constructingan optimal fuzzy system model which is used to identify the corresponding practical system. Among these approaches; the control by “neuro-fuzzy”, is currently one of the concerns of the researchers in the world.Self-tuning fuzzy inference sliding mode control (STFISMC), combines neuro-fuzzy control (STFIS) with SMC. STFISMC makes control destination from trace error to sliding mode function. It is a soft control which has the ability to reduce or even eliminate chattering (<xref ref-type="bibr" rid="bibr9-1077546311419177">Kawamura et al., 1994</xref>). In the literature <xref ref-type="bibr" rid="bibr5-1077546311419177">Ha et al. (2001)</xref> applied an equal control to switching control and fuzzy control to realize a fuzzy sliding mode controller. <xref ref-type="bibr" rid="bibr27-1077546311419177">Zhuang et al. (2000)</xref> used a fuzzy control to estimate the uncertainties of system. <xref ref-type="bibr" rid="bibr19-1077546311419177">Ryu and Park (2001)</xref> designed fuzzy rules based on chattering reduction and <xref ref-type="bibr" rid="bibr11-1077546311419177">Kim and Lee (1995)</xref> divided a sliding mode surface with fuzzy theory. <xref ref-type="bibr" rid="bibr24-1077546311419177">Yoo and Ham (1998)</xref> approached an unknown function with a fuzzy system and <xref ref-type="bibr" rid="bibr13-1077546311419177">Liang and Su (2003)</xref> designed a sliding mode surface with an integral sliding mode function. <xref ref-type="bibr" rid="bibr2-1077546311419177">Chen (1999)</xref> used a membership function to adjust the switching gain. <xref ref-type="bibr" rid="bibr3-1077546311419177">Chen et al. (1999)</xref> and <xref ref-type="bibr" rid="bibr4-1077546311419177">Grossimon et al. (1996)</xref> used a sliding mode controller into an inverted pendulum control.</p>
<p> Motivated by the above discussion, this paper proposes a new STFISMC to control a class of nonlinear systems in the presence of uncertainties and external disturbance. The STFIS controller is used to generate a control signal which forms the equivalent control part and the switching function block generating the discontinuous control part. In this structure, the STFIS block is used to directly generate the “equivalent control term”. Two specific forms of this controller are also derived. Using the Lyapunov theory, the stability of the adaptive controllers is proved. Simulation results indicate the effectiveness of the proposed methods. The rest of this paper is organized as follows: <xref ref-type="sec" rid="sec2-1077546311419177">Section 2</xref> presents an intelligent and innovative method, in what is called self- tuning fuzzy inference system (STFIS) network. <xref ref-type="sec" rid="sec5-1077546311419177">Section 3</xref> presents the system definitions and the classical SMC design method. <xref ref-type="sec" rid="sec6-1077546311419177">Section 4</xref> introduces our proposed adaptive fuzzy inference sliding mode control (STFISMC) scheme. Simulation results are included in <xref ref-type="sec" rid="sec7-1077546311419177">Section 5</xref>. <xref ref-type="sec" rid="sec8-1077546311419177">Section 6</xref> provides the concluding remarks.</p>
</sec>
<sec id="sec2-1077546311419177"><title>2. Neuro-fuzzy approach</title>
<p>In this part of the work an intelligent and innovative method is presented, combining two techniques (fuzzy and neural) which are designed to pursue a path of a nonlinear system and they have proved their efficiency, speed and ease of implementation (<xref ref-type="bibr" rid="bibr1-1077546311419177">Ajith, 2001</xref>). The system can be interpreted like a special neural network with vague parameters or like a vague system application in a parallel distributed form (<xref ref-type="bibr" rid="bibr17-1077546311419177">Nauck and Kruse, 1997</xref>).</p>
<sec id="sec3-1077546311419177"><title>2.1. Self- tuning fuzzy inference system (STFIS)</title>
<p>The method provides a complete structural system with a fuzzy inference of zero order type Takagi-Sugeno. The architecture of a neuro-fuzzy system is shown in <xref ref-type="fig" rid="fig1-1077546311419177">Figure 1</xref>. This system, called STFIS, is a network consisting of four layers (<xref ref-type="bibr" rid="bibr23-1077546311419177">Wang, 2009</xref>):
<fig id="fig1-1077546311419177" position="float"><label>Figure 1.</label><caption><p>Self-tuning fuzzy inference system.</p></caption><graphic xlink:href="10.1177_1077546311419177-fig1.tif"/></fig></p>
<list list-type="simple">
<list-item><p>Layer 1: it receives inputs;</p></list-item>
<list-item><p>Layer 2: calculates the membership degrees of these inputs to their fuzzy subset. The weights of the network between the first layer and this layer correspond to the parameters defining the membership functions.</p></list-item>
<list-item><p>Layer 3: calculates the values of truth. The weights between two hidden layers define the AND chosen operator.</p></list-item>
<list-item><p>Layer 4: The fourth layer is the output layer. The weights <italic>w<sub>i</sub></italic> of the network between the third and fourth layer correspond to the conclusion part of the rules.</p></list-item>
</list>
</sec>
<sec id="sec4-1077546311419177"><title>2.2. Learning Algorithm</title>
<p>In this work, the architecture known as the “mini-JEAN” proposed by <xref ref-type="bibr" rid="bibr8-1077546311419177">Jordan and Rumelhart (1991)</xref> is used. This architecture, illustrated in <xref ref-type="fig" rid="fig2-1077546311419177">Figure 2</xref> , does not require an emulator network. It uses only one network as a controller; the effectiveness of the learning is done directly by the back propagation of the output error (<xref ref-type="bibr" rid="bibr15-1077546311419177">Maaref and Barret, 2001</xref>).
<fig id="fig2-1077546311419177" position="float"><label>Figure 2.</label><caption><p>Mini-JEAN control architecture.</p></caption><graphic xlink:href="10.1177_1077546311419177-fig2.tif"/></fig></p>
<p>In the type of controller STFIS employed in this work, the back propagation gradient algorithm is used to adjust the weights of the last layer of the network. The general principle of this algorithm is as follows:</p>
<p>At each iteration the weights of the output layer are modified; this change will make the weights in the opposite direction to the gradient of the cost function. The process is repeated until the weights of the output layer have converged. That is to say that the gap between the network output and the desired output becomes acceptable.</p>
<p> Optimization is conducted entirely online by minimizing a cost function <italic>J</italic> to generate the parameters <italic>w<sub>i</sub></italic>, characterizing and adjusting the conclusion part of the rules. The gradient descent algorithm with the regression parameters optimizing only the conclusion part of the rules was adopted to meet the targets (<xref ref-type="bibr" rid="bibr25-1077546311419177">Zemalache et al., 2008</xref>). The cost function is given by:</p>
<disp-formula id="disp-formula1-1077546311419177"><label>(1)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp1-1077546311419177"><mml:mrow><mml:mi>J</mml:mi><mml:mo>=</mml:mo><mml:mi>E</mml:mi><mml:mo>+</mml:mo><mml:mi>λ</mml:mi><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:munder><mml:msubsup><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi> </mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math><graphic alternate-form-of="disp-formula1-1077546311419177" xlink:href="10.1177_1077546311419177-eq1.tif"/></disp-formula>
<p>Where <italic>w<sub>i</sub></italic> are the parameters (weights), <italic>λ</italic> is a constant that controls the growth parameters, and <italic>E</italic> is the classic quadratic error:</p>
<disp-formula id="disp-formula2-1077546311419177"><label>(2)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp2-1077546311419177"><mml:mrow><mml:mi>E</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math><graphic alternate-form-of="disp-formula2-1077546311419177" xlink:href="10.1177_1077546311419177-eq2.tif"/></disp-formula>
<p>Where <italic>e</italic> is the difference between the set point process outputs.</p>
<p>Using the back propagation algorithm, the parameters are adjusted with the following formula (<xref ref-type="bibr" rid="bibr12-1077546311419177">Lutaud-Brunet, 1996</xref>):</p>
<disp-formula id="disp-formula3-1077546311419177"><label>(3)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp3-1077546311419177"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>ij</mml:mi> </mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>ij</mml:mi> </mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>Δ</mml:mi><mml:msubsup><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>ij</mml:mi> </mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><graphic alternate-form-of="disp-formula3-1077546311419177" xlink:href="10.1177_1077546311419177-eq3.tif"/></disp-formula>
<p>and</p>
<disp-formula id="disp-formula4-1077546311419177"><label>(4)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp4-1077546311419177"><mml:mrow><mml:mi>Δ</mml:mi><mml:msubsup><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>ij</mml:mi> </mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>-</mml:mo><mml:mi>η</mml:mi><mml:msubsup><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi> </mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi> </mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>+</mml:mo><mml:mi>b</mml:mi><mml:mi>Δ</mml:mi><mml:msubsup><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>ij</mml:mi> </mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><graphic alternate-form-of="disp-formula4-1077546311419177" xlink:href="10.1177_1077546311419177-eq4.tif"/></disp-formula>
<p>Where</p>
<p><inline-formula id="ilm5-1077546311419177"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math5-1077546311419177"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>ij</mml:mi> </mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> :<italic>i<sup>th</sup></italic> parameter between <italic>i</italic> of layer <italic>n</italic> and <italic>j<sup>st</sup></italic> unit of layer n–1.</p>
<p><italic>η</italic> : learning gain, positive definite.</p>
<p><italic>t</italic> : Training iteration.</p>
<p><italic>b</italic> : Moment parameter.</p>
<p><inline-formula id="ilm6-1077546311419177"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math6-1077546311419177"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi> </mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> : Derived term of the cost function (<italic>i<sup>th</sup></italic> neuron of layer n).</p>
<p>α<sub>j</sub><italic>n</italic> − 1: Output of <italic>j<sup>th</sup></italic> unit of layer n-1.</p>
<p>The modification of the back-propagation algorithm of the gradient in order to integrate the effect of the regression term of the weights in the cost function is simple. Indeed, the cost function is derived compared to each weight <italic>w<sub>i</sub></italic> which leads to a modification of this weight by the back- propagation algorithm of the gradient such as:</p>
<disp-formula id="disp-formula5-1077546311419177"><label>(5)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp5-1077546311419177"><mml:mrow><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>-</mml:mo><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo><mml:mi>J</mml:mi></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:mi>w</mml:mi></mml:mrow></mml:mfrac><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>b</mml:mi><mml:mi>Δ</mml:mi><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><graphic alternate-form-of="disp-formula5-1077546311419177" xlink:href="10.1177_1077546311419177-eq5.tif"/></disp-formula>
<p>Indeed, it suffices to differentiate the cost function <italic>J</italic> with respect to each parameter <italic>w<sub>i</sub></italic> and by taking β = 2λ η (regression coefficient) (<xref ref-type="bibr" rid="bibr15-1077546311419177">Maaref and Barret, 2001</xref>). The following equation is obtained:</p>
<disp-formula id="disp-formula6-1077546311419177"><label>(6)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp6-1077546311419177"><mml:mrow><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>-</mml:mo><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo><mml:mi>E</mml:mi></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:mi>w</mml:mi></mml:mrow></mml:mfrac><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>b</mml:mi><mml:mi>Δ</mml:mi><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>-</mml:mo><mml:mi>β</mml:mi><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><graphic alternate-form-of="disp-formula6-1077546311419177" xlink:href="10.1177_1077546311419177-eq6.tif"/></disp-formula>
<p>Here, we have a neuro-fuzzy network; we adapt theformula (6) by multiplying <italic>β</italic> by</p>
<p><inline-formula id="ilm11-1077546311419177"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math11-1077546311419177"><mml:mrow><mml:msub><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:munder><mml:mi>α</mml:mi><mml:msub><mml:mrow/><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. This algorithm easily incorporates the effect of the regression terms in the cost function (<xref ref-type="bibr" rid="bibr25-1077546311419177">Zemalache and Maaref, 2009</xref>). With:</p>
<p><italic>β</italic> : is a weight decay term or regression term.</p>
<p><italic>w</italic> : weight or parameter.</p>
<p>This study was limited to the optimization of the outputs conclusion, as follows: (for a global optimization of a fuzzy controller, see the reference <xref ref-type="bibr" rid="bibr12-1077546311419177">Lutaud-Brunet, (1996)</xref>).</p>
<disp-formula id="disp-formula7-1077546311419177"><label>(7)</label><graphic xlink:href="10.1177_1077546311419177-eq7.tif"/></disp-formula>
<p>With</p>
<disp-formula id="disp-formula8-1077546311419177"><label>(8)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp8-1077546311419177"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn> </mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mi>y</mml:mi><mml:mo>/</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:munder><mml:mi>α</mml:mi><mml:msubsup><mml:mrow/><mml:mrow><mml:mi>j</mml:mi> </mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math><graphic alternate-form-of="disp-formula8-1077546311419177" xlink:href="10.1177_1077546311419177-eq8.tif"/></disp-formula>
<p>Where:</p>
<p><italic>y</italic><sub>1</sub>: effective output value.</p>
<p><italic>y</italic> : desired output.</p>
<p>In resume, the procedure is entirely done on-line on the plant. The table of rules (weights <italic>w<sub>i</sub></italic>) can be initially empty or filled with an <italic>a priori</italic> knowledge. The engine acquires by its systems output measures, calculates the error to back-propagated and updates the triggered rules online. The weights of the table of decision are then adjusted locally and progressively.</p>
</sec>
</sec>
<sec id="sec5-1077546311419177"><title>3. System definitions and classical sliding mode control design</title>
<p>Consider nonlinear systems IN which dynamical equations can be expressed in the canonical form (<xref ref-type="bibr" rid="bibr6-1077546311419177">Isidori, 1995</xref>):</p>
<disp-formula id="disp-formula9-1077546311419177"><label>(9)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp9-1077546311419177"><mml:mrow><mml:mover><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>+</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><graphic alternate-form-of="disp-formula9-1077546311419177" xlink:href="10.1177_1077546311419177-eq9.tif"/></disp-formula>
<p>Where <inline-formula id="ilm15-1077546311419177"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math15-1077546311419177"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> is the state vector<italic>, f</italic>(<italic>x,t</italic>) and <italic>g</italic>(<italic>x,t</italic>) belong to <inline-formula id="ilm16-1077546311419177"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math16-1077546311419177"><mml:mrow><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup><mml:mo>→</mml:mo><mml:mi>R</mml:mi></mml:mrow></mml:math></inline-formula> space<italic>. u</italic>(<italic>t</italic>); <italic>d</italic>(<italic>t</italic>) ∈ <italic>R</italic> are the control input and the external disturbance, respectively. In order for (<xref ref-type="disp-formula" rid="disp-formula9-1077546311419177">9</xref>) to be controllable, it is required that <italic>g</italic>(<italic>x,t</italic>) &gt; 0 for <italic>x</italic> in certain controllability region <italic>U<sub>c</sub></italic> ∈ <inline-formula id="ilm17-1077546311419177"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math17-1077546311419177"><mml:mrow><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula></p>
<p>Assumption 1. The unknown functions <italic>f</italic>(<italic>x,t</italic>), <italic>g</italic>(<italic>x,t</italic>) and <italic>d</italic>(<italic>t</italic>) satisfy the following conditions:</p>
<disp-formula id="disp-formula10-1077546311419177"><label>(10)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp10-1077546311419177"><mml:mrow><mml:mo>|</mml:mo><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>|</mml:mo><mml:mo>≤</mml:mo><mml:mtext>L</mml:mtext><mml:mi>γ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mi> </mml:mi></mml:mrow></mml:math><graphic alternate-form-of="disp-formula10-1077546311419177" xlink:href="10.1177_1077546311419177-eq10.tif"/></disp-formula>
<disp-formula id="disp-formula11-1077546311419177"><label>(11)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp11-1077546311419177"><mml:mrow><mml:mn>0</mml:mn><mml:msub><mml:mrow><mml:mi>&lt;g</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:mi>g</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mi> </mml:mi><mml:mi> </mml:mi></mml:mrow></mml:math><graphic alternate-form-of="disp-formula11-1077546311419177" xlink:href="10.1177_1077546311419177-eq11.tif"/></disp-formula>
<disp-formula id="disp-formula12-1077546311419177"><label>(12)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp12-1077546311419177"><mml:mrow><mml:mi>d</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>≤</mml:mo><mml:mi> </mml:mi><mml:mtext>d</mml:mtext><mml:mi> </mml:mi></mml:mrow></mml:math><graphic alternate-form-of="disp-formula12-1077546311419177" xlink:href="10.1177_1077546311419177-eq12.tif"/></disp-formula>
<p>where L, <italic>g<sub>1</sub></italic> and δ are unknown positive constants. γ (<italic>x</italic>) is the known positive function. For simplification, <italic>f</italic>(<italic>x,t</italic>), <italic>g</italic>(<italic>x,t</italic>) and <italic>d</italic>(t) are written as <italic>f</italic>, <italic>g</italic> and <italic>d</italic>, respectively (<xref ref-type="bibr" rid="bibr18-1077546311419177">Noroozi et al., 2009</xref>).</p>
<p>Let the tracking error be defined as follows:</p>
<disp-formula id="disp-formula13-1077546311419177"><label>(13)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp13-1077546311419177"><mml:mrow><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mtext>e</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mo>,</mml:mo><mml:mtext>e</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>.</mml:mo><mml:msub><mml:mrow><mml:mo>,</mml:mo><mml:mtext>e</mml:mtext></mml:mrow><mml:mrow><mml:mtext>n</mml:mtext></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mrow><mml:mtext>T</mml:mtext></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo>[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>~</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>~</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>~</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>]</mml:mo></mml:mrow><mml:mrow><mml:mtext>T</mml:mtext></mml:mrow></mml:msup></mml:mrow></mml:math><graphic alternate-form-of="disp-formula13-1077546311419177" xlink:href="10.1177_1077546311419177-eq13.tif"/></disp-formula>
<p>with <inline-formula id="ilm22-1077546311419177"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math22-1077546311419177"><mml:mrow><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>~</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is the desired trajectory</p>
<p>The control problem is to drive vector <italic>e</italic> asymptotically to zero for any initial condition <italic>x<sub>0</sub> = x</italic>(<italic>t<sub>0</sub></italic>), given at an initial time <italic>t<sub>0</sub></italic>. Let a switching function <italic>s</italic> be defined as:</p>
<disp-formula id="disp-formula14-1077546311419177"><label>(14)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp14-1077546311419177"><mml:mrow><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math><graphic alternate-form-of="disp-formula14-1077546311419177" xlink:href="10.1177_1077546311419177-eq14.tif"/></disp-formula>
<p>In which <italic>c</italic> = [<italic>c<sub>1</sub>,c<sub>2</sub>, . . . ,c<sub>n</sub></italic>]<sup><italic>T</italic></sup> is chosen such that <italic>c<sub>n</sub></italic> = 1, and <italic>P</italic>(<italic>λ</italic>) is a Hurwitz polynomial with</p>
<p><italic>P</italic>(<italic>λ</italic>) = <italic>λ<sup>n</sup></italic> + <italic>c<sub>n-1</sub>λ<sup>n-1</sup></italic> +… + <italic>c<sub>2</sub>λ<sup>2</sup></italic> + <italic>c<sub>1</sub></italic>. To achieve the control objective, it was sufficient to find a control law <italic>u</italic> (<xref ref-type="bibr" rid="bibr10-1077546311419177">Khalil, 1996)</xref>.</p>
<p>If <italic>f</italic>, <italic>g</italic> and <italic>d,</italic> in (<xref ref-type="disp-formula" rid="disp-formula9-1077546311419177">9</xref>) are exactly known, the control objective could be achieved by the control law designed as (<xref ref-type="bibr" rid="bibr20-1077546311419177">Slotine and Li, 1991</xref>):</p>
<disp-formula id="disp-formula15-1077546311419177"><label>(15)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp15-1077546311419177"><mml:mrow><mml:mi>u</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math><graphic alternate-form-of="disp-formula15-1077546311419177" xlink:href="10.1177_1077546311419177-eq15.tif"/></disp-formula>
<p>where <italic>u<sup>*</sup></italic> is the equivalent control law and is definedas:</p>
<disp-formula id="disp-formula16-1077546311419177"><label>(16)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp16-1077546311419177"><mml:mrow><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msup><mml:mi/><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">[</mml:mo><mml:mo>-</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>-</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>-</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn> </mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mover><mml:mrow><mml:mover><mml:mrow/><mml:mi>~</mml:mi></mml:mover></mml:mrow><mml:mi>·</mml:mi></mml:mover><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math><graphic alternate-form-of="disp-formula16-1077546311419177" xlink:href="10.1177_1077546311419177-eq16.tif"/></disp-formula>
<p>The stability of system (<xref ref-type="disp-formula" rid="disp-formula9-1077546311419177">9</xref>) with control law (<xref ref-type="disp-formula" rid="disp-formula15-1077546311419177">15</xref>) is proved as follows. Define the following Lyapunov function:</p>
<disp-formula id="disp-formula17-1077546311419177"><label>(17)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp17-1077546311419177"><mml:mrow><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math><graphic alternate-form-of="disp-formula17-1077546311419177" xlink:href="10.1177_1077546311419177-eq17.tif"/></disp-formula>
<p>The time-derivative of <italic>V</italic> is:</p>
<disp-formula id="disp-formula18-1077546311419177"><label>(18)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp18-1077546311419177"><mml:mrow><mml:mover><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>s</mml:mi><mml:mover><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover><mml:mo>=</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mover><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover><mml:mo>+</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn> </mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><graphic alternate-form-of="disp-formula18-1077546311419177" xlink:href="10.1177_1077546311419177-eq18.tif"/></disp-formula>
<p>In the above equation, if <inline-formula id="ilm28-1077546311419177"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math28-1077546311419177"><mml:mrow><mml:mover><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover><mml:mo>≤</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> for all s ≠ 0, it is called a reaching condition (<xref ref-type="bibr" rid="bibr22-1077546311419177">Utkin, 1977</xref>). That is the control <italic>u</italic> is designed to guarantee that the states are hitting on the sliding surface s = 0. In the traditional SMC, the reaching law is selected as <italic>u<sub>r</sub></italic> (<xref ref-type="bibr" rid="bibr20-1077546311419177">Slotine and Li, 1991</xref>).</p>
<disp-formula id="disp-formula19-1077546311419177"><label>(19)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp19-1077546311419177"><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo>-</mml:mo><mml:mi>k</mml:mi><mml:mtext>sgn</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><graphic alternate-form-of="disp-formula19-1077546311419177" xlink:href="10.1177_1077546311419177-eq19.tif"/></disp-formula>
<p><italic>k</italic> is the positive constant gain.</p>
<p>Then, <italic>V</italic>(<italic>t</italic>) ≤ − <italic>k</italic>|<italic>s</italic>(<italic>t</italic>) and the system states approach to the hyper-plane. The error vector is reduced asymptotically to zero once the system states are on <italic>s</italic> = 0. In practical applications, however, <italic>f</italic>, <italic>g</italic> and d are generally uncertain or even unknown rather than given. Therefore, the controller of (<xref ref-type="disp-formula" rid="disp-formula15-1077546311419177">15</xref>) is not always applicable. Moreover, the sign function in this control law causes the control input to produce the chattering phenomenon. In order to overcome these problems, the adaptive scheme using the fuzzy logic system is proposed in next section.</p>
</sec>
<sec id="sec6-1077546311419177"><title>4. Adaptive fuzzy inference sliding mode control</title>
<p>Consider nonlinear system (<xref ref-type="disp-formula" rid="disp-formula9-1077546311419177">9</xref>); when <italic>f</italic>, <italic>g</italic> and <italic>d</italic> are unknown, the equivalent control <italic>u*</italic>(<italic>t</italic>) can be replaced by the STFIS controller.</p>
<disp-formula id="disp-formula20-1077546311419177"><label>(20)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp20-1077546311419177"><mml:mrow><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>stfis</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><graphic alternate-form-of="disp-formula20-1077546311419177" xlink:href="10.1177_1077546311419177-eq20.tif"/></disp-formula>
<p>The STFIS control rules can now be represented as the mapping of the input linguistic variables <italic>s</italic> and <inline-formula id="ilm32-1077546311419177"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math32-1077546311419177"><mml:mrow><mml:mover><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow></mml:math></inline-formula> to output linguistic variable <italic>u<sub>stfis</sub></italic> as follows:</p>
<disp-formula id="disp-formula21-1077546311419177"><label>(21)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp21-1077546311419177"><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>stfis</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mover><mml:msub><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:mover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mover><mml:msub><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math><graphic alternate-form-of="disp-formula21-1077546311419177" xlink:href="10.1177_1077546311419177-eq21.tif"/></disp-formula>
<p>In this line, the adaptive fuzzy inference sliding mode controller is presented for system (<xref ref-type="disp-formula" rid="disp-formula9-1077546311419177">9</xref>).</p>
<disp-formula id="disp-formula22-1077546311419177"><label>(22)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp22-1077546311419177"><mml:mrow><mml:mi>u</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>stfis</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math><graphic alternate-form-of="disp-formula22-1077546311419177" xlink:href="10.1177_1077546311419177-eq22.tif"/></disp-formula>
<p>STFIS are used to directly generate the equivalent control term <italic>u*</italic>. But there exists always an error between<italic>u*</italic> and the real STFIS output <italic>u*<sub>stfis</sub></italic>. The switching control law <italic>u<sub>r</sub></italic> compensate this error. We have:</p>
<disp-formula id="disp-formula23-1077546311419177"><label>(23)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp23-1077546311419177"><mml:mrow><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>stfis</mml:mi> </mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ɛ</mml:mi><mml:mo>=</mml:mo><mml:mover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mover><mml:msub><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi> </mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup><mml:mo>/</mml:mo><mml:mover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mover><mml:msub><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>ɛ</mml:mi></mml:mrow></mml:math><graphic alternate-form-of="disp-formula23-1077546311419177" xlink:href="10.1177_1077546311419177-eq23.tif"/></disp-formula>
<p>Where <italic>ε</italic> is an approximate error and satisfied with <inline-formula id="ilm36-1077546311419177"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math36-1077546311419177"><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>ɛ</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mi>&lt;k</mml:mi></mml:mrow></mml:math></inline-formula></p>
<p>Here, we define <inline-formula id="ilm37-1077546311419177"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math37-1077546311419177"><mml:mrow><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>∧</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>stfis</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> the estimation of <italic>u</italic>* as:</p>
<disp-formula id="disp-formula24-1077546311419177"><label>(24)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp24-1077546311419177"><mml:mrow><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>∧</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>stfis</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mover><mml:msub><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>∧</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:mover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mover><mml:msub><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math><graphic alternate-form-of="disp-formula24-1077546311419177" xlink:href="10.1177_1077546311419177-eq24.tif"/></disp-formula>
<p>By taking:</p>
<disp-formula id="disp-formula25-1077546311419177"><label>(25)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp25-1077546311419177"><mml:mrow><mml:msub><mml:mrow><mml:mi>ζ</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn> </mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:math><graphic alternate-form-of="disp-formula25-1077546311419177" xlink:href="10.1177_1077546311419177-eq25.tif"/></disp-formula>
<p>We get:</p>
<disp-formula id="disp-formula26-1077546311419177"><label>(26)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp26-1077546311419177"><mml:mrow><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>stfis</mml:mi> </mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ɛ</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mi>ζ</mml:mi><mml:mo>+</mml:mo><mml:mi>ɛ</mml:mi></mml:mrow></mml:math><graphic alternate-form-of="disp-formula26-1077546311419177" xlink:href="10.1177_1077546311419177-eq26.tif"/></disp-formula>
<disp-formula id="disp-formula27-1077546311419177"><label>(27)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp27-1077546311419177"><mml:mrow><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>∧</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>stfis</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>∧</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mi>ζ</mml:mi></mml:mrow></mml:math><graphic alternate-form-of="disp-formula27-1077546311419177" xlink:href="10.1177_1077546311419177-eq27.tif"/></disp-formula>
<p>Where <italic>w</italic> = [<italic>w</italic><sub>1</sub> <italic>w</italic><sub>2</sub> … <italic>w<sub>m</sub></italic>]<sup>T</sup> , ζ = [ζ<sub>1</sub> ζ<sub>2</sub> …ζ<sub>m</sub>]<italic><sup>T</sup></italic> and <inline-formula id="ilm43-1077546311419177"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math43-1077546311419177"><mml:mrow><mml:mover><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>∧</mml:mi></mml:mover></mml:mrow></mml:math></inline-formula> is the estimation of <italic>w</italic>*</p>
<p>The configuration of our proposed closed loop system is shown in <xref ref-type="fig" rid="fig3-1077546311419177">Figure 3</xref>. In the following theorem, the stability of our proposed closed loop system is proved. With the aid of this, it is possible to force thenonlinear system (<xref ref-type="disp-formula" rid="disp-formula9-1077546311419177">9</xref>) onto the sliding mode surface <italic>s</italic>(<italic>t</italic>) = 0. That is possible, if the reaching condition <inline-formula id="ilm44-1077546311419177"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math44-1077546311419177"><mml:mrow><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mover><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> &lt; 0 is guaranteed.
<fig id="fig3-1077546311419177" position="float"><label>Figure 3.</label><caption><p>Adaptive fuzzy inference sliding mode controller.</p></caption><graphic xlink:href="10.1177_1077546311419177-fig3.tif"/></fig></p>
<p>Theorem 1. Consider uncertain dynamic system (<xref ref-type="disp-formula" rid="disp-formula9-1077546311419177">9</xref>). Suppose that Assumption 1 is satisfied. The control law is designed as (<xref ref-type="disp-formula" rid="disp-formula22-1077546311419177">22</xref>) with the adaptive law (<xref ref-type="disp-formula" rid="disp-formula23-1077546311419177">23</xref>). Then, the asymptotical stability of <italic>s</italic>(<italic>t</italic>)→0 as <italic>t</italic>→∞ for the controlled system in (<xref ref-type="disp-formula" rid="disp-formula9-1077546311419177">9</xref>) can be guaranteed.</p>
<p>Chattering is generally highly undesirable in practice, since it involves extremely high control activity, and further may excites high frequency dynamics neglected in the system dynamics. In this approach, the sliding surface <italic>s</italic> is allowed to be time varying and the control procedure consists of: first, the control forces the error trajectory towards the sliding surface while in the second, the controller is smoothed inside a possibly time-varying “boundary layer”. This will achieve optimal trade-off between control bandwidth and tracking precision, therefore eliminating chattering and the sensitivity of the controller to high-frequency unmodeled dynamics.</p>
<p>With this modification, the control objective is to ensure that any trajectory, initially outside this layer, will converge towards it and slides inside this layer. The boundary layer is defined by:</p>
<disp-formula id="disp-formula28-1077546311419177"><label>(28)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp28-1077546311419177"><mml:mrow><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mi>X</mml:mi><mml:mo>:</mml:mo><mml:mo>/</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow><mml:mo>≤</mml:mo><mml:mi>Φ</mml:mi><mml:mo>}</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mi>   </mml:mi><mml:mi>   </mml:mi><mml:mi>Φ</mml:mi><mml:mn>&gt;0</mml:mn></mml:mrow></mml:math><graphic alternate-form-of="disp-formula28-1077546311419177" xlink:href="10.1177_1077546311419177-eq28.tif"/></disp-formula>
<p>Where Φ is the boundary layer width that has a width of <italic>σ</italic></p>
<p>In our case, this boundary layer approach is used by replacing the sign function, sign(<italic>s</italic>) in the control law (<xref ref-type="disp-formula" rid="disp-formula19-1077546311419177">19</xref>) by the saturation function <inline-formula id="ilm46-1077546311419177"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math46-1077546311419177"><mml:mrow><mml:mi>sat</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>/</mml:mo><mml:mi>σ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> with σ &gt; 0, and:</p>
<disp-formula id="disp-formula29-1077546311419177"><label>(29)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp29-1077546311419177"><mml:mrow><mml:mi>sat</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>/</mml:mo><mml:mi>σ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mtable align="left"><mml:mtr><mml:mtd columnalign="center"><mml:mtr><mml:mtd columnalign="center" columnspan="1"><mml:mrow><mml:mi>sign</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>   </mml:mi><mml:mi>   </mml:mi><mml:mi>if</mml:mi><mml:mrow><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mi>&gt;Φ</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center" columnspan="1"><mml:mrow><mml:mi>s</mml:mi><mml:mo>/</mml:mo><mml:mi>σ</mml:mi><mml:mi>   </mml:mi><mml:mi>   </mml:mi><mml:mi>   </mml:mi><mml:mi>if</mml:mi><mml:mrow><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mo>≤</mml:mo><mml:mi>Φ</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtd></mml:mtr></mml:mtable><mml:mo> </mml:mo></mml:mrow></mml:mrow></mml:math><graphic alternate-form-of="disp-formula29-1077546311419177" xlink:href="10.1177_1077546311419177-eq29.tif"/></disp-formula>
<p>It is clear that the width of this boundary layer becomes small. The control action will have approximately the same performance as the switching type control.</p>
<p>In the closed loop system shown in <xref ref-type="fig" rid="fig3-1077546311419177">Figure 3</xref>, the output <italic>u<sub>stfis</sub></italic> is determined by the STFIS learning algorithm. All memberships functions (MFs) for STFIS system inputs, <italic>s</italic> and <inline-formula id="ilm49-1077546311419177"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math49-1077546311419177"><mml:mrow><mml:mover><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow></mml:math></inline-formula> are defined on the common normalized domain [−1, 1]. We use sigmoid and Gaussian memberships functions (MFs). The MFs for both normalized inputs (<italic>s<sub>N</sub></italic> and<inline-formula id="ilm50-1077546311419177"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math50-1077546311419177"><mml:mrow><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>) and output (<italic>u<sub>N</sub></italic>) of the STFIS controller have defined on the common normalized domain [−1, 1]. The relationships between the scales factors (<italic>G<sub>s</sub></italic>, <inline-formula id="ilm51-1077546311419177"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math51-1077546311419177"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mrow><mml:mover><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <italic>G<sub>u</sub></italic>) and the input and output variables of STFIS controller are as follows:</p>
<disp-formula id="disp-formula30-1077546311419177"><label>(30)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp30-1077546311419177"><mml:mrow><mml:msub><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow/></mml:msub><mml:mi> </mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>·</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math><graphic alternate-form-of="disp-formula30-1077546311419177" xlink:href="10.1177_1077546311419177-eq30.tif"/></disp-formula>
<disp-formula id="disp-formula31-1077546311419177"><label>(31)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp31-1077546311419177"><mml:mrow><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mrow><mml:mover><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow></mml:msub><mml:mo>·</mml:mo><mml:mover><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow></mml:math><graphic alternate-form-of="disp-formula31-1077546311419177" xlink:href="10.1177_1077546311419177-eq31.tif"/></disp-formula>
<disp-formula id="disp-formula32-1077546311419177"><label>(32)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp32-1077546311419177"><mml:mrow><mml:msub><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow/></mml:msub><mml:mi> </mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub><mml:mo>·</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>stfis</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math><graphic alternate-form-of="disp-formula32-1077546311419177" xlink:href="10.1177_1077546311419177-eq32.tif"/></disp-formula>
</sec>
<sec id="sec7-1077546311419177"><title>5. Simulation results</title>
<p>In this section the theoretical results presented in the previous section are applied to an inverted pendulum stabilization problem. The stabilization problem is todesign a controller to keep the pendulum in its unstable equilibrium point in the presence of disturbances.</p>
<p>Because of its challenging dynamic structure, the inverted pendulum system is widely used in the literature to check the validity of control strategies (<xref ref-type="bibr" rid="bibr5-1077546311419177">Ha et al., 2001</xref>). The dynamic equation of the inverted pendulum can be given (<xref ref-type="bibr" rid="bibr7-1077546311419177">Jia and Wang, 2008</xref>):</p>
<disp-formula id="disp-formula33-1077546311419177"><label>(33)</label><graphic xlink:href="10.1177_1077546311419177-eq33.tif"/></disp-formula>
<p>Where <italic>x</italic><sub>1</sub> is angular position and <italic>x</italic><sub>2</sub> is the velocity of the pole respectively, <italic>g = 9.8<italic>m/s</italic><sup>2</sup>,</italic> <italic>m<sub>c</sub></italic> is the mass of cart and <italic>m<sub>c</sub></italic> =1 kg, <italic>m</italic> is the mass of pole and <italic>m</italic> = 0.1 kg, here <italic>l</italic>= 0.5 m is half length of the pole, <italic>u</italic> is the control input, <italic>d(t)</italic> is the external disturbance (<xref ref-type="bibr" rid="bibr7-1077546311419177">Jia and Wang, 2008</xref>). Here we take <italic>d(t) = 20sin(2πt)</italic>, position tracking reference input is <italic>r(t) = 0.2sin(πt+π/2)</italic>. This inverted pendulum dynamic model is constructed using MATLAB Simulink software. The initial states of a single inverted pendulum are <italic>x</italic><sub>1</sub>= π/60, and <italic>x</italic><sub>2</sub> = 0.</p>
<p>An adaptive fuzzy inference sliding mode controller based on an on-line optimization of a zero order Takagi-Sugeno inference system is successfully applied. The MFs are normalized and shared in five subsets for all displacement (<xref ref-type="fig" rid="fig4-1077546311419177">Figure 4</xref>). The linguistic labels are defined as follows: NB: negative big, NS: negative small, Z: approximately zero, PS: positive small and PB: positive big. For the STFIS network parameters, there were five MFs of type sigmoid and Gaussians (<xref ref-type="fig" rid="fig4-1077546311419177">Figure 4</xref>) and β = 0.00001, η = 0.7 and b= 0.3. Classically these coefficients are chosen by successive tests.
<fig id="fig4-1077546311419177" position="float"><label>Figure 4.</label><caption><p>Memberships function assigned to input variables (<italic>s</italic> and <inline-formula id="ilm56-1077546311419177"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math56-1077546311419177"><mml:mrow><mml:mover><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover></mml:mrow></mml:math></inline-formula>).</p></caption><graphic xlink:href="10.1177_1077546311419177-fig4.tif"/></fig></p>
<p>For the switching control law represented by the saturation function<inline-formula id="ilm57-1077546311419177"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline" id="mml-math57-1077546311419177"><mml:mrow><mml:mi>sat</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>/</mml:mo><mml:mi>σ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>; here are taken the parameters c = 10 and <italic>k</italic> = 40, so the sliding mode surface can be given as:</p>
<disp-formula id="disp-formula34-1077546311419177"><label>(34)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp34-1077546311419177"><mml:mrow><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mn>10</mml:mn><mml:mi>e</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><graphic alternate-form-of="disp-formula34-1077546311419177" xlink:href="10.1177_1077546311419177-eq34.tif"/></disp-formula>
<p><xref ref-type="fig" rid="fig5-1077546311419177">Figure 5</xref> shows the adaptive fuzzy inference sliding mode controller response of the inverted pendulum for the given desired point angle trajectory and <xref ref-type="fig" rid="fig6-1077546311419177">Figure 6</xref> shows the control input for inverted pendulum. It is found that actual trajectories of the inverted pendulum are almost merged with the desired trajectory, with the presence of the perturbations.
<fig id="fig5-1077546311419177" position="float"><label>Figure 5.</label><caption><p>Desired and tracking trajectories of inverted pendulum with self-tuning fuzzy inference system angle controller.</p></caption><graphic xlink:href="10.1177_1077546311419177-fig5.tif"/></fig>
<fig id="fig6-1077546311419177" position="float"><label>Figure 6.</label><caption><p>Control input for inverted pendulum.</p></caption><graphic xlink:href="10.1177_1077546311419177-fig6.tif"/></fig></p>
<p>From this inference, it is concluded that STFIS training is completely satisfied and the inverted pendulum tracking error is almost zero as shown in <xref ref-type="fig" rid="fig7-1077546311419177">Figure 7</xref>. <xref ref-type="fig" rid="fig8-1077546311419177">Figure 8</xref> demonstrates the convergence of the parameters (weights) of the last layer obtained by online optimization for the inverted pendulum control.
<fig id="fig7-1077546311419177" position="float"><label>Figure 7.</label><caption><p>Position tracking error for inverted pendulum.</p></caption><graphic xlink:href="10.1177_1077546311419177-fig7.tif"/></fig>
<fig id="fig8-1077546311419177" position="float"><label>Figure 8.</label><caption><p>The convergence of the parameters (weights).</p></caption><graphic xlink:href="10.1177_1077546311419177-fig8.tif"/></fig></p>
<p>The main advantage of the described technique is the optimization of the controller with respect to the actual characteristics of the plant. The use of a cost function including a quadratic error and a regression term of the weights enabled this goal to be achieved.</p>
<p>In <xref ref-type="fig" rid="fig9-1077546311419177">Figure 9</xref>, a step changes reference has been applied under the same previous conditions. Here again, no initial estimates for adaptive fuzzy inference sliding mode parameters are given. <xref ref-type="fig" rid="fig10-1077546311419177">Figure 10</xref> displays the state error trajectory and it is seen that the system states converge to zero rapidly as the system starts. Hence the asymptotical stabilization of system (<xref ref-type="disp-formula" rid="disp-formula33-1077546311419177">33</xref>) is achieved.
<fig id="fig9-1077546311419177" position="float"><label>Figure 9.</label><caption><p>System response under step changes.</p></caption><graphic xlink:href="10.1177_1077546311419177-fig9.tif"/></fig>
<fig id="fig10-1077546311419177" position="float"><label>Figure 10.</label><caption><p>System response error under step changes.</p></caption><graphic xlink:href="10.1177_1077546311419177-fig10.tif"/></fig></p>
<p><xref ref-type="fig" rid="fig11-1077546311419177">Figure 11</xref> shows the system response to a saw tooth command, it is seen that the system response output has converged reasonably well to the target. <xref ref-type="fig" rid="fig12-1077546311419177">Figure 12</xref> shows the system response error signal. The results demonstrate the effectiveness of adaptive fuzzy inference SMC strategies.
<fig id="fig11-1077546311419177" position="float"><label>Figure 11.</label><caption><p>System response under saw tooth changes.</p></caption><graphic xlink:href="10.1177_1077546311419177-fig11.tif"/></fig>
<fig id="fig12-1077546311419177" position="float"><label>Figure 12.</label><caption><p>System response error under saw tooth changes.</p></caption><graphic xlink:href="10.1177_1077546311419177-fig12.tif"/></fig></p>
</sec>
<sec id="sec8-1077546311419177"><title>6. Conclusion</title>
<p>An STFISMC system was presented to realize the stabilizing tracking control problem for the inverted pendulum system. The definition of SMC was presented and on the basis of the inverted pendulum system, the sliding mode controller was designed and combined with the STFIS, which is an on-line optimized Takagi-Sugeno type fuzzy inference system of zero order (STFIS). The STFIS does not require a good knowledge of the model and is simple to implement. It leads to a very quick and efficient optimization technique. Stability of the proposed control scheme is proved by the Lyapunov theorem and the control scheme is applied to an inverted pendulum system. Simulation studies show that the methods are effective and can be applied to a nonlinear control system. The STFISMC demonstrated very interesting tracking features and was able to respond to different dynamic conditions.</p>
</sec>
</body>
<back>
<sec id="sec9-1077546311419177"><title>Funding</title>
<p>This research received no specific grant from any funding agency in the public, commercial, or not-for-profit sectors.</p>
</sec>
<ref-list><title>References</title>
<ref id="bibr1-1077546311419177"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Ajith</surname><given-names>A</given-names></name></person-group> (<year>2001</year>) <source>Neuro-fuzzy Systems: State-of-the-Art Modeling Techniques</source>. <publisher-loc>Melbourne, Australia</publisher-loc>: <publisher-name>School of Computing &amp; Information Technology, Monash University</publisher-name>.</citation></ref>
<ref id="bibr2-1077546311419177"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Chen</surname><given-names>JY</given-names></name></person-group> (<year>1999</year>) <article-title>Expert SMC-based fuzzy control with genetic algorithms</article-title>. <source>Journal of the Franklin Institute</source> <volume>336</volume>: <fpage>589</fpage>–<lpage>610</lpage>.</citation></ref>
<ref id="bibr3-1077546311419177"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Chen</surname><given-names>YP</given-names></name><name><surname>Chang</surname><given-names>JL</given-names></name><name><surname>Chu</surname><given-names>SR</given-names></name></person-group> (<year>1999</year>) <article-title>PC-based sliding mode control applied to parallel type double inverted pendulum system</article-title>. <source>Mechatronics</source> <volume>9</volume>: <fpage>553</fpage>–<lpage>564</lpage>.</citation></ref>
<ref id="bibr4-1077546311419177"><citation citation-type="confproc"><person-group person-group-type="author"><name><surname>Grossimon</surname><given-names>PG</given-names></name><name><surname>Barbieri</surname><given-names>E</given-names></name><name><surname>Drakunov</surname><given-names>S</given-names></name></person-group> (<year>1996</year>) <article-title>Sliding mode control of an inverted pendulum</article-title>. <source><italic>In</italic> Proceedings of the Twenty-Eighth Southeastern Symposium on System Theory</source> <fpage>248</fpage>–<lpage>252</lpage>.</citation></ref>
<ref id="bibr5-1077546311419177"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Ha</surname><given-names>QP</given-names></name><name><surname>Nguyen</surname><given-names>QH</given-names></name><name><surname>Rye</surname><given-names>DC</given-names></name><name><surname>Durrant-Whyte</surname><given-names>HF</given-names></name></person-group> (<year>2001</year>) <article-title>Fuzzy sliding mode controllers with applications</article-title>. <source>IEEE Transactions on Industrial Electronics</source> <volume>48</volume>(<issue>1</issue>): <fpage>38</fpage>–<lpage>46</lpage>.</citation></ref>
<ref id="bibr6-1077546311419177"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Isidori</surname><given-names>A</given-names></name></person-group> (<year>1995</year>) <source>Nonlinear Control Systems</source>. <publisher-loc>Berlin</publisher-loc>: <publisher-name>Springer-Verlag</publisher-name>.</citation></ref>
<ref id="bibr7-1077546311419177"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Jia</surname><given-names>N</given-names></name><name><surname>Wang</surname><given-names>H</given-names></name></person-group> (<year>2008</year>) <article-title>Nonlinear control of an inverted pendulum system based on sliding mode method</article-title>. <source>Acta Analysis Functionalis Applicata</source> <volume>9</volume>(<issue>3</issue>): <fpage>234</fpage>–<lpage>237</lpage>.</citation></ref>
<ref id="bibr8-1077546311419177"><citation citation-type="confproc"><person-group person-group-type="author"><name><surname>Jordan</surname><given-names>MI</given-names></name><name><surname>Rumelhart</surname><given-names>D</given-names></name></person-group> (<year>1991</year>) <article-title>Internal world models and supervised learning</article-title>. <source><italic>In </italic>Proceedings of the 8th International Workshop on Machine Learning</source> <fpage>70</fpage>–<lpage>74</lpage>.</citation></ref>
<ref id="bibr9-1077546311419177"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Kawamura</surname><given-names>A</given-names></name><name><surname>Itoh</surname><given-names>H</given-names></name><name><surname>Sakamoto</surname><given-names>K</given-names></name></person-group> (<year>1994</year>) <article-title>Chattering reduction of disturbance observer based sliding mode control</article-title>. <source>IEEE Transactions on Industry Applications</source> <volume>30</volume>(<issue>2</issue>): <fpage>456</fpage>–<lpage>461</lpage>.</citation></ref>
<ref id="bibr10-1077546311419177"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Khalil</surname><given-names>HK</given-names></name></person-group> (<year>1996</year>) <source>Nonlinear Systems</source>, <edition>2nd edn</edition>. <publisher-loc>Englewood Cliffs, NJ</publisher-loc>: <publisher-name>Prentice Hall</publisher-name>.</citation></ref>
<ref id="bibr11-1077546311419177"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Kim</surname><given-names>SW</given-names></name><name><surname>Lee</surname><given-names>JJ</given-names></name></person-group> (<year>1995</year>) <article-title>Design of a fuzzy controller with fuzzy sliding surface</article-title>. <source>Fuzzy Sets and Systems</source> <volume>71</volume>(<issue>3</issue>): <fpage>359</fpage>–<lpage>367</lpage>.</citation></ref>
<ref id="bibr12-1077546311419177"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Lutaud-Brunet</surname><given-names>M</given-names></name></person-group> (<year>1996</year>) <article-title>Identification et contrôle de processus par réseaux neuro-flous</article-title>. <publisher-name>PhD Thesis of University of Evry Val d’Essonne</publisher-name> <comment>France. In French</comment>.</citation></ref>
<ref id="bibr13-1077546311419177"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Liang</surname><given-names>CY</given-names></name><name><surname>Su</surname><given-names>JP</given-names></name></person-group> (<year>2003</year>) <article-title>A new approach to the design of a fuzzy sliding mode controller</article-title>. <source>Fuzzy Sets and Systems</source> <volume>139</volume>(<issue>1</issue>): <fpage>111</fpage>–<lpage>124</lpage>.</citation></ref>
<ref id="bibr14-1077546311419177"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Lin</surname><given-names>FJ</given-names></name><name><surname>Shen</surname><given-names>PH</given-names></name><name><surname>Hsu</surname><given-names>SP</given-names></name></person-group> (<year>2002</year>) <article-title>Adaptive back stepping sliding mode control for linear induction motor drive</article-title>. <source>IEEE Proceedings Electric Power Applications</source> <volume>149</volume>(<issue>3</issue>): <fpage>181</fpage>–<lpage>194</lpage>.</citation></ref>
<ref id="bibr15-1077546311419177"><citation citation-type="confproc"><person-group person-group-type="author"><name><surname>Maaref</surname><given-names>H</given-names></name><name><surname>Barret</surname><given-names>C</given-names></name></person-group> (<year>2001</year>) <article-title>Progressive optimization of a fuzzy inference system</article-title>. <source><italic>In </italic>Proceedings of IFSA-NAFIPS 2001</source>. <publisher-loc>Canada</publisher-loc>: <publisher-name>Vancouver</publisher-name>, pp. <fpage>665</fpage>–<lpage>679</lpage>, <comment>July 25–28</comment>.</citation></ref>
<ref id="bibr16-1077546311419177"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>MacVicar-Whelan</surname><given-names>PJ</given-names></name></person-group> (<year>1976</year>) <article-title>Fuzzy sets for man machine interactions</article-title>. <source>International Journal of Man-Machine Studies</source> <volume>8</volume>: <fpage>687</fpage>–<lpage>697</lpage>.</citation></ref>
<ref id="bibr17-1077546311419177"><citation citation-type="confproc"><person-group person-group-type="author"><name><surname>Nauck</surname><given-names>D</given-names></name><name><surname>Kruse</surname><given-names>R</given-names></name></person-group> (<year>1997</year>) <article-title>What are neuro-fuzzy classifiers</article-title>. <source><italic>In </italic>Proceedings of Seventh International Fuzzy Systems Association World Congress IFSA’97</source> <volume>4</volume>: <fpage>228</fpage>–<lpage>233</lpage>. <comment>Prague Academy, June 25–29</comment>.</citation></ref>
<ref id="bibr18-1077546311419177"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Noroozi</surname><given-names>N</given-names></name><name><surname>Roopaei</surname><given-names>M</given-names></name><name><surname>Jahromi</surname><given-names>MZ</given-names></name></person-group> (<year>2009</year>) <article-title>Adaptive fuzzy sliding mode control scheme for uncertain systems</article-title>. <source>Communications in Nonlinear Science and Numerical Simulation</source> <volume>14</volume>: <fpage>3978</fpage>–<lpage>3992</lpage>.</citation></ref>
<ref id="bibr19-1077546311419177"><citation citation-type="confproc"><person-group person-group-type="author"><name><surname>Ryu</surname><given-names>S-H</given-names></name><name><surname>Park</surname><given-names>J-H</given-names></name></person-group> (<year>2001</year>) <article-title>Auto-tuning of sliding mode control parameters using fuzzy logic</article-title>. <source><italic>In </italic>Proceedings of the American Control Conference. <italic>Arlington, USA</italic></source> <fpage>618</fpage>–<lpage>623</lpage>.</citation></ref>
<ref id="bibr20-1077546311419177"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Slotine</surname><given-names>JE</given-names></name><name><surname>Li</surname><given-names>W</given-names></name></person-group> (<year>1991</year>) <source>Applied Nonlinear Control</source>. <publisher-loc>Englewood Cliffs, NJ</publisher-loc>: <publisher-name>Prentice Hall</publisher-name>.</citation></ref>
<ref id="bibr21-1077546311419177"><citation citation-type="confproc"><person-group person-group-type="author"><name><surname>Tan</surname><given-names>Y</given-names></name><name><surname>Chang</surname><given-names>J</given-names></name><name><surname>Tan</surname><given-names>H</given-names></name><name><surname>Hu</surname><given-names>J</given-names></name></person-group> (<year>2000</year>) <article-title>Integral back stepping control and experimental implementation for motion system</article-title>. <source><italic>In </italic>Proceedings of the IEEE International Conference on Control Applications</source> <fpage>25</fpage>–<lpage>27</lpage>. <comment>Anchorage AK, Sept. 25–27</comment>.</citation></ref>
<ref id="bibr22-1077546311419177"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Utkin</surname><given-names>VI</given-names></name></person-group> (<year>1977</year>) <article-title>Variable structure systems with sliding modes</article-title>. <source>IEEE Transactions on Automatic Control</source> <volume>AC-22</volume>: <fpage>212</fpage>–<lpage>22</lpage>.</citation></ref>
<ref id="bibr23-1077546311419177"><citation citation-type="confproc"><person-group person-group-type="author"><name><surname>Wang</surname><given-names>W</given-names></name></person-group> (<year>2009</year>) <article-title>Adaptive fuzzy sliding mode control for inverted pendulum</article-title>. <source><italic>In </italic>Proceedings of the Second Symposium International Computer Science and Computational Technology (ISCSCT ’09)</source> <volume>26</volume>: <fpage>231</fpage>–<lpage>234</lpage>. <comment>Huangshan, People’s Republic of China, Dec. 26–28</comment>.</citation></ref>
<ref id="bibr24-1077546311419177"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Yoo</surname><given-names>B</given-names></name><name><surname>Ham</surname><given-names>W</given-names></name></person-group> (<year>1998</year>) <article-title>Adaptive fuzzy sliding mode control of nonlinear system</article-title>. <source>IEEE Transactions on Fuzzy Systems</source> <volume>6</volume>(<issue>2</issue>): <fpage>315</fpage>–<lpage>321</lpage>.</citation></ref>
<ref id="bibr25-1077546311419177"><citation citation-type="confproc"><person-group person-group-type="author"><name><surname>Zemalache</surname><given-names>K</given-names></name><name><surname>Maaref</surname><given-names>H</given-names></name></person-group> (<year>2009</year>) <article-title>Intelligent control for a drone by self-tunable fuzzy inference system</article-title>. <source><italic>In</italic> Proceedings of the 6th International Multi-conference on Systems, Signals and Devices</source> <fpage>23</fpage>–<lpage>26</lpage>, <comment>Djerba, Tunisia, March 23–26</comment>.</citation></ref>
<ref id="bibr26-1077546311419177"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Zemalache</surname><given-names>K</given-names></name><name><surname>Beji</surname><given-names>L</given-names></name><name><surname>Maaref</surname><given-names>H</given-names></name></person-group> (<year>2008</year>) <article-title>Control of drone: Study and analysis of the robustness</article-title>. <source>Journal of Automation, Mobile Robotics and Intelligent Systems</source> <volume>2</volume>(<issue>1</issue>): <fpage>33</fpage>–<lpage>42</lpage>.</citation></ref>
<ref id="bibr27-1077546311419177"><citation citation-type="confproc"><person-group person-group-type="author"><name><surname>Zhuang</surname><given-names>KY</given-names></name><name><surname>Su</surname><given-names>HY</given-names></name><name><surname>Chu</surname><given-names>J</given-names></name><name><surname>Zhang</surname><given-names>KQ</given-names></name></person-group> (<year>2000</year>) <article-title>Globally stable robust tracking of uncertain systems via fuzzy integral sliding mode control</article-title>. <source><italic>In </italic>Proceedings of the 3rd World Congress on Intelligent Control and Automation</source> <fpage>1824</fpage>–<lpage>1831</lpage>, <comment>Hefei, People’s Republic of China, June 6–July 2</comment>.</citation></ref>
</ref-list>
<app-group>
<app id="app1-1077546311419177"><title>Appendix</title>
<sec id="sec10-1077546311419177"><title/>
<p>Proof of Theorem 1: Choose a Lyapunov function candidate as:</p>
<disp-formula id="disp-formula35-1077546311419177"><label>(35)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp35-1077546311419177"><mml:mrow><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mi>g</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>η</mml:mi></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>~</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mover><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>~</mml:mi></mml:mover></mml:mrow></mml:math><graphic alternate-form-of="disp-formula35-1077546311419177" xlink:href="10.1177_1077546311419177-eq35.tif"/></disp-formula>
<p>we have:</p>
<disp-formula id="disp-formula36-1077546311419177"><label>(36)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp36-1077546311419177"><mml:mrow><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>~</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>stfis</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>∧</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>stfis</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>∧</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>stfis</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:msubsup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>stfis</mml:mi> </mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup><mml:mo>-</mml:mo><mml:mi>ɛ</mml:mi></mml:mrow></mml:math><graphic alternate-form-of="disp-formula36-1077546311419177" xlink:href="10.1177_1077546311419177-eq36.tif"/></disp-formula>
<p>Define <italic>ŵ</italic> = <italic>ŵ</italic> − <italic>w</italic>* and we can get:</p>
<disp-formula id="disp-formula37-1077546311419177"><label>(37)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp37-1077546311419177"><mml:mrow><mml:msub><mml:mrow><mml:mover><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>~</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>stfis</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>~</mml:mi></mml:mover></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mi>ζ</mml:mi><mml:mo>-</mml:mo><mml:mi>ɛ</mml:mi></mml:mrow></mml:math><graphic alternate-form-of="disp-formula37-1077546311419177" xlink:href="10.1177_1077546311419177-eq37.tif"/></disp-formula>
<disp-formula id="disp-formula38-1077546311419177"><label>(38)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp38-1077546311419177"><mml:mrow><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msup><mml:mi/><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">[</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>-</mml:mo><mml:mover><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math><graphic alternate-form-of="disp-formula38-1077546311419177" xlink:href="10.1177_1077546311419177-eq38.tif"/></disp-formula>
<disp-formula id="disp-formula39-1077546311419177"><label>(39)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp39-1077546311419177"><mml:mrow><mml:mover><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>·</mml:mi></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>stfis</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>-</mml:mo><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math><graphic alternate-form-of="disp-formula39-1077546311419177" xlink:href="10.1177_1077546311419177-eq39.tif"/></disp-formula>
<p>The time derivative of V is:</p>
<disp-formula id="disp-formula40-1077546311419177"><label>(40)</label><graphic xlink:href="10.1177_1077546311419177-eq40.tif"/></disp-formula>
<p>The adaptive law and switching control are respectively given by (<xref ref-type="disp-formula" rid="disp-formula41-1077546311419177">41</xref>) and (<xref ref-type="disp-formula" rid="disp-formula42-1077546311419177">42</xref>).</p>
<disp-formula id="disp-formula41-1077546311419177"><label>(41)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp41-1077546311419177"><mml:mrow><mml:mover><mml:mrow><mml:mover><mml:mrow/><mml:mi>~</mml:mi></mml:mover></mml:mrow><mml:mi>·</mml:mi></mml:mover><mml:mi>w</mml:mi><mml:mo>=</mml:mo><mml:mo>-</mml:mo><mml:mi>η</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>ζ</mml:mi></mml:mrow></mml:math><graphic alternate-form-of="disp-formula41-1077546311419177" xlink:href="10.1177_1077546311419177-eq41.tif"/></disp-formula>
<disp-formula id="disp-formula42-1077546311419177"><label>(42)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block" id="mml-disp42-1077546311419177"><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo>-</mml:mo><mml:mi>k</mml:mi><mml:mtext>  sgn</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><graphic alternate-form-of="disp-formula42-1077546311419177" xlink:href="10.1177_1077546311419177-eq42.tif"/></disp-formula>
<p>Then:</p>
<disp-formula id="disp-formula43-1077546311419177"><label>(43)</label><graphic xlink:href="10.1177_1077546311419177-eq43.tif"/></disp-formula>
<p>Then, a choice of the positive gains <italic>k</italic> can be made to ensure the negativity of the time derivative of the Lyapunov function candidate. Which implies that thesurface <italic>s = 0</italic> is reached in a finite time. This completes the proof.</p>
</sec></app></app-group>
</back>
</article>