<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD Journal Publishing DTD v2.3 20070202//EN" "journalpublishing.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" xml:lang="en">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">SIM</journal-id>
<journal-id journal-id-type="hwp">spsim</journal-id>
<journal-title>SIMULATION</journal-title>
<issn pub-type="ppub">0037-5497</issn>
<issn pub-type="epub">1741-3133</issn>
<publisher>
<publisher-name>SAGE Publications</publisher-name>
<publisher-loc>Sage UK: London, England</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1177/0037549712454931</article-id>
<article-id pub-id-type="publisher-id">10.1177_0037549712454931</article-id>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Articles</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>A novel parallelization technique for DEVS simulation of continuous and hybrid systems</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" corresp="yes">
<name><surname>Bergero</surname><given-names>Federico</given-names></name>
<xref ref-type="aff" rid="aff1-0037549712454931">1</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Kofman</surname><given-names>Ernesto</given-names></name>
<xref ref-type="aff" rid="aff1-0037549712454931">1</xref>
</contrib>
<contrib contrib-type="author">
<name><surname>Cellier</surname><given-names>François</given-names></name>
<xref ref-type="aff" rid="aff2-0037549712454931">2</xref>
</contrib>
</contrib-group>
<aff id="aff1-0037549712454931">
<label>1</label>Laboratorio de Sistemas Dinámicos, FCEIA - UNR, CIFASIS–CONICET, Rosario, Argentina</aff>
<aff id="aff2-0037549712454931">
<label>2</label>Modeling and Simulation Research Group, ETH, Zürich, Switzerland</aff>
<author-notes>
<corresp id="corresp1-0037549712454931">Federico Bergero, Laboratorio de Sistemas Dinámicos, FCEIA - UNR, CIFASIS–CONICET, 27 de Febrero 210 Bis, S2000EZP Rosario, Argentina. Email: <email>bergero@cifasis-conicet.gov.ar</email></corresp>
</author-notes>
<pub-date pub-type="epub-ppub">
<month>6</month>
<year>2013</year>
</pub-date>
<volume>89</volume>
<issue>6</issue>
<fpage>663</fpage>
<lpage>683</lpage>
<permissions>
<copyright-statement>© 2012 The Society for Modeling and Simulation International</copyright-statement>
<copyright-year>2012</copyright-year>
<copyright-holder content-type="society">Simulation Councils Inc.</copyright-holder>
</permissions>
<abstract>
<p>In this paper, we introduce a novel parallelization technique for Discrete Event System Specification (DEVS) simulation of continuous and hybrid systems. Here, like in most parallel discrete event simulation methodologies, the models are first split into several sub-models which are then concurrently simulated on different processors. In order to avoid the cost of the global synchronization of all processes, the simulation time of each sub-model is locally synchronized in a real-time fashion with a scaled version of physical time, which implicitly synchronizes all sub-models. The new methodology, coined Scaled Real-Time Synchronization (SRTS), does not ensure a perfect synchronization in its implementation. However, under certain conditions, the synchronization error introduced only provokes bounded numerical errors in the simulation results. SRTS uses the same physical time-scaling parameter throughout the entire simulation. We also developed an adaptive version of the methodology (Adaptive-SRTS) where this parameter automatically evolves during the simulation according to the workload. We implemented the SRTS and Adaptive-SRTS techniques in <italic>PowerDEVS</italic>, a DEVS simulation tool, under a real-time operating system called the Real-Time Application Interface. We tested their performance by simulating three large-scale models, obtaining in all cases a considerable speedup.</p>
</abstract>
<kwd-group>
<kwd>parallel simulation</kwd>
<kwd>real-time systems</kwd>
<kwd>discrete event systems</kwd>
<kwd>QSS</kwd>
<kwd>hybrid systems</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="section1-0037549712454931" sec-type="intro">
<title>1. Introduction</title>
<p>Computer simulation has become a crucial tool for studying, developing, and evaluating mathematical models of systems of different domains (physics, economics, biology, etc.).</p>
<p>Continuous systems are usually represented by sets of differential equations. Since most differential equations lack analytical solutions, they must be discretized to simulate the continuous systems they represent. To this end, most numerical integration methods approximate the differential equations by discretizing the time variable transforming them into sets of difference equations.<sup><xref ref-type="bibr" rid="bibr1-0037549712454931">1</xref></sup></p>
<p>Some recently developed numerical methods, however, are based on state discretization. These methods, called Quantized State Systems (QSS)<sup><xref ref-type="bibr" rid="bibr1-0037549712454931">1</xref></sup> transform the originally continuous systems into discrete event systems that can be represented by the Discrete Event System Specification (DEVS) formalism.<sup><xref ref-type="bibr" rid="bibr2-0037549712454931">2</xref></sup> The usage of QSS algorithms then allows the DEVS formalism to represent and to simulate continuous and hybrid systems. DEVS models can be easily simulated, but when the models are large, the computational requirements become critical and parallelization techniques must be employed.</p>
<p>Parallel Discrete Event Simulation (PDES) is a technique that can be used for the simulation of large DEVS models in multi-core or cluster environments. In PDES, the model is first split into several sub-systems called physical processes. Then, the processes are simulated concurrently on different logical processors (LPs).</p>
<p>Compared with simulating a large model in a sequential manner, PDES reduces the computational cost but it introduces a new problem related to the need of synchronization between processes. Synchronization between different LPs is required since each process needs to know the results of other processes in order to correctly simulate its own sub-system. If the LPs are not correctly synchronized, the simulation may receive events out of order (with time-stamps lower than the actual simulation time), which can lead to an incorrect result. This is called a causality constraint.</p>
<p>There are many approaches to overcome this problem. One of the earliest was the CMB algorithm proposed by Chandy, Misra, and Bryant.<sup><xref ref-type="bibr" rid="bibr3-0037549712454931">3</xref><xref ref-type="bibr" rid="bibr4-0037549712454931"/>–<xref ref-type="bibr" rid="bibr5-0037549712454931">5</xref></sup> CMB implements a conservative synchronization where none of the LPs advances its simulation time until it is safe. A different approach is that proposed by Jefferson,<sup><xref ref-type="bibr" rid="bibr6-0037549712454931">6</xref></sup> where an optimistic synchronization mechanism is introduced relaxing the causality constraint. The LPs are allowed to advance their simulation time as fast as they can, and proper actions are taken when inconsistencies are detected. Finally, a technique called NOTIME<sup><xref ref-type="bibr" rid="bibr7-0037549712454931">7</xref></sup> explores the effects of not synchronizing the processes at all.</p>
<p>In this article, we present a novel PDES technique, specialized for DEVS approximations of continuous and hybrid system, called Scaled Real-Time Synchronization (SRTS). The basic idea is to synchronize each LP’s simulation time with a scaled version of the physical time or wall-clock time. As all LPs are synchronized with the physical time, they are indirectly synchronized against each other.</p>
<p>As our approach is intended for continuous and hybrid systems, events represent continuous trajectories. Thus, synchronization errors provoke numerical errors. Provided that the errors are bounded, they do not invalidate the final results, hence we can relax the causality constraints.</p>
<p>While in SRTS the user must provide the real-time scaling factor as a simulation parameter, we also developed an Adaptive-SRTS (ASRTS) algorithm where the scaling factor is adjusted dynamically depending on the system workload.</p>
<p>We have implemented SRTS and ASRTS in <italic>PowerDEVS</italic>,<sup><xref ref-type="bibr" rid="bibr8-0037549712454931">8</xref></sup> a general-purpose open-source DEVS simulator. <italic>PowerDEVS</italic><sup><xref ref-type="bibr" rid="bibr8-0037549712454931">8</xref></sup> implements the complete family of QSS methods on which this work is based.<sup><xref ref-type="bibr" rid="bibr1-0037549712454931">1</xref>,<xref ref-type="bibr" rid="bibr19-0037549712454931">19</xref>–<xref ref-type="bibr" rid="bibr13-0037549712454931">13</xref></sup> As we need a precise synchronization with physical time in order to achieve a precise synchronization between the processes, the implementation runs under a real-time operating system called the Real-Time Application Interface (RTAI).<sup><xref ref-type="bibr" rid="bibr14-0037549712454931">14</xref></sup></p>
<p>This article is organized as follows. Section 2 introduces the main concepts used in the rest of the paper, and Section 3 describes some related work in the field. Then Sections 4 and 5 introduce and describe the SRTS and ASRTS algorithms, the main contributions of this article. Finally, Section 6 shows some application examples, and Section 7 concludes the article and discusses some lines of future work.</p>
</sec>
<sec id="section2-0037549712454931">
<title>2. Background</title>
<p>In this section, we introduce a few basic concepts and ideas that will be used in the article. We first describe the DEVS formalism and the QSS methods, a family of numerical integration methods for continuous and hybrid system simulation. Then, we describe the RTAI real-time operating system and the DEVS simulation tool called <italic>PowerDEVS</italic>. Finally, we provide a brief introduction to parallel architectures.</p>
<sec id="section3-0037549712454931">
<title>2.1 DEVS</title>
<p>DEVS stands for Discrete EVent System specification, a formalism introduced originally by Bernard P Zeigler.<sup><xref ref-type="bibr" rid="bibr15-0037549712454931">15</xref></sup></p>
<p>A DEVS model processes an input event trajectory and, according to that trajectory and its own initial conditions, provokes an output event trajectory.</p>
<p>An atomic DEVS model is defined by the following structure:</p>
<p>
<disp-formula id="disp-formula1-0037549712454931">
<mml:math display="block" id="math1-0037549712454931">
<mml:mrow>
<mml:mi>M</mml:mi>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>X</mml:mi>
<mml:mo>,</mml:mo>
<mml:mi>Y</mml:mi>
<mml:mo>,</mml:mo>
<mml:mi>S</mml:mi>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mrow>
<mml:mtext>int</mml:mtext>
</mml:mrow>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>ext</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mi>λ</mml:mi>
<mml:mo>,</mml:mo>
<mml:mi>ta</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula1-0037549712454931" xlink:href="10.1177_0037549712454931-eq1.tif"/>
</disp-formula>
</p>
<p>where:</p>
<list id="list1-0037549712454931" list-type="bullet">
<list-item>
<p>
<inline-formula id="inline-formula1-0037549712454931">
<mml:math display="inline" id="math2-0037549712454931">
<mml:mrow>
<mml:mi>X</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula> is the set of input event values, i.e. the set of all possible values that an input event can adopt;</p>
</list-item>
<list-item>
<p>
<inline-formula id="inline-formula2-0037549712454931">
<mml:math display="inline" id="math3-0037549712454931">
<mml:mrow>
<mml:mi>Y</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula> is the set of output event values;</p>
</list-item>
<list-item>
<p>
<inline-formula id="inline-formula3-0037549712454931">
<mml:math display="inline" id="math4-0037549712454931">
<mml:mrow>
<mml:mi>S</mml:mi>
</mml:mrow>
</mml:math>
</inline-formula> is the set of state values;</p>
</list-item>
<list-item>
<p>
<inline-formula id="inline-formula4-0037549712454931">
<mml:math display="inline" id="math5-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>int</mml:mtext>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
</inline-formula>, <inline-formula id="inline-formula5-0037549712454931">
<mml:math display="inline" id="math6-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>ext</mml:mtext>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula>, <inline-formula id="inline-formula6-0037549712454931">
<mml:math display="inline" id="math7-0037549712454931">
<mml:mrow>
<mml:mi>λ</mml:mi>
</mml:mrow>
</mml:math></inline-formula> and <inline-formula id="inline-formula7-0037549712454931">
<mml:math display="inline" id="math8-0037549712454931">
<mml:mrow>
<mml:mi>ta</mml:mi>
</mml:mrow>
</mml:math></inline-formula> are functions that define the system dynamics.</p>
</list-item>
</list>
<p>Each possible state <inline-formula id="inline-formula8-0037549712454931">
<mml:math display="inline" id="math9-0037549712454931">
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
</mml:math></inline-formula> (<inline-formula id="inline-formula9-0037549712454931">
<mml:math display="inline" id="math10-0037549712454931">
<mml:mrow>
<mml:mi>s</mml:mi>
<mml:mo>∈</mml:mo>
<mml:mi>S</mml:mi>
</mml:mrow>
</mml:math></inline-formula>) has an associated time advance computed by the time advance function <inline-formula id="inline-formula10-0037549712454931">
<mml:math display="inline" id="math11-0037549712454931">
<mml:mrow>
<mml:mi>ta</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>s</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula> (<inline-formula id="inline-formula11-0037549712454931">
<mml:math display="inline" id="math12-0037549712454931">
<mml:mrow>
<mml:mi>ta</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>s</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>:</mml:mo>
<mml:mi>S</mml:mi>
<mml:mo>→</mml:mo>
<mml:msubsup>
<mml:mrow>
<mml:mo>ℜ</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mo>+</mml:mo>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:math></inline-formula>). The time advance is a non-negative real number specifying how long the system remains in a given state in the absence of input events.</p>
<p>Thus, if the state adopts the value <inline-formula id="inline-formula12-0037549712454931">
<mml:math display="inline" id="math13-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> at time <inline-formula id="inline-formula13-0037549712454931">
<mml:math display="inline" id="math14-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula>, <inline-formula id="inline-formula14-0037549712454931">
<mml:math display="inline" id="math15-0037549712454931">
<mml:mrow>
<mml:mi>ta</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula> units of time later (i.e. at time <inline-formula id="inline-formula15-0037549712454931">
<mml:math display="inline" id="math16-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo>
<mml:mi>ta</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula>) the system undergoes an internal transition, changing its state from <inline-formula id="inline-formula16-0037549712454931">
<mml:math display="inline" id="math17-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> to <inline-formula id="inline-formula17-0037549712454931">
<mml:math display="inline" id="math18-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula>. The new state is calculated as <inline-formula id="inline-formula18-0037549712454931">
<mml:math display="inline" id="math19-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>int</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula>. Function <inline-formula id="inline-formula19-0037549712454931">
<mml:math display="inline" id="math20-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>int</mml:mtext>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> (<inline-formula id="inline-formula20-0037549712454931">
<mml:math display="inline" id="math21-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>int</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo>:</mml:mo>
<mml:mi>S</mml:mi>
<mml:mo>→</mml:mo>
<mml:mi>S</mml:mi>
</mml:mrow>
</mml:math></inline-formula>) is called the internal transition function.</p>
<p>When the state transitions from <inline-formula id="inline-formula21-0037549712454931">
<mml:math display="inline" id="math22-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> to <inline-formula id="inline-formula22-0037549712454931">
<mml:math display="inline" id="math23-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula>, an output event is produced with value <inline-formula id="inline-formula23-0037549712454931">
<mml:math display="inline" id="math24-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>y</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mi>λ</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula>. Function <inline-formula id="inline-formula24-0037549712454931">
<mml:math display="inline" id="math25-0037549712454931">
<mml:mrow>
<mml:mi>λ</mml:mi>
</mml:mrow>
</mml:math></inline-formula> (<inline-formula id="inline-formula25-0037549712454931">
<mml:math display="inline" id="math26-0037549712454931">
<mml:mrow>
<mml:mi>λ</mml:mi>
<mml:mo>:</mml:mo>
<mml:mi>S</mml:mi>
<mml:mo>→</mml:mo>
<mml:mi>Y</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula> is called the output function. In this way, the functions <inline-formula id="inline-formula26-0037549712454931">
<mml:math display="inline" id="math27-0037549712454931">
<mml:mrow>
<mml:mi>ta</mml:mi>
</mml:mrow>
</mml:math></inline-formula>, <inline-formula id="inline-formula27-0037549712454931">
<mml:math display="inline" id="math28-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>int</mml:mtext>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula>, and <inline-formula id="inline-formula28-0037549712454931">
<mml:math display="inline" id="math29-0037549712454931">
<mml:mrow>
<mml:mi>λ</mml:mi>
</mml:mrow>
</mml:math></inline-formula> define the autonomous behavior of a DEVS model.</p>
<p>When an input event arrives, the state changes instantaneously. The new state value depends not only on the input event value but also on the previous state value and the elapsed time since the last transition. If the system entered state <inline-formula id="inline-formula29-0037549712454931">
<mml:math display="inline" id="math30-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> at time <inline-formula id="inline-formula30-0037549712454931">
<mml:math display="inline" id="math31-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> and then an input event arrives at time <inline-formula id="inline-formula31-0037549712454931">
<mml:math display="inline" id="math32-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo>
<mml:mi>e</mml:mi>
</mml:mrow>
</mml:math></inline-formula> with value <inline-formula id="inline-formula32-0037549712454931">
<mml:math display="inline" id="math33-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula>, the new state is calculated as <inline-formula id="inline-formula33-0037549712454931">
<mml:math display="inline" id="math34-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>3</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>ext</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mi>e</mml:mi>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula> (note that <inline-formula id="inline-formula34-0037549712454931">
<mml:math display="inline" id="math35-0037549712454931">
<mml:mrow>
<mml:mi>ta</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>s</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>&gt;</mml:mo>
<mml:mi>e</mml:mi>
</mml:mrow>
</mml:math></inline-formula>). In this case, we say that the system performs an external transition. Function <inline-formula id="inline-formula35-0037549712454931">
<mml:math display="inline" id="math36-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>ext</mml:mtext>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> (<inline-formula id="inline-formula36-0037549712454931">
<mml:math display="inline" id="math37-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>ext</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo>:</mml:mo>
<mml:mi>S</mml:mi>
<mml:mo>×</mml:mo>
<mml:msubsup>
<mml:mrow>
<mml:mo>ℜ</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mo>+</mml:mo>
</mml:mrow>
</mml:msubsup>
<mml:mo>×</mml:mo>
<mml:mi>X</mml:mi>
<mml:mo>→</mml:mo>
<mml:mi>S</mml:mi>
</mml:mrow>
</mml:math></inline-formula>) is called the external transition function. No output event is produced during an external transition.</p>
<p>The formalism presented is also called classic DEVS to distinguish it from parallel DEVS,<sup><xref ref-type="bibr" rid="bibr2-0037549712454931">2</xref></sup> which consists of an extension of the classic DEVS formalism designed to improve the handling of simultaneous events.</p>
<p>Atomic DEVS models can be coupled. DEVS theory guarantees that the coupling of atomic DEVS models defines new DEVS models (i.e.DEVS is closed under coupling) and, thus, complex systems can be represented by DEVS in a hierarchical way.<sup><xref ref-type="bibr" rid="bibr2-0037549712454931">2</xref></sup></p>
<p>Coupling in DEVS is usually represented through the use of input and output ports. With these ports, the coupling of DEVS models becomes a simple block-diagram construction. <xref ref-type="fig" rid="fig1-0037549712454931">Figure 1</xref> shows a coupled DEVS model <inline-formula id="inline-formula37-0037549712454931">
<mml:math display="inline" id="math38-0037549712454931">
<mml:mrow>
<mml:mi>N</mml:mi>
</mml:mrow>
</mml:math></inline-formula> that results from coupling models <inline-formula id="inline-formula38-0037549712454931">
<mml:math display="inline" id="math39-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>M</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> and <inline-formula id="inline-formula39-0037549712454931">
<mml:math display="inline" id="math40-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>M</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>b</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula>.</p>
<fig id="fig1-0037549712454931" position="float">
<label>Figure 1.</label>
<caption><p>Coupled DEVS model.</p></caption><graphic xlink:href="10.1177_0037549712454931-fig1.tif"/></fig>
<p>According to the closure property, the model <inline-formula id="inline-formula40-0037549712454931">
<mml:math display="inline" id="math41-0037549712454931">
<mml:mrow>
<mml:mi>N</mml:mi>
</mml:mrow>
</mml:math></inline-formula> can itself be interpreted as an atomic DEVS and can be coupled with other atomic or coupled models.</p>
</sec>
<sec id="section4-0037549712454931">
<title>2.2 Quantized state systems</title>
<p>A continuous time system can be written as a set of ordinary differential equations (ODEs):</p>
<p>
<disp-formula id="disp-formula2-0037549712454931">
<label>(1)</label>
<mml:math display="block" id="math42-0037549712454931">
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi mathvariant="bold">x</mml:mi>
</mml:mrow>
<mml:mo>·</mml:mo>
</mml:mover>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="bold">f</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="bold">x</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>,</mml:mo>
<mml:mi mathvariant="bold">u</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula2-0037549712454931" xlink:href="10.1177_0037549712454931-eq2.tif"/>
</disp-formula>
</p>
<p>where <inline-formula id="inline-formula41-0037549712454931">
<mml:math display="inline" id="math43-0037549712454931">
<mml:mrow>
<mml:mi mathvariant="bold">x</mml:mi>
<mml:mo>∈</mml:mo>
<mml:msup>
<mml:mrow>
<mml:mo>ℜ</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math></inline-formula> is the state vector and <inline-formula id="inline-formula42-0037549712454931">
<mml:math display="inline" id="math44-0037549712454931">
<mml:mrow>
<mml:mi mathvariant="bold">u</mml:mi>
<mml:mo>∈</mml:mo>
<mml:msup>
<mml:mrow>
<mml:mo>ℜ</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math></inline-formula> is a vector of known input functions.</p>
<p>The mathematical model (1) can be simulated using a numerical integration method. While conventional integration algorithms are based on time discretization, a new family of numerical methods was developed based on state quantization.<sup><xref ref-type="bibr" rid="bibr1-0037549712454931">1</xref></sup> The new algorithms, called QSS methods, approximate ODEs like that of <xref ref-type="disp-formula" rid="disp-formula2-0037549712454931">Equation (1)</xref> by DEVS models.</p>
<p>Formally, the first-order accurate QSS method (QSS1) approximates <xref ref-type="disp-formula" rid="disp-formula2-0037549712454931">Equation (1)</xref> by</p>
<p>
<disp-formula id="disp-formula3-0037549712454931">
<label>(2)</label>
<mml:math display="block" id="math45-0037549712454931">
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi mathvariant="bold">x</mml:mi>
</mml:mrow>
<mml:mo>·</mml:mo>
</mml:mover>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="bold">f</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="bold">q</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>,</mml:mo>
<mml:mi mathvariant="bold">v</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula3-0037549712454931" xlink:href="10.1177_0037549712454931-eq3.tif"/>
</disp-formula>
</p>
<p>where each pair of variables <inline-formula id="inline-formula43-0037549712454931">
<mml:math display="inline" id="math46-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> and <inline-formula id="inline-formula44-0037549712454931">
<mml:math display="inline" id="math47-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> are related by a hysteretic quantization function.</p>
<p>The presence of a hysteretic quantization function relating <inline-formula id="inline-formula45-0037549712454931">
<mml:math display="inline" id="math48-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula> and <inline-formula id="inline-formula46-0037549712454931">
<mml:math display="inline" id="math49-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula> implies that <inline-formula id="inline-formula47-0037549712454931">
<mml:math display="inline" id="math50-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula> follows a piecewise constant trajectory that only changes when the difference with <inline-formula id="inline-formula48-0037549712454931">
<mml:math display="inline" id="math51-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula> becomes equal to a parameter <inline-formula id="inline-formula49-0037549712454931">
<mml:math display="inline" id="math52-0037549712454931">
<mml:mrow>
<mml:mi>Δ</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula>, called quantum. The variables <inline-formula id="inline-formula50-0037549712454931">
<mml:math display="inline" id="math53-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> are called quantized variables. They can be viewed as piecewise constant approximations of the corresponding state variables <inline-formula id="inline-formula51-0037549712454931">
<mml:math display="inline" id="math54-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula>. Similarly, the components of <inline-formula id="inline-formula52-0037549712454931">
<mml:math display="inline" id="math55-0037549712454931">
<mml:mrow>
<mml:mi mathvariant="bold">v</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula> are piecewise constant approximations of the corresponding components of <inline-formula id="inline-formula53-0037549712454931">
<mml:math display="inline" id="math56-0037549712454931">
<mml:mrow>
<mml:mi mathvariant="bold">u</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula>.</p>
<p>Since the components <inline-formula id="inline-formula54-0037549712454931">
<mml:math display="inline" id="math57-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula> and <inline-formula id="inline-formula55-0037549712454931">
<mml:math display="inline" id="math58-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>v</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula> follow piecewise constant trajectories, it results that the state derivatives <inline-formula id="inline-formula56-0037549712454931">
<mml:math display="inline" id="math59-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mo>·</mml:mo>
</mml:mover>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula> also follow piecewise constant trajectories. Then, the state variables <inline-formula id="inline-formula57-0037549712454931">
<mml:math display="inline" id="math60-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula> have piecewise linear evolutions.</p>
<p>Each component of <xref ref-type="disp-formula" rid="disp-formula3-0037549712454931">Equation (2)</xref> can be thought of as the coupling of two elementary sub-systems, a static one,</p>
<p>
<disp-formula id="disp-formula4-0037549712454931">
<label>(3)</label>
<mml:math display="block" id="math61-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mo>·</mml:mo>
</mml:mover>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>f</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mo>…</mml:mo>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>v</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mo>…</mml:mo>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>v</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula4-0037549712454931" xlink:href="10.1177_0037549712454931-eq4.tif"/>
</disp-formula>
</p>
<p>and a dynamical one</p>
<p>
<disp-formula id="disp-formula5-0037549712454931">
<label>(4)</label>
<mml:math display="block" id="math62-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>Q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mo>·</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>Q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mo>∫</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mo>·</mml:mo>
</mml:mover>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>τ</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mi>d</mml:mi>
<mml:mi>τ</mml:mi>
<mml:mo>)</mml:mo>
</mml:mrow>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula5-0037549712454931" xlink:href="10.1177_0037549712454931-eq5.tif"/>
</disp-formula>
</p>
<p>where <inline-formula id="inline-formula58-0037549712454931">
<mml:math display="inline" id="math63-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>Q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> is the hysteretic quantization function (it is not a function of the instantaneous value <inline-formula id="inline-formula59-0037549712454931">
<mml:math display="inline" id="math64-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula>, but a functional of the trajectory <inline-formula id="inline-formula60-0037549712454931">
<mml:math display="inline" id="math65-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mo>·</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula>).</p>
<p>Since the components <inline-formula id="inline-formula61-0037549712454931">
<mml:math display="inline" id="math66-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>v</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula>, <inline-formula id="inline-formula62-0037549712454931">
<mml:math display="inline" id="math67-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula>, and <inline-formula id="inline-formula63-0037549712454931">
<mml:math display="inline" id="math68-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mo>·</mml:mo>
</mml:mover>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula> are piecewise constant, both sub-systems have piecewise constant input and output trajectories that can be represented by sequences of events. Then, subsystems (3) and (4) define a relation between their input and output sequences of events. Consequently, equivalent DEVS models can be found for these systems, called static functions and quantized integrators, respectively.<sup><xref ref-type="bibr" rid="bibr1-0037549712454931">1</xref></sup> The piecewise constant input trajectories <inline-formula id="inline-formula64-0037549712454931">
<mml:math display="inline" id="math69-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>v</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula> can be also represented by sequences of events, and source DEVS models that generate them can be easily obtained.</p>
<p>Then, the QSS approximation (2) can be exactly simulated by a DEVS model consisting of the coupling of <inline-formula id="inline-formula65-0037549712454931">
<mml:math display="inline" id="math70-0037549712454931">
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:math></inline-formula> quantized integrators, <inline-formula id="inline-formula66-0037549712454931">
<mml:math display="inline" id="math71-0037549712454931">
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:math></inline-formula> static functions, and <inline-formula id="inline-formula67-0037549712454931">
<mml:math display="inline" id="math72-0037549712454931">
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
</mml:math></inline-formula> signal sources. The resulting coupled DEVS model looks identical to the block diagram representation of the original system of <xref ref-type="disp-formula" rid="disp-formula2-0037549712454931">Equation (1)</xref>, as <xref ref-type="fig" rid="fig2-0037549712454931">Figure 2</xref> shows.</p>
<fig id="fig2-0037549712454931" position="float">
<label>Figure 2.</label>
<caption>
<p>Coupled DEVS model of a QSS approximation.</p>
</caption>
<graphic xlink:href="10.1177_0037549712454931-fig2.tif"/>
</fig>
<p>Based on the idea of QSS1, a second-order accurate method was developed replacing the piecewise constant approximations by piecewise linear ones. The method, called QSS2, can be implemented using DEVS in the same way as QSS1. However, the trajectories are now piecewise linear instead of piecewise constant. Thus, the events carry two numbers that indicate the initial value and the slope of each segment. Also, the static functions and quantized integrators are modified with respect to those of QSS so that they can take into account the slopes.</p>
<p>Following the idea of QSS2, the third-order accurate QSS3 method<sup><xref ref-type="bibr" rid="bibr16-0037549712454931">16</xref></sup> uses piecewise parabolic trajectories. The family of QSS methods has been further augmented with methods for stiff and marginally stable systems (Backward QSS [BQSS] and Centered QSS [CQSS] of first order,<sup><xref ref-type="bibr" rid="bibr13-0037549712454931">13</xref></sup> and Linearly Implicit stiff QSS methods of orders 1 and 2 [LIQSS1 and LIQSS2]<sup><xref ref-type="bibr" rid="bibr11-0037549712454931">11</xref></sup>).</p>
</sec>
<sec id="section5-0037549712454931">
<title>2.3 RTAI</title>
<p>RTAI is a real-time operating system (RTOS) that supports several architectures (i386, PowerPC, ARM). RTAI is an extension of the Linux kernel to support real-time tasks to run concurrently with Linux processes. In order to enable real-time simulation, RTAI employs a method that was first used in RT-Linux.<sup><xref ref-type="bibr" rid="bibr17-0037549712454931">17</xref></sup></p>
<p>The Linux kernel is not by itself a RTOS. It does not provide real-time services, and in some parts of the kernel, interrupts are disabled as a method of synchronization (to update internal structures in an atomic way). The periods of time when interrupts are disabled lead to a scenario where the response time of the system is unknown and time deadlines may therefore be missed.</p>
<p>To avoid this problem, RTAI inserts an abstraction layer underneath the Linux kernel. In this way, Linux never disables the <italic>real</italic> hardware interrupts. The Linux kernel is run on top of another micro-kernel (RTAI + Adeos; Adeos<sup><xref ref-type="bibr" rid="bibr18-0037549712454931">18</xref>,<xref ref-type="bibr" rid="bibr19-0037549712454931">19</xref></sup> is the abstraction layer used in RTAI, Adeos implements the concept of an interrupt domain, see <ext-link ext-link-type="uri" xlink:href="http://home.gna.org/adeos/">http://home.gna.org/adeos/</ext-link>) as user processes. All hardware interrupts are captured by this micro-kernel and are forwarded to Linux (if Linux has interrupts enabled).</p>
<p>Another problem running real-time tasks under Linux is that the Linux scheduler can take control of the processor from any running process without restrictions. This is unacceptable in a real-time system. Thus, in RTAI, all real-time tasks are run in the micro-kernel without any supervision by Linux. Moreover, these processes are not seen by the Linux scheduler.</p>
<p>Real-time tasks are managed by the RTAI scheduler. There are two different kinds of processes, Linux processes and RTAI processes. RTAI processes cannot make use of Linux services (such as the File system) and vice versa. To avoid this problem, RTAI offers various IPC mechanisms (Pipes, Mailboxes, Shared Memory, etc.).</p>
<p>RTAI provides the user with basic services to implement real-time systems:</p>
<p>
<bold>Deterministic interrupt response time:</bold> An interrupt is an external event to the system. The response time to this event varies from one computer to another, but RTAI guarantees an upper limit (on each computer), which is necessary to communicate with external hardware, for example a data acquisition board.</p>
<p>
<bold>Inter-process communication (IPC):</bold> RTAI supports a number of different methods of IPC, such as semaphores, pipes, mailboxes, and shared memory. These IPC mechanisms can be used for the communication between processes running in real time and normal Linux processes.</p>
<p>
<bold>High-accuracy timers:</bold> When developing real-time systems, the time handling accuracy is very important. RTAI offers clocks and timers with nanosecond (<inline-formula id="inline-formula68-0037549712454931">
<mml:math display="inline" id="math73-0037549712454931">
<mml:mrow>
<mml:mn>1</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>0</mml:mn>
<mml:mo>×</mml:mo>
<mml:msup>
<mml:mrow>
<mml:mn>10</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mo>−</mml:mo>
<mml:mn>9</mml:mn>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math></inline-formula> s) precision. On i386 architectures, these timers use the processor time stamp; therefore, they are very precise.</p>
<p>
<bold>Interrupt handling:</bold> RTAI allows the user to capture hardware interrupts and treat them with custom user handlers. Normal operating systems (such as Linux, Windows) hide hardware interrupts from the user, making the development of communication with external hardware more cumbersome (one needs to write a kernel driver).</p>
<p>
<bold>Multiprocessor support:</bold> RTAI supports also multiprocessor architectures enabling the user to run simultaneously different real-time tasks on separate processors.</p>
</sec>
<sec id="section6-0037549712454931">
<title>2.4 PowerDEVS and real time</title>
<p><italic>PowerDEVS</italic><sup><xref ref-type="bibr" rid="bibr8-0037549712454931">8</xref></sup> is a general-purpose tool for DEVS simulation. It consists of two main modules: the graphic interface that allows the user to describe DEVS models in a block-diagram fashion, and the simulation engine that simulates the models.</p>
<p>In order to simulate a model, <italic>PowerDEVS</italic> first translates it into a C+<?h-1?>+ description and compiles it together with the simulation engine. In spite of being usable as a general-purpose DEVS simulator, <italic>PowerDEVS</italic> was primarily designed to simulate continuous and hybrid systems through the use of QSS methods. The standard distribution comes with a comprehensive library of atomic models for hybrid system simulation based on these methods. Users can add new atomic models by defining the dynamics of the DEVS model in C++.</p>
<p>
<italic>PowerDEVS</italic> can be run under RTAI synchronizing the simulation with the physical (wall-clock) time obtaining an accuracy of the order of 1 <inline-formula id="inline-formula69-0037549712454931">
<mml:math display="inline" id="math74-0037549712454931">
<mml:mrow>
<mml:mi>μ</mml:mi>
</mml:mrow>
</mml:math></inline-formula>s.<sup><xref ref-type="bibr" rid="bibr8-0037549712454931">8</xref></sup></p>
</sec>
<sec id="section7-0037549712454931">
<title>2.5 Parallelization platforms</title>
<p>Parallel computing is a form of computation, in which many calculations are simultaneously carried out on separate processors. Large problems can usually be divided into smaller ones that can then be solved concurrently.</p>
<p>There are different levels of parallelism: instruction level, data level, task level, etc. They differ in many aspects, such as shared or distributed memory, single or multiple processors, the type of communication mechanism they employ, such as message passing, or shared memory, etc.</p>
<p>We shall focus on task-level parallelism, where each LP runs a different piece of code with different data, i.e. according to Flynn’s taxonomy,<sup><xref ref-type="bibr" rid="bibr20-0037549712454931">20</xref></sup> we operate on multiple instructions and multiple data (MIMD) streams.</p>
<p>In particular, we shall work with a multi-core architecture<sup><xref ref-type="bibr" rid="bibr21-0037549712454931">21</xref></sup> as this offers many desirable features for our implementation, such as shared and unified memory, local communication (on chip), and a generic instruction set.</p>
<p>There exist also other architectures, such as the Message Passing Interface (MPI)<sup><xref ref-type="bibr" rid="bibr22-0037549712454931">22</xref></sup> and general-purpose computing on graphics processing units (GPGPU),<sup><xref ref-type="bibr" rid="bibr23-0037549712454931">23</xref></sup> but they both have their drawbacks. MPI is a message-passing protocol. This protocol is particularly well suited for clusters. GPGPU does not fit our purposes well, since the architecture lacks shared memory, the code executed on each processor must be identical, synchronization is very expensive, and the instruction set is not as generic as for a PC.</p>
</sec>
</sec>
<sec id="section8-0037549712454931">
<title>3. Related work</title>
<p>In this section, we review previous work and similar developments.</p>
<sec id="section9-0037549712454931">
<title>3.1 Parallel discrete event simulation</title>
<p>Since the beginning of the 1980s, much research has been published on algorithms for synchronizing parallel simulation of discrete event systems.</p>
<p>One of the first approaches to the problem was proposed by Chandy, Misra, and Bryant.<sup><xref ref-type="bibr" rid="bibr3-0037549712454931">3</xref><xref ref-type="bibr" rid="bibr4-0037549712454931"/>–<xref ref-type="bibr" rid="bibr5-0037549712454931">5</xref></sup> They suggested a conservative distributed algorithm, whereby processes communicate only by message passing without shared memory and with a centralized coordinator.</p>
<p>The synchronization is achieved by enforcing the correct order of all messages, making all LPs wait until it is safe to produce the next event. By safe we mean that the LP producing the next event is certain that it will never receive a message with an earlier time-stamp than its own logical simulation time.</p>
<p>The authors prove formally the correctness of the algorithm and show that no deadlock can occur by the use of null messages. The memory consumption of the algorithm is fixed as it does not require state saving at all. Chandy and Misra<sup><xref ref-type="bibr" rid="bibr24-0037549712454931">24</xref></sup> also proposed an alternative scheme that avoids the use of null messages and allows deadlocks to happen, which are then broken.</p>
<p>The major drawback of this approach is that the amount of actual parallel computing done is greatly diminished by the mechanism used to enforce the causality constraint. By including lookahead and structure analysis, the efficiency of the algorithm can be improved, but the achievable speedup is highly dependent on the model.</p>
<p>Another solution was proposed by Jefferson<sup><xref ref-type="bibr" rid="bibr6-0037549712454931">6</xref></sup> who introduced an optimistic synchronization method for parallel simulation, called Time Warp. Each LP carries its own logical time and advances as if there were no need for synchronization at all. If an event with a smaller time-stamp than the simulation time is received (a straggler event), the LP rolls back to a previously saved state where it is safe to receive that event. It also un-sends (by using anti-messages) all events that were sent out in the rollback period. This involves saving state values in each LP for possible rollbacks and, thus, the memory requirements are larger than for other algorithms.</p>
<p>Both the state saving and the anti-message scheme (that may produce a cascade of rollbacks) are computationally expensive and, consequently, many extensions and additions have been proposed to the original algorithm to avoid rollbacks and reduce the number of state savings required. A complete review of these extensions can be found in an article by Liu.<sup><xref ref-type="bibr" rid="bibr25-0037549712454931">25</xref></sup></p>
<p>More recently, an algorithm called NOTIME<sup><xref ref-type="bibr" rid="bibr7-0037549712454931">7</xref></sup> was proposed where the simulation is performed without any synchronization. Using this approach, the different LPs simulate their physical processes as fast as they can. Straggler events are allowed and accepted as correct. This introduces some error in the simulation since the logical time in the different LPs will vary from one processor to another.</p>
<p>While this approach exploits the parallelism optimally well, the technique can produce incorrect results. Yet it may be an acceptable technique in situations where a user is willing to trade simulation accuracy for simulation speed.</p>
<p>The correctness of the results depends indirectly on how the work load is balanced across different LPs. If the work load is unevenly distributed, some LPs will run faster, while those with a heavier workload will run more slowly.</p>
<p>Tang et al. studied an optimistic PDES using reverse computations applied to partial differential equation problems obtaining linear speedup for up to four processors.<sup><xref ref-type="bibr" rid="bibr26-0037549712454931">26</xref></sup> Similar studies have been reported that applied PDES algorithms to the simulation of physical systems, such as an article by Bauer and Page<sup><xref ref-type="bibr" rid="bibr27-0037549712454931">27</xref></sup> (based on a paper by Nutaro<sup><xref ref-type="bibr" rid="bibr28-0037549712454931">28</xref></sup>) concluding that for certain kinds of problems optimistic PDES is not suitable if not accompanied by dynamic load balancing.</p>
<p>Results have also been reported concerning the distributed real-time simulation of systems other than differential equations systems. Adelantado et al.<sup><xref ref-type="bibr" rid="bibr29-0037549712454931">29</xref></sup> present a real-time capable HLA middleware and a formal model for its validation. As we shall see, Adelantado et al.’s technique is related to our work as it also uses a local wall clock to synchronize different federates. On the other hand, he assumes in his formal model that each federate executes periodically with a known worst-case execution time. This assumption does not hold for our types of applications since the execution time of each federate is often not known in advance and may vary during the simulation.</p>
</sec>
<sec id="section10-0037549712454931">
<title>3.2 Parallel and real-time DEVS simulation</title>
<p>Many articles address the problem of simulating DEVS models in parallel using any of the aforementioned approaches. Jafer and Wainer<sup><xref ref-type="bibr" rid="bibr30-0037549712454931">30</xref></sup> present CCD++, a conservative DEVS and Cell-DEVS simulator, and they compare this approach with an optimistic one. Kim et al.<sup><xref ref-type="bibr" rid="bibr31-0037549712454931">31</xref></sup> present a Time Warp-based methodology for distributed DEVS simulation. A mixed approach combining conservative and optimistic strategies that is able to optimally exploit the lookahead is investigated by Praehofer and Reisinger.<sup><xref ref-type="bibr" rid="bibr32-0037549712454931">32</xref></sup> Liu<sup><xref ref-type="bibr" rid="bibr33-0037549712454931">33</xref></sup> explores a light version of the Time Warp mechanism for a DEVS (and Cell-DEVS) simulator on the Cell processor. He introduces the Lightweight Time Warp (LTW) and Multicore Accelerated DEVS System (MADS) as means to overcome Time Warp bottlenecks and to hide the complexity of multicore programming from the general user.</p>
<p>Finally Hong et al.<sup><xref ref-type="bibr" rid="bibr34-0037549712454931">34</xref></sup> proposed an extension to the DEVS formalism, called Real-Time DEVS (RTDEVS), for modeling real-time systems. The main idea of RTDEVS is to fill time advances with executable activities and to specify time bounds required for each activity. They also implemented a DEVS executive (or DEVS simulator) that synchronizes the wall clock with the simulation time. As shall be discussed (Section 5.3), their technique is also related to our work.</p>
</sec>
<sec id="section11-0037549712454931">
<title>3.3 Parallel simulation of QSS approximations of continuous systems</title>
<p>Some previous results have also been reported concerning the parallelization of simulations of DEVS models resulting from the application of QSS algorithms to continuous systems.</p>
<p>Nutaro<sup><xref ref-type="bibr" rid="bibr35-0037549712454931">35</xref></sup> investigated an implementation of the QSS1 algorithm on a parallel DEVS simulator. The author studied the use of the Time Warp approach and concluded that it is unsuited for simulating large continuous systems. By using a (first-order accurate) QSS, he simulated a sod shock tube problem achieving a speedup that increased to a maximum factor of three when using up to six processors, but quickly decreased when using more processors.</p>
<p>Another implementation of QSS on a multi-processor architecture has been investigated by Maggio et al.<sup><xref ref-type="bibr" rid="bibr36-0037549712454931">36</xref></sup> This implementation was realized using CUDA (a GPGPU language). Unfortunately as was already mentioned earlier in this article, graphical processing units (GPUs) offer a limited instruction set, and synchronization tasks are very expensive. Moreover, GPUs follow a single instruction multiple data (SIMD) stream under Flynn’s taxonomy,<sup><xref ref-type="bibr" rid="bibr20-0037549712454931">20</xref></sup> where all processors execute the same code in parallel, which significantly reduces the performance when the code has diverging branches.</p>
<p>These issues limit the classes of applications were GPUs can be efficiently used. In the example analyzed in the cited reference, a speedup of up to a factor of 7.2 has been reported for a system with 64 states using 64 processors.</p>
</sec>
</sec>
<sec id="section12-0037549712454931">
<title>4. Scaled Real-Time Synchronization</title>
<p>In this section, we present the SRTS technique for PDES synchronization.</p>
<sec id="section13-0037549712454931">
<title>4.1 Basic idea</title>
<p>As mentioned already, several different PDES techniques have been proposed in the literature that are based on either conservative, optimistic, or unsynchronized algorithms.</p>
<p>DEVS models resulting of the application of QSS methods to large-scale continuous systems have particular features:</p>
<list id="list2-0037549712454931" list-type="order">
<list-item>
<p>Each event originates at a quantized integrator and is instantaneously transmitted to other quantized integrators through the static functions depending on the corresponding state variable.</p>
</list-item>
<list-item>
<p>The events received by quantized integrators change their future evolution, but they do not provoke instantaneous output events.</p>
</list-item>
<list-item>
<p>Different quantized integrators provoke output events at different times.</p>
</list-item>
<list-item>
<p>Each event represents a section of a piecewise polynomial function.</p>
</list-item>
</list>
<p>On the one hand, the second feature implies that synchronization is usually necessary and that techniques such as NOTIME can rarely be used.</p>
<p>On the other hand, if the synchronization is strict so that it respects the ordering of all events, there will be very few calculations performed in parallel. The reason for this assertion is simple. Each time an integrator provokes an event, the event is transmitted to a few static functions, and through them to a few quantized integrators.</p>
<p>A conservative algorithm will not allow any other LP to advance the simulation time until those computations have been completed. Consequently, almost nothing is gained by parallelization.</p>
<p>An optimistic algorithm will allow the simulation time of other LPs to advance, but as soon as the effect of an event is propagated to them, a rollback mechanism will need to take place. Rollback in a large continuous system is impractical, as this will consume a large amount of memory and time and, furthermore, it is difficult to assess in advance, how much time is going to be used up by the rollback.</p>
<p>To overcome these difficulties, we propose a technique, in which we perform a non-strict synchronization. Recalling that events represent sections of polynomials, errors in the synchronization imply a bounded numerical error in the trajectories transmitted from one process to another.</p>
<p>As with other PDES techniques, SRTS divides the overall model into sub-models representing physical processes, and each of these processes is simulated on a different LP.</p>
<p>In order to avoid the inter-process synchronization overhead, instead of synchronizing the simulation time between all LPs, we synchronize in SRTS the simulation time of each LP with the physical (wall-clock) time.</p>
<p>The only communication between different LPs takes place when events are transmitted from one LP to another. These events are transmitted using RTAI’s mailbox IPC mechanism.<sup><xref ref-type="bibr" rid="bibr14-0037549712454931">14</xref></sup></p>
<p>Each LP synchronizes with the wall clock in the following way. If the next event in the LP is scheduled to occur after <inline-formula id="inline-formula70-0037549712454931">
<mml:math display="inline" id="math75-0037549712454931">
<mml:mrow>
<mml:mi>τ</mml:mi>
</mml:mrow>
</mml:math></inline-formula> units of simulation time, the LP waits until the wall clock advances by <inline-formula id="inline-formula71-0037549712454931">
<mml:math display="inline" id="math76-0037549712454931">
<mml:mrow>
<mml:mi>τ</mml:mi>
<mml:mo stretchy="false">/</mml:mo>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:math></inline-formula> units of physical time. We call <inline-formula id="inline-formula72-0037549712454931">
<mml:math display="inline" id="math77-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:math></inline-formula> the real-time scaling factor. It is a parameter that must be chosen according to the speed, at which the system can be simulated.</p>
<p>Once the waiting period is completed, the LP computes the output event and recomputes the state. When the output event needs to be propagated to sub-models belonging to different LPs, a time-stamped message containing the event is sent to the corresponding mailboxes.</p>
<p>During the waiting period, each LP checks for messages arriving at its mailboxes. Whenever a message arrives, the LP processes the event making use of the time-stamp, recomputes the state, and, if the recomputed next event is scheduled after the current time, it waits again.</p>
<p>In <xref ref-type="fig" rid="fig3-0037549712454931">Figure 3</xref>, a time diagram is shown where two LPs are synchronized using SRTS. Initially both LPs are waiting. At logical simulation time <inline-formula id="inline-formula73-0037549712454931">
<mml:math display="inline" id="math78-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> (scaled wall time <inline-formula id="inline-formula74-0037549712454931">
<mml:math display="inline" id="math79-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">/</mml:mo>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:math></inline-formula>), LP <inline-formula id="inline-formula75-0037549712454931">
<mml:math display="inline" id="math80-0037549712454931">
<mml:mrow>
<mml:mi>A</mml:mi>
</mml:mrow>
</mml:math></inline-formula> computes its next event. This computation takes <inline-formula id="inline-formula76-0037549712454931">
<mml:math display="inline" id="math81-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>Δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> units of wall time. Then LP <inline-formula id="inline-formula77-0037549712454931">
<mml:math display="inline" id="math82-0037549712454931">
<mml:mrow>
<mml:mi>A</mml:mi>
</mml:mrow>
</mml:math></inline-formula> waits until <inline-formula id="inline-formula78-0037549712454931">
<mml:math display="inline" id="math83-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> is reached (at <inline-formula id="inline-formula79-0037549712454931">
<mml:math display="inline" id="math84-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">/</mml:mo>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:math></inline-formula> of scaled wall time) when it emits its output event, i.e. makes an internal transition, and then goes back to wait. This event is propagated to LP <inline-formula id="inline-formula80-0037549712454931">
<mml:math display="inline" id="math85-0037549712454931">
<mml:mrow>
<mml:mi>B</mml:mi>
</mml:mrow>
</mml:math></inline-formula> that computes its external transition processing the received event (consuming <inline-formula id="inline-formula81-0037549712454931">
<mml:math display="inline" id="math86-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>Δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> units of wall time), schedules its next event to occur at <inline-formula id="inline-formula82-0037549712454931">
<mml:math display="inline" id="math87-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>3</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula>, and goes back to wait. This cycle is repeated until the final (logical) time is reached.</p>
<fig id="fig3-0037549712454931" position="float">
<label>Figure 3.</label>
<caption>
<p>Time diagram of the SRTS technique</p>
</caption>
<graphic xlink:href="10.1177_0037549712454931-fig3.tif"/>
</fig>
<p>Implementing this scheme in an abstract simulator, there can be no straggler events; the only problem that could arise concerns simultaneous events in different LPs, but they have no consequences when simulating a QSS approximation. In a real implementation, however, straggler events can appear, since neither the synchronization nor the communication methods are perfect, and also the computation of each event consumes some time.</p>
<p>Yet, as was mentioned before, bounded synchronization errors in the context of QSS simulation provoke in most cases only bounded numerical errors in the trajectories transmitted between LPs.</p>
</sec>
<sec id="section14-0037549712454931">
<title>4.2 SRTS technique</title>
<p>As with other PDES techniques, SRTS requires that the model first be split into as many physical processes as there are different LPs to be used. In this article, we shall not discuss any methodology for efficiently partitioning a model, but many publications can be consulted that address this issue.<sup><xref ref-type="bibr" rid="bibr37-0037549712454931">37</xref><xref ref-type="bibr" rid="bibr38-0037549712454931"/><xref ref-type="bibr" rid="bibr39-0037549712454931"/>–<xref ref-type="bibr" rid="bibr40-0037549712454931">40</xref></sup></p>
<p>We consider that each LP holds a coupled DEVS sub-model, and those sub-models are coupled through input and output ports modeling the interactions between the sub-systems. <xref ref-type="fig" rid="fig4-0037549712454931">Figure 4</xref> shows the coupling structure of a model <inline-formula id="inline-formula83-0037549712454931">
<mml:math display="inline" id="math88-0037549712454931">
<mml:mrow>
<mml:mi>M</mml:mi>
</mml:mrow>
</mml:math></inline-formula> divided into four sub-models simulated on four different LPs.</p>
<fig id="fig4-0037549712454931" position="float">
<label>Figure 4.</label>
<caption>
<p>Coupling structure of SRTS.</p>
</caption>
<graphic xlink:href="10.1177_0037549712454931-fig4.tif"/>
</fig>
<sec id="section15-0037549712454931">
<title>4.2.1 Simulation startup</title>
<p>A sequential DEVS simulation invokes first an initialization routine that sets the initial state of the model, the parameters, etc. Then, the simulation starts.</p>
<p>In SRTS, after each sub-model has been initialized, all simulation threads must start at the same wall-clock time in order to ensure synchronization between different LPs.</p>
<p>To accomplish a simultaneous startup, a barrier is used. All simulation threads are launched and the <inline-formula id="inline-formula84-0037549712454931">
<mml:math display="inline" id="math89-0037549712454931">
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:math></inline-formula>th thread starts in the following way:</p>
<list id="list3-0037549712454931" list-type="order">
<list-item>
<p>Set the shared memory variable <inline-formula id="inline-formula85-0037549712454931">
<mml:math display="inline" id="math90-0037549712454931">
<mml:mrow>
<mml:mi>flag</mml:mi>
<mml:mo stretchy="false">[</mml:mo>
<mml:mi>i</mml:mi>
<mml:mo stretchy="false">]</mml:mo>
<mml:mo>=</mml:mo>
<mml:mi>true</mml:mi>
</mml:mrow>
</mml:math></inline-formula>.</p>
</list-item>
<list-item>
<p>Wait until <inline-formula id="inline-formula86-0037549712454931">
<mml:math display="inline" id="math91-0037549712454931">
<mml:mrow>
<mml:mi>flag</mml:mi>
<mml:mo stretchy="false">[</mml:mo>
<mml:mi>j</mml:mi>
<mml:mo stretchy="false">]</mml:mo>
<mml:mo>=</mml:mo>
<mml:mi>true</mml:mi>
</mml:mrow>
</mml:math></inline-formula> for all <inline-formula id="inline-formula87-0037549712454931">
<mml:math display="inline" id="math92-0037549712454931">
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mo>≠</mml:mo>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:math></inline-formula>.</p>
</list-item>
<list-item>
<p>Measure the initial wall-clock time <inline-formula id="inline-formula88-0037549712454931">
<mml:math display="inline" id="math93-0037549712454931">
<mml:mrow>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">[</mml:mo>
<mml:mi>i</mml:mi>
<mml:mo stretchy="false">]</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula> of the LP.</p>
</list-item>
<list-item>
<p>Start the simulation routine.</p>
</list-item>
</list>
<p>The initial wall-clock time is then used to compute the physical time from the beginning of the simulation, by subtracting it from the measured wall-clock time.</p>
</sec>
<sec id="section16-0037549712454931">
<title>4.2.2 Simulation algorithm</title>
<p>The SRTS simulation algorithm can be described as follows:</p>
<list id="list4-0037549712454931" list-type="order">
<list-item>
<p>Compute the time of next event <inline-formula id="inline-formula89-0037549712454931">
<mml:math display="inline" id="math94-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> of the sub-model.</p>
</list-item>
<list-item>
<p>If <inline-formula id="inline-formula90-0037549712454931">
<mml:math display="inline" id="math95-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>&gt;</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>f</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> (final simulation time), then set <inline-formula id="inline-formula91-0037549712454931">
<mml:math display="inline" id="math96-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>:</mml:mo>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>f</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula>.</p>
</list-item>
<list-item>
<p>Wait until the scaled physical time reaches the simulation time (i.e. <inline-formula id="inline-formula92-0037549712454931">
<mml:math display="inline" id="math97-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>p</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">/</mml:mo>
<mml:mi>r</mml:mi>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula>) or until a message arrives.</p>
</list-item>
<list-item>
<p>If a message arrives, go to step 10.</p>
</list-item>
<list-item>
<p>If <inline-formula id="inline-formula93-0037549712454931">
<mml:math display="inline" id="math98-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>f</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> end of simulation.</p>
</list-item>
<list-item>
<p>Advance the simulation time to <inline-formula id="inline-formula94-0037549712454931">
<mml:math display="inline" id="math99-0037549712454931">
<mml:mrow>
<mml:mi>t</mml:mi>
<mml:mo>:</mml:mo>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula>.</p>
</list-item>
<list-item>
<p>Compute and propagate the output event inside the sub-model (external transition).</p>
</list-item>
<list-item>
<p>If the event propagates to other sub-models, send messages to the corresponding LPs.</p>
</list-item>
<list-item>
<p>Recompute the state of the model causing the event (internal transition) and return to step 1.</p>
</list-item>
<list-item>
<p>Advance the simulation time <inline-formula id="inline-formula95-0037549712454931">
<mml:math display="inline" id="math100-0037549712454931">
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
</mml:math></inline-formula> to the value contained in the message time-stamp.</p>
</list-item>
<list-item>
<p>Propagate the event inside the sub-model (external transition) and return to step 1.</p>
</list-item>
</list>
<p>This algorithm works well provided that every LP sends and receives the messages at the correct time. To send a message at the correct time, a LP must finish the corresponding calculations before that time, i.e. it should not be in overrun. We shall discuss this issue next.</p>
</sec>
<sec id="section17-0037549712454931">
<title>4.2.3 Overrun policy</title>
<p>Overrun situations can be minimized by setting a sufficiently small value for the real-time factor <inline-formula id="inline-formula96-0037549712454931">
<mml:math display="inline" id="math101-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:math></inline-formula>. However, we want <inline-formula id="inline-formula97-0037549712454931">
<mml:math display="inline" id="math102-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:math></inline-formula> to be as big as possible in order to simulate fast. Also, even choosing a very small value for <inline-formula id="inline-formula98-0037549712454931">
<mml:math display="inline" id="math103-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:math></inline-formula>, real operating systems have latency, and overrun situations occur often.</p>
<p>When a LP is in overrun, it continues simulating without checking for input events. The reason is that input events arriving are in the future with respect to the logical time of the LP in overrun. Thus, it is better to process arriving messages only after the overrun situation has finished.</p>
</sec>
<sec id="section18-0037549712454931">
<title>4.2.4 Message handling</title>
<p>As mentioned earlier, events sent to sub-models belonging to different LPs are transmitted through time-stamped messages. It can happen that a sub-model is in overrun or busy computing state transitions while a message is sent to it. If it does not finish its job before a new message arrives, we face two options. We can queue the messages until the LP is able to process them, or we can discard some of the messages.</p>
<p>While in the context of general DEVS models queueing the messages seems the most reasonable choice, we recall that SRTS is intended to simulate continuous systems where events represent changes in trajectories.</p>
<p>If at time <inline-formula id="inline-formula99-0037549712454931">
<mml:math display="inline" id="math104-0037549712454931">
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
</mml:math></inline-formula> the LP finishes its job and realizes that there are two input messages in the same mailbox waiting to be processed, one corresponding to time <inline-formula id="inline-formula100-0037549712454931">
<mml:math display="inline" id="math105-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> and the other to time <inline-formula id="inline-formula101-0037549712454931">
<mml:math display="inline" id="math106-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> with <inline-formula id="inline-formula102-0037549712454931">
<mml:math display="inline" id="math107-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>&lt;</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>&lt;</mml:mo>
<mml:mi>t</mml:mi>
</mml:mrow>
</mml:math></inline-formula>, it serves no purpose to process the older message. It is already late, and the change in the trajectory it represented has been ignored. However, it makes sense to process the change in <inline-formula id="inline-formula103-0037549712454931">
<mml:math display="inline" id="math108-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> that contains more recent information about the trajectory.</p>
<p>For this reason, each sub-model in SRTS uses one mailbox for each input port (i.e. one mailbox per input trajectory), and each mailbox has capacity 1. No matter if the LP was able to read it or not, each message at the mailbox is overridden by the arrival of a new message.</p>
</sec>
</sec>
<sec id="section19-0037549712454931">
<title>4.3 SRTS and numerical errors in QSS methods</title>
<p>The use of SRTS implies that messages sent between LPs may be received at incorrect times. Since LPs do not check for input messages when they are in overrun, they will not receive messages with time-stamps greater than the logical time. In other words, they never receive messages from the future. Synchronization errors always imply that messages arrive late.</p>
<p>Let us suppose that we use SRTS with two processors to simulate a QSS approximation of a high-order system:</p>
<p>
<disp-formula id="disp-formula6-0037549712454931">
<mml:math display="block" id="math109-0037549712454931">
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi mathvariant="bold">x</mml:mi>
</mml:mrow>
<mml:mo>·</mml:mo>
</mml:mover>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="bold">f</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="bold">q</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>,</mml:mo>
<mml:mi mathvariant="bold">v</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula6-0037549712454931" xlink:href="10.1177_0037549712454931-eq6.tif"/>
</disp-formula>
</p>
<p>To this end, we split the system as follows:</p>
<p>
<disp-formula id="disp-formula7-0037549712454931">
<mml:math display="block" id="math110-0037549712454931">
<mml:mrow>
<mml:mtable align="left">
<mml:mtr>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi mathvariant="bold">x</mml:mi>
</mml:mrow>
<mml:mo>·</mml:mo>
</mml:mover>
</mml:mrow>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="bold">f</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>b</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>,</mml:mo>
<mml:mi mathvariant="bold">v</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="center" columnspan="1">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi mathvariant="bold">x</mml:mi>
</mml:mrow>
<mml:mo>·</mml:mo>
</mml:mover>
</mml:mrow>
<mml:mrow>
<mml:mi>b</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="bold">f</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>b</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>b</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>,</mml:mo>
<mml:mi mathvariant="bold">v</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula7-0037549712454931" xlink:href="10.1177_0037549712454931-eq7.tif"/>
</disp-formula>
</p>
<p>where</p>
<p>
<disp-formula id="disp-formula8-0037549712454931">
<mml:math display="block" id="math111-0037549712454931">
<mml:mrow>
<mml:mi mathvariant="bold">x</mml:mi>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">[</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="bold">x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mspace width="0.25em"/>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="bold">x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>b</mml:mi>
</mml:mrow>
</mml:msub>
<mml:msup>
<mml:mrow>
<mml:mo stretchy="false">]</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mtext>T</mml:mtext>
</mml:mrow>
</mml:msup>
<mml:mo>;</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi mathvariant="bold">q</mml:mi>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">[</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mspace width="0.25em"/>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>b</mml:mi>
</mml:mrow>
</mml:msub>
<mml:msup>
<mml:mrow>
<mml:mo stretchy="false">]</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mtext>T</mml:mtext>
</mml:mrow>
</mml:msup>
<mml:mo>;</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi mathvariant="bold">f</mml:mi>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">[</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="bold">f</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mspace width="0.25em"/>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="bold">f</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>b</mml:mi>
</mml:mrow>
</mml:msub>
<mml:msup>
<mml:mrow>
<mml:mo stretchy="false">]</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mtext>T</mml:mtext>
</mml:mrow>
</mml:msup>
<mml:mo>.</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula8-0037549712454931" xlink:href="10.1177_0037549712454931-eq8.tif"/>
</disp-formula>
</p>
<p>The delay introduced by the SRTS mechanism implies that <inline-formula id="inline-formula104-0037549712454931">
<mml:math display="inline" id="math112-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> is received with a delay by the LP that computes <inline-formula id="inline-formula105-0037549712454931">
<mml:math display="inline" id="math113-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="bold">x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>b</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula>, and vice versa. Thus, the QSS approximation takes the form</p>
<p>
<disp-formula id="disp-formula9-0037549712454931">
<mml:math display="block" id="math114-0037549712454931">
<mml:mrow>
<mml:mtable align="left">
<mml:mtr>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi mathvariant="bold">x</mml:mi>
</mml:mrow>
<mml:mo>·</mml:mo>
</mml:mover>
</mml:mrow>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="bold">f</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>b</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>τ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>b</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>,</mml:mo>
<mml:mi mathvariant="bold">v</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="center" columnspan="1">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi mathvariant="bold">x</mml:mi>
</mml:mrow>
<mml:mo>·</mml:mo>
</mml:mover>
</mml:mrow>
<mml:mrow>
<mml:mi>b</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="bold">f</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>b</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>τ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="bold">q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>b</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>,</mml:mo>
<mml:mi mathvariant="bold">v</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula9-0037549712454931" xlink:href="10.1177_0037549712454931-eq9.tif"/>
</disp-formula>
</p>
<p>where <inline-formula id="inline-formula106-0037549712454931">
<mml:math display="inline" id="math115-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>τ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula> and <inline-formula id="inline-formula107-0037549712454931">
<mml:math display="inline" id="math116-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>τ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>b</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula> are the communication delays between the LPs (including latency and overrun effects, and delays affected by the real-time scaling factor).</p>
<p>We shall discuss later some implementation issues that ensure that the delays are bounded. Depending on some features of the original ODE (input-to-state stability properties<sup><xref ref-type="bibr" rid="bibr12-0037549712454931">12</xref></sup>), the presence of bounded delays will only provoke a numerical error that will be superposed to that introduced by the QSS approximation itself. Although this analysis can be easily extended to systems with <inline-formula id="inline-formula108-0037549712454931">
<mml:math display="inline" id="math117-0037549712454931">
<mml:mrow>
<mml:mi>N</mml:mi>
</mml:mrow>
</mml:math></inline-formula> LPs, we do not intend to perform a formal study of stability and numerical error bounds related to the usage of SRTS in this article. It is, however, worth mentioning that the numerical error introduced by SRTS is minimized when latency and overrun are minimized.</p>
</sec>
<sec id="section20-0037549712454931">
<title>4.4 Implementation of SRTS on PowerDEVS -RTAI</title>
<p>We implemented the SRTS algorithm in <italic>PowerDEVS</italic> on a multicore architecture. We chose <italic>PowerDEVS</italic> because it implements the whole family of QSS methods and can run under a RTOS (RTAI). The usage of a RTOS is crucial for SRTS since, as explained before, the delay introduced by the latency must be bounded and minimized.</p>
<p>The PDES version of <italic>PowerDEVS</italic> generates a simulation executable that performs the following steps:</p>
<list id="list5-0037549712454931" list-type="bullet">
<list-item>
<p>It initializes the <italic>PowerDEVS</italic> model (see Section 2.4).</p>
</list-item>
<list-item>
<p>It starts the RTAI real-time system, initializing the real-time clocks and a main real-time task.</p>
</list-item>
<list-item>
<p>For each LP, it creates and sets up as many mailboxes as there are input ports.</p>
</list-item>
<list-item>
<p>It starts one real-time thread per physical process. It then forks these threads with the simulation loop. An index parameter allows each thread to know, which physical processes it corresponds to.</p>
</list-item>
<list-item>
<p>It waits for all real-time threads to finish and then exits while un-allocating all mailboxes and threads.</p>
</list-item>
</list>
<p>We have developed a live-CD from where one can try out (or install) <italic>PowerDEVS</italic> -RTAI on any i386 processor.</p>
<sec id="section21-0037549712454931">
<title>4.4.1 Synchronization and CPU allocation</title>
<p>We implemented all synchronization tasks by a busy-waiting strategy, wasting CPU cycles without releasing the processor until the waiting time ends or a new message arrives. Although this strategy wastes computing power, it offers a more accurate synchronization. A busy-waiting strategy under RTAI does not allow any other task to use the processor that is running the thread. In this way, the latency is minimized. However, with this strategy, each processor can only run one thread, which limits the number of processes that can run in parallel.</p>
<p>RTAI also gives the user the ability to select the processor to run a given thread, i.e. we can allocate one thread per processor. As a consequence, we can divide the model into as many sub-models representing physical processes as there are processors available. On our hardware, we can allocate up to 12 LPs (as hyper-threading technology divides each core processor into two virtual processors).</p>
</sec>
<sec id="section22-0037549712454931">
<title>4.4.2 Latency and overrun</title>
<p>In the absence of latency and neglecting the processing time for messages, transitions, and other calculations, the algorithm described earlier in this section correctly simulates the overall model. However, in a real implementation, we cannot avoid some latency, and sometimes calculations take longer than the physical time allowed, and the simulation then enters an overrun situation.</p>
<p>For example, if the physical processor needs 1 wall-clock second to simulate 1 second of logical time, we cannot use a real-time scaling factor greater than 1. If we do that, the thread will never be able to catch up with the scaled wall-clock time. While this type of overrun situation can be avoided by using a sufficiently small real-time scaling factor, one event generated by a quantized integrator in a QSS method usually triggers many simultaneous events through the static functions. Whereas the first event will be correctly synchronized, the remaining events will be invariably in overrun.</p>
<p>Latency also introduces some error in the synchronization, which affects the communication mechanism. If an event scheduled for <inline-formula id="inline-formula109-0037549712454931">
<mml:math display="inline" id="math118-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> is sent out at time <inline-formula id="inline-formula110-0037549712454931">
<mml:math display="inline" id="math119-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo>
<mml:mi>Δ</mml:mi>
<mml:mi>t</mml:mi>
</mml:mrow>
</mml:math></inline-formula>, the other threads will receive it with a time delay of <inline-formula id="inline-formula111-0037549712454931">
<mml:math display="inline" id="math120-0037549712454931">
<mml:mrow>
<mml:mi>Δ</mml:mi>
<mml:mi>t</mml:mi>
</mml:mrow>
</mml:math></inline-formula>. If during that delay period the other threads computed an event, an error appears that affects the global result.</p>
<p>The hardware platform we use under RTAI exhibits an average latency that ranges from 150 to 500 ns, with a maximum value of around 10 <inline-formula id="inline-formula112-0037549712454931">
<mml:math display="inline" id="math121-0037549712454931">
<mml:mrow>
<mml:mi>μ</mml:mi>
</mml:mrow>
</mml:math></inline-formula>s. These values limit the maximum real-time factor that we may use. For instance, if we use a real-time factor of 1000, a latency of 10 <inline-formula id="inline-formula113-0037549712454931">
<mml:math display="inline" id="math122-0037549712454931">
<mml:mrow>
<mml:mi>μ</mml:mi>
</mml:mrow>
</mml:math></inline-formula>s is translated to 10 ms of maximum simulation time error in events transmitted between different LPs. If that simulation time error provokes an unacceptable simulation error, then we would be enforced to use a smaller real-time factor.</p>
</sec>
</sec>
</sec>
<sec id="section23-0037549712454931">
<title>5. Adaptive real-time scaling</title>
<p>The main drawback of SRTS is that the real-time scaling factor <inline-formula id="inline-formula114-0037549712454931">
<mml:math display="inline" id="math123-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:math></inline-formula> must be chosen by the user. Unless the user performs some previous trial and error experiments, he would be hard-pressed to know a priori which value to assign to the real-time scaling factor. Another problem is that <inline-formula id="inline-formula115-0037549712454931">
<mml:math display="inline" id="math124-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:math></inline-formula> remains constant during the entire simulation. In many cases, the simulation workload changes with time, and it makes sense to adapt <inline-formula id="inline-formula116-0037549712454931">
<mml:math display="inline" id="math125-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:math></inline-formula> according to the actual workload. In this section, we introduce an adaptive version of SRTS, called ASRTS, where the real-time scaling factor is automatically adapted to optimize the efficiency of the simulation.</p>
<sec id="section24-0037549712454931">
<title>5.1 Basic idea</title>
<p>ASRTS attempts to automatically change the real-time scaling factor to minimize the time that processors spend waiting but without provoking overrun situations. In this way, ASRTS improves the overall efficiency by lowering the simulation time.</p>
<p>The idea behind ASRTS is rather simple. It is identical to SRTS, except that it periodically changes the real-time scaling factor. ASRTS cuts the simulation time into sampling periods of equal duration. During each such period, each LP measures the total time that it spends waiting. At the end of the period, one of the threads collects the accumulated waiting times of all LPs and determines their minimum (i.e. the waiting time of the process that had the heaviest workload). Using that information, it computes the ratio between the smallest accumulated waiting time and the length of the sampling period. If the minimum waiting ratio <inline-formula id="inline-formula117-0037549712454931">
<mml:math display="inline" id="math126-0037549712454931">
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
</mml:math></inline-formula> is greater than a prescribed desired waiting ratio <inline-formula id="inline-formula118-0037549712454931">
<mml:math display="inline" id="math127-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> (we use values around 10%), the algorithm is allowed to increase the real-time scaling factor and simulate faster. Otherwise, the algorithm decreases <inline-formula id="inline-formula119-0037549712454931">
<mml:math display="inline" id="math128-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:math></inline-formula>. In this way, ASRTS tries to keep the minimum waiting ratio around the desired waiting ratio <inline-formula id="inline-formula120-0037549712454931">
<mml:math display="inline" id="math129-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula>.</p>
<p>Changes in the real-time scaling factor are done synchronously, that is, all LPs change their value of <inline-formula id="inline-formula121-0037549712454931">
<mml:math display="inline" id="math130-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:math></inline-formula> at the same time (logically and physically) and to the same value, since the scaling factor affects directly the implicit synchronization among the entire group of LPs. Once <inline-formula id="inline-formula122-0037549712454931">
<mml:math display="inline" id="math131-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:math></inline-formula> has been changed, the LPs continue with the simulation using the SRTS algorithm until the next sampling period has ended.</p>
</sec>
<sec id="section25-0037549712454931">
<title>5.2 ASRTS algorithm</title>
<p>As mentioned above, ASRTS is identical to SRTS but includes periodic checkpoints (with a sampling period of <inline-formula id="inline-formula123-0037549712454931">
<mml:math display="inline" id="math132-0037549712454931">
<mml:mrow>
<mml:mi>Δ</mml:mi>
<mml:mi>T</mml:mi>
</mml:mrow>
</mml:math></inline-formula>), when the scaling factor <inline-formula id="inline-formula124-0037549712454931">
<mml:math display="inline" id="math133-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:math></inline-formula> may be changed. During each sampling, ASRTS gathers statistics about the workload and the time spent waiting by each LP. When they reach the next checkpoint, the LPs stop simulating and wait until the new real-time scaling factor has been computed. This computation is done by a thread coordinator (thread <inline-formula id="inline-formula125-0037549712454931">
<mml:math display="inline" id="math134-0037549712454931">
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:math></inline-formula>), while the remaining threads wait in a synchronizing barrier that holds them until the new scaling factor has been computed. At the end of each sampling period, after each LP computed its accumulated waiting time <inline-formula id="inline-formula126-0037549712454931">
<mml:math display="inline" id="math135-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula>, the coordinator computes the new real-time scaling factor as follows:</p>
<list id="list6-0037549712454931" list-type="order">
<list-item>
<p>It finds the minimum waiting ratio</p>
<p>
<disp-formula id="disp-formula10-0037549712454931">
<mml:math display="block" id="math136-0037549712454931">
<mml:mrow>
<mml:mi>w</mml:mi>
<mml:mo>=</mml:mo>
<mml:mfrac>
<mml:mrow>
<mml:munder>
<mml:mrow>
<mml:mo>min</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:munder>
<mml:mo stretchy="false">{</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mi>σ</mml:mi>
<mml:mo stretchy="false">}</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>Δ</mml:mi>
<mml:mi>T</mml:mi>
</mml:mrow>
</mml:mfrac>
<mml:mo>,</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula10-0037549712454931" xlink:href="10.1177_0037549712454931-eq10.tif"/>
</disp-formula>
</p>
<p>where <inline-formula id="inline-formula127-0037549712454931">
<mml:math display="inline" id="math137-0037549712454931">
<mml:mrow>
<mml:mi>σ</mml:mi>
</mml:mrow>
</mml:math></inline-formula> is a value lower but close to 1 to avoid division by zero. In a real implementation not all of the <inline-formula id="inline-formula128-0037549712454931">
<mml:math display="inline" id="math138-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> can be 1 because of overheads.</p>
</list-item>
<list-item>
<p>It computes the optimal real-time scaling factor <inline-formula id="inline-formula129-0037549712454931">
<mml:math display="inline" id="math139-0037549712454931">
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
<mml:mo>^</mml:mo>
</mml:mover>
</mml:mrow>
</mml:math></inline-formula> for the desired waiting ratio <inline-formula id="inline-formula130-0037549712454931">
<mml:math display="inline" id="math140-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> as</p>
<p>
<disp-formula id="disp-formula11-0037549712454931">
<label>(5)</label>
<mml:math display="block" id="math141-0037549712454931">
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
<mml:mo>^</mml:mo>
</mml:mover>
<mml:mo>=</mml:mo>
<mml:mi>r</mml:mi>
<mml:mfrac>
<mml:mrow>
<mml:mn>1</mml:mn>
<mml:mo>−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
<mml:mo>−</mml:mo>
<mml:mi>w</mml:mi>
</mml:mrow>
</mml:mfrac>
<mml:mo>.</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula11-0037549712454931" xlink:href="10.1177_0037549712454931-eq11.tif"/>
</disp-formula>
</p>
</list-item>
<list-item>
<p>If <inline-formula id="inline-formula131-0037549712454931">
<mml:math display="inline" id="math142-0037549712454931">
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
<mml:mo>^</mml:mo>
</mml:mover>
<mml:mo>&lt;</mml:mo>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:math></inline-formula>, it computes the new real-time scaling factor as <inline-formula id="inline-formula132-0037549712454931">
<mml:math display="inline" id="math143-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
<mml:mo>:</mml:mo>
<mml:mo>=</mml:mo>
<mml:mover>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
<mml:mo>^</mml:mo>
</mml:mover>
</mml:mrow>
</mml:math></inline-formula>, slowing down the speed of the simulation.</p>
</list-item>
<list-item>
<p>Otherwise if <inline-formula id="inline-formula133-0037549712454931">
<mml:math display="inline" id="math144-0037549712454931">
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
<mml:mo>^</mml:mo>
</mml:mover>
<mml:mo>≥</mml:mo>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:math></inline-formula>, it computes the new real-time scaling factor as</p>
<p>
<disp-formula id="disp-formula12-0037549712454931">
<label>(6)</label>
<mml:math display="block" id="math145-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
<mml:mo>:</mml:mo>
<mml:mo>=</mml:mo>
<mml:mi>λ</mml:mi>
<mml:mi>r</mml:mi>
<mml:mo>+</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>−</mml:mo>
<mml:mi>λ</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mover>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
<mml:mo>^</mml:mo>
</mml:mover>
<mml:mo>,</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula12-0037549712454931" xlink:href="10.1177_0037549712454931-eq12.tif"/>
</disp-formula>
</p>
<p>which smoothly increases the simulation speed according to the discrete eigenvalue <inline-formula id="inline-formula134-0037549712454931">
<mml:math display="inline" id="math146-0037549712454931">
<mml:mrow>
<mml:mi>λ</mml:mi>
</mml:mrow>
</mml:math></inline-formula>. (Note that <xref ref-type="disp-formula" rid="disp-formula12-0037549712454931">Equation (6)</xref> is a difference equation with <inline-formula id="inline-formula135-0037549712454931">
<mml:math display="inline" id="math147-0037549712454931">
<mml:mrow>
<mml:mi>λ</mml:mi>
</mml:mrow>
</mml:math></inline-formula> as eigenvalue.)</p>
</list-item>
</list>
<p>The ASRTS algorithm has three tuning parameters: the sampling period <inline-formula id="inline-formula136-0037549712454931">
<mml:math display="inline" id="math148-0037549712454931">
<mml:mrow>
<mml:mi>Δ</mml:mi>
<mml:mi>T</mml:mi>
</mml:mrow>
</mml:math></inline-formula>, the desired waiting ratio <inline-formula id="inline-formula137-0037549712454931">
<mml:math display="inline" id="math149-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula>, and the discrete eigenvalue <inline-formula id="inline-formula138-0037549712454931">
<mml:math display="inline" id="math150-0037549712454931">
<mml:mrow>
<mml:mi>λ</mml:mi>
</mml:mrow>
</mml:math></inline-formula>. We discuss the most suitable values of these parameters later in this section. ASRTS makes use of <xref ref-type="disp-formula" rid="disp-formula11-0037549712454931">Equation (5)</xref> that computes the real-time scaling factor <inline-formula id="inline-formula139-0037549712454931">
<mml:math display="inline" id="math151-0037549712454931">
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
<mml:mo>^</mml:mo>
</mml:mover>
</mml:mrow>
</mml:math></inline-formula>, for which a waiting ratio <inline-formula id="inline-formula140-0037549712454931">
<mml:math display="inline" id="math152-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> is obtained. This expression is derived below.</p>
<sec id="section26-0037549712454931">
<title>5.2.1 Optimal real-time scaling factor</title>
<p>As mentioned above, ASRTS attempts to drive the minimum waiting ratio <inline-formula id="inline-formula141-0037549712454931">
<mml:math display="inline" id="math153-0037549712454931">
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
</mml:math></inline-formula> to the desired waiting ratio <inline-formula id="inline-formula142-0037549712454931">
<mml:math display="inline" id="math154-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> by adjusting the real-time scaling factor <inline-formula id="inline-formula143-0037549712454931">
<mml:math display="inline" id="math155-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:math></inline-formula>. Suppose that during a sampling period <inline-formula id="inline-formula144-0037549712454931">
<mml:math display="inline" id="math156-0037549712454931">
<mml:mrow>
<mml:mi>Δ</mml:mi>
<mml:mi>T</mml:mi>
</mml:mrow>
</mml:math></inline-formula> the LP with the maximum workload had a waiting ratio <inline-formula id="inline-formula145-0037549712454931">
<mml:math display="inline" id="math157-0037549712454931">
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
</mml:math></inline-formula> while the real-time scaling factor was <inline-formula id="inline-formula146-0037549712454931">
<mml:math display="inline" id="math158-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:math></inline-formula>. Thus, during that period, it spent computing a total of</p>
<p>
<disp-formula id="disp-formula13-0037549712454931">
<mml:math display="block" id="math159-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mi>Δ</mml:mi>
<mml:mi>T</mml:mi>
<mml:mo>−</mml:mo>
<mml:mi>w</mml:mi>
<mml:mo>·</mml:mo>
<mml:mi>Δ</mml:mi>
<mml:mi>T</mml:mi>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>−</mml:mo>
<mml:mi>w</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>·</mml:mo>
<mml:mi>Δ</mml:mi>
<mml:mi>T</mml:mi>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula13-0037549712454931" xlink:href="10.1177_0037549712454931-eq13.tif"/>
</disp-formula>
</p>
<p>units of time, and the simulation time advanced by <inline-formula id="inline-formula147-0037549712454931">
<mml:math display="inline" id="math160-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
<mml:mo>·</mml:mo>
<mml:mi>Δ</mml:mi>
<mml:mi>T</mml:mi>
</mml:mrow>
</mml:math></inline-formula> units of time.</p>
<p>Thus, in order to advance <inline-formula id="inline-formula148-0037549712454931">
<mml:math display="inline" id="math161-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
<mml:mo>·</mml:mo>
<mml:mi>Δ</mml:mi>
<mml:mi>T</mml:mi>
</mml:mrow>
</mml:math></inline-formula> units of simulation time, the LP needed <inline-formula id="inline-formula149-0037549712454931">
<mml:math display="inline" id="math162-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> units of physical time. We can define the workload as follows</p>
<p>
<disp-formula id="disp-formula14-0037549712454931">
<mml:math display="block" id="math163-0037549712454931">
<mml:mrow>
<mml:mi>W</mml:mi>
<mml:mover>
<mml:mrow>
<mml:mo>=</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>Δ</mml:mi>
</mml:mrow>
</mml:mover>
<mml:mfrac>
<mml:mrow>
<mml:mtext>physical time</mml:mtext>
</mml:mrow>
<mml:mrow>
<mml:mtext>simulation time</mml:mtext>
</mml:mrow>
</mml:mfrac>
<mml:mo>=</mml:mo>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>c</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:mi>r</mml:mi>
<mml:mo>·</mml:mo>
<mml:mi>Δ</mml:mi>
<mml:mi>T</mml:mi>
</mml:mrow>
</mml:mfrac>
<mml:mo>=</mml:mo>
<mml:mfrac>
<mml:mrow>
<mml:mn>1</mml:mn>
<mml:mo>−</mml:mo>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:mfrac>
<mml:mo>.</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula14-0037549712454931" xlink:href="10.1177_0037549712454931-eq14.tif"/>
</disp-formula>
</p>
<p>If we assume that the workload changes slowly, we can expect that, in the next sampling period, it will remain almost unchanged. If we use the appropriate scaling real-time factor <inline-formula id="inline-formula150-0037549712454931">
<mml:math display="inline" id="math164-0037549712454931">
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
<mml:mo>^</mml:mo>
</mml:mover>
</mml:mrow>
</mml:math></inline-formula> in the new sampling period, we shall obtain the desired waiting ratio <inline-formula id="inline-formula151-0037549712454931">
<mml:math display="inline" id="math165-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> and, then,</p>
<p>
<disp-formula id="disp-formula15-0037549712454931">
<mml:math display="block" id="math166-0037549712454931">
<mml:mrow>
<mml:mi>W</mml:mi>
<mml:mo>=</mml:mo>
<mml:mfrac>
<mml:mrow>
<mml:mn>1</mml:mn>
<mml:mo>−</mml:mo>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:mfrac>
<mml:mo>=</mml:mo>
<mml:mfrac>
<mml:mrow>
<mml:mn>1</mml:mn>
<mml:mo>−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
<mml:mo>^</mml:mo>
</mml:mover>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula15-0037549712454931" xlink:href="10.1177_0037549712454931-eq15.tif"/>
</disp-formula>
</p>
<p>from which we obtain <xref ref-type="disp-formula" rid="disp-formula11-0037549712454931">Equation (5)</xref>.</p>
</sec>
<sec id="section27-0037549712454931">
<title>5.2.2 Parameter selection</title>
<p>In order to properly set the values of the method parameters of ASRTS, we may consider the following points.</p>
<list id="list7-0037549712454931" list-type="bullet">
<list-item>
<p>The sampling period <inline-formula id="inline-formula152-0037549712454931">
<mml:math display="inline" id="math167-0037549712454931">
<mml:mrow>
<mml:mi>Δ</mml:mi>
<mml:mi>T</mml:mi>
</mml:mrow>
</mml:math></inline-formula> should be large compared with the physical time required by the re-synchronization routine and also compared with the time necessary to compute several events. In this way, the time spent in the synchronization routine is negligible, and every sampling occurs after several events were computed so that workload statistics make sense. However, <inline-formula id="inline-formula153-0037549712454931">
<mml:math display="inline" id="math168-0037549712454931">
<mml:mrow>
<mml:mi>Δ</mml:mi>
<mml:mi>T</mml:mi>
</mml:mrow>
</mml:math></inline-formula> must be small enough so that the real-time scaling factor is changed several times during the simulation to be able to react to workload changes in a timely fashion.</p>
<p>In the <italic>PowerDEVS</italic> implementation, we used <inline-formula id="inline-formula154-0037549712454931">
<mml:math display="inline" id="math169-0037549712454931">
<mml:mrow>
<mml:mi>Δ</mml:mi>
<mml:mi>T</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>100</mml:mn>
</mml:mrow>
</mml:math></inline-formula> ms. In our platform, the synchronization routine takes from 10 to 100 <inline-formula id="inline-formula155-0037549712454931">
<mml:math display="inline" id="math170-0037549712454931">
<mml:mrow>
<mml:mi>μ</mml:mi>
</mml:mrow>
</mml:math></inline-formula>s, and we are interested in simulations that take at least several seconds (otherwise parallelization might not be necessary). Thus, a period of <inline-formula id="inline-formula156-0037549712454931">
<mml:math display="inline" id="math171-0037549712454931">
<mml:mrow>
<mml:mi>Δ</mml:mi>
<mml:mi>T</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>100</mml:mn>
</mml:mrow>
</mml:math></inline-formula> ms is a reasonable choice for most cases.</p>
</list-item>
<list-item>
<p>The desired waiting ratio <inline-formula id="inline-formula157-0037549712454931">
<mml:math display="inline" id="math172-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> should be greater than 0 and less than 1. We want simulations to run fast, minimizing the waiting time, so a small value of <inline-formula id="inline-formula158-0037549712454931">
<mml:math display="inline" id="math173-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> should be chosen. However, if <inline-formula id="inline-formula159-0037549712454931">
<mml:math display="inline" id="math174-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> is very close to <inline-formula id="inline-formula160-0037549712454931">
<mml:math display="inline" id="math175-0037549712454931">
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:math></inline-formula>, several types of overrun situations can occur that may cause large numerical errors.</p>
<p>In the <italic>PowerDEVS</italic> implementation, we normally use <inline-formula id="inline-formula161-0037549712454931">
<mml:math display="inline" id="math176-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mn>0</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>15</mml:mn>
</mml:mrow>
</mml:math></inline-formula>, which means that the real-time scaling factor is adjusted such that the LP with the heaviest workload wastes approximately 15% of the time in a waiting routine.</p>
</list-item>
<list-item>
<p>The discrete eigenvalue <inline-formula id="inline-formula162-0037549712454931">
<mml:math display="inline" id="math177-0037549712454931">
<mml:mrow>
<mml:mi>λ</mml:mi>
</mml:mrow>
</mml:math></inline-formula> (with <inline-formula id="inline-formula163-0037549712454931">
<mml:math display="inline" id="math178-0037549712454931">
<mml:mrow>
<mml:mn>0</mml:mn>
<mml:mo>&lt;</mml:mo>
<mml:mi>λ</mml:mi>
<mml:mo>&lt;</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:math></inline-formula>) determines how fast the real-time scaling factor <inline-formula id="inline-formula164-0037549712454931">
<mml:math display="inline" id="math179-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:math></inline-formula> increases its value to reach the optimal value <inline-formula id="inline-formula165-0037549712454931">
<mml:math display="inline" id="math180-0037549712454931">
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
<mml:mo>^</mml:mo>
</mml:mover>
</mml:mrow>
</mml:math></inline-formula> according to <xref ref-type="disp-formula" rid="disp-formula12-0037549712454931">Equation (6)</xref>. When <inline-formula id="inline-formula166-0037549712454931">
<mml:math display="inline" id="math181-0037549712454931">
<mml:mrow>
<mml:mi>λ</mml:mi>
</mml:mrow>
</mml:math></inline-formula> is close to 0 the adaptation is fast. When it is close to 1, the adaptation is slow and smooth. In the presence of fast changes in the workload, a slow adaptation prevents the real-time scaling factor from assuming very large values that might cause frequent overruns.</p>
<p>For this reason, we normally choose <inline-formula id="inline-formula167-0037549712454931">
<mml:math display="inline" id="math182-0037549712454931">
<mml:mrow>
<mml:mi>λ</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>0</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>9</mml:mn>
</mml:mrow>
</mml:math></inline-formula>. With this value, the real-time scaling factor reaches 80% of its final value after 10 periods (i.e. 1 second in our implementation).</p>
</list-item>
</list>
</sec>
</sec>
<sec id="section28-0037549712454931">
<title>5.3 Relation with other approaches</title>
<p>The present work can be seen as a combination of two previously formulated ideas of the PDES and DEVS worlds. First, it is related to the RTDEVS executive<sup><xref ref-type="bibr" rid="bibr34-0037549712454931">34</xref></sup> since simulations run synchronized with the wall clock, although in our case, a scaled version of the wall clock. However, the RTDEVS formalism is not used for model description, and regular DEVS is used instead. In our case, the time-consuming activities are, in fact, the computation of the output events and the busy waiting associated with synchronizing them.</p>
<p>SRTS and ASRTS are also related to the NOTIME technique<sup><xref ref-type="bibr" rid="bibr7-0037549712454931">7</xref></sup> since the causality constraint may be violated. Violations of the causality constraint are, however, minimized by the introduction of busy waiting associated with the synchronization of the LPs with the wall clock. These waiting periods act as an artificial load that help balance the workload among LPs, thus they implicitly solve the unbalancing problem of NOTIME.</p>
</sec>
</sec>
<sec id="section29-0037549712454931">
<title>6. Applications and examples</title>
<p>In this section, we present some simulation results. We simulated three separate large-scale systems using QSS methods, first in a sequential way and then using SRTS and ASRTS techniques.</p>
<p>All examples were run using an Intel i7 970, six-core machine with hyper-threading.<sup><xref ref-type="bibr" rid="bibr41-0037549712454931">41</xref></sup> RTAI’s test suite reports 416 ns average and 18,000 ns maximum latencies on this setup. In all examples, each simulation was repeated 10 times, and the results did not exhibit any noticeable change.</p>
<sec id="section30-0037549712454931">
<title>6.1 Power control of an air conditioner population</title>
<p>This example, taken from Perfumo et al.,<sup><xref ref-type="bibr" rid="bibr42-0037549712454931">42</xref></sup> is a model to study the dynamics and control of the power consumption of a population of air conditioners (ACs).</p>
<p>We consider here a large population of ACs used to control the temperature of different rooms. The temperature of the <inline-formula id="inline-formula168-0037549712454931">
<mml:math display="inline" id="math183-0037549712454931">
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:math></inline-formula>th room <inline-formula id="inline-formula169-0037549712454931">
<mml:math display="inline" id="math184-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>θ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula> follows the equation</p>
<p>
<disp-formula id="disp-formula16-0037549712454931">
<label>(7)</label>
<mml:math display="block" id="math185-0037549712454931">
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:mi>d</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>θ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>dt</mml:mi>
</mml:mrow>
</mml:mfrac>
<mml:mo>=</mml:mo>
<mml:mo>−</mml:mo>
<mml:mfrac>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>C</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>·</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>R</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfrac>
<mml:mo stretchy="false">[</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>θ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>θ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>R</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>·</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>·</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">]</mml:mo>
<mml:mo>,</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula16-0037549712454931" xlink:href="10.1177_0037549712454931-eq16.tif"/>
</disp-formula>
</p>
<p>where <inline-formula id="inline-formula170-0037549712454931">
<mml:math display="inline" id="math186-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>R</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> and <inline-formula id="inline-formula171-0037549712454931">
<mml:math display="inline" id="math187-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>C</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> are parameters representing the thermal resistance and capacity of the <inline-formula id="inline-formula172-0037549712454931">
<mml:math display="inline" id="math188-0037549712454931">
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:math></inline-formula>th room, respectively. Here <inline-formula id="inline-formula173-0037549712454931">
<mml:math display="inline" id="math189-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> is the power of the <inline-formula id="inline-formula174-0037549712454931">
<mml:math display="inline" id="math190-0037549712454931">
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:math></inline-formula>th air conditioner when it is in its on state, <inline-formula id="inline-formula175-0037549712454931">
<mml:math display="inline" id="math191-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>θ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>a</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> is the ambient temperature, and <inline-formula id="inline-formula176-0037549712454931">
<mml:math display="inline" id="math192-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula> is a noise term representing thermal disturbances.</p>
<p>Variable <inline-formula id="inline-formula177-0037549712454931">
<mml:math display="inline" id="math193-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula> is the state of the <inline-formula id="inline-formula178-0037549712454931">
<mml:math display="inline" id="math194-0037549712454931">
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:math></inline-formula>th air conditioner, which takes a value of 1 when the unit is in its on state, and 0 otherwise. It follows the hysteretic on–off control law:</p>
<p>
<disp-formula id="disp-formula17-0037549712454931">
<label>(8)</label>
<mml:math display="block" id="math195-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:msup>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>+</mml:mo>
</mml:mrow>
</mml:msup>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mrow>
<mml:mo>{</mml:mo>
<mml:mtable align="left">
<mml:mtr>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mtext>if</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:msub>
<mml:mrow>
<mml:mi>θ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>≤</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>θ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>−</mml:mo>
<mml:mn>0</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>5</mml:mn>
<mml:mspace width="0.25em"/>
<mml:mtext>and</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:msub>
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="left" columnspan="1">
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mtext>if</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:msub>
<mml:mrow>
<mml:mi>θ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>≤</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>θ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>+</mml:mo>
<mml:mn>0</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>5</mml:mn>
<mml:mspace width="0.25em"/>
<mml:mtext>and</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:msub>
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="center" columnspan="1">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mtext>otherwise</mml:mtext>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mrow>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula17-0037549712454931" xlink:href="10.1177_0037549712454931-eq17.tif"/>
</disp-formula>
</p>
<p>where <inline-formula id="inline-formula179-0037549712454931">
<mml:math display="inline" id="math196-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>θ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula> is the reference temperature that is calculated by a global control system.</p>
<p>The power consumption of the entire AC population is computed as</p>
<p>
<disp-formula id="disp-formula18-0037549712454931">
<mml:math display="block" id="math197-0037549712454931">
<mml:mrow>
<mml:mi>P</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>N</mml:mi>
</mml:mrow>
</mml:munderover>
<mml:msub>
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>·</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula18-0037549712454931" xlink:href="10.1177_0037549712454931-eq18.tif"/>
</disp-formula>
</p>
<p>and a global control system regulates it, so it follows a desired power profile <inline-formula id="inline-formula180-0037549712454931">
<mml:math display="inline" id="math198-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula>. In order to accomplish this, a proportional integral (PI) control law is used to compute the reference temperature:</p>
<p>
<disp-formula id="disp-formula19-0037549712454931">
<mml:math display="block" id="math199-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>θ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>K</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>P</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>·</mml:mo>
<mml:mo stretchy="false">[</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>−</mml:mo>
<mml:mi>P</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">]</mml:mo>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>K</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>I</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>·</mml:mo>
<mml:msubsup>
<mml:mrow>
<mml:mo>∫</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi>τ</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>0</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
</mml:msubsup>
<mml:mo stretchy="false">[</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>τ</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>−</mml:mo>
<mml:mi>P</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>τ</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">]</mml:mo>
<mml:mtext>d</mml:mtext>
<mml:mi>τ</mml:mi>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula19-0037549712454931" xlink:href="10.1177_0037549712454931-eq19.tif"/>
</disp-formula>
</p>
<p>where <inline-formula id="inline-formula181-0037549712454931">
<mml:math display="inline" id="math200-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>K</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>P</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> and <inline-formula id="inline-formula182-0037549712454931">
<mml:math display="inline" id="math201-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>K</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>I</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula> are the parameters of the PI controller.</p>
<p>In this example, we chose <inline-formula id="inline-formula183-0037549712454931">
<mml:math display="inline" id="math202-0037549712454931">
<mml:mrow>
<mml:mi>N</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>2400</mml:mn>
</mml:mrow>
</mml:math></inline-formula> air conditioner units, and the set of parameters given in the article.<sup><xref ref-type="bibr" rid="bibr42-0037549712454931">42</xref></sup> Thus, we are dealing with a fairly large hybrid system consisting of a set of <inline-formula id="inline-formula184-0037549712454931">
<mml:math display="inline" id="math203-0037549712454931">
<mml:mrow>
<mml:mn>2401</mml:mn>
</mml:mrow>
</mml:math></inline-formula> differential equations, with 2400 zero-crossing conditions.</p>
<p>We first simulated the system using the QSS3 method with a quantization of <inline-formula id="inline-formula185-0037549712454931">
<mml:math display="inline" id="math204-0037549712454931">
<mml:mrow>
<mml:mi>Δ</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>Q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>rel</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:msup>
<mml:mrow>
<mml:mn>10</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mo>−</mml:mo>
<mml:mn>3</mml:mn>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math></inline-formula> and <inline-formula id="inline-formula186-0037549712454931">
<mml:math display="inline" id="math205-0037549712454931">
<mml:mrow>
<mml:mi>Δ</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>Q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>min</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:msup>
<mml:mrow>
<mml:mn>10</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mo>−</mml:mo>
<mml:mn>6</mml:mn>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math></inline-formula> in a sequential fashion. <xref ref-type="fig" rid="fig5-0037549712454931">Figure 5</xref> plots the average power consumption <inline-formula id="inline-formula187-0037549712454931">
<mml:math display="inline" id="math206-0037549712454931">
<mml:mrow>
<mml:mi>P</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo stretchy="false">/</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>max</mml:mtext>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula>.</p>
<fig id="fig5-0037549712454931" position="float">
<label>Figure 5.</label>
<caption><p>Power consumption in the AC system (sequential simulation result).</p></caption><graphic xlink:href="10.1177_0037549712454931-fig5.tif"/></fig>
<p>The final simulation time was <inline-formula id="inline-formula188-0037549712454931">
<mml:math display="inline" id="math207-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>f</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mn>3000</mml:mn>
</mml:mrow>
</mml:math></inline-formula> s, and the sequential simulation consumed 58 s of physical time.</p>
<p>We then divided the system into 12 sub-systems with 200 ACs in each sub-model. The first sub-model also included the PI controller. We then used the SRTS technique with different real-time scaling factors. We started with a scaling factor of <inline-formula id="inline-formula189-0037549712454931">
<mml:math display="inline" id="math208-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>200</mml:mn>
</mml:mrow>
</mml:math></inline-formula>, which consumes <inline-formula id="inline-formula190-0037549712454931">
<mml:math display="inline" id="math209-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>f</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mi>z</mml:mi>
<mml:mo stretchy="false">/</mml:mo>
<mml:mi>r</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>3000</mml:mn>
<mml:mo stretchy="false">/</mml:mo>
<mml:mn>200</mml:mn>
<mml:mo>=</mml:mo>
<mml:mn>50</mml:mn>
</mml:mrow>
</mml:math></inline-formula> s of physical time. We obtained decent results using scaling factors of up to <inline-formula id="inline-formula191-0037549712454931">
<mml:math display="inline" id="math210-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>950</mml:mn>
</mml:mrow>
</mml:math></inline-formula>, which takes <inline-formula id="inline-formula192-0037549712454931">
<mml:math display="inline" id="math211-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>f</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">/</mml:mo>
<mml:mi>r</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>3000</mml:mn>
<mml:mo stretchy="false">/</mml:mo>
<mml:mn>950</mml:mn>
<mml:mo>=</mml:mo>
<mml:mn>3</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>16</mml:mn>
</mml:mrow>
</mml:math></inline-formula> s. For each scaling factor, we compared the simulation results with those of the sequential simulation and measured the relative root mean square (RMS) error.</p>
<p>Here and in the following examples, the RMS error is computed as follows:</p>
<p>
<disp-formula id="disp-formula20-0037549712454931">
<mml:math display="block" id="math212-0037549712454931">
<mml:mrow>
<mml:mtext>RMS</mml:mtext>
<mml:mo>=</mml:mo>
<mml:mfrac>
<mml:mrow>
<mml:mtext>mean</mml:mtext>
<mml:msup>
<mml:mrow>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>x</mml:mi>
<mml:mo>−</mml:mo>
<mml:mover>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mo>^</mml:mo>
</mml:mover>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msup>
</mml:mrow>
<mml:mrow>
<mml:mtext>mean</mml:mtext>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>x</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula20-0037549712454931" xlink:href="10.1177_0037549712454931-eq20.tif"/>
</disp-formula>
</p>
<p>where <inline-formula id="inline-formula193-0037549712454931">
<mml:math display="inline" id="math213-0037549712454931">
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
</mml:math></inline-formula> is the sequential result and <inline-formula id="inline-formula194-0037549712454931">
<mml:math display="inline" id="math214-0037549712454931">
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mo>^</mml:mo>
</mml:mover>
</mml:mrow>
</mml:math></inline-formula> is the parallel result.</p>
<p>
<xref ref-type="fig" rid="fig6-0037549712454931">Figure 6</xref> plots the measured error in function of the real-time scaling factor.</p>
<fig id="fig6-0037549712454931" position="float">
<label>Figure 6.</label>
<caption><p>SRTS: error versus real-time scaling factor, AC example</p></caption><graphic xlink:href="10.1177_0037549712454931-fig6.tif"/></fig>
<p>In this example, using <inline-formula id="inline-formula195-0037549712454931">
<mml:math display="inline" id="math215-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>950</mml:mn>
</mml:mrow>
</mml:math></inline-formula>, SRTS was more than 18 times faster than the sequential simulation without introducing unacceptably large numerical errors.</p>
<p>However for <inline-formula id="inline-formula196-0037549712454931">
<mml:math display="inline" id="math216-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
<mml:mo>&gt;</mml:mo>
<mml:mn>500</mml:mn>
</mml:mrow>
</mml:math></inline-formula>, we observed that the LPs were most of the time in overrun. Yet, in this case, the overrun situation does not affect the numerical error in major ways.</p>
<p>Then we simulated the system using ASRTS with parameters <inline-formula id="inline-formula197-0037549712454931">
<mml:math display="inline" id="math217-0037549712454931">
<mml:mrow>
<mml:mi>Δ</mml:mi>
<mml:mi>T</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>100</mml:mn>
</mml:mrow>
</mml:math></inline-formula> ms, <inline-formula id="inline-formula198-0037549712454931">
<mml:math display="inline" id="math218-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mn>0</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>15</mml:mn>
</mml:mrow>
</mml:math></inline-formula>, and <inline-formula id="inline-formula199-0037549712454931">
<mml:math display="inline" id="math219-0037549712454931">
<mml:mrow>
<mml:mi>λ</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>0</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>9</mml:mn>
</mml:mrow>
</mml:math></inline-formula>. The ASRTS simulation took 6.6 s, reaching a maximum real-time scaling factor of <inline-formula id="inline-formula200-0037549712454931">
<mml:math display="inline" id="math220-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>480</mml:mn>
</mml:mrow>
</mml:math></inline-formula>. In consequence, ASRTS was almost 9 times faster than the sequential simulation using 12 processors. The real-time scaling factor reached was close to the limit, at which large overruns are observed.</p>
<p>We repeated the simulation with ASRTS for different values of <inline-formula id="inline-formula201-0037549712454931">
<mml:math display="inline" id="math221-0037549712454931">
<mml:mrow>
<mml:mi>λ</mml:mi>
</mml:mrow>
</mml:math></inline-formula>. <xref ref-type="fig" rid="fig7-0037549712454931">Figure 7</xref> shows the way in which ASRTS adapts the scaling real-time factor during each simulation run.</p>
<fig id="fig7-0037549712454931" position="float">
<label>Figure 7.</label>
<caption>
<p>ASRTS: real-time scaling factor adaptation for different values of <inline-formula id="inline-formula202-0037549712454931">
<mml:math display="inline" id="math222-0037549712454931">
<mml:mrow>
<mml:mi>λ</mml:mi>
</mml:mrow>
</mml:math></inline-formula>, AC example</p>
</caption>
<graphic xlink:href="10.1177_0037549712454931-fig7.tif"/>
</fig>
<p>We notice that <inline-formula id="inline-formula203-0037549712454931">
<mml:math display="inline" id="math223-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:math></inline-formula> converges very slowly to the optimal scaling factor for large values of <inline-formula id="inline-formula204-0037549712454931">
<mml:math display="inline" id="math224-0037549712454931">
<mml:mrow>
<mml:mi>λ</mml:mi>
</mml:mrow>
</mml:math></inline-formula> (close to 0.99). Consequently the simulation is slow. On the other hand, <inline-formula id="inline-formula205-0037549712454931">
<mml:math display="inline" id="math225-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:math></inline-formula> converges quickly for small values of <inline-formula id="inline-formula206-0037549712454931">
<mml:math display="inline" id="math226-0037549712454931">
<mml:mrow>
<mml:mi>λ</mml:mi>
</mml:mrow>
</mml:math></inline-formula> (around 0.8) but needs to reduce its value frequently. A reduction in the real-time scaling factor indicates that some LP waited less than the desired waiting ratio <inline-formula id="inline-formula207-0037549712454931">
<mml:math display="inline" id="math227-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math></inline-formula>, which is unsafe as this might indicate overrun. A value of <inline-formula id="inline-formula208-0037549712454931">
<mml:math display="inline" id="math228-0037549712454931">
<mml:mrow>
<mml:mi>λ</mml:mi>
<mml:mo>≈</mml:mo>
<mml:mn>0</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>9</mml:mn>
</mml:mrow>
</mml:math></inline-formula> provides a good compromise between fast adaptation and overrun avoidance.</p>
<p>We then repeated the ASRTS simulation while varying the number of processors, splitting the model into two, four, six, eight and twelve sub-models. <xref ref-type="fig" rid="fig8-0037549712454931">Figure 8</xref> shows the simulation speedup obtained for these cases.</p>
<fig id="fig8-0037549712454931" position="float">
<label>Figure 8.</label>
<caption>
<p>ASRTS: speedup versus number of processors, AC example.</p>
</caption>
<graphic xlink:href="10.1177_0037549712454931-fig8.tif"/>
</fig>
<p>We can observe a close to linear increase in the simulation speedup with the number of processors.</p>
</sec>
<sec id="section31-0037549712454931">
<title>6.2 Logical inverter chain</title>
<p>A logical inverter performs a logical operation on a signal. When the signal assumes a high level, it outputs a low level, and vice versa.</p>
<p>Logical inverters are implemented by electrical circuits. They exhibit a non-ideal response since the rise and fall time of the signal output is limited by physical characteristics, and the correct output level is not immediately obtained, i.e. it is delayed.</p>
<p>An inverter chain is a concatenation of several inverters, where the output of each inverter acts as the input to the next one. Making use of the aforementioned physical limitations, inverter chains can be used to obtain delayed signals. We consider here a chain of <inline-formula id="inline-formula209-0037549712454931">
<mml:math display="inline" id="math229-0037549712454931">
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
</mml:math></inline-formula> inverters according to the model given in Savcenco and Mattheij,<sup><xref ref-type="bibr" rid="bibr43-0037549712454931">43</xref></sup> which is characterized by the following equations:</p>
<p>
<disp-formula id="disp-formula21-0037549712454931">
<label>(9)</label>
<mml:math display="block" id="math230-0037549712454931">
<mml:mrow>
<mml:mrow>
<mml:mo>{</mml:mo>
<mml:mtable align="left">
<mml:mtr>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>ω</mml:mi>
</mml:mrow>
<mml:mo>·</mml:mo>
</mml:mover>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>U</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>op</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo>−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>ω</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>−</mml:mo>
<mml:mi>ϒ</mml:mi>
<mml:mi>g</mml:mi>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>u</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>in</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>ω</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>)</mml:mo>
</mml:mrow>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="center" columnspan="1">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>ω</mml:mi>
</mml:mrow>
<mml:mo>·</mml:mo>
</mml:mover>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>U</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>op</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo>−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>ω</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>−</mml:mo>
<mml:mi>ϒ</mml:mi>
<mml:mi>g</mml:mi>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>ω</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mo>−</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>ω</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="center" columnspan="1">
<mml:mrow>
<mml:mspace width="0.25em"/>
<mml:mi>j</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo>,</mml:mo>
<mml:mn>3</mml:mn>
<mml:mo>,</mml:mo>
<mml:mo>…</mml:mo>
<mml:mo>,</mml:mo>
<mml:mi>m</mml:mi>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mrow>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula21-0037549712454931" xlink:href="10.1177_0037549712454931-eq21.tif"/>
</disp-formula>
</p>
<p>where</p>
<p>
<disp-formula id="disp-formula22-0037549712454931">
<label>(10)</label>
<mml:math display="block" id="math231-0037549712454931">
<mml:mrow>
<mml:mi>g</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>u</mml:mi>
<mml:mo>,</mml:mo>
<mml:mi>v</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:msup>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mo>max</mml:mo>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>u</mml:mi>
<mml:mo>−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>U</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>thres</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mn>0</mml:mn>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msup>
<mml:mo>−</mml:mo>
<mml:msup>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mo>max</mml:mo>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mi>u</mml:mi>
<mml:mo>−</mml:mo>
<mml:mi>v</mml:mi>
<mml:mo>−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>U</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>thres</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mn>0</mml:mn>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msup>
<mml:mo>.</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula22-0037549712454931" xlink:href="10.1177_0037549712454931-eq22.tif"/>
</disp-formula>
</p>
<p>We used the set of parameters given in the article: <inline-formula id="inline-formula210-0037549712454931">
<mml:math display="inline" id="math232-0037549712454931">
<mml:mrow>
<mml:mi>ϒ</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>100</mml:mn>
</mml:mrow>
</mml:math></inline-formula> (which results in a very stiff system), <inline-formula id="inline-formula211-0037549712454931">
<mml:math display="inline" id="math233-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>U</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>thres</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:math></inline-formula>, and <inline-formula id="inline-formula212-0037549712454931">
<mml:math display="inline" id="math234-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>U</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>op</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mn>5</mml:mn>
</mml:mrow>
</mml:math></inline-formula>. The initial conditions are, as in the given reference, <inline-formula id="inline-formula213-0037549712454931">
<mml:math display="inline" id="math235-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>ω</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mn>6</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>247</mml:mn>
<mml:mo>×</mml:mo>
<mml:msup>
<mml:mrow>
<mml:mn>10</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mo>−</mml:mo>
<mml:mn>3</mml:mn>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math></inline-formula> for odd values of <inline-formula id="inline-formula214-0037549712454931">
<mml:math display="inline" id="math236-0037549712454931">
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:math></inline-formula> and <inline-formula id="inline-formula215-0037549712454931">
<mml:math display="inline" id="math237-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>ω</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mn>5</mml:mn>
</mml:mrow>
</mml:math></inline-formula> for even values of <inline-formula id="inline-formula216-0037549712454931">
<mml:math display="inline" id="math238-0037549712454931">
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:math></inline-formula>. The input is a periodic trapezoid signal, with parameters <inline-formula id="inline-formula217-0037549712454931">
<mml:math display="inline" id="math239-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>up</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mn>5</mml:mn>
</mml:mrow>
</mml:math></inline-formula> V, <inline-formula id="inline-formula218-0037549712454931">
<mml:math display="inline" id="math240-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>V</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>low</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:math></inline-formula> V, <inline-formula id="inline-formula219-0037549712454931">
<mml:math display="inline" id="math241-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>down</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mn>10</mml:mn>
</mml:mrow>
</mml:math></inline-formula>, <inline-formula id="inline-formula220-0037549712454931">
<mml:math display="inline" id="math242-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>up</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mn>5</mml:mn>
</mml:mrow>
</mml:math></inline-formula>, <inline-formula id="inline-formula221-0037549712454931">
<mml:math display="inline" id="math243-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>rise</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mn>5</mml:mn>
</mml:mrow>
</mml:math></inline-formula>, and <inline-formula id="inline-formula222-0037549712454931">
<mml:math display="inline" id="math244-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>fall</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:math></inline-formula>.</p>
<p>In this case, we considered a system of <inline-formula id="inline-formula223-0037549712454931">
<mml:math display="inline" id="math245-0037549712454931">
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>504</mml:mn>
</mml:mrow>
</mml:math></inline-formula> inverters, so we have a set of <inline-formula id="inline-formula224-0037549712454931">
<mml:math display="inline" id="math246-0037549712454931">
<mml:mrow>
<mml:mn>504</mml:mn>
</mml:mrow>
</mml:math></inline-formula> differential equations with 1008 discontinuity conditions due to the `<inline-formula id="inline-formula225-0037549712454931">
<mml:math display="inline" id="math247-0037549712454931">
<mml:mrow>
<mml:mtext>max</mml:mtext>
</mml:mrow>
</mml:math></inline-formula>’ functions in <xref ref-type="disp-formula" rid="disp-formula22-0037549712454931">Equation (10)</xref>.</p>
<p>As in the previous example, we first simulated the system in a sequential fashion using the stiff LIQSS3 solver, which has been added to <italic>PowerDEVS</italic> after publication of Migoni and Kofman.<sup><xref ref-type="bibr" rid="bibr11-0037549712454931">11</xref></sup> The resulting voltage at the last inverter is shown in <xref ref-type="fig" rid="fig9-0037549712454931">Figure 9</xref>.</p>
<fig id="fig9-0037549712454931" position="float">
<label>Figure 9.</label>
<caption>
<p>Voltage on the last inverter (sequential simulation result).</p>
</caption>
<graphic xlink:href="10.1177_0037549712454931-fig9.tif"/>
</fig>
<p>We then divided the system into 12 sub-models with 42 inverters each and simulated with SRTS and different real-time scaling factors. This time around, we obtained decent results for up to <inline-formula id="inline-formula226-0037549712454931">
<mml:math display="inline" id="math248-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
<mml:mo>≈</mml:mo>
<mml:mn>35</mml:mn>
</mml:mrow>
</mml:math></inline-formula>.</p>
<p>
<xref ref-type="fig" rid="fig10-0037549712454931">Figure 10</xref> shows the error in function of the real-time scaling factor used. The RMS error looks large because it is mainly due to a small time shift in the output voltage wave. As the wave shows abrupt changes, a small time shift can cause a large RMS error.</p>
<fig id="fig10-0037549712454931" position="float">
<label>Figure 10.</label>
<caption>
<p>SRTS: error versus real-time scaling factor, inverter chain example.</p>
</caption>
<graphic xlink:href="10.1177_0037549712454931-fig10.tif"/>
</fig>
<p>We then applied the ASRTS algorithm and, using 12 processors, the simulation was almost 4.5 times faster than the sequential one.</p>
<p>In this example, the workload is not evenly distributed over the system. As the wave travels, it provokes a high workload at the processor that computes the states that are switching. In contrast, processors that compute states that do not change show a very low workload. Consequently in this case, neither SRTS nor ASRTS can exploit parallelization as efficiently as in the previous example. However, the results are still good.</p>
<p>We then repeated the simulations using ASRTS while varying the number of processors. <xref ref-type="fig" rid="fig11-0037549712454931">Figure 11</xref> shows the speedup obtained in each case.</p>
<fig id="fig11-0037549712454931" position="float">
<label>Figure 11.</label>
<caption>
<p>ASRTS: speedup versus number of processors, inverter chain example.</p>
</caption>
<graphic xlink:href="10.1177_0037549712454931-fig11.tif"/>
</fig>
<p>Once again, the simulation speed increases almost linearly with the number of processors in use.</p>
</sec>
<sec id="section32-0037549712454931">
<title>6.3 LC transmission line</title>
<p>The following system of equations represents a lumped model of a lossless transmission line, formed by 600 sections of LC circuits with parameters <inline-formula id="inline-formula227-0037549712454931">
<mml:math display="inline" id="math249-0037549712454931">
<mml:mrow>
<mml:mi>L</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi>C</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:math></inline-formula>:</p>
<p>
<disp-formula id="disp-formula23-0037549712454931">
<label>(11)</label>
<mml:math display="block" id="math250-0037549712454931">
<mml:mrow>
<mml:mtable align="left">
<mml:mtr>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>ϕ</mml:mi>
</mml:mrow>
<mml:mo>·</mml:mo>
</mml:mover>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>u</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>u</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="left" columnspan="1">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>u</mml:mi>
</mml:mrow>
<mml:mo>·</mml:mo>
</mml:mover>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>ϕ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>ϕ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="left" columnspan="1">
<mml:mrow>
<mml:mo>⋮</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="left" columnspan="1">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>ϕ</mml:mi>
</mml:mrow>
<mml:mo>·</mml:mo>
</mml:mover>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>u</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mo>−</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>u</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="left" columnspan="1">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>u</mml:mi>
</mml:mrow>
<mml:mo>·</mml:mo>
</mml:mover>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>ϕ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>ϕ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mo>+</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="left" columnspan="1">
<mml:mrow>
<mml:mo>⋮</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="left" columnspan="1">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>ϕ</mml:mi>
</mml:mrow>
<mml:mo>·</mml:mo>
</mml:mover>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>u</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
<mml:mo>−</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>u</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="left" columnspan="1">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:mi>u</mml:mi>
</mml:mrow>
<mml:mo>·</mml:mo>
</mml:mover>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>ϕ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>.</mml:mo>
</mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula23-0037549712454931" xlink:href="10.1177_0037549712454931-eq23.tif"/>
</disp-formula>
</p>
<p>We consider a sinusoidal input signal:</p>
<p>
<disp-formula id="disp-formula24-0037549712454931">
<label>(12)</label>
<mml:math display="block" id="math251-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>u</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mi>sin</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>ω</mml:mi>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula24-0037549712454931" xlink:href="10.1177_0037549712454931-eq24.tif"/>
</disp-formula>
</p>
<p>with <inline-formula id="inline-formula228-0037549712454931">
<mml:math display="inline" id="math252-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mn>0</mml:mn>
<mml:mo>.</mml:mo>
<mml:mn>13</mml:mn>
</mml:mrow>
</mml:math></inline-formula> Hz. We also set zero initial conditions <inline-formula id="inline-formula229-0037549712454931">
<mml:math display="inline" id="math253-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>u</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>ϕ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mn>0</mml:mn>
<mml:mo>,</mml:mo>
<mml:mspace width="0.25em"/>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>,</mml:mo><mml:mo>…</mml:mo>
<mml:mo>,</mml:mo>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:math></inline-formula>. This is a marginally stable system, of order 1200 as there are two state variables per segment.</p>
<p>As in the previous examples, we first simulated the system in a sequential fashion using the QSS3 solver. <xref ref-type="fig" rid="fig12-0037549712454931">Figure 12</xref> shows the resulting voltage at the end of the transmission line <inline-formula id="inline-formula230-0037549712454931">
<mml:math display="inline" id="math254-0037549712454931">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>u</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>600</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math></inline-formula>.</p>
<fig id="fig12-0037549712454931" position="float">
<label>Figure 12.</label>
<caption>
<p>Voltage on last LC segment (sequential simulation result).</p>
</caption>
<graphic xlink:href="10.1177_0037549712454931-fig12.tif"/>
</fig>
<p>Then we divided the system into 12 sub-models with 50 segments each and simulated it using SRTS with different values of the real-time scaling factor. <xref ref-type="fig" rid="fig13-0037549712454931">Figure 13</xref> shows the RMS error as a function of the real-time scaling factor.</p>
<fig id="fig13-0037549712454931" position="float">
<label>Figure 13.</label>
<caption>
<p>SRTS: RMS error versus real-time scaling factor, LC line example.</p>
</caption>
<graphic xlink:href="10.1177_0037549712454931-fig13.tif"/>
</fig>
<p>This time around, we obtained good results for <inline-formula id="inline-formula231-0037549712454931">
<mml:math display="inline" id="math255-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
<mml:mo>&lt;</mml:mo>
<mml:mn>400</mml:mn>
</mml:mrow>
</mml:math></inline-formula>. For larger values of the real-time scaling factor, the results soon become numerically unstable. This is not surprising as the addition of delays in marginally stable systems tends to cause instability.</p>
<p>We then simulated the system using ASRTS. With 12 processors, ASRTS managed to accelerate the simulation so it ran more than 5.5 times faster than the sequential simulation.</p>
<p>As in the previous example, the workload is not evenly distributed while the wave travels from the input to the output, which limits the advantages of parallelization.</p>
<p>We then used ASRTS with a varying number of processors, obtaining again an almost linear relationship between the number of processors in use and a speedup as shown in <xref ref-type="fig" rid="fig14-0037549712454931">Figure 14</xref>.</p>
<fig id="fig14-0037549712454931" position="float">
<label>Figure 14.</label>
<caption>
<p>ASRTS: speedup versus number of processors, LC line example.</p>
</caption>
<graphic xlink:href="10.1177_0037549712454931-fig14.tif"/>
</fig>
</sec>
</sec>
<sec id="section33-0037549712454931" sec-type="conclusions">
<title>7. Conclusions and future work</title>
<p>We have introduced SRTS and ASRTS, two new techniques for parallel DEVS of continuous and hybrid systems.</p>
<p>The techniques are based on the idea of synchronizing each LP simulation time with a scaled version of the physical time. As all LPs are synchronized with the physical time, they are indirectly synchronized also against each other. This indirect synchronization permits running each process independently of the remaining processes, avoiding the overhead imposed by inter-process synchronization and coordination.</p>
<p>We implemented these new techniques in <italic>PowerDEVS</italic> using the RTOS RTAI. The RTOS was needed to ensure a precise synchronization, to properly perform the CPU allocation, and for avoiding that the OS (Linux) takes control of the processor while the thread is running.</p>
<p>We tested these new techniques with three application examples and studied their performance and limitations. Using 12 processors, we found a major improvement on the simulation speed. In the examples analyzed, ASRTS simulated from 4.5 to 9 times faster than the sequential simulation. The non-adaptive SRTS is able to simulate even slightly faster but requires prior experimentation to determine the most suitable real-time scaling factor to use.</p>
<p>We have also analyzed the additional numerical error introduced by the techniques. We found that, provided that the real-time scaling factor <inline-formula id="inline-formula232-0037549712454931">
<mml:math display="inline" id="math256-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:math></inline-formula> remains small enough to avoid frequent overruns, the error remains bounded. Moreover, ASRTS adjusts <inline-formula id="inline-formula233-0037549712454931">
<mml:math display="inline" id="math257-0037549712454931">
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:math></inline-formula> in order to avoid overruns so the error introduced is kept small.</p>
<p>This work opens up several lines of research to be considered in the future. A few of them are listed below:</p>
<list id="list8-0037549712454931" list-type="bullet">
<list-item>
<p>In the present work, we manually split the model trying to obtain a well-balanced division. It is interesting to investigate an automatic way to split the model and also to study techniques to dynamically re-balance the workload among the available processors.</p>
<p>We are currently working on an extension to the DEVS formalism, called vectorial DEVS, that will simplify this task.</p>
</list-item>
<list-item>
<p>A fall-back mechanism for overrun situations is also a desirable feature. By implementing a rollback mechanism when a large overrun is found, we could bound the errors introduced.</p>
<p>To this end, we could use the ASRTS checkpoints as rollback stages. In this way, we would only need to save the state of the system at the last checkpoint consuming a bounded and constant amount of memory. Also, we can know exactly how much time we waste at each rollback: <inline-formula id="inline-formula234-0037549712454931">
<mml:math display="inline" id="math258-0037549712454931">
<mml:mrow>
<mml:mi>Δ</mml:mi>
<mml:mi>T</mml:mi>
</mml:mrow>
</mml:math></inline-formula>.</p>
</list-item>
<list-item>
<p>We have developed the implementation on a multicore system running a RTOS. A very important issue is to study how these algorithms scale with a greater number of processors or in a cluster environment. To this end, several problems have to be solved first, such as the clock synchronization among different nodes or CPUs, the communication between nodes (in the current multicore approach it is implemented using shared memory), and the CPU allocation.</p>
</list-item>
<list-item>
<p>We will work on a formal analysis of how the delays in the communication affect the numerical results, following the approach outlined in Section 4.3. The idea is to represent the effects of the delays as bounded perturbations and to analyze the perturbed systems to ensure numerical stability and error boundedness.</p>
</list-item>
<list-item>
<p>We can also investigate new heuristics for the ASRTS. So far, we have only included the time spent waiting as a measurement of how the simulation is doing but including overrun statistics or delay data might result in an improved performance.</p>
</list-item>
<list-item>
<p>Although we developed these new techniques for discrete event simulation of continuous systems, it may be interesting to study their usage also with other numerical integration methods for continuous and hybrid systems (particularly with multi-rate algorithms). Also, it is worth considering the study of SRTS and ASRTS in more general applications of discrete event simulation.</p>
</list-item>
</list>
<p>The complete code of the SRTS and ASRTS implementation in <italic>PowerDEVS</italic> can be found and downloaded from the real-time branch of the SVN.<sup><xref ref-type="bibr" rid="bibr44-0037549712454931">44</xref></sup></p>
</sec>
</body>
<back>
<bio>
<title>Author biographies</title>
<p><bold>Federico Bergero</bold> received a computer science degree in 2008 from the Universidad Nacional de Rosario, Argentina. He is currently a PhD student at the French Argentine International Center for Information and Systems Sciences (CIFASIS) and he holds a teaching position at the Universidad Nacional de Rosario in the department of computer science, FCEIA-UNR, Rosario, Argentina. His research interests include discrete event systems, real time and parallel simulation, signal processing, and audio filtering methods.</p>
<p><bold>Ernesto Kofman</bold> received his BS degree in electronic engineering in 1999 and his PhD degree in automatic control in 2003, all from the National University of Rosario. He is an adjunct professor at the department of control of the National University of Rosario (FCEIA - UNR). He also holds a research position at the National Research Council of Argentina (CIFASIS-CONICET). His research interests include automatic control theory and numerical simulation of hybrid systems. He coauthored a textbook on continuous system simulation in 2006 with Springer, New York.</p>
<p><bold>François Cellier</bold> received his BS degree in electrical engineering in 1972, his MS degree in automatic control in 1973, and his PhD degree in technical sciences in 1979, all from the Swiss Federal Institute of Technology (ETH) Zurich. He worked at the University of Arizona as professor of electrical and computer engineering from 1984 until 2005. He then returned to his home country of Switzerland, where he is now once again working at his alma mater of ETH Zurich. His main scientific interests concern modelling and simulation methodologies, and the design of advanced software systems for simulation, computer-aided modeling, and computer-aided design. He has authored or co-authored more than 250 technical publications, and he has edited several books. He published a textbook on continuous system modeling in 1991 and a second textbook on continuous system simulation in 2006, both with Springer, New York.</p>
</bio>
<ref-list>
<title>References</title>
<ref id="bibr1-0037549712454931">
<label>1.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Cellier</surname><given-names>F</given-names></name>
<name><surname>Kofman</surname><given-names>E</given-names></name>
</person-group>. <source>Continuous System Simulation</source>. <publisher-loc>New York</publisher-loc>: <publisher-name>Springer</publisher-name>, <year>2006</year>.</citation>
</ref>
<ref id="bibr2-0037549712454931">
<label>2.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Zeigler</surname><given-names>B</given-names></name>
<name><surname>Praehofer</surname><given-names>H</given-names></name>
<name><surname>Kim</surname><given-names>TG</given-names></name>
</person-group>. <source>Theory of Modeling and Simulation</source>, <edition>2nd edn.</edition> <publisher-loc>New York</publisher-loc>: <publisher-name>Academic Press</publisher-name>, <year>2000</year>.</citation>
</ref>
<ref id="bibr3-0037549712454931">
<label>3.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Bryant</surname><given-names>RE</given-names></name>
</person-group>. <source>Simulation of Packet Communication Architecture Computer Systems</source>. Technical Report, <publisher-loc>Cambridge, MA</publisher-loc>: <publisher-name>Massachusetts Institute of Technology</publisher-name>, <year>1977</year>.</citation>
</ref>
<ref id="bibr4-0037549712454931">
<label>4.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Chandy</surname><given-names>KM</given-names></name>
<name><surname>Misra</surname><given-names>J</given-names></name>
</person-group>. <article-title>Distributed simulation: a case study in design and verification of distributed programs</article-title>. <source>IEEE Trans Softw Engng</source> <year>1979</year>; <volume>5</volume>: <fpage>440</fpage>–<lpage>452</lpage>.</citation>
</ref>
<ref id="bibr5-0037549712454931">
<label>5.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Misra</surname><given-names>J</given-names></name>
</person-group>. <article-title>Distributed discrete-event simulation</article-title>. <source>ACM Comput Surv</source> <year>1986</year>; <volume>18</volume>: <fpage>39</fpage>–<lpage>65</lpage>.</citation>
</ref>
<ref id="bibr6-0037549712454931">
<label>6.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Jefferson</surname><given-names>DR</given-names></name>
</person-group>. <article-title>Virtual time</article-title>. <source>ACM Trans Program Lang Syst</source> <year>1985</year>; <volume>7</volume>: <fpage>404</fpage>–<lpage>425</lpage>.</citation>
</ref>
<ref id="bibr7-0037549712454931">
<label>7.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Rao</surname><given-names>DM</given-names></name>
<name><surname>Thondugulam</surname><given-names>NV</given-names></name>
<name><surname>Radhakrishnan</surname><given-names>R</given-names></name>
<name><surname>Wilsey</surname><given-names>PA</given-names></name>
</person-group>. <article-title>Unsynchronized parallel discrete event simulation</article-title>. In <conf-name>Simulation Conference Proceedings, 1998, Winter</conf-name>, <volume>vol. 2</volume>, <year>1998</year>, pp. <fpage>1563</fpage>–<lpage>1570</lpage>.</citation>
</ref>
<ref id="bibr8-0037549712454931">
<label>8.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Bergero</surname><given-names>F</given-names></name>
<name><surname>Kofman</surname><given-names>E</given-names></name>
</person-group>. <article-title>PowerDEVS: a tool for hybrid system modeling and real-time simulation</article-title>. <source>Simulation</source> <year>2011</year>; <volume>87</volume>: <fpage>113</fpage>–<lpage>132</lpage>.</citation>
</ref>
<ref id="bibr9-0037549712454931">
<label>9.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Kofman</surname><given-names>E</given-names></name>
</person-group>. <article-title>Quantization-based simulation of differential algebraic equation systems</article-title>. <source>Simulation</source> <year>2003</year>; <volume>79</volume>: <fpage>363</fpage>–<lpage>376</lpage>.</citation>
</ref>
<ref id="bibr10-0037549712454931">
<label>10.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Kofman</surname><given-names>E</given-names></name>
</person-group>. <article-title>Discrete event simulation of hybrid systems</article-title>. <source>SIAM J Sci Comput</source> <year>2004</year>; <volume>25</volume>: <fpage>1771</fpage>–<lpage>1797</lpage>.</citation>
</ref>
<ref id="bibr11-0037549712454931">
<label>11.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Migoni</surname><given-names>G</given-names></name>
<name><surname>Kofman</surname><given-names>E</given-names></name>
</person-group>. <article-title>Linearly implicit discrete event methods for stiff ODEs</article-title>. <source>Latin Am Appl Res</source> <year>2009</year>; <volume>39</volume>: <fpage>245</fpage>–<lpage>254</lpage>.</citation>
</ref>
<ref id="bibr12-0037549712454931">
<label>12.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Castro</surname><given-names>R</given-names></name>
<name><surname>Kofman</surname><given-names>E</given-names></name>
<name><surname>Cellier</surname><given-names>F</given-names></name>
</person-group>. <article-title>Quantization based integration methods for delay differential equations</article-title>. <source>Sim Modell Practice Theory</source> <year>2011</year>; <volume>19</volume>: <fpage>314</fpage>–<lpage>336</lpage>.</citation>
</ref>
<ref id="bibr13-0037549712454931">
<label>13.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Migoni</surname><given-names>G</given-names></name>
<name><surname>Kofman</surname><given-names>E</given-names></name>
<name><surname>Cellier</surname><given-names>F</given-names></name>
</person-group>. <article-title>Quantization-based new integration methods for stiff ordinary differential equations</article-title>. <source>SIMULATION</source> <year>2012</year>; <volume>88</volume>: <fpage>387</fpage>–<lpage>407</lpage>.</citation>
</ref>
<ref id="bibr14-0037549712454931">
<label>14.</label>
<citation citation-type="web">
<collab>DIAPM</collab>. <article-title>Programming Guide 1.0</article-title>, <year>2000</year>. <ext-link ext-link-type="uri" xlink:href="http://www.aero.polimi.it/~rtai/documentation/">http://www.aero.polimi.it/~rtai/documentation/</ext-link>.</citation>
</ref>
<ref id="bibr15-0037549712454931">
<label>15.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Zeigler</surname><given-names>B</given-names></name>
</person-group>. <source>Theory of Modeling and Simulation</source>. <publisher-loc>New York</publisher-loc>: <publisher-name>John Wiley &amp; Sons</publisher-name>, <year>1976</year>.</citation>
</ref>
<ref id="bibr16-0037549712454931">
<label>16.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Kofman</surname><given-names>E</given-names></name>
</person-group>. <article-title>A third order discrete event simulation method for continuous system simulation</article-title>. <source>Latin Am Appl Res</source> <year>2006</year>; <volume>36</volume>: <fpage>101</fpage>–<lpage>108</lpage>.</citation>
</ref>
<ref id="bibr17-0037549712454931">
<label>17.</label>
<citation citation-type="thesis">
<person-group person-group-type="author">
<name><surname>Barabanov</surname><given-names>M</given-names></name>
</person-group>. <source>A Linux-based RealTime Operating System</source>. Master’s thesis, <publisher-name>New Mexico Institute of Mining and Technology</publisher-name>, <publisher-loc>New Mexico</publisher-loc>, <year>1997</year>.</citation>
</ref>
<ref id="bibr18-0037549712454931">
<label>18.</label>
<citation citation-type="web">
<person-group person-group-type="author">
<name><surname>Yaghmour</surname><given-names>K</given-names></name>
</person-group>. <article-title>Adaptive Domain Environment for Operating Systems</article-title>, <year>2002</year>. <ext-link ext-link-type="uri" xlink:href="http://www.opersys.com/adeos/">http://www.opersys.com/adeos/</ext-link>.</citation>
</ref>
<ref id="bibr19-0037549712454931">
<label>19.</label>
<citation citation-type="web">
<person-group person-group-type="author">
<name><surname>Yaghmour</surname><given-names>K</given-names></name>
</person-group>. <article-title>Building a Real-Time Operating Systems on top of the Adaptive Domain Environment for Operating Systems</article-title>, <year>2003</year>. <ext-link ext-link-type="uri" xlink:href="http://www.opersys.com/adeos/">http://www.opersys.com/adeos/</ext-link>.</citation>
</ref>
<ref id="bibr20-0037549712454931">
<label>20.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Flynn</surname><given-names>MJ</given-names></name>
</person-group>. <article-title>Very high-speed computing systems</article-title>. <source>Proceedings of the IEEE</source> <year>1966</year>; <volume>54</volume>: <fpage>1901</fpage>–<lpage>1909</lpage>.</citation>
</ref>
<ref id="bibr21-0037549712454931">
<label>21.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Blake</surname><given-names>G</given-names></name>
<name><surname>Dreslinski</surname><given-names>RG</given-names></name>
<name><surname>Mudge</surname><given-names>T</given-names></name>
</person-group>. <article-title>A survey of multicore processors</article-title>. <source>IEEE Signal Processing Magazine</source> <year>2009</year>; <volume>26</volume>(<issue>6</issue>): <fpage>26</fpage>–<lpage>37</lpage>.</citation>
</ref>
<ref id="bibr22-0037549712454931">
<label>22.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Snir</surname><given-names>M</given-names></name>
<name><surname>Otto</surname><given-names>S</given-names></name>
<name><surname>Huss-Lederman</surname><given-names>S</given-names></name>
<name><surname>Walker</surname><given-names>D</given-names></name>
<name><surname>Dongarra</surname><given-names>J</given-names></name>
</person-group>. <source>MPI-The Complete Reference, Volume 1: The MPI Core</source>, <edition>2nd (revised) edn.</edition> <publisher-loc>Cambridge, MA</publisher-loc>: <publisher-name>MIT Press</publisher-name>, <year>1998</year>.</citation>
</ref>
<ref id="bibr23-0037549712454931">
<label>23.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Randima</surname><given-names>F</given-names></name>
</person-group>. <source>GPU Gems: Programming Techniques, Tips and Tricks for Real-Time Graphics</source>. <publisher-name>Pearson Higher Education</publisher-name>, <year>2004</year>.</citation>
</ref>
<ref id="bibr24-0037549712454931">
<label>24.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Chandy</surname><given-names>KM</given-names></name>
<name><surname>Misra</surname><given-names>J</given-names></name>
</person-group>. <article-title>Asynchronous distributed simulation via a sequence of parallel computations</article-title>. <source>Commun ACM</source> <year>1981</year> <volume>24</volume>: <fpage>198</fpage>–<lpage>206</lpage>.</citation>
</ref>
<ref id="bibr25-0037549712454931">
<label>25.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Liu</surname><given-names>J</given-names></name>
</person-group>. <source>Parallel Discrete-Event Simulation (Wiley Encyclopedia of Operations Research and Management Science)</source>. <publisher-loc>New York</publisher-loc>: <publisher-name>John Wiley &amp; Sons</publisher-name>, <year>2010</year>.</citation>
</ref>
<ref id="bibr26-0037549712454931">
<label>26.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Tang</surname><given-names>Y</given-names></name>
<name><surname>Perumalla</surname><given-names>KS</given-names></name>
<name><surname>Fujimoto</surname><given-names>RM</given-names></name>
<name><surname>Karimabadi</surname><given-names>H</given-names></name>
<name><surname>Driscoll</surname><given-names>J</given-names></name>
<name><surname>Omelchenko</surname><given-names>Y</given-names></name>
</person-group>. <article-title>Optimistic parallel discrete event simulations of physical systems using reverse computation</article-title>. In <conf-name>Workshop on Principles of Advanced and Distributed Simulation, 2005 (PADS 2005)</conf-name>, <year>2005</year>, pp. <fpage>26</fpage>–<lpage>35</lpage>.</citation>
</ref>
<ref id="bibr27-0037549712454931">
<label>27.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Bauer</surname><given-names>DW</given-names></name>
<name><surname>Page</surname><given-names>EH</given-names></name>
</person-group>. <article-title>Optimistic parallel discrete event simulation of the event-based transmission line matrix method</article-title>. In <conf-name>Winter Simulation Conference</conf-name>, <year>2007</year>, pp. <fpage>676</fpage>–<lpage>684</lpage>.</citation>
</ref>
<ref id="bibr28-0037549712454931">
<label>28.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Nutaro</surname><given-names>J</given-names></name>
</person-group>. <article-title>A discrete event method for wave simulation</article-title>. <source>ACM Trans Model Comput Simul</source> <year>2006</year>; <volume>16</volume>: <fpage>174</fpage>–<lpage>195</lpage>.</citation>
</ref>
<ref id="bibr29-0037549712454931">
<label>29.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Adelantado</surname><given-names>M</given-names></name>
<name><surname>Siron</surname><given-names>P</given-names></name>
<name><surname>Chaudron</surname><given-names>J</given-names></name>
</person-group>. <article-title>Towards an HLA run-time infrastructure with hard real-time capabilities</article-title>. In <conf-name>International Simulation Multi-Conference</conf-name>, <conf-loc>Ottawa, Canada</conf-loc>, <year>2010</year>.</citation>
</ref>
<ref id="bibr30-0037549712454931">
<label>30.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Jafer</surname><given-names>S</given-names></name>
<name><surname>Wainer</surname><given-names>G</given-names></name>
</person-group>. <article-title>Conservative DEVS: a novel protocol for parallel conservative simulation of DEVS and cell-DEVS models</article-title>. In <conf-name>Proceedings of the 2010 Spring Simulation Multiconference (SpringSim ’10)</conf-name>, <conf-loc>San Diego, CA</conf-loc>, <conf-date>2010</conf-date>. <publisher-name>Society for Computer Simulation International</publisher-name>, <year>2010</year>, pp. <fpage>140:1</fpage>–<lpage>140:8</lpage>.</citation>
</ref>
<ref id="bibr31-0037549712454931">
<label>31.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Kim</surname><given-names>KH</given-names></name>
<name><surname>Seong</surname><given-names>YR</given-names></name>
<name><surname>Kim</surname><given-names>TG</given-names></name>
<name><surname>Park</surname><given-names>KH</given-names></name>
</person-group>. <article-title>Distributed simulation of hierarchical DEVS models: hierarchical scheduling locally and time warp globally</article-title>. <source>Trans Soc Comput Sim Int</source> <year>1996</year>; <volume>13</volume>: <fpage>135</fpage>–<lpage>154</lpage>.</citation>
</ref>
<ref id="bibr32-0037549712454931">
<label>32.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Praehofer</surname><given-names>H</given-names></name>
<name><surname>Reisinger</surname><given-names>G</given-names></name>
</person-group>. <article-title>Distributed simulation of DEVS-based multiformalism models</article-title>. In <conf-name>Proceedings of the Fifth Annual Conference on AI, Simulation, and Planning in High Autonomy Systems, 1994</conf-name>. Distributed Interactive Simulation Environments, <year>1994</year>, pp. <fpage>150</fpage>–<lpage>156</lpage>.</citation>
</ref>
<ref id="bibr33-0037549712454931">
<label>33.</label>
<citation citation-type="thesis">
<person-group person-group-type="author">
<name><surname>Liu</surname><given-names>Q</given-names></name>
</person-group>. <source>Algorithms for Parallel Simulation of Large-Scale DEVS and Cell-DEVS Models</source>. PhD Thesis, <publisher-name>Systems and Computer Engineering Department, Carleton University</publisher-name>, <year>2010</year>.</citation>
</ref>
<ref id="bibr34-0037549712454931">
<label>34.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Hong</surname><given-names>JS</given-names></name>
<name><surname>Song</surname><given-names>H-S</given-names></name>
<name><surname>Kim</surname><given-names>TG</given-names></name>
<name><surname>Park</surname><given-names>KH</given-names></name>
</person-group>. <article-title>A real-time discrete event system specification formalism for seamless real-time software development</article-title>. <source>Discrete Event Dynamic Syst</source> <year>1997</year>; <volume>7</volume>: <fpage>355</fpage>–<lpage>375</lpage>. DOI: <pub-id pub-id-type="doi">10.1023/A:1008262409521</pub-id>.</citation>
</ref>
<ref id="bibr35-0037549712454931">
<label>35.</label>
<citation citation-type="thesis">
<person-group person-group-type="author">
<name><surname>Nutaro</surname><given-names>J</given-names></name>
</person-group>. <source>Parallel Discrete Event Simulation with Application to Continuous Systems</source>. PhD thesis, <publisher-name>University of Arizona</publisher-name>, <publisher-loc>US</publisher-loc>, <year>2003</year>. AAI3119971.</citation>
</ref>
<ref id="bibr36-0037549712454931">
<label>36.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Maggio</surname><given-names>M</given-names></name>
<name><surname>Stavåker</surname><given-names>K</given-names></name>
<name><surname>Donida</surname><given-names>F</given-names></name>
<name><surname>Casella</surname><given-names>F</given-names></name>
<name><surname>Fritzson</surname><given-names>P</given-names></name>
</person-group>. <article-title>Parallel simulation of equation-based object-oriented models with quantized state systems on a GPU</article-title>. In <conf-name>Proceedings of 7th Modelica Conference</conf-name>, <conf-loc>Como, Italy</conf-loc>, <year>2009</year>.</citation>
</ref>
<ref id="bibr37-0037549712454931">
<label>37.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Deelman</surname><given-names>E</given-names></name>
<name><surname>Szymanski</surname><given-names>BK</given-names></name>
</person-group>. <article-title>Dynamic load balancing in parallel discrete event simulation for spatially explicit problems</article-title>. In <conf-name>Proceedings Twelfth Workshop on Parallel and Distributed Simulation, 1998 (PADS 98)</conf-name>, <year>1998</year>, pp. <fpage>46</fpage>–<lpage>53</lpage>.</citation>
</ref>
<ref id="bibr38-0037549712454931">
<label>38.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Som</surname><given-names>TJ</given-names></name>
<name><surname>Sargent</surname><given-names>RG</given-names></name>
</person-group>. <article-title>Model structure and load balancing in optimistic parallel discrete event simulation</article-title>. In <conf-name>Proceedings of the 14th Workshop on Parallel and Distributed Simulation (PADS ’00)</conf-name>. <publisher-loc>Washington, DC</publisher-loc>: <publisher-name>IEEE Computer Society</publisher-name>, <year>2000</year>, pp. <fpage>147</fpage>–<lpage>154</lpage>.</citation>
</ref>
<ref id="bibr39-0037549712454931">
<label>39.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Glazer</surname><given-names>DW</given-names></name>
<name><surname>Tropper</surname><given-names>C</given-names></name>
</person-group>. <article-title>On process migration and load balancing in Time Warp</article-title>. <source>IEEE Trans Parallel Distributed Syst</source> <year>1993</year>; <volume>4</volume>: <fpage>318</fpage>–<lpage>327</lpage>.</citation>
</ref>
<ref id="bibr40-0037549712454931">
<label>40.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Boukerche</surname><given-names>A</given-names></name>
<name><surname>Tropper</surname><given-names>C</given-names></name>
</person-group>. <article-title>A static partitioning and mapping algorithm for conservative parallel simulations</article-title>. <source>SIGSIM Sim Dig</source> <year>1994</year>; <volume>24</volume>: <fpage>164</fpage>–<lpage>172</lpage>.</citation>
</ref>
<ref id="bibr41-0037549712454931">
<label>41.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Marr</surname><given-names>DT</given-names></name>
<name><surname>Binns</surname><given-names>F</given-names></name>
<name><surname>Hill</surname><given-names>DL</given-names></name>
<name><surname>Hinton</surname><given-names>G</given-names></name>
<name><surname>Koufaty</surname><given-names>DA</given-names></name>
<name><surname>Miller</surname><given-names>JA</given-names></name><etal/>
</person-group>. <source>Hyper-Threading Technology Architecture and Microarchitecture</source>. Technical report, <publisher-name>Intel Technology Journal</publisher-name>, <year>2002</year>.</citation>
</ref>
<ref id="bibr42-0037549712454931">
<label>42.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Perfumo</surname><given-names>C</given-names></name>
<name><surname>Kofman</surname><given-names>E</given-names></name>
<name><surname>Braslavsky</surname><given-names>J</given-names></name>
<name><surname>Ward</surname><given-names>JK</given-names></name>
</person-group>. <article-title>Load management: Model-based control of aggregate power for populations of thermostatically controlled loads</article-title>. <source>Energy Conversion Management</source> <year>2012</year>; <volume>55</volume>: <fpage>36</fpage>–<lpage>48</lpage>.</citation>
</ref>
<ref id="bibr43-0037549712454931">
<label>43.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Savcenco</surname><given-names>V</given-names></name>
<name><surname>Mattheij</surname><given-names>RMM</given-names></name>
</person-group>. <article-title>A multirate time stepping strategy for stiff ordinary differential equations</article-title>. <source>BIT Numer Math</source> <year>2007</year>; <volume>47</volume>: <fpage>137</fpage>–<lpage>155</lpage>.</citation>
</ref>
<ref id="bibr44-0037549712454931">
<label>44.</label>
<citation citation-type="web">
<article-title>PowerDEVS site at SourceForge</article-title>, <ext-link ext-link-type="uri" xlink:href="http://sourceforge.net/projects/powerdevs/">http://sourceforge.net/projects/powerdevs/</ext-link>.</citation>
</ref>
</ref-list>
</back>
</article>