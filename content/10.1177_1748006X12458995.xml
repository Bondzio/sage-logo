<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD Journal Publishing DTD v2.3 20070202//EN" "journalpublishing.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">PIO</journal-id>
<journal-id journal-id-type="hwp">sppio</journal-id>
<journal-title>Proceedings of the Institution of Mechanical Engineers, Part O: Journal of Risk and Reliability</journal-title>
<issn pub-type="ppub">1748-006X</issn>
<issn pub-type="epub">1748-0078</issn>
<publisher>
<publisher-name>SAGE Publications</publisher-name>
<publisher-loc>Sage UK: London, England</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1177/1748006X12458995</article-id>
<article-id pub-id-type="publisher-id">10.1177_1748006X12458995</article-id>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Special Issue Articles</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>On the efficiency of functional decomposition in fault tree analysis</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<name><surname>Matuzas</surname><given-names>Vaidas</given-names></name>
<xref ref-type="aff" rid="aff1-1748006X12458995">1</xref>
</contrib>
<contrib contrib-type="author" corresp="yes">
<name><surname>Contini</surname><given-names>Sergio</given-names></name>
<xref ref-type="aff" rid="aff2-1748006X12458995">2</xref>
</contrib>
</contrib-group>
<aff id="aff1-1748006X12458995"><label>1</label>Lithuanian Energy Institute, Lithuania</aff>
<aff id="aff2-1748006X12458995"><label>2</label>European Commission, Joint Research Centre, Italy</aff>
<author-notes>
<corresp id="corresp1-1748006X12458995">European Commission, Joint Research Centre, Via Enrico Fermi, 2749 - 21027 Ispra (VA), Italy. Emails: <email>sergio.contini@jrc.ec.europa.eu</email></corresp>
</author-notes>
<pub-date pub-type="epub-ppub">
<month>12</month>
<year>2012</year>
</pub-date>
<volume>226</volume>
<issue>6</issue>
<issue-title>Special issue of selected articles from ESREL 2011</issue-title>
<fpage>635</fpage>
<lpage>645</lpage>
<history>
<date date-type="received">
<day>19</day>
<month>3</month>
<year>2012</year>
</date>
<date date-type="accepted">
<day>2</day>
<month>8</month>
<year>2012</year>
</date>
</history>
<permissions>
<copyright-statement>© IMechE 2012</copyright-statement>
<copyright-year>2012</copyright-year>
<copyright-holder content-type="society">Institution of Mechanical Engineers</copyright-holder>
</permissions>
<abstract>
<p>The exact analysis of complex fault trees is a very difficult task. Many methods have been defined to reduce computation time and working memory usage. This problem was recently studied by the authors who proposed an approach based on functional decomposition. A complex fault tree is recursively decomposed into a set of mutually exclusive simpler fault trees until their dimensions are compatible with the available working memory size. Then, the results of the analysis of all generated simpler trees are composed to obtain the results for the original un-decomposed fault tree. Large fault trees, which were impossible to analyse owing to insufficient working memory for the construction of the binary decision diagrams, were successfully analysed by means of the functional decomposition method. Since a fault tree is decomposed with respect to a small subset <bold>S</bold> of the vector <bold>x</bold> of basic events, the efficiency of the decomposition process is highly dependent on this subset. Hence the problem is how to select the events of <bold>S</bold> in order to minimise the fault tree analysis time. This article describes and compares four different algorithms to construct <bold>S</bold> with the aim of identifying the one for which the decomposition procedure requires the least computational time. Owing to the heuristic nature of this problem, all algorithms have been tested on a number of fault trees of different complexity in order to draw useful indications on the relatively ‘best’ one(s). According to the efficiency measures adopted for comparison purposes, the results showed that the best way to proceed is to set <bold>S</bold> as a minimal path set of the fault tree to be decomposed.</p>
</abstract>
<kwd-group>
<kwd>Fault tree analysis</kwd>
<kwd>binary decision diagrams</kwd>
<kwd>functional decomposition</kwd>
<kwd>complex fault trees</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="section1-1748006X12458995" sec-type="intro">
<title>Introduction</title>
<p>The Level-1 Probabilistic Safety Analysis (PSA) of a nuclear power plant is based on event tree (ET) and fault tree (FT) techniques.<sup><xref ref-type="bibr" rid="bibr1-1748006X12458995">1</xref></sup> Results of the analysis are used to take important decisions about design modifications to be implemented to achieve a given safety goal. Hence, the correctness and consistency of the results are fundamental for decision making.</p>
<p>The analysis of event tree accident sequences, by means of the fault tree linking method, generally implies the analysis of very complex fault trees. The concept of fault tree complexity is hard to define since it depends on several factors, e.g. number of repeated events and gates, types of gates, boundary conditions sets, and number of minimal cut sets (MCS).</p>
<p>Generally, owing to the high level of complexity of the problem, techniques able to simplify the fault tree before the analysis takes place are available in literature. Among these, particularly important are: re-writing and modularisation. The former consists of a set of rules aiming at removing superfluous branches without changing the fault tree logic.<sup><xref ref-type="bibr" rid="bibr2-1748006X12458995">2</xref></sup> The latter decomposes the fault tree into a set of independent sub-trees (called modules) that can be independently analysed; generally, the most complex sub-tree is the top module, i.e. the module containing the top event.<sup><xref ref-type="bibr" rid="bibr3-1748006X12458995">3</xref>,<xref ref-type="bibr" rid="bibr4-1748006X12458995">4</xref></sup> These logical methods, which are independent of the applied fault tree analysis approach, are very helpful to reduce the fault tree complexity, but beyond a certain level of complexity they must be complemented by other methods.<sup><xref ref-type="bibr" rid="bibr5-1748006X12458995">5</xref></sup></p>
<p>The classical analytical approach to fault tree analysis is based on the determination of MCS that represent the basis for the subsequent probabilistic analysis.<sup><xref ref-type="bibr" rid="bibr6-1748006X12458995">6</xref>,<xref ref-type="bibr" rid="bibr7-1748006X12458995">7</xref></sup> In practice, owing to the huge number of MCS the analysis of the fault tree is limited to the determination of the subset of significant MCS (SMCS), i.e. those MCS having a probability greater than or equal to a probabilistic threshold value <italic>P</italic><sub>lim</sub> (probabilistic cut-off) and/or order less than or equal to a logical threshold value (logical cut-off) <italic>n</italic><sub>lim</sub>. Since the number of SMCS is generally a small percentage of the number of all MCS, there is the need to estimate the truncation error <italic>P</italic><sub>e</sub>, i.e. the cumulative probability of all neglected MCS. Unfortunately the available methods for the estimation of <italic>P</italic><sub>e</sub><sup><xref ref-type="bibr" rid="bibr8-1748006X12458995">8</xref>,<xref ref-type="bibr" rid="bibr9-1748006X12458995">9</xref>,<xref ref-type="bibr" rid="bibr10-1748006X12458995">10</xref></sup> do not satisfactorily work on large fault trees. Considering that the quantification procedure is based on the (conservative) rare event approximation equations, the sign of the error on the top event probability is unknown. Consequently, different runs with lower <italic>P</italic><sub>lim</sub> values are necessary to verify the achievement of a steady state condition of the top event probability.</p>
<p>A very efficient approach to the analysis of Boolean functions is the binary decision diagram (BDD).<sup><xref ref-type="bibr" rid="bibr11-1748006X12458995">11</xref>,<xref ref-type="bibr" rid="bibr12-1748006X12458995">12</xref>,<xref ref-type="bibr" rid="bibr13-1748006X12458995">13</xref></sup> According to the typical analysis procedure a fault tree is stored in the form of an ordered BDD (OBDD) on which the exact probabilistic quantification can be performed; then, from the OBDD, a zero-suppressed BDD (ZBDD) embedding all MCS or only part of them (SMCS) is derived.<sup><xref ref-type="bibr" rid="bibr14-1748006X12458995">14</xref>,<xref ref-type="bibr" rid="bibr15-1748006X12458995">15</xref></sup></p>
<p>In spite of the superiority of the BDD approach over the MCS approach, it could happen that the construction of the OBDD cannot be completed if the available working memory size is not sufficient. This is owing to the exponential increase of the number of nodes of the BDD with the complexity of the fault tree.</p>
<p>In order to overcome this limitation the truncated ZBDD (TZBDD) construction method was proposed for coherent and non-coherent fault trees.<sup><xref ref-type="bibr" rid="bibr16-1748006X12458995">16</xref>,<xref ref-type="bibr" rid="bibr17-1748006X12458995">17</xref></sup> These methods make use of the cut-off technique during the construction of the ZBDD, thus producing a more compact graph embedding all SMCS. However, as for the MCS approach, the lack of knowledge of the truncation error involves the need to repeat the fault tree analysis with lower threshold values, until the top-event probability shows a constant behaviour.</p>
<p>Independently of the approach used (SMCS or TZBDD), when the ‘constant behaviour’ cannot be achieved there is no way of estimating the truncation error. This problem shows that, despite its usefulness, in certain cases the use of the truncation method may not be sufficient to analyse complex fault trees.</p>
<p>An investigation aiming at comparing the results obtained using the MCS and the BDD approaches on a real PSA showed significant differences.<sup><xref ref-type="bibr" rid="bibr18-1748006X12458995">18</xref></sup> A study outlining how the choice of <italic>P</italic><sub>lim</sub> may impact the decision on safety improvement is provided in Cepin.<sup><xref ref-type="bibr" rid="bibr19-1748006X12458995">19</xref></sup></p>
<p>In spite of the above techniques, which significantly improved the efficiency of fault tree analysers, there are still complex trees that cannot be quantified with the desired accuracy. The main factor that prevents the exact analysis of large fault trees is the insufficient size of working memory to store the BDD or the MCS, depending on the applied analysis approach. Hence, new methods are needed to analyse complex fault trees when both BDD and TZBDD fail.</p>
<p>An interesting method has been proposed by Ibáñez-Llano et al.<sup><xref ref-type="bibr" rid="bibr20-1748006X12458995">20</xref></sup> It is based on the determination of two fault trees, both simpler than the original one, the analysis of which allows the determination of upper and lower bounds of the top event unavailability. The difference between these bounds decreases as the probabilistic cut-off decreases. This method is called ‘hybrid’ because it uses both MCS and BDD approaches.</p>
<p>Another method was proposed by the authors in Contini and Matuzas.<sup><xref ref-type="bibr" rid="bibr21-1748006X12458995">21</xref>,<xref ref-type="bibr" rid="bibr22-1748006X12458995">22</xref></sup> It is based on the concept of functional decomposition. The original complex fault tree is recursively decomposed into a set of <italic>mutually exclusive</italic> simpler fault trees, until their dimensions are compatible with the available computational resources. The number of the fault trees in which the complex tree is decomposed is inversely proportional to the available working memory size. Thanks to the mutual exclusivity of the generated simpler trees the results obtained from their quantification (unavailability, failure frequency, importance measures) can be combined in order to get the results for the original fault tree. Complex fault trees that were impossible to analyse with the methods previously mentioned (MCS, BDD) have been successfully analysed by means of the functional decomposition method.<sup><xref ref-type="bibr" rid="bibr22-1748006X12458995">22</xref></sup></p>
<p>Let <bold>x</bold> = (<italic>x</italic><sub>1</sub>, <italic>x</italic><sub>2</sub>, …, <italic>x</italic><sub>n</sub>) be the vector of binary variables associated with the basic events of a fault tree and <bold>S</bold> = (<italic>x</italic><sub>1</sub>, <italic>x</italic><sub>2</sub>, …, <italic>x</italic><sub>m</sub>) be a subset of <bold>x</bold>, with <inline-formula id="inline-formula1-1748006X12458995"><mml:math display="inline" id="math1-1748006X12458995"><mml:mrow><mml:mi>m</mml:mi><mml:mo>≪</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>. Any Boolean function Φ(<bold>x</bold>) can be decomposed into disjoint terms with respect to <bold>S.</bold> The first implementation<sup><xref ref-type="bibr" rid="bibr21-1748006X12458995">21</xref>,<xref ref-type="bibr" rid="bibr22-1748006X12458995">22</xref></sup> considered <bold>S</bold> as equal to one of the minimal path set (MPS) of the fault tree to be decomposed. An MPS is a set of basic events such that if none of them is verified the top event is not verified. This means that each MCS contains at least one event of the MPS. Hence the complex fault tree can be decomposed into a number of simpler disjoint trees equal to the order of the selected MPS. Consequently a complex tree can be decomposed in as many different ways as the number of its MPSs. Since the efficiency of the decomposition method is sensitive to the composition of the MPS, an important problem is to determine the MPS that minimises the total analysis time.</p>
<p>It is obviously possible to construct <bold>S</bold> in many other ways. In addition to the MPS method, three other methods are considered in this article. The basic events that make up <bold>S</bold> are selected according to:</p>
<list id="list1-1748006X12458995" list-type="bullet">
<list-item><p>the number of times they are repeated in the fault tree (repetition factor (RF) method), also applied in Yevkin<sup><xref ref-type="bibr" rid="bibr23-1748006X12458995">23</xref></sup> in a different way;</p></list-item>
<list-item><p>the degree of reduction of the fault tree complexity when the event is set to 1 and 0 (reduction power (RP) method);</p></list-item>
<list-item><p>The minimum distance from the top event (minimum depth (MD) method), where the distance is measured as the number of gates on the path from the basic event to the top.</p></list-item>
</list>
<p>The aim of this article is to compare these different methods from the point of view of decomposition efficiency.</p>
<p>Owing to the heuristic nature of this problem the four different methods have been tested on a number of fault trees of different complexity in order to try to identify the relatively ‘best’ one(s).</p>
<p>The article is structured as follows. In the next section the decomposition method is briefly summarised. ‘Construction of the decomposition variables’ set <bold>S</bold>’ is devoted to the description of the four methods for the construction of <bold>S</bold>. The experimental results are then provided and finally, conclusions follow.</p>
</sec>
<sec id="section2-1748006X12458995">
<title>The fault tree decomposition method</title>
<p>The fault tree decomposition approach has been proposed by Contini and Matuzas,<sup><xref ref-type="bibr" rid="bibr21-1748006X12458995">21</xref></sup> where two methods have been described; the first concerned the determination of the number of MCS together with upper and lower bounds of the top event unavailability; the second method focused on the probabilistic analysis. A deeper description of the second method is available in Contini and Matuzas,<sup><xref ref-type="bibr" rid="bibr22-1748006X12458995">22</xref></sup> in which the results of its application to complex fault trees are provided. In this section the functional decomposition approach is briefly outlined, before describing and comparing the different methods to define <bold>S</bold>.</p>
<p>Any Boolean function Φ(<bold>x</bold>) can be easily decomposed into disjoint terms with respect to <bold>S</bold> = (<italic>x</italic><sub>1</sub>, <italic>x</italic><sub>2</sub>, …, <italic>x</italic><sub>m</sub>), where <italic>m</italic> ≪ <italic>n</italic>, using a truth table. The truth table contains <italic>2</italic><sup><italic>m</italic></sup> terms. This way of decomposing Φ(<bold>x</bold>) is not of practical interest for values of <italic>m</italic> greater than 10–12, since the high number of terms would require unacceptable computation times.</p>
<p>A more convenient way of decomposing Φ(<bold>x</bold>) is given by the following disjunctive form containing <italic>m+</italic>1 terms</p>
<disp-formula id="disp-formula1-1748006X12458995">
<mml:math display="block" id="math2-1748006X12458995">
<mml:mrow>
<mml:mi>Φ</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="bold">x</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
<mml:mo>,</mml:mo>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
<mml:mo>,</mml:mo>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>…</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mo>,</mml:mo>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mi>Φ</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mo>…</mml:mo>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mo>+</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>,</mml:mo>
</mml:mrow>
</mml:msub>
<mml:mo>…</mml:mo>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
<mml:mo>,</mml:mo>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
<mml:mo>,</mml:mo>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>…</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mo>−</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>,</mml:mo>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mo>,</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mi>Φ</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mo>…</mml:mo>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mo>-</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mo>+</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mo>…</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
<mml:mo>,</mml:mo>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
<mml:mo>,</mml:mo>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>…</mml:mo>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mo>-</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo>,</mml:mo>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mo>-</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>,</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mi>Φ</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mo>…</mml:mo>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mo>-</mml:mo>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
<mml:mo>-</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mo>…</mml:mo>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>+</mml:mo>
<mml:mo>…</mml:mo>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
<mml:mo>,</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mi>Φ</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:mo>…</mml:mo>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula1-1748006X12458995" xlink:href="10.1177_1748006X12458995-eq1.tif"/>
</disp-formula>
<p>where <italic>x</italic><sub><italic>i</italic>,0</sub> (<italic>x</italic><sub><italic>i</italic>,1</sub>) means that the variable is in complemented (normal) form, whereas 0<sub><italic>i</italic></sub> (1<sub><italic>i</italic></sub>) means <italic>x</italic><sub><italic>i</italic></sub>=0 (<italic>x</italic><sub><italic>i</italic></sub>=1).</p>
<p>This logical expression can be synthetically written as</p>
<disp-formula id="disp-formula2-1748006X12458995">
<label>(1)</label>
<mml:math display="block" id="math3-1748006X12458995">
<mml:mrow>
<mml:mi>Φ</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="bold">x</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:munderover>
<mml:mo>⋃</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>0</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mo>[</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>S</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>∩</mml:mo>
<mml:mi>φ</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="bold">y</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>]</mml:mo>
</mml:mrow>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula2-1748006X12458995" xlink:href="10.1177_1748006X12458995-eq2.tif"/>
</disp-formula>
<p>where <italic>S</italic><sub><italic>i</italic></sub>, called <italic>boundary condition</italic> (BC), is a particular assignment (1,0) to some or all elements of <bold>S</bold> = (<italic>x</italic><sub>1</sub>, <italic>x</italic><sub>2</sub>, <italic>…, x</italic><sub><italic>m</italic></sub>); <bold><italic>y</italic></bold><sub><italic>i</italic></sub> is a vector of binary variables <bold>x</bold> taking into account <italic>S</italic><sub><italic>i</italic></sub> assignments, i.e. <inline-formula id="inline-formula2-1748006X12458995"><mml:math display="inline" id="math4-1748006X12458995"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">y</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="inline-formula3-1748006X12458995"><mml:math display="inline" id="math5-1748006X12458995"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
<p>All <italic>S</italic><sub><italic>i</italic></sub> (<italic>i</italic>=0,<italic>m</italic>) are arranged in an [(<italic>m</italic>+1) x <italic>m</italic>] array (called BC-Tab) as shown in <xref ref-type="fig" rid="fig1-1748006X12458995">Figure 1</xref>.</p>
<fig id="fig1-1748006X12458995" position="float">
<label>Figure 1.</label>
<caption>
<p>The main data structure (BC-Tab) used for decomposition.</p>
</caption>
<graphic xlink:href="10.1177_1748006X12458995-fig1.tif"/>
</fig>
<p>Functions <italic>ϕ</italic>, referred to as simpler functions, are the result of the assignment of S<sub><italic>i</italic></sub> to Φ(<bold>x</bold>), i.e. <italic>ϕ</italic>(<bold><italic>y</italic></bold><sub><italic>i</italic></sub>) = Φ(<bold>x</bold>)∣<sub><italic>Si</italic></sub>. The <italic>m+</italic>1 terms in <xref ref-type="disp-formula" rid="disp-formula2-1748006X12458995">equation (1)</xref> are mutually exclusive, since <inline-formula id="inline-formula4-1748006X12458995"><mml:math display="inline" id="math6-1748006X12458995"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mspace width="0.25em"/><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>;</mml:mo><mml:mspace width="0.25em"/><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
<p>The complexity of the simpler functions <italic>ϕ</italic>(<bold><italic>y</italic></bold><sub><italic>i</italic></sub>) generally increases as the index <italic>i</italic> in BC-Tab increases. Consequently it may happen that some <italic>ϕ</italic>(<bold><italic>y</italic></bold><sub><italic>i</italic></sub>) are still too complex to be analysed with the available working memory. Hence they can be decomposed in the same way. This determines the second order decomposition depth (DD). Again, if one of the newly generated simpler trees is still too complex, then it has to be further decomposed, thus increasing the DD value. The decomposition process can be applied recursively until all generated (simpler) functions can be successfully analysed with the available working memory. It follows that the total computation time required to analyse a large fault tree depends on the decomposition depth, which is strongly related to the available working memory size. The decomposition time, which rapidly increases with the DD value, could be limited by applying the probabilistic cut-off.<sup><xref ref-type="bibr" rid="bibr22-1748006X12458995">22</xref></sup> Since the terms in <xref ref-type="disp-formula" rid="disp-formula2-1748006X12458995">equation (1)</xref> are disjoint, the exact unavailability can be obtained by applying <xref ref-type="disp-formula" rid="disp-formula3-1748006X12458995">equation (2)</xref>, provided that <inline-formula id="inline-formula5-1748006X12458995"><mml:math display="inline" id="math7-1748006X12458995"><mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>φ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> are calculated exactly by means of the BDD approach.<sup><xref ref-type="bibr" rid="bibr15-1748006X12458995">15</xref></sup></p>
<disp-formula id="disp-formula3-1748006X12458995">
<label>(2)</label>
<mml:math display="block" id="math8-1748006X12458995">
<mml:mrow>
<mml:mi>P</mml:mi>
<mml:mrow>
<mml:mo>{</mml:mo>
<mml:mi>Φ</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi mathvariant="bold">x</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>}</mml:mo>
</mml:mrow>
<mml:mo>=</mml:mo>
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>0</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>m</mml:mi>
</mml:mrow>
</mml:munderover>
<mml:mi>P</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>S</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mi>P</mml:mi>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mi>φ</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="bold-italic">y</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">)</mml:mo>
<mml:mo>)</mml:mo>
</mml:mrow>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula3-1748006X12458995" xlink:href="10.1177_1748006X12458995-eq3.tif"/>
</disp-formula>
<p>Therefore it can be stated that any fault tree can be decomposed into a set of simpler fault trees. The results of their probabilistic analysis (top event probability and basic events importance measures) are finally re-combined to obtain the results for the original complex fault tree.</p>
<p>To give an idea on the usefulness of functional decomposition, <xref ref-type="table" rid="table1-1748006X12458995">Table 1</xref> shows the results of the analysis of three complex fault trees.<sup><xref ref-type="bibr" rid="bibr14-1748006X12458995">14</xref></sup> It was possible to analyse them only by means of functional decomposition, since any previous attempt to complete the BDD construction with working memory size able to store up to 50 million nodes failed.</p>
<table-wrap id="table1-1748006X12458995" position="float">
<label>Table 1.</label>
<caption>
<p>Results of the analysis of fault trees using the functional decomposition approach.</p>
</caption>
<graphic alternate-form-of="table1-1748006X12458995" xlink:href="10.1177_1748006X12458995-table1.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="char" char="."/>
<col align="char" char="."/>
<col align="char" char="."/>
<col align="char" char="."/>
<col align="char" char="."/>
<col align="char" char="."/>
</colgroup>
<thead>
<tr>
<th align="left">FT name</th>
<th align="left"># Gates</th>
<th align="left"># Events</th>
<th align="left">ITE peak <sup><xref ref-type="table-fn" rid="table-fn1-1748006X12458995">(*)</xref></sup></th>
<th align="left">Probability cut-off</th>
<th align="left">Q<sub>UB</sub></th>
<th align="left">Q<sub>LB</sub></th>
</tr>
</thead>
<tbody>
<tr>
<td>FT3</td>
<td>1041</td>
<td>243</td>
<td>&gt;50 M</td>
<td>1E-07</td>
<td>1.086078E-4</td>
<td>1.085987E-4</td>
</tr>
<tr>
<td>FT4</td>
<td>1122</td>
<td>1709</td>
<td>&gt;50 M</td>
<td>1E-12</td>
<td>1.767798E-4</td>
<td>1.460042E-4</td>
</tr>
<tr>
<td>FT5</td>
<td>650</td>
<td>958</td>
<td>&gt;50 M</td>
<td>1E-07</td>
<td>8.941281E-6</td>
<td>8.939893E-6</td>
</tr>
</tbody>
</table>
<table-wrap-foot>
<fn id="table-fn1-1748006X12458995">
<label>(*)</label>
<p>memory need for BDD analysis without decomposition in millions of ITE records.</p>
</fn>
<fn id="table-fn2-1748006X12458995">
<p>FT: fault tree; ITE: if-then-else record.</p>
</fn>
</table-wrap-foot>
</table-wrap>
</sec>
<sec id="section3-1748006X12458995">
<title>Construction of the decomposition variables’ set S</title>
<p>The efficiency of the decomposition method, i.e. the number and complexity of the generated trees, is highly sensitive to the composition of <bold>S</bold>. In this section, four different methods are described, namely:</p>
<list id="list2-1748006X12458995" list-type="order">
<list-item><p>MPS;</p></list-item>
<list-item><p>repetition factors (RF);</p></list-item>
<list-item><p>reduction power (RP);</p></list-item>
<list-item><p>minimum depth (MD).</p></list-item>
</list>
<sec id="section4-1748006X12458995">
<title>MPS</title>
<p>A MPS is the minimal set of components such that, if they are all working the system is working, i.e. <inline-formula id="inline-formula6-1748006X12458995"><mml:math display="inline" id="math9-1748006X12458995"><mml:mrow><mml:mi>Φ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold">x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>Φ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. Hence this type of decomposition does not consider <italic>S</italic><sub>0</sub>.</p>
<p>Since <bold>S</bold>≡ MPS it follows that a fault tree can be decomposed in as many ways as the number of its MPS. The problem is to identify the particular MPS that minimises the computational resources. The following algorithm has been implemented in order to identify a suitable MPS.</p>
<p>Each basic event is associated with the following weighting function</p>
<disp-formula id="disp-formula4-1748006X12458995">
<label>(3)</label>
<mml:math display="block" id="math10-1748006X12458995">
<mml:mrow>
<mml:mi>f</mml:mi>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mrow>
<mml:mi>f</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>p</mml:mi>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mrow>
<mml:mi>f</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>p</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula4-1748006X12458995" xlink:href="10.1177_1748006X12458995-eq4.tif"/>
</disp-formula>
<p><italic>f</italic><sub><italic>r</italic></sub> is a repetition factor-based function and <italic>f</italic><sub><italic>p</italic></sub> is a failure probability-based function, defined as</p>
<disp-formula id="disp-formula5-1748006X12458995">
<label>(4)</label>
<mml:math display="block" id="math11-1748006X12458995">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>f</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mi>r</mml:mi>
<mml:mo stretchy="false">/</mml:mo>
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>−</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
</mml:munderover>
<mml:msub>
<mml:mrow>
<mml:mi>r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula5-1748006X12458995" xlink:href="10.1177_1748006X12458995-eq5.tif"/>
</disp-formula>
<p>and</p>
<disp-formula id="disp-formula6-1748006X12458995">
<label>(5)</label>
<mml:math display="block" id="math12-1748006X12458995">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>f</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>p</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mi>log</mml:mi>
<mml:mo stretchy="false">(</mml:mo>
<mml:mi>q</mml:mi>
<mml:mo stretchy="false">)</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula6-1748006X12458995" xlink:href="10.1177_1748006X12458995-eq6.tif"/>
</disp-formula>
<p>where <italic>r</italic> is the number of repetitions of the basic event, <italic>q</italic> is its mission time unavailability, and <italic>n</italic> is the number of basic events with repetition factor greater than 1.</p>
<p>Weights <italic>w</italic><sub><italic>r</italic></sub> and <italic>w</italic><sub><italic>p</italic></sub> take values in the interval [0, 1], such that <inline-formula id="inline-formula7-1748006X12458995"><mml:math display="inline" id="math13-1748006X12458995"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>.</p>
<p>A single MPS can be determined by visiting the fault tree twice: first, in a bottom-up mode and then in a top-down mode. Depending on the weights used different path sets can be determined.</p>
<sec id="section5-1748006X12458995">
<title>Bottom-up phase</title>
<list id="list3-1748006X12458995" list-type="order">
<list-item><p>The function <italic>f</italic> is calculated for each basic event.</p></list-item>
<list-item><p>By visiting the fault tree in bottom-up mode the function <italic>f</italic> is associated to each gate using the following rules</p></list-item>
</list>
<disp-formula id="disp-formula7-1748006X12458995">
<label>(6)</label>
<mml:math display="block" id="math14-1748006X12458995">
<mml:mrow>
<mml:mo>−</mml:mo>
<mml:mtext>AND</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>gate</mml:mtext>
<mml:mo>:</mml:mo>
<mml:mspace width="0.25em"/>
<mml:msub>
<mml:mrow>
<mml:mi>f</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>AND</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:munder>
<mml:mo>max</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:munder>
<mml:mo stretchy="false">{</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>f</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">}</mml:mo>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula7-1748006X12458995" xlink:href="10.1177_1748006X12458995-eq7.tif"/>
</disp-formula>
<disp-formula id="disp-formula8-1748006X12458995">
<label>(7)</label>
<mml:math display="block" id="math15-1748006X12458995">
<mml:mrow>
<mml:mo>−</mml:mo>
<mml:mtext>OR</mml:mtext>
<mml:mspace width="0.25em"/>
<mml:mtext>gate</mml:mtext>
<mml:mo>:</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>f</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>OR</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:munder>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:munder>
<mml:msub>
<mml:mrow>
<mml:mi>f</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula8-1748006X12458995" xlink:href="10.1177_1748006X12458995-eq8.tif"/>
</disp-formula>
<p>where <italic>j</italic> is index of descendants.</p>
<list id="list4-1748006X12458995" list-type="order">
<list-item><p>For each gate its descendants are ordered according to decreasing <italic>f</italic> values, with priority given to basic events over gates.</p></list-item>
</list>
</sec>
<sec id="section6-1748006X12458995">
<title>Top-down phase</title>
<p>The tree is visited in a top-down mode. At each AND gate the descendant with the highest <italic>f</italic> value is selected; if this is a basic event then it becomes an element of the path set. At each OR gate all descendants are considered; basic events become elements of the path set. After the path set is found, a simple algorithm is applied to minimise it.</p>
<p>The ‘best’ MPS should be the one having the lowest order and the largest difference between the lowest and the highest probability of basic events. Indeed, the low MPS order reduces the number of simpler fault trees to be generated; the low probability of basic events increases the number of simpler fault trees with low probabilistic importance.<sup><xref ref-type="bibr" rid="bibr22-1748006X12458995">22</xref></sup></p>
<p>It should be outlined that not only the selection of the MPS plays an important role, but also the ordering criterion of the MPS elements has an important effect on the efficiency of decomposition.</p>
</sec>
<sec id="section7-1748006X12458995">
<title>Repetition factors</title>
<p>The repetition factors (RF) method is based on the number of repetitions of basic events in the fault tree. A list of basic events is generated and each event is associated with the number of repetitions; then events are sorted by decreasing repetition factors. The set <bold>S</bold> is established by taking the first <italic>m</italic> events from the sorted list, where <italic>m</italic> equals to the user-defined percentage of the total number of events. Differently from the MPS method, in this case S<sub>0</sub> must be considered since <inline-formula id="inline-formula8-1748006X12458995"><mml:math display="inline" id="math16-1748006X12458995"><mml:mrow><mml:mi>Φ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold">x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>Φ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>.</p>
<p>According to the BC-Tab shown in <xref ref-type="fig" rid="fig1-1748006X12458995">Figure 1</xref> events are organised as follows. The event with the lowest repetition factor is placed in the second row; then the corresponding simpler function is given by <inline-formula id="inline-formula9-1748006X12458995"><mml:math display="inline" id="math17-1748006X12458995"><mml:mrow><mml:mi>φ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">y</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mspace width="0.25em"/><mml:mi>Φ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, whereas the event with the highest repetition factor is placed in the last row in which the corresponding simpler function is given by <inline-formula id="inline-formula10-1748006X12458995"><mml:math display="inline" id="math18-1748006X12458995"><mml:mrow><mml:mi>φ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">y</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mspace width="0.25em"/><mml:mi>Φ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. If a generated function is still too complex, it can be further decomposed in the same way.</p>
</sec>
</sec>
<sec id="section8-1748006X12458995">
<title>Reduction power</title>
<p>The reduction power (RP) method considers the degree of fault tree reduction when a single event (e.g. <italic>x</italic>) is set to one of its logical states (failed or working). The measure of the reduction is expressed as the number of basic event occurrences removed from the fault tree when the event is set to <italic>x</italic> = 1 and <italic>x</italic> = 0. Also in this case <italic>S</italic><sub>0</sub> must be considered.</p>
<p>The determination of the reduction power index for each basic event is done in two steps.</p>
<list id="list5-1748006X12458995" list-type="order">
<list-item><p>The fault tree is visited in a bottom-up mode. Each gate is associated with the reduction index (<italic>RI</italic>), representing the total number of event occurrences in the sub-tree having the gate as top, i.e. reduction index includes events directly descending from the gate as well as events indirectly descending from it (descending through lower level gates). Hence <italic>RI</italic> is the total number of event occurrences removed from the fault tree if the selected gate is removed.</p></list-item>
<list-item><p>Each event is then processed and two intermediate indexes <italic>RP</italic><sup>0</sup> and <italic>RP</italic><sup><xref ref-type="bibr" rid="bibr1-1748006X12458995">1</xref></sup> (number of removed event occurrences when the event under consideration is respectively set to 0 and 1) for the <italic>i</italic>th event are calculated as follows</p></list-item>
</list>
<disp-formula id="disp-formula9-1748006X12458995">
<label>(8)</label>
<mml:math display="block" id="math19-1748006X12458995">
<mml:mrow>
<mml:mtable>
<mml:mtr>
<mml:mtd>
<mml:msubsup>
<mml:mrow>
<mml:mi>RP</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msubsup>
<mml:mo>=</mml:mo>
<mml:msubsup>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>AND</mml:mtext>
</mml:mrow>
</mml:msubsup>
<mml:mo>+</mml:mo>
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:msubsup>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>OR</mml:mtext>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:munderover>
<mml:mi>R</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>I</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>;</mml:mo>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:msubsup>
<mml:mrow>
<mml:mi>RP</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msubsup>
<mml:mo>=</mml:mo>
<mml:msubsup>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>OR</mml:mtext>
</mml:mrow>
</mml:msubsup>
<mml:mo>+</mml:mo>
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:msubsup>
<mml:mrow>
<mml:mi>n</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>AND</mml:mtext>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:munderover>
<mml:mi>R</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>I</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>;</mml:mo>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula9-1748006X12458995" xlink:href="10.1177_1748006X12458995-eq9.tif"/>
</disp-formula>
<p>where <italic>n</italic><sup>AND</sup> and <italic>n</italic><sup>OR</sup> are the number of AND and OR gates from which the <italic>i</italic>th event directly descends. Finally, the total reduction power index <italic>RP</italic> for the event is determined as <italic>RP</italic> = <italic>RP</italic><sup>0</sup> + <italic>RP</italic><sup><xref ref-type="bibr" rid="bibr1-1748006X12458995">1</xref></sup>. A list of events ranked by decreasing <italic>RP</italic> values is generated.</p>
<p>The decomposition set <bold>S</bold> is determined by taking the first <italic>m</italic> events from the list, corresponding to the user-defined percentage value.</p>
<p>As shown in <xref ref-type="fig" rid="fig1-1748006X12458995">Figure 1</xref>, in the first two rows all elements of <bold>S</bold> are assigned a value (0, 1), whereas in all of the others (<italic>i</italic> &gt;1) only some elements have a value; in particular, the last row consists of only one element. This means that the last <italic>ϕ</italic>(<bold><italic>y</italic></bold><sub><italic>m</italic></sub>) potentially has the lowest fault tree reduction effect. In order to maximise the fault tree reduction potential, high priority should be given to reductions produced by setting basic events to 1, i.e. to events descending from OR gates. In order to account for the reduction derived from setting the event to 0, <italic>RP</italic> is determined by introducing weighting factors as</p>
<disp-formula id="disp-formula10-1748006X12458995">
<label>(9)</label>
<mml:math display="block" id="math20-1748006X12458995">
<mml:mrow>
<mml:mi>RP</mml:mi>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>AND</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mi>R</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>w</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mtext>OR</mml:mtext>
</mml:mrow>
</mml:msub>
<mml:mi>R</mml:mi>
<mml:msub>
<mml:mrow>
<mml:mi>P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula10-1748006X12458995" xlink:href="10.1177_1748006X12458995-eq10.tif"/>
</disp-formula>
<p>where <italic>w</italic><sub>AND</sub> and <italic>w</italic><sub>OR</sub> are weights for AND and OR gates.</p>
<p>In this way different reduction index values can be calculated and the effects compared.</p>
</sec>
<sec id="section9-1748006X12458995">
<title>Minimum depth</title>
<p>The minimum depth (MD) method selects the elements of <bold>S</bold> according to the minimum distance of basic events from the top gate. The distance is measured as the number of operators (AND, OR) on paths from the event occurrence to the top gate.</p>
<p>The fault tree is visited in top-down mode. The MD rank assignment starts from the top gate where MD = 0. All descendants from a generic gate, including descending gates, get an MD rank – if it is not yet assigned – equal to their parent gate MD rank increased by one. The MD rank for other events is determined in the same way by visiting the fault tree in a top-down mode. After the fault tree is processed, each event has a MD rank equal to the minimal number of logical operators from the event to the top gate.</p>
<p>The main difference between the MPS method and all the others is the cardinality of <bold>S</bold>. With the MPS method the cardinality is equal to the order of the MPS (which depends on the fault tree structure), whereas in all other methods it depends on the percentage of all events defined by the user.</p>
</sec>
</sec>
<sec id="section10-1748006X12458995">
<title>Experimental results</title>
<p>The above presented methods for the determination of <bold>S</bold> were implemented and tested on the fault trees of different complexity listed in <xref ref-type="table" rid="table2-1748006X12458995">Table 2</xref>. Tests were performed on a computer with 3.33 GHz and 48 GB of RAM. In order to allow comparison of the working memory usage requested by the different decomposition methods and to avoid recursive decomposition (i.e. DD &gt;1) the maximal working memory size was set to 300 million ITE (if-then-else) nodes (300M).</p>
<table-wrap id="table2-1748006X12458995" position="float">
<label>Table 2.</label>
<caption>
<p>Fault trees used for the experimental phase.</p>
</caption>
<graphic alternate-form-of="table2-1748006X12458995" xlink:href="10.1177_1748006X12458995-table2.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="char" char="."/>
<col align="char" char="."/>
</colgroup>
<thead>
<tr>
<th align="left">Fault tree</th>
<th align="left">Gates</th>
<th align="left">Events</th>
</tr>
</thead>
<tbody>
<tr>
<td>FT1</td>
<td>166</td>
<td>298</td>
</tr>
<tr>
<td>FT2</td>
<td>158</td>
<td>311</td>
</tr>
<tr>
<td>FT3</td>
<td>474</td>
<td>409</td>
</tr>
<tr>
<td>FT4</td>
<td>475</td>
<td>362</td>
</tr>
<tr>
<td>FT5</td>
<td>435</td>
<td>458</td>
</tr>
<tr>
<td>FT6</td>
<td>2226</td>
<td>267</td>
</tr>
<tr>
<td>FT7</td>
<td>451</td>
<td>678</td>
</tr>
<tr>
<td>FT8</td>
<td>852</td>
<td>1362</td>
</tr>
<tr>
<td>FT9</td>
<td>1041</td>
<td>243</td>
</tr>
<tr>
<td>FT10</td>
<td>650</td>
<td>958</td>
</tr>
<tr>
<td>FT11</td>
<td>1122</td>
<td>1709</td>
</tr>
</tbody>
</table>
</table-wrap>
<p>Fault trees FT1–FT6 in <xref ref-type="table" rid="table2-1748006X12458995">Table 2</xref> could also be analysed using the BDD approach on a standard computer. They have been considered for the verification of the results of the decomposition algorithms. However, fault trees from FT7 to FT11 could not be analysed owing to a working memory requirement (for construction of the BDD) greater than 300 M. The analysis of these trees was successfully performed by means of the functional decomposition approach.</p>
<p>The main assumptions adopted for the experimental phase are the following.</p>
<list id="list6-1748006X12458995" list-type="order">
<list-item><p>Trees are analysed with a run-time threshold equal to five times the minimum run-time.</p></list-item>
<list-item><p>The only quantitative analysis method used was BDD, i.e. no use was made of the TZBDD methods as applied in Minato.<sup><xref ref-type="bibr" rid="bibr14-1748006X12458995">14</xref></sup></p></list-item>
</list>
<p>The description of the results of the experimental phase is subdivided into two parts. In ‘Test of the MPS method’ the MPS method is examined in order to identify the weights <italic>w</italic><sub><italic>r</italic></sub>, <italic>w</italic><sub><italic>p</italic></sub> that reduce the computational resources. Then, the MPS with the selected weights is compared with the other methods (RF/RP/MD) in ‘Experimental results from the application of all methods’.</p>
<sec id="section11-1748006X12458995">
<title>Test of the MPS method</title>
<p>Referring to the algorithm described in the previous section, the decomposition tests for the selection of the MPS were performed using three sets of values for <italic>w</italic><sub>r</sub> and <italic>w</italic><sub>p</sub>:</p>
<list id="list7-1748006X12458995" list-type="bullet">
<list-item><p><italic>w</italic><sub>r</sub> = 1.0 and <italic>w</italic><sub>p</sub> = 0.0;</p></list-item>
<list-item><p><italic>w</italic><sub>r</sub> = 0.5 and <italic>w</italic><sub>p</sub> = 0.5;</p></list-item>
<list-item><p><italic>w</italic><sub>r</sub> = 0.0 and <italic>w</italic><sub>p</sub> = 1.0.</p></list-item>
</list>
<p>The assignment of different values to <italic>w</italic><sub>r</sub> /<italic>w</italic><sub>p</sub> leads to different MPS. In addition, for each weight value, different orderings of the events in the MPS were tested:</p>
<list id="list8-1748006X12458995" list-type="bullet">
<list-item><p>repetition-based decreasing ordering;</p></list-item>
<list-item><p>probability-based decreasing ordering;</p></list-item>
<list-item><p><italic>f</italic> value-based decreasing ordering.</p></list-item>
</list>
<p>All test cases were performed for four fault trees. Fault trees FT1–FT3 (simple fault trees) and FT8 (complex fault tree) were used (see <xref ref-type="table" rid="table2-1748006X12458995">Table 2</xref>). In total, nine tests were run for each fault tree, as summarised in <xref ref-type="table" rid="table3-1748006X12458995">Table 3</xref>. The dependence of the MPS order, run-time, and ITE peak size from the weights values are considered here.</p>
<table-wrap id="table3-1748006X12458995" position="float">
<label>Table 3.</label>
<caption>
<p>Considered test cases for the MPS method.</p>
</caption>
<graphic alternate-form-of="table3-1748006X12458995" xlink:href="10.1177_1748006X12458995-table3.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="char" char="."/>
<col align="char" char="."/>
<col align="left"/>
</colgroup>
<thead>
<tr>
<th align="left">#Case</th>
<th align="left"><italic>w</italic><sub>r</sub></th>
<th align="left"><italic>w</italic><sub>p</sub></th>
<th align="left">Ordering based on</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0.0</td>
<td>1.0</td>
<td>Repetition</td>
</tr>
<tr>
<td>2</td>
<td>0.5</td>
<td>0.5</td>
<td>Repetition</td>
</tr>
<tr>
<td>3</td>
<td>1.0</td>
<td>0.0</td>
<td>Repetition</td>
</tr>
<tr>
<td>4</td>
<td>0.0</td>
<td>1.0</td>
<td>Probability</td>
</tr>
<tr>
<td>5</td>
<td>0.5</td>
<td>0.5</td>
<td>Probability</td>
</tr>
<tr>
<td>6</td>
<td>1.0</td>
<td>0.0</td>
<td>Probability</td>
</tr>
<tr>
<td>7</td>
<td>0.0</td>
<td>1.0</td>
<td>Function <italic>f</italic></td>
</tr>
<tr>
<td>8</td>
<td>0.5</td>
<td>0.5</td>
<td>Function <italic>f</italic></td>
</tr>
<tr>
<td>9</td>
<td>1.0</td>
<td>0.0</td>
<td>Function <italic>f</italic></td>
</tr>
</tbody>
</table>
</table-wrap>
<p>First of all the MPS orders, calculated using different weights <italic>w</italic><sub>r</sub> and <italic>w</italic><sub>p</sub>, are presented in <xref ref-type="table" rid="table4-1748006X12458995">Table 4</xref>, which shows that there is no significant difference in the MPS order owing to the use of different weights. Besides, the corresponding run-time, provided in <xref ref-type="table" rid="table5-1748006X12458995">Table 5</xref>, does not indicate significant variations with respect to the weights used. On average, <italic>w</italic><sub>r</sub> = 0.5 and <italic>w</italic><sub>p</sub> = 0.5 seems to show the relatively best results.</p>
<table-wrap id="table4-1748006X12458995" position="float">
<label>Table 4.</label>
<caption>
<p>MPS order versus weights.</p>
</caption>
<graphic alternate-form-of="table4-1748006X12458995" xlink:href="10.1177_1748006X12458995-table4.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="char" char="."/>
<col align="char" char="."/>
<col align="char" char="."/>
<col align="char" char="."/>
<col align="char" char="."/>
</colgroup>
<thead>
<tr>
<th align="left"><italic>w</italic><sub>r</sub></th>
<th align="left"><italic>w</italic><sub>p</sub></th>
<th align="left">FT1</th>
<th align="left">FT2</th>
<th align="left">FT3</th>
<th align="left">FT8</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.0</td>
<td>1.0</td>
<td>157</td>
<td>52</td>
<td>78</td>
<td>290</td>
</tr>
<tr>
<td>0.5</td>
<td>0.5</td>
<td>157</td>
<td>52</td>
<td>69</td>
<td>287</td>
</tr>
<tr>
<td>1.0</td>
<td>0.0</td>
<td>157</td>
<td>52</td>
<td>69</td>
<td>278</td>
</tr>
</tbody>
</table>
</table-wrap>
<table-wrap id="table5-1748006X12458995" position="float">
<label>Table 5.</label>
<caption>
<p>MPS method: run times (s).</p>
</caption>
<graphic alternate-form-of="table5-1748006X12458995" xlink:href="10.1177_1748006X12458995-table5.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="char" char="."/>
<col align="char" char="."/>
<col align="char" char="."/>
<col align="char" char="."/>
</colgroup>
<thead>
<tr>
<th align="left"># Case</th>
<th align="left">FT1</th>
<th align="left">FT2</th>
<th align="left">FT3</th>
<th align="left">FT8</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>202</td>
<td>19.9</td>
<td>77.3</td>
<td>2000</td>
</tr>
<tr>
<td>2</td>
<td>205</td>
<td>20.0</td>
<td>73.5</td>
<td>1770</td>
</tr>
<tr>
<td>3</td>
<td>243</td>
<td>20.0</td>
<td>72.4</td>
<td>1610</td>
</tr>
<tr>
<td>4</td>
<td>322</td>
<td>21.7</td>
<td>41.3</td>
<td>2100</td>
</tr>
<tr>
<td>5</td>
<td>324</td>
<td>21.2</td>
<td>63.3</td>
<td>2090</td>
</tr>
<tr>
<td>6</td>
<td>385</td>
<td>21.6</td>
<td>73.4</td>
<td>1970</td>
</tr>
<tr>
<td>7</td>
<td>353</td>
<td>21.3</td>
<td>85.2</td>
<td>2690</td>
</tr>
<tr>
<td>8</td>
<td>351</td>
<td>21.9</td>
<td>68.5</td>
<td>3040</td>
</tr>
<tr>
<td>9</td>
<td>346</td>
<td>22.5</td>
<td>100</td>
<td>3570</td>
</tr>
</tbody>
</table>
</table-wrap>
<p>Concerning the ITE peak size, results are provided in <xref ref-type="table" rid="table6-1748006X12458995">Table 6</xref>. It can be noticed that different weights do not affect the ITE peak size significantly. Differences are mainly caused by the different MPS ordering. In general the ordering based on repetition factors gave the lowest memory need, except for FT2 (ordering by probabilities resulted in almost 40% lower memory use).</p>
<table-wrap id="table6-1748006X12458995" position="float">
<label>Table 6.</label>
<caption>
<p>MPS method: ITE peak sizes.</p>
</caption>
<graphic alternate-form-of="table6-1748006X12458995" xlink:href="10.1177_1748006X12458995-table6.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="char" char="."/>
<col align="char" char="."/>
<col align="char" char="."/>
<col align="char" char="."/>
</colgroup>
<thead>
<tr>
<th align="left"># Case</th>
<th align="left">FT1</th>
<th align="left">FT2</th>
<th align="left">FT3</th>
<th align="left">FT8</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>4,568,664</td>
<td>1,096,996</td>
<td>3,902,548</td>
<td>17,159,341</td>
</tr>
<tr>
<td>2</td>
<td>4,568,664</td>
<td>1,096,996</td>
<td>3,591,890</td>
<td>17,023,035</td>
</tr>
<tr>
<td>3</td>
<td>5,695,352</td>
<td>1,096,996</td>
<td>3,591,904</td>
<td>20,325,371</td>
</tr>
<tr>
<td>4</td>
<td>5,506,063</td>
<td>606,186</td>
<td>3,889,985</td>
<td>&gt;25 M</td>
</tr>
<tr>
<td>5</td>
<td>5,506,063</td>
<td>606,186</td>
<td>3,566,980</td>
<td>&gt;25 M</td>
</tr>
<tr>
<td>6</td>
<td>3,830,684</td>
<td>606,186</td>
<td>3,566,992</td>
<td>&gt;25 M</td>
</tr>
<tr>
<td>7</td>
<td>6,675,876</td>
<td>1,424,635</td>
<td>3,623,910</td>
<td>20,133,065</td>
</tr>
<tr>
<td>8</td>
<td>8,669,007</td>
<td>1,424,635</td>
<td>3,377,633</td>
<td>&gt;25 M</td>
</tr>
<tr>
<td>9</td>
<td>8,717,586</td>
<td>1,424,635</td>
<td>3,580,332</td>
<td>&gt;25 M</td>
</tr>
</tbody>
</table>
</table-wrap>
<p>During the detailed analysis of MPS it was discovered that in FT2, low probability events had high repetition factors, while in other fault trees the situation was different. So, in the FT2 case the ordering based on probabilities was very similar to the one based on repetitions. This once again confirms the importance of the basic events’ repetition factor in constructing and ordering the MPS.</p>
<p>As the results above suggest, the recommended MPS would be the one obtained by using weights <italic>w</italic><sub><italic>r</italic></sub> = 0.5 and <italic>w</italic><sub><italic>p</italic></sub> = 0.5 and ordering of events based on repetition factor.</p>
<p>Furthermore, a random MPS selection method was used to examine the distribution of the order of the MPS in fault trees. For each fault tree 10,000 random MPS were generated to approximately calculate the ranges of the MPS order. The results obtained are shown in <xref ref-type="table" rid="table7-1748006X12458995">Table 7</xref>. From the content of this table it is clear that the algorithm applied (<italic>w</italic><sub><italic>r</italic></sub> = 0.5, <italic>w</italic><sub><italic>p</italic></sub> = 0.5, R) found MPS with order very close to the minimum for FT1 and FT2. However, for more complex fault trees, the MPS order was more shifted towards the middle of the range. An example of the distribution of the sampled MPS orders for FT8 is shown in <xref ref-type="fig" rid="fig2-1748006X12458995">Figure 2</xref>. These results show the general variability of the order of the different path sets.</p>
<table-wrap id="table7-1748006X12458995" position="float">
<label>Table 7.</label>
<caption>
<p>Range of MPS order in fault trees.</p>
</caption>
<graphic alternate-form-of="table7-1748006X12458995" xlink:href="10.1177_1748006X12458995-table7.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="char" char="."/>
<col align="char" char="."/>
</colgroup>
<thead>
<tr>
<th align="left">Fault tree</th>
<th align="left">Minimum MPS order</th>
<th align="left">Maximum MPS order</th>
</tr>
</thead>
<tbody>
<tr>
<td>FT1</td>
<td>157</td>
<td>175</td>
</tr>
<tr>
<td>FT2</td>
<td>50</td>
<td>235</td>
</tr>
<tr>
<td>FT3</td>
<td>15</td>
<td>115</td>
</tr>
<tr>
<td>FT8</td>
<td>198</td>
<td>451</td>
</tr>
</tbody>
</table>
</table-wrap>
<fig id="fig2-1748006X12458995" position="float">
<label>Figure 2.</label>
<caption>
<p>Distribution of the MPS order for FT8: (10,000 samples).</p>
</caption>
<graphic xlink:href="10.1177_1748006X12458995-fig2.tif"/>
</fig>
<p>Moreover, for the same fault tree, 35 cases were selected out of the sampled MPS and analysed in order to check whether the analysis run times were significantly affected by the MPS order. Results are shown in <xref ref-type="fig" rid="fig3-1748006X12458995">Figure 3</xref>: the higher the MPS order the longer will be the run time.</p>
<fig id="fig3-1748006X12458995" position="float">
<label>Figure 3.</label>
<caption>
<p>Run-time versus MPS order for FT8.</p>
</caption>
<graphic xlink:href="10.1177_1748006X12458995-fig3.tif"/>
</fig>
<p>Finally, some tests were carried out in order to see to what extent the MPS composition affects the performance of decomposition. The FT3 fault tree was decomposed using different MPS of order 15. <xref ref-type="table" rid="table8-1748006X12458995">Table 8</xref> provides the run time and the ITE peak size for the five best and the five worst performances out of 100 runs. As can be noticed, the difference in run times and memory usage between the best and the worst MPS is around 10 times. Moreover, it is interesting to note that some of the MPS shown in <xref ref-type="table" rid="table8-1748006X12458995">Table 8</xref> (e.g. 3 and 10) differ just by a single element.</p>
<table-wrap id="table8-1748006X12458995" position="float">
<label>Table 8.</label>
<caption>
<p>Decomposition performance for FT3.</p>
</caption>
<graphic alternate-form-of="table8-1748006X12458995" xlink:href="10.1177_1748006X12458995-table8.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="char" char="."/>
<col align="char" char="."/>
</colgroup>
<thead>
<tr>
<th align="left"># MPS</th>
<th align="left">Run time, s</th>
<th align="left">ITE peak</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>6.18</td>
<td>298,204</td>
</tr>
<tr>
<td>2</td>
<td>6.20</td>
<td>303,488</td>
</tr>
<tr>
<td>3</td>
<td>6.21</td>
<td>298,500</td>
</tr>
<tr>
<td>4</td>
<td>6.25</td>
<td>306,114</td>
</tr>
<tr>
<td>5</td>
<td>7.09</td>
<td>284,058</td>
</tr>
<tr>
<td>6</td>
<td>53.80</td>
<td>4,184,819</td>
</tr>
<tr>
<td>7</td>
<td>54.03</td>
<td>4,165,766</td>
</tr>
<tr>
<td>8</td>
<td>55.11</td>
<td>4,184,819</td>
</tr>
<tr>
<td>9</td>
<td>55.29</td>
<td>3,661,330</td>
</tr>
<tr>
<td>10</td>
<td>58.65</td>
<td>4,165,766</td>
</tr>
</tbody>
</table>
<table-wrap-foot>
<fn id="table-fn3-1748006X12458995">
<p>ITE: if-then-else record.</p>
</fn>
</table-wrap-foot>
</table-wrap>
<p>Based on the results obtained, it can be stated that the MPS method – based on weights <italic>w</italic><sub><italic>r</italic></sub> = 0.5 and <italic>w</italic><sub><italic>p</italic></sub> = 0.5 and with elements ordered according to the repetition factors – should give results that are generally good. Hence, this method will be considered in the next section and compared with the other three decomposition methods, namely RF, RP, and MD.</p>
</sec>
<sec id="section12-1748006X12458995">
<title>Experimental results from the application of all methods</title>
<p>The comparison of the four methods to construct <bold>S</bold> i.e. MPS, RF, RP and MD, was done using all the fault trees listed in <xref ref-type="table" rid="table1-1748006X12458995">Table 1</xref>. With the exception of MPS, all other methods require the user-defined percentage value of basic events to generate <bold>S</bold>. In this experimental phase three different percentage values were used: 10%, 20%, and 30% of the total number of events. Ten cases were analysed for each of the 11 fault trees for a total of 110 cases.</p>
<p>The purpose of these tests was to check how the decomposition efficiency changes when different sets <bold>S</bold> are being used. The decomposition efficiency is based on two parameters: a) the duration of the decomposition analysis (run time), and b) the memory usage (ITE peak size).</p>
<p>Since the fault trees are of different complexity, in order to compare the efficiency of the different methods, the results are normalised. <italic>E</italic><sup><italic>T</italic></sup>– the efficiency indicator for the run time – is determined using the following expression</p>
<disp-formula id="disp-formula11-1748006X12458995">
<label>(10)</label>
<mml:math display="block" id="math21-1748006X12458995">
<mml:mrow>
<mml:msup>
<mml:mrow>
<mml:mi>E</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
</mml:msup>
<mml:mo>=</mml:mo>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>max</mml:mo>
</mml:mrow>
</mml:msub>
<mml:mo>−</mml:mo>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>max</mml:mo>
</mml:mrow>
</mml:msub>
<mml:mo>−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi>t</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>min</mml:mo>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula11-1748006X12458995" xlink:href="10.1177_1748006X12458995-eq11.tif"/>
</disp-formula>
<p>
<inline-formula id="inline-formula11-1748006X12458995">
<mml:math display="inline" id="math22-1748006X12458995">
<mml:mrow>
<mml:mn>0</mml:mn>
<mml:mo>≤</mml:mo>
<mml:msup>
<mml:mrow>
<mml:mi>E</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
</mml:msup>
<mml:mo>≤</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:math>
</inline-formula>, where 1 corresponds to the highest efficiency (<italic>t = t</italic><sub>min</sub>) and 0 to the lowest efficiency (<italic>t = t</italic><sub>max</sub>).</p>
<p>The average run-time efficiency of a given method applied to the 11 fault trees in <xref ref-type="table" rid="table2-1748006X12458995">Table 2</xref> is determined as the average of the efficiency indicators obtained for different fault trees</p>
<disp-formula id="disp-formula12-1748006X12458995">
<label>(11)</label>
<mml:math display="block" id="math23-1748006X12458995">
<mml:mrow>
<mml:mover>
<mml:mrow>
<mml:msup>
<mml:mrow>
<mml:mi>E</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
</mml:msup>
</mml:mrow>
<mml:mo stretchy="true">¯</mml:mo>
</mml:mover>
<mml:mo>=</mml:mo>
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
</mml:mrow>
<mml:mrow>
<mml:mn>11</mml:mn>
</mml:mrow>
</mml:munderover>
<mml:msubsup>
<mml:mrow>
<mml:mi>E</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>i</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
</mml:msubsup>
<mml:mo>/</mml:mo>
<mml:mn>11</mml:mn>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula12-1748006X12458995" xlink:href="10.1177_1748006X12458995-eq12.tif"/>
</disp-formula>
<p>The memory consumption efficiency indicator <inline-formula id="inline-formula12-1748006X12458995"><mml:math display="inline" id="math24-1748006X12458995"><mml:mrow><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mrow><mml:mi>M</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> is determined in the same way.</p>
<p>The efficiency indicators for different decomposition methods are provided in the <xref ref-type="app" rid="app1-1748006X12458995">appendix</xref> (<xref ref-type="table" rid="table9-1748006X12458995">Table 9</xref>). An efficiency value equal to 1.0 indicates the best result (shortest run time or lowest memory usage). It may happen that different methods give identical results (i.e. identical peak memory usage for different <bold>S</bold>).</p>
<p>Owing to the long run times for the most complex fault trees, run-time limitations were introduced: if the run time exceeded 30 times the best run-time available, the efficiency indicator would be set to the lowest value 0.0.</p>
<p>As can be seen from <xref ref-type="table" rid="table9-1748006X12458995">Table 9</xref>, the efficiency of the different methods differs from one fault tree to the other. As shown in the previous section (<xref ref-type="fig" rid="fig3-1748006X12458995">Figure 3</xref>), the run time increased as the size of S increased, but nothing was said about the memory usage. By slightly increasing the run time, a decrease in the working memory size was expected since more – though simpler – fault trees are involved.</p>
<p>Almost all the test cases showed that the run time increased when the <bold>S</bold> size was changed from 10% to 20% and then to 30% (except in the case of FT1, repetition factors method used). Looking at the corresponding variation in the memory usage, it appeared that it was not affected significantly by the size of <bold>S</bold>. In the majority of the cases the memory usage was independent from the selected <bold>S</bold> size and only in a few cases it decreased (mainly when the repetition factors method was used). Since the memory is not significantly affected by the size of <bold>S</bold>, it can be stated that a smaller <bold>S</bold> size should be used as this also allows a reduction in the computation time.</p>
<p>In order to better compare the different methods a single efficiency indicator <xref ref-type="disp-formula" rid="disp-formula13-1748006X12458995">equation (12)</xref> was applied, in which the efficiency of the run time and working memory were supposed equally important</p>
<disp-formula id="disp-formula13-1748006X12458995">
<label>(12)</label>
<mml:math display="block" id="math25-1748006X12458995">
<mml:mrow>
<mml:mi>E</mml:mi>
<mml:mo>=</mml:mo>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mover>
<mml:mrow>
<mml:msup>
<mml:mrow>
<mml:mi>E</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>T</mml:mi>
</mml:mrow>
</mml:msup>
</mml:mrow>
<mml:mo stretchy="true">¯</mml:mo>
</mml:mover>
<mml:mo>+</mml:mo>
<mml:mover>
<mml:mrow>
<mml:msup>
<mml:mrow>
<mml:mi>E</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi>M</mml:mi>
</mml:mrow>
</mml:msup>
</mml:mrow>
<mml:mo stretchy="true">¯</mml:mo>
</mml:mover>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>/</mml:mo>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:math>
<graphic alternate-form-of="disp-formula13-1748006X12458995" xlink:href="10.1177_1748006X12458995-eq13.tif"/>
</disp-formula>
<p><xref ref-type="fig" rid="fig4-1748006X12458995">Figure 4</xref> shows the <italic>E</italic> values for all four methods based on the 11 fault trees in <xref ref-type="table" rid="table1-1748006X12458995">Table 1</xref>. This histogram shows that both MPS and repetition factor methods are more efficient than the other two. Hence, considerations will be addressed to these two methods only. The MPS method seems to be the most efficient way to decompose complex fault trees. The repetition factor method is also very efficient on almost all cases, with the exception of FT3 and FT10. The examination of the FT3 structure revealed that it contained many non-repeated events, which compromised the efficiency of the repetition factor method. Hence, when the fault tree does not contain events with high repetition factors it is better not to use the repetition factor method.</p>
<fig id="fig4-1748006X12458995" position="float">
<label>Figure 4.</label>
<caption>
<p>Comparison of the average efficiency index for different methods.</p>
</caption>
<graphic xlink:href="10.1177_1748006X12458995-fig4.tif"/>
</fig>
<p>As the efficiency of both MPS and repetition factor methods is similar, it is important to identify which one to apply according to the fault tree structure. A simple solution is to consider the number of repeated events and their repetition factor. Starting from these values a decision can be made: to use the repetition factor only when the number of events repeated is sufficiently high (at least equal to the size of the <bold>S</bold> set), otherwise the MPS method is preferable. Therefore, it may happen that the first level decomposition is performed using the repetition factor method and the second level using the MPS method or vice versa. For instance, if the repetition factor method was used during the first decomposition, then the generated simpler trees may not contain enough repeated events (or events with relatively high repetition factors) for further use of the repetition factor method. In this case the MPS method may be preferred. So, depending on the fault tree structure, <bold>S</bold> may be determined by dynamically selecting one of the above presented methods.</p>
</sec>
</sec>
<sec id="section13-1748006X12458995" sec-type="conclusions">
<title>Conclusions</title>
<p>Methods currently used for the exact analysis fault trees of high complexity are not always able to provide reliable results owing to the high computational resources required. Recently a new method based on functional decomposition was proposed,<sup><xref ref-type="bibr" rid="bibr21-1748006X12458995">21</xref>,<xref ref-type="bibr" rid="bibr22-1748006X12458995">22</xref></sup> which allows the performance of complex fault tree analyses with limited computational resources. The method is based on the selection of a predefined sub-set of events <bold>S</bold>, which is used to recursively decompose a large fault tree into a set of mutually exclusive simpler trees until they can be analysed by means of the available working memory size. However, the performance of the decomposition method is highly sensitive to the order and composition of <bold>S</bold>. Hence, it was important to investigate the dependence of the decomposition efficiency on <bold>S</bold>.</p>
<p>In this article four different algorithms for determining <bold>S</bold> were described and compared on the basis of 11 fault trees in order to identify their effects on the efficiency (run time and working memory size) of the decomposition method. In Contini and Matuzas,<sup><xref ref-type="bibr" rid="bibr21-1748006X12458995">21</xref>,<xref ref-type="bibr" rid="bibr22-1748006X12458995">22</xref></sup> the MPS method was applied. This method could be implemented in many different ways giving different results. Tests performed indicated that the best MPS should be the one obtained by using weights <italic>w</italic><sub><italic>r</italic></sub> = 0.5 and <italic>w</italic><sub><italic>p</italic></sub> = 0.5 and in which events are ordered according to their repetition factor.</p>
<p>In addition to MPS, three other methods to determine <bold>S</bold> were considered, referred to as repetition factor, reduction power, and minimum depth. Tests were performed using 11 fault trees of different complexity. From the results obtained it can be concluded that the decomposition process based on the set <bold>S</bold> as a MPS is generally the most efficient one. Also, the repetition factor method was quite efficient on many fault trees; however, it is sensitive to the number of repeated events and their repetition factor. Hence it could give poor results when there are no repeated events or when their repetition factors are low. The other methods examined for the determination of <bold>S</bold> were not so efficient and should not be considered as a basis for the decomposition of complex fault trees.</p>
<p>Since the computation time for the determination of <bold>S</bold> is negligible compared with the duration of fault tree analysis, it is convenient to analyse the fault tree structure (mainly the number of repeated events and their repetition factors) before decomposing it in order to identify which method to apply.</p>
</sec>
</body>
<back>
<app-group>
<app id="app1-1748006X12458995">
<title>Appendix</title>
<table-wrap id="table9-1748006X12458995" position="float">
<label>Table 9.</label>
<caption>
<p>Run time and ITE peak size efficiency indicators for different decomposition methods applied to 11 fault trees.</p>
</caption>
<graphic alternate-form-of="table9-1748006X12458995" xlink:href="10.1177_1748006X12458995-table9.tif"/>
<table>
<colgroup>
<col align="left"/>
<col align="left"/>
<col align="char" char="."/>
<col align="char" char="."/>
<col align="char" char="."/>
<col align="char" char="."/>
<col align="char" char="."/>
<col align="char" char="."/>
</colgroup>
<thead>
<tr>
<th align="left">FT</th>
<th align="left">Method</th>
<th align="center" colspan="2">10%<hr/></th>
<th align="center" colspan="2">20%<hr/></th>
<th align="center" colspan="2">30%<hr/></th>
</tr>
<tr>
<th/>
<th/>
<th align="left">Run time</th>
<th align="left">ITE peak</th>
<th align="left">Run-time</th>
<th align="left">ITE peak</th>
<th align="left">Run time</th>
<th align="left">ITE peak</th>
</tr>
</thead>
<tbody>
<tr>
<td>FT1</td>
<td>MPS<xref ref-type="table-fn" rid="table-fn4-1748006X12458995">*</xref></td>
<td>0.00</td>
<td>0.49</td>
<td colspan="4"/>
</tr>
<tr>
<td/>
<td>RF</td>
<td>0.96</td>
<td>0.00</td>
<td>1.00</td>
<td>0.36</td>
<td>1.00</td>
<td>0.52</td>
</tr>
<tr>
<td/>
<td>RP</td>
<td>0.88</td>
<td>0.46</td>
<td>0.79</td>
<td>1.00</td>
<td>0.78</td>
<td>1.00</td>
</tr>
<tr>
<td/>
<td>MD</td>
<td>0.75</td>
<td>0.61</td>
<td>0.74</td>
<td>0.61</td>
<td>0.73</td>
<td>0.61</td>
</tr>
<tr>
<td>FT2</td>
<td>MPS<xref ref-type="table-fn" rid="table-fn4-1748006X12458995">*</xref></td>
<td>0.82</td>
<td>0.82</td>
<td colspan="4"/>
</tr>
<tr>
<td/>
<td>RF</td>
<td>1.00</td>
<td>0.34</td>
<td>0.73</td>
<td>0.84</td>
<td>0.55</td>
<td>1.00</td>
</tr>
<tr>
<td/>
<td>RP</td>
<td>0.64</td>
<td>0.40</td>
<td>0.27</td>
<td>0.40</td>
<td>0.00</td>
<td>0.40</td>
</tr>
<tr>
<td/>
<td>MD</td>
<td>0.73</td>
<td>0.00</td>
<td>0.64</td>
<td>0.00</td>
<td>0.64</td>
<td>0.00</td>
</tr>
<tr>
<td>FT3</td>
<td>MPS<xref ref-type="table-fn" rid="table-fn4-1748006X12458995">*</xref></td>
<td>0.63</td>
<td>0.09</td>
<td colspan="4"/>
</tr>
<tr>
<td/>
<td>RF</td>
<td>0.07</td>
<td>0.06</td>
<td>0.02</td>
<td>0.06</td>
<td>0.00</td>
<td>0.06</td>
</tr>
<tr>
<td/>
<td>RP</td>
<td>0.77</td>
<td>1.00</td>
<td>0.42</td>
<td>1.00</td>
<td>0.37</td>
<td>1.00</td>
</tr>
<tr>
<td/>
<td>MD</td>
<td>1.00</td>
<td>0.00</td>
<td>0.97</td>
<td>0.00</td>
<td>0.97</td>
<td>0.00</td>
</tr>
<tr>
<td>FT4</td>
<td>MPS<xref ref-type="table-fn" rid="table-fn4-1748006X12458995">*</xref></td>
<td>0.00</td>
<td>0.17</td>
<td colspan="4"/>
</tr>
<tr>
<td/>
<td>RF</td>
<td>0.83</td>
<td>0.17</td>
<td>0.58</td>
<td>0.17</td>
<td>0.50</td>
<td>0.17</td>
</tr>
<tr>
<td/>
<td>RP</td>
<td>1.00</td>
<td>0.14</td>
<td>0.88</td>
<td>0.36</td>
<td>0.75</td>
<td>0.83</td>
</tr>
<tr>
<td/>
<td>MD</td>
<td>0.92</td>
<td>0.00</td>
<td>0.67</td>
<td>0.37</td>
<td>0.58</td>
<td>1.00</td>
</tr>
<tr>
<td>FT5</td>
<td>MPS<xref ref-type="table-fn" rid="table-fn4-1748006X12458995">*</xref></td>
<td>0.53</td>
<td>0.68</td>
<td colspan="4"/>
</tr>
<tr>
<td/>
<td>RF</td>
<td>0.59</td>
<td>0.68</td>
<td>0.28</td>
<td>0.68</td>
<td>0.00</td>
<td>0.68</td>
</tr>
<tr>
<td/>
<td>RP</td>
<td>0.89</td>
<td>0.00</td>
<td>1.00</td>
<td>0.67</td>
<td>0.92</td>
<td>0.68</td>
</tr>
<tr>
<td/>
<td>MD</td>
<td>0.78</td>
<td>0.33</td>
<td>0.99</td>
<td>0.34</td>
<td>1.00</td>
<td>1.00</td>
</tr>
<tr>
<td>FT6</td>
<td>MPS<xref ref-type="table-fn" rid="table-fn4-1748006X12458995">*</xref></td>
<td>1.00</td>
<td>0.80</td>
<td colspan="4"/>
</tr>
<tr>
<td/>
<td>RF</td>
<td>0.62</td>
<td>0.06</td>
<td>0.44</td>
<td>0.06</td>
<td>0.00</td>
<td>0.06</td>
</tr>
<tr>
<td/>
<td>RP</td>
<td>0.30</td>
<td>0.00</td>
<td>0.56</td>
<td>0.00</td>
<td>0.68</td>
<td>0.00</td>
</tr>
<tr>
<td/>
<td>MD</td>
<td>0.56</td>
<td>1.00</td>
<td>0.42</td>
<td>1.00</td>
<td>0.26</td>
<td>1.00</td>
</tr>
<tr>
<td>FT7</td>
<td>MPS<xref ref-type="table-fn" rid="table-fn4-1748006X12458995">*</xref></td>
<td>0.72</td>
<td>1.00</td>
<td colspan="4"/>
</tr>
<tr>
<td/>
<td>RF</td>
<td>0.87</td>
<td>0.79</td>
<td>0.68</td>
<td>1.00</td>
<td>0.57</td>
<td>1.00</td>
</tr>
<tr>
<td/>
<td>RP</td>
<td>1.00</td>
<td>0.56</td>
<td>0.89</td>
<td>0.65</td>
<td>0.81</td>
<td>0.68</td>
</tr>
<tr>
<td/>
<td>MD</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
</tr>
<tr>
<td>FT8</td>
<td>MPS<xref ref-type="table-fn" rid="table-fn4-1748006X12458995">*</xref></td>
<td>1.00</td>
<td>0.34</td>
<td colspan="4"/>
</tr>
<tr>
<td/>
<td>RF</td>
<td>0.93</td>
<td>1.00</td>
<td>0.92</td>
<td>1.00</td>
<td>0.91</td>
<td>1.00</td>
</tr>
<tr>
<td/>
<td>RP</td>
<td>0.67</td>
<td>0.13</td>
<td>0.16</td>
<td>0.13</td>
<td>0.00</td>
<td>0.00</td>
</tr>
<tr>
<td/>
<td>MD</td>
<td>0.68</td>
<td>0.26</td>
<td>0.29</td>
<td>0.26</td>
<td>0.45</td>
<td>0.26</td>
</tr>
<tr>
<td>FT9</td>
<td>MPS<xref ref-type="table-fn" rid="table-fn4-1748006X12458995">*</xref></td>
<td>0.94</td>
<td>1.00<sup>(d=2)</sup></td>
<td colspan="4"/>
</tr>
<tr>
<td/>
<td>RF</td>
<td>0.98</td>
<td>0.0<sup>(d=4)</sup></td>
<td>0.99</td>
<td>0.20<sup>(d=3)</sup></td>
<td>1.00</td>
<td>0.80<sup>(d=2)</sup></td>
</tr>
<tr>
<td/>
<td>RP</td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn5-1748006X12458995">(1)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn6-1748006X12458995">(2)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn5-1748006X12458995">(1)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn6-1748006X12458995">(2)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn5-1748006X12458995">(1)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn6-1748006X12458995">(2)</xref></sup></td>
</tr>
<tr>
<td/>
<td>MD</td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn5-1748006X12458995">(1)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn6-1748006X12458995">(2)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn5-1748006X12458995">(1)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn6-1748006X12458995">(2)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn5-1748006X12458995">(1)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn6-1748006X12458995">(2)</xref></sup></td>
</tr>
<tr>
<td>FT10</td>
<td>MPS<xref ref-type="table-fn" rid="table-fn4-1748006X12458995">*</xref></td>
<td>1.00</td>
<td>1.00</td>
<td colspan="4"/>
</tr>
<tr>
<td/>
<td>RF</td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn5-1748006X12458995">(1)</xref></sup></td>
<td>0.00<sup>(d=4)</sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn5-1748006X12458995">(1)</xref></sup></td>
<td>0.00<sup>(d=4)</sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn5-1748006X12458995">(1)</xref></sup></td>
<td>0.00<sup>(d=4)</sup></td>
</tr>
<tr>
<td/>
<td>RP</td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn5-1748006X12458995">(1)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn6-1748006X12458995">(2)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn5-1748006X12458995">(1)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn6-1748006X12458995">(2)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn5-1748006X12458995">(1)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn6-1748006X12458995">(2)</xref></sup></td>
</tr>
<tr>
<td/>
<td>MD</td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn5-1748006X12458995">(1)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn6-1748006X12458995">(2)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn5-1748006X12458995">(1)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn6-1748006X12458995">(2)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn5-1748006X12458995">(1)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn6-1748006X12458995">(2)</xref></sup></td>
</tr>
<tr>
<td>FT11</td>
<td>MPS<xref ref-type="table-fn" rid="table-fn4-1748006X12458995">*</xref></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn5-1748006X12458995">(1)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn6-1748006X12458995">(2)</xref></sup></td>
<td colspan="4"/>
</tr>
<tr>
<td/>
<td>RF</td>
<td>1.00</td>
<td>1.00</td>
<td>0.53</td>
<td>1.00</td>
<td>0.29</td>
<td>1.00</td>
</tr>
<tr>
<td/>
<td>RP</td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn5-1748006X12458995">(1)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn6-1748006X12458995">(2)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn5-1748006X12458995">(1)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn6-1748006X12458995">(2)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn5-1748006X12458995">(1)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn6-1748006X12458995">(2)</xref></sup></td>
</tr>
<tr>
<td/>
<td>MD</td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn5-1748006X12458995">(1)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn6-1748006X12458995">(2)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn5-1748006X12458995">(1)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn6-1748006X12458995">(2)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn5-1748006X12458995">(1)</xref></sup></td>
<td>0.00<sup><xref ref-type="table-fn" rid="table-fn6-1748006X12458995">(2)</xref></sup></td>
</tr>
</tbody>
</table>
<table-wrap-foot>
<fn id="table-fn4-1748006X12458995">
<label>*</label>
<p>No user-defined size for the MPS method.</p>
</fn>
<fn id="table-fn5-1748006X12458995">
<label>(1)</label>
<p>run-time <italic>t</italic> is set to zero if (<italic>t</italic> &gt; 30·<italic>t</italic><sub><italic>min</italic></sub>), where the <italic>t</italic><sub><italic>min</italic></sub> &gt; 100 s; corresponding ITE peak size 0.00.</p>
</fn>
<fn id="table-fn6-1748006X12458995">
<label>(2)</label>
<p>decomposition depth <italic>x</italic> achieved <italic>x</italic>≥ 5.</p>
</fn>
<fn id="table-fn7-1748006X12458995">
<p>(d = <italic>x</italic>) decomposition depth 1 &lt; <italic>x</italic> &lt; 5.</p>
</fn>
<fn id="table-fn8-1748006X12458995">
<p>FT: fault tree; ITE: if-then-else record; MPS: minimal path set; RF: repetition factor; RP: reduction power; MD: minimum depth.</p>
</fn>
</table-wrap-foot>
</table-wrap>
</app>
</app-group>
<fn-group>
<fn fn-type="financial-disclosure">
<label>Funding</label>
<p>This research received no specific grant from any funding agency in the public, commercial, or not-for-profit sectors.</p>
</fn>
</fn-group>
<ref-list>
<title>References</title>
<ref id="bibr1-1748006X12458995">
<label>1.</label>
<citation citation-type="book">
<collab>NUREG/CR-2815</collab>. <article-title>Probabilistic safety analysis procedures guide</article-title>. <publisher-name>US NRC</publisher-name>, <year>1983</year>.</citation>
</ref>
<ref id="bibr2-1748006X12458995">
<label>2.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Nikolskaia</surname><given-names>M</given-names></name>
<name><surname>Rauzy</surname><given-names>A</given-names></name>
</person-group>. <article-title>Fine-tuning of Boolean formulae pre-processing techniques</article-title>. In: <person-group person-group-type="editor">
<name><surname>Schueller</surname><given-names>GI</given-names></name>
<name><surname>Kafka</surname><given-names>P</given-names></name>
</person-group> (eds) <source>Advances in safety and reliability</source>. <publisher-loc>Rotterdam</publisher-loc>: <publisher-name>A.A. Balkema</publisher-name>, <year>1999</year>, pp.<fpage>1027</fpage>–<lpage>1032</lpage>.</citation>
</ref>
<ref id="bibr3-1748006X12458995">
<label>3.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Chatterjee</surname><given-names>P</given-names></name>
</person-group>. <article-title>Modularization of fault trees: A method to reduce the cost of analysis</article-title>. In: <person-group person-group-type="editor">
<name><surname>Barlow</surname><given-names>RE</given-names></name>
<name><surname>Fussel</surname><given-names>JB</given-names></name>
<name><surname>Singpurwalla</surname><given-names>ND</given-names></name>
</person-group> (eds) <source>Reliability and Fault Tree Analysis</source>. <publisher-name>SIAM</publisher-name>, <publisher-loc>Philadelphia</publisher-loc>, <year>1975</year>, pp <fpage>101</fpage>–<lpage>137</lpage>.</citation>
</ref>
<ref id="bibr4-1748006X12458995">
<label>4.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Dutuit</surname><given-names>Y</given-names></name>
<name><surname>Rauzy</surname><given-names>A</given-names></name>
</person-group>. <article-title>A linear-time algorithm to find modules of fault trees</article-title>. <source>IEEE Trans Rel</source> <year>1996</year>; <volume>45</volume>(<issue>3</issue>): <fpage>422</fpage>–<lpage>425</lpage>.</citation>
</ref>
<ref id="bibr5-1748006X12458995">
<label>5.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Rauzy</surname><given-names>AB</given-names></name>
<name><surname>Gauthier</surname><given-names>J</given-names></name>
<name><surname>Leduc</surname><given-names>X</given-names></name>
</person-group>. <article-title>Assessment of large automatically generated fault trees by means of binary decision diagrams</article-title>. <source>Proc IMechE, Part O: J Risk and Reliability</source> <year>2007</year>; <volume>221</volume>(<issue>2</issue>): <fpage>95</fpage>–<lpage>105</lpage>.</citation>
</ref>
<ref id="bibr6-1748006X12458995">
<label>6.</label>
<citation citation-type="book">
<collab>NUREG-0492</collab>. <article-title>Fault tree handbook</article-title>. <publisher-name>US NRC</publisher-name>, <year>1981</year>.</citation>
</ref>
<ref id="bibr7-1748006X12458995">
<label>7.</label>
<citation citation-type="other">
<collab>NASA</collab>. <article-title>Fault tree handbook with aerospace applications</article-title>, <year>2002</year>.</citation>
</ref>
<ref id="bibr8-1748006X12458995">
<label>8.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Choi</surname><given-names>JS</given-names></name>
<name><surname>Cho</surname><given-names>NZ</given-names></name>
</person-group>. <article-title>Truncation error evaluation method for minimal cut set-based fault tree analysis</article-title>. <source>J Nuc Sci Technol</source> <year>2005</year>; <volume>42</volume>: <fpage>854</fpage>–<lpage>860</lpage>.</citation>
</ref>
<ref id="bibr9-1748006X12458995">
<label>9.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Modarres</surname><given-names>M</given-names></name>
</person-group>. <article-title>A truncation methodology for evaluating large fault trees</article-title>. <source>IEEE Trans Rel</source> <year>1984</year>; <volume>R-33</volume>(<issue>4</issue>): <fpage>325</fpage>–<lpage>328</lpage>.</citation>
</ref>
<ref id="bibr10-1748006X12458995">
<label>10.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Jung</surname><given-names>W</given-names></name>
<name><surname>Yang</surname><given-names>J</given-names></name>
<name><surname>Ha</surname><given-names>J</given-names></name>
</person-group>. <article-title>Development of measures to estimate truncation error in fault tree analysis</article-title>. <source>Rel Engng Syst Saf</source> <year>2005</year>; <volume>90</volume>(<issue>1</issue>): <fpage>30</fpage>–<lpage>36</lpage>.</citation>
</ref>
<ref id="bibr11-1748006X12458995">
<label>11.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Bryant</surname><given-names>RE</given-names></name>
</person-group>. <article-title>Graph-based algorithms for Boolean function manipulation</article-title>. <source>IEEE Trans Computers</source> <year>1986</year>; <volume>C-35</volume>: <fpage>677</fpage>–<lpage>691</lpage>.</citation>
</ref>
<ref id="bibr12-1748006X12458995">
<label>12.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Brace</surname><given-names>KS</given-names></name>
<name><surname>Rudell</surname><given-names>RL</given-names></name>
<name><surname>Bryan</surname><given-names>RE</given-names></name>
</person-group>. <article-title>Efficient implementation of a BDD package</article-title>. In: <conf-name>27th ACM/IEEE design automation conference - DAC’90</conf-name>, <conf-loc>Orlando, Florida, USA</conf-loc>, <conf-date>24-28 June</conf-date> <year>1990</year>, pp. <fpage>40</fpage>–<lpage>45</lpage> (<publisher-name>ACM Press</publisher-name>, <publisher-loc>New York, USA</publisher-loc>).</citation>
</ref>
<ref id="bibr13-1748006X12458995">
<label>13.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Rauzy</surname><given-names>A</given-names></name>
</person-group>. <article-title>New algorithms for fault trees analysis</article-title>. <source>Rel Engng Syst Saf</source> <year>1993</year>; <volume>40</volume>: <fpage>203</fpage>–<lpage>211</lpage>.</citation>
</ref>
<ref id="bibr14-1748006X12458995">
<label>14.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Minato</surname><given-names>S</given-names></name>
</person-group>. <article-title>Zero-suppressed BDDs for set manipulation in combinatorial problems</article-title>. In: <conf-name>30th ACM/IEEE design automation conference - DAC’93</conf-name>, <conf-loc>Dallas, Texas, USA</conf-loc>, <conf-date>20-24 Sept.</conf-date> <year>1993</year>, pp.<fpage>272</fpage>–<lpage>277</lpage> (<publisher-name>ACM Press</publisher-name>, <publisher-loc>New York, USA</publisher-loc>).</citation>
</ref>
<ref id="bibr15-1748006X12458995">
<label>15.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Rauzy</surname><given-names>A</given-names></name>
<name><surname>Dutuit</surname><given-names>Y</given-names></name>
</person-group>. <article-title>Exact and truncated computations of prime implicants of coherent and non-coherent fault trees within Aralia</article-title>. <source>Rel Engng Syst Saf</source> <year>1997</year>; <volume>58</volume>: <fpage>127</fpage>–<lpage>144</lpage>.</citation>
</ref>
<ref id="bibr16-1748006X12458995">
<label>16.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Jung</surname><given-names>WS</given-names></name>
<name><surname>Han</surname><given-names>SH</given-names></name>
<name><surname>Yang</surname><given-names>J-E</given-names></name>
</person-group>. <article-title>Fast BDD truncation method for efficient top event probability calculation</article-title>. <source>Nuc Engng Technol</source> <year>2008</year>; <volume>40</volume>: <fpage>571</fpage>–<lpage>580</lpage>.</citation>
</ref>
<ref id="bibr17-1748006X12458995">
<label>17.</label>
<citation citation-type="book">
<person-group person-group-type="author">
<name><surname>Contini</surname><given-names>S</given-names></name>
<name><surname>Matuzas</surname><given-names>V</given-names></name>
</person-group>. <article-title>Reduced ZBDD construction algorithms for large fault tree analysis</article-title>. In: <person-group person-group-type="editor">
<name><surname>Ale</surname></name>
<name><surname>Papazoglou</surname></name>
<name><surname>Zio</surname></name>
</person-group> (eds) <source>Reliability, risk and safety—back to the future</source>. <publisher-loc>UK</publisher-loc>: <publisher-name>Taylor &amp; Francis Group</publisher-name>, <year>2010</year>, pp.<fpage>898</fpage>–<lpage>906</lpage>.</citation>
</ref>
<ref id="bibr18-1748006X12458995">
<label>18.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Epstein</surname><given-names>S</given-names></name>
<name><surname>Rauzy</surname><given-names>A</given-names></name>
</person-group>. <article-title>Can we trust PRA?</article-title> <source>Rel Engng Syst Saf</source> <year>2005</year>; <volume>88</volume>: <fpage>195</fpage>–<lpage>205</lpage>.</citation>
</ref>
<ref id="bibr19-1748006X12458995">
<label>19.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Cepin</surname><given-names>M</given-names></name>
</person-group>. <article-title>Analysis of truncation limit in probabilistic safety assessment</article-title>. <source>Rel Engng Syst Saf</source> <year>2005</year>; <volume>87</volume>: <fpage>395</fpage>–<lpage>403</lpage>.</citation>
</ref>
<ref id="bibr20-1748006X12458995">
<label>20.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Ibáñez-Llano</surname><given-names>C</given-names></name>
<name><surname>Rauzy</surname><given-names>A</given-names></name>
<name><surname>Meléndez</surname><given-names>E</given-names></name><etal/>
</person-group>. <article-title>Hybrid approach for the assessment of PSA models by means of binary decision diagrams</article-title>. <source>Rel Engng Syst Saf</source> <year>2010</year>; <volume>95</volume>(<issue>10</issue>): <fpage>1076</fpage>–<lpage>1092</lpage>.</citation>
</ref>
<ref id="bibr21-1748006X12458995">
<label>21.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Contini</surname><given-names>S</given-names></name>
<name><surname>Matuzas</surname><given-names>V</given-names></name>
</person-group>. <article-title>Analysis of large fault trees based on functional decomposition</article-title>. <source>Rel Engng Syst Saf</source> <year>2011</year>; <volume>96</volume>(<issue>3</issue>): <fpage>383</fpage>–<lpage>390</lpage>.</citation>
</ref>
<ref id="bibr22-1748006X12458995">
<label>22.</label>
<citation citation-type="journal">
<person-group person-group-type="author">
<name><surname>Contini</surname><given-names>S</given-names></name>
<name><surname>Matuzas</surname><given-names>V</given-names></name>
</person-group>. <article-title>Coupling decomposition and truncation for the analysis of complex fault trees</article-title>. <source>Proc IMechE, Part O: J Risk and Reliability</source> <year>2011</year>; <volume>226</volume>(<issue>3</issue>): <fpage>249</fpage>–<lpage>261</lpage></citation>
</ref>
<ref id="bibr23-1748006X12458995">
<label>23.</label>
<citation citation-type="confproc">
<person-group person-group-type="author">
<name><surname>Yevkin</surname><given-names>O</given-names></name>
</person-group>. <article-title>Truncation approach with the decomposition method for system reliability analysis</article-title>. In: <conf-name>Reliability and maintainability symposium - RAMS</conf-name> <year>2009</year>, <conf-loc>Fort Worth, Texas, USA</conf-loc>, <conf-date>26-29 Jan.</conf-date> <year>2009</year>, pp.<fpage>430</fpage>–<lpage>435</lpage> (<publisher-name>IEEE</publisher-name>).</citation>
</ref>
</ref-list>
</back>
</article>